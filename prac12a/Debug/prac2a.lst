
prac2a.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00002358  0c100000  0c100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .bss          0011755c  0c102358  0c102358  0000a358  2**2
                  ALLOC
  2 .text         00011888  0c2198b4  0c2198b4  000118b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .debug_abbrev 00002912  00000000  00000000  0002313c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000b163  00000000  00000000  00025a4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00003b26  00000000  00000000  00030bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 000c1a24  00000000  00000000  000346d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000030a4  00000000  00000000  000f60fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00001c55  00000000  00000000  000f919f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubtypes 000013d2  00000000  00000000  000fadf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000560  00000000  00000000  000fc1c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001fe1  00000000  00000000  000fc728  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002a  00000000  00000000  000fe709  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000030  00000000  00000000  000fe733  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000026c0  00000000  00000000  000fe764  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c2198b4 <test_EEPROM>:
#include "test_EEPROM.h"
#include "../at24c04.h"
#include "../44b.h"
#include "../uart.h"

void test_EEPROM(void) {
 c2198b4:	e1a0c00d 	mov	ip, sp
 c2198b8:	e92dd800 	push	{fp, ip, lr, pc}
 c2198bc:	e24cb004 	sub	fp, ip, #4
 c2198c0:	e24dde41 	sub	sp, sp, #1040	; 0x410
    uint8 buffer[AT24C04_DEPTH], buffer_aux[AT24C04_DEPTH];
    uint16 i, j;
    uint32 addr, data;

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );
 c2198c4:	e59f04b8 	ldr	r0, [pc, #1208]	; c219d84 <Image_ZI_Limit+0x4d0>
 c2198c8:	eb00434a 	bl	c22a5f8 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c2198cc:	e3a03000 	mov	r3, #0
 c2198d0:	e14b30be 	strh	r3, [fp, #-14]
 c2198d4:	ea000009 	b	c219900 <test_EEPROM+0x4c>
		at24c04_byteread( i, &buffer[i] );
 c2198d8:	e15b30be 	ldrh	r3, [fp, #-14]
 c2198dc:	e24b2f86 	sub	r2, fp, #536	; 0x218
 c2198e0:	e0823003 	add	r3, r2, r3
 c2198e4:	e15b20be 	ldrh	r2, [fp, #-14]
 c2198e8:	e1a00002 	mov	r0, r2
 c2198ec:	e1a01003 	mov	r1, r3
 c2198f0:	eb00308b 	bl	c225b24 <at24c04_byteread>

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c2198f4:	e15b30be 	ldrh	r3, [fp, #-14]
 c2198f8:	e2833001 	add	r3, r3, #1
 c2198fc:	e14b30be 	strh	r3, [fp, #-14]
 c219900:	e15b20be 	ldrh	r2, [fp, #-14]
 c219904:	e59f347c 	ldr	r3, [pc, #1148]	; c219d88 <Image_ZI_Limit+0x4d4>
 c219908:	e1520003 	cmp	r2, r3
 c21990c:	9afffff1 	bls	c2198d8 <test_EEPROM+0x24>
		at24c04_byteread( i, &buffer[i] );
	uart0_puts( " - Lectura aleatoria (" );
 c219910:	e59f0474 	ldr	r0, [pc, #1140]	; c219d8c <Image_ZI_Limit+0x4d8>
 c219914:	eb004337 	bl	c22a5f8 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c219918:	e3a00c02 	mov	r0, #512	; 0x200
 c21991c:	eb004349 	bl	c22a648 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c219920:	e59f0468 	ldr	r0, [pc, #1128]	; c219d90 <Image_ZI_Limit+0x4dc>
 c219924:	eb004333 	bl	c22a5f8 <uart0_puts>

	/************************************/
	at24c04_load( buffer_aux );
 c219928:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c21992c:	e243300c 	sub	r3, r3, #12
 c219930:	e243300c 	sub	r3, r3, #12
 c219934:	e1a00003 	mov	r0, r3
 c219938:	eb0030a9 	bl	c225be4 <at24c04_load>
	uart0_puts( " - Lectura secuencial (" );
 c21993c:	e59f0450 	ldr	r0, [pc, #1104]	; c219d94 <Image_ZI_Limit+0x4e0>
 c219940:	eb00432c 	bl	c22a5f8 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c219944:	e3a00c02 	mov	r0, #512	; 0x200
 c219948:	eb00433e 	bl	c22a648 <uart0_putint>
	uart0_puts( " bytes)" );
 c21994c:	e59f0444 	ldr	r0, [pc, #1092]	; c219d98 <Image_ZI_Limit+0x4e4>
 c219950:	eb004328 	bl	c22a5f8 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c219954:	e3a03000 	mov	r3, #0
 c219958:	e14b30be 	strh	r3, [fp, #-14]
 c21995c:	ea000012 	b	c2199ac <test_EEPROM+0xf8>
		if( buffer[i] != buffer_aux[i] )
 c219960:	e15b20be 	ldrh	r2, [fp, #-14]
 c219964:	e59f3430 	ldr	r3, [pc, #1072]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219968:	e24b000c 	sub	r0, fp, #12
 c21996c:	e0802002 	add	r2, r0, r2
 c219970:	e0823003 	add	r3, r2, r3
 c219974:	e5d32000 	ldrb	r2, [r3]
 c219978:	e15b10be 	ldrh	r1, [fp, #-14]
 c21997c:	e59f341c 	ldr	r3, [pc, #1052]	; c219da0 <Image_ZI_Limit+0x4ec>
 c219980:	e24b000c 	sub	r0, fp, #12
 c219984:	e0801001 	add	r1, r0, r1
 c219988:	e0813003 	add	r3, r1, r3
 c21998c:	e5d33000 	ldrb	r3, [r3]
 c219990:	e1520003 	cmp	r2, r3
 c219994:	0a000001 	beq	c2199a0 <test_EEPROM+0xec>
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );
 c219998:	e59f0404 	ldr	r0, [pc, #1028]	; c219da4 <Image_ZI_Limit+0x4f0>
 c21999c:	eb004315 	bl	c22a5f8 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c2199a0:	e15b30be 	ldrh	r3, [fp, #-14]
 c2199a4:	e2833001 	add	r3, r3, #1
 c2199a8:	e14b30be 	strh	r3, [fp, #-14]
 c2199ac:	e15b20be 	ldrh	r2, [fp, #-14]
 c2199b0:	e59f33d0 	ldr	r3, [pc, #976]	; c219d88 <Image_ZI_Limit+0x4d4>
 c2199b4:	e1520003 	cmp	r2, r3
 c2199b8:	9affffe8 	bls	c219960 <test_EEPROM+0xac>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );
 c2199bc:	e59f03e4 	ldr	r0, [pc, #996]	; c219da8 <Image_ZI_Limit+0x4f4>
 c2199c0:	eb00430c 	bl	c22a5f8 <uart0_puts>

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c2199c4:	e3a03000 	mov	r3, #0
 c2199c8:	e14b30be 	strh	r3, [fp, #-14]
 c2199cc:	ea000066 	b	c219b6c <test_EEPROM+0x2b8>
		uart0_puts( "\n" );
 c2199d0:	e59f03d4 	ldr	r0, [pc, #980]	; c219dac <Image_ZI_Limit+0x4f8>
 c2199d4:	eb004307 	bl	c22a5f8 <uart0_puts>
		if( i<<4 <= 0xf )
 c2199d8:	e15b30be 	ldrh	r3, [fp, #-14]
 c2199dc:	e1a03203 	lsl	r3, r3, #4
 c2199e0:	e353000f 	cmp	r3, #15
 c2199e4:	ca000002 	bgt	c2199f4 <test_EEPROM+0x140>
			uart0_puts( "00" );
 c2199e8:	e59f03c0 	ldr	r0, [pc, #960]	; c219db0 <Image_ZI_Limit+0x4fc>
 c2199ec:	eb004301 	bl	c22a5f8 <uart0_puts>
 c2199f0:	ea000005 	b	c219a0c <test_EEPROM+0x158>
		else if( i<<4 <= 0xff )
 c2199f4:	e15b30be 	ldrh	r3, [fp, #-14]
 c2199f8:	e1a03203 	lsl	r3, r3, #4
 c2199fc:	e35300ff 	cmp	r3, #255	; 0xff
 c219a00:	ca000001 	bgt	c219a0c <test_EEPROM+0x158>
			uart0_putchar( '0' );
 c219a04:	e3a00030 	mov	r0, #48	; 0x30
 c219a08:	eb0042d4 	bl	c22a560 <uart0_putchar>
		uart0_puthex( i<<4 );
 c219a0c:	e15b30be 	ldrh	r3, [fp, #-14]
 c219a10:	e1a03203 	lsl	r3, r3, #4
 c219a14:	e1a00003 	mov	r0, r3
 c219a18:	eb00434a 	bl	c22a748 <uart0_puthex>
		uart0_puts( "h:"  );
 c219a1c:	e59f0390 	ldr	r0, [pc, #912]	; c219db4 <Image_ZI_Limit+0x500>
 c219a20:	eb0042f4 	bl	c22a5f8 <uart0_puts>
		for( j=0; j<16; j++ )
 c219a24:	e3a03000 	mov	r3, #0
 c219a28:	e14b31b0 	strh	r3, [fp, #-16]
 c219a2c:	ea00001a 	b	c219a9c <test_EEPROM+0x1e8>
		{
			if( buffer[(i<<4)+j] <= 0xf )
 c219a30:	e15b30be 	ldrh	r3, [fp, #-14]
 c219a34:	e1a02203 	lsl	r2, r3, #4
 c219a38:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219a3c:	e0822003 	add	r2, r2, r3
 c219a40:	e59f3354 	ldr	r3, [pc, #852]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219a44:	e24b100c 	sub	r1, fp, #12
 c219a48:	e0812002 	add	r2, r1, r2
 c219a4c:	e0823003 	add	r3, r2, r3
 c219a50:	e5d33000 	ldrb	r3, [r3]
 c219a54:	e353000f 	cmp	r3, #15
 c219a58:	8a000001 	bhi	c219a64 <test_EEPROM+0x1b0>
				uart0_putchar( '0' );
 c219a5c:	e3a00030 	mov	r0, #48	; 0x30
 c219a60:	eb0042be 	bl	c22a560 <uart0_putchar>
			uart0_puthex( buffer[(i<<4)+j] );
 c219a64:	e15b30be 	ldrh	r3, [fp, #-14]
 c219a68:	e1a02203 	lsl	r2, r3, #4
 c219a6c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219a70:	e0822003 	add	r2, r2, r3
 c219a74:	e59f3320 	ldr	r3, [pc, #800]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219a78:	e24b000c 	sub	r0, fp, #12
 c219a7c:	e0802002 	add	r2, r0, r2
 c219a80:	e0823003 	add	r3, r2, r3
 c219a84:	e5d33000 	ldrb	r3, [r3]
 c219a88:	e1a00003 	mov	r0, r3
 c219a8c:	eb00432d 	bl	c22a748 <uart0_puthex>
			uart0_puts( "00" );
		else if( i<<4 <= 0xff )
			uart0_putchar( '0' );
		uart0_puthex( i<<4 );
		uart0_puts( "h:"  );
		for( j=0; j<16; j++ )
 c219a90:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219a94:	e2833001 	add	r3, r3, #1
 c219a98:	e14b31b0 	strh	r3, [fp, #-16]
 c219a9c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219aa0:	e353000f 	cmp	r3, #15
 c219aa4:	9affffe1 	bls	c219a30 <test_EEPROM+0x17c>
		{
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
 c219aa8:	e59f0308 	ldr	r0, [pc, #776]	; c219db8 <Image_ZI_Limit+0x504>
 c219aac:	eb0042d1 	bl	c22a5f8 <uart0_puts>
		for( j=0; j<16; j++ )
 c219ab0:	e3a03000 	mov	r3, #0
 c219ab4:	e14b31b0 	strh	r3, [fp, #-16]
 c219ab8:	ea000025 	b	c219b54 <test_EEPROM+0x2a0>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
 c219abc:	e15b30be 	ldrh	r3, [fp, #-14]
 c219ac0:	e1a02203 	lsl	r2, r3, #4
 c219ac4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219ac8:	e0822003 	add	r2, r2, r3
 c219acc:	e59f32c8 	ldr	r3, [pc, #712]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219ad0:	e24b100c 	sub	r1, fp, #12
 c219ad4:	e0812002 	add	r2, r1, r2
 c219ad8:	e0823003 	add	r3, r2, r3
 c219adc:	e5d33000 	ldrb	r3, [r3]
 c219ae0:	e353001f 	cmp	r3, #31
 c219ae4:	9a000014 	bls	c219b3c <test_EEPROM+0x288>
 c219ae8:	e15b30be 	ldrh	r3, [fp, #-14]
 c219aec:	e1a02203 	lsl	r2, r3, #4
 c219af0:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219af4:	e0822003 	add	r2, r2, r3
 c219af8:	e59f329c 	ldr	r3, [pc, #668]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219afc:	e24b000c 	sub	r0, fp, #12
 c219b00:	e0802002 	add	r2, r0, r2
 c219b04:	e0823003 	add	r3, r2, r3
 c219b08:	e5d33000 	ldrb	r3, [r3]
 c219b0c:	e353007e 	cmp	r3, #126	; 0x7e
 c219b10:	8a000009 	bhi	c219b3c <test_EEPROM+0x288>
 c219b14:	e15b30be 	ldrh	r3, [fp, #-14]
 c219b18:	e1a02203 	lsl	r2, r3, #4
 c219b1c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219b20:	e0822003 	add	r2, r2, r3
 c219b24:	e59f3270 	ldr	r3, [pc, #624]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219b28:	e24b100c 	sub	r1, fp, #12
 c219b2c:	e0812002 	add	r2, r1, r2
 c219b30:	e0823003 	add	r3, r2, r3
 c219b34:	e5d33000 	ldrb	r3, [r3]
 c219b38:	ea000000 	b	c219b40 <test_EEPROM+0x28c>
 c219b3c:	e3a0302e 	mov	r3, #46	; 0x2e
 c219b40:	e1a00003 	mov	r0, r3
 c219b44:	eb004285 	bl	c22a560 <uart0_putchar>
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
		for( j=0; j<16; j++ )
 c219b48:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219b4c:	e2833001 	add	r3, r3, #1
 c219b50:	e14b31b0 	strh	r3, [fp, #-16]
 c219b54:	e15b31b0 	ldrh	r3, [fp, #-16]
 c219b58:	e353000f 	cmp	r3, #15
 c219b5c:	9affffd6 	bls	c219abc <test_EEPROM+0x208>

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c219b60:	e15b30be 	ldrh	r3, [fp, #-14]
 c219b64:	e2833001 	add	r3, r3, #1
 c219b68:	e14b30be 	strh	r3, [fp, #-14]
 c219b6c:	e15b30be 	ldrh	r3, [fp, #-14]
 c219b70:	e353001f 	cmp	r3, #31
 c219b74:	9affff95 	bls	c2199d0 <test_EEPROM+0x11c>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
	};

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );
 c219b78:	e59f023c 	ldr	r0, [pc, #572]	; c219dbc <Image_ZI_Limit+0x508>
 c219b7c:	eb00429d 	bl	c22a5f8 <uart0_puts>

	for( i=0; i<5; i++ )
 c219b80:	e3a03000 	mov	r3, #0
 c219b84:	e14b30be 	strh	r3, [fp, #-14]
 c219b88:	ea000012 	b	c219bd8 <test_EEPROM+0x324>
	{
		uart0_puts( "  - Introduzca una direccion (0h-1ffh): " );
 c219b8c:	e59f022c 	ldr	r0, [pc, #556]	; c219dc0 <Image_ZI_Limit+0x50c>
 c219b90:	eb004298 	bl	c22a5f8 <uart0_puts>
		addr = uart0_gethex( );
 c219b94:	eb00436a 	bl	c22a944 <uart0_gethex>
 c219b98:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
		uart0_puts( "  - Introduzca el dato (0h-ffh): " );
 c219b9c:	e59f0220 	ldr	r0, [pc, #544]	; c219dc4 <Image_ZI_Limit+0x510>
 c219ba0:	eb004294 	bl	c22a5f8 <uart0_puts>
		data = uart0_gethex( );
 c219ba4:	eb004366 	bl	c22a944 <uart0_gethex>
 c219ba8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
		buffer[addr] = data;
 c219bac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c219bb0:	e20320ff 	and	r2, r3, #255	; 0xff
 c219bb4:	e59f31e0 	ldr	r3, [pc, #480]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219bb8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c219bbc:	e24b000c 	sub	r0, fp, #12
 c219bc0:	e0801001 	add	r1, r0, r1
 c219bc4:	e0813003 	add	r3, r1, r3
 c219bc8:	e5c32000 	strb	r2, [r3]

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i<5; i++ )
 c219bcc:	e15b30be 	ldrh	r3, [fp, #-14]
 c219bd0:	e2833001 	add	r3, r3, #1
 c219bd4:	e14b30be 	strh	r3, [fp, #-14]
 c219bd8:	e15b30be 	ldrh	r3, [fp, #-14]
 c219bdc:	e3530004 	cmp	r3, #4
 c219be0:	9affffe9 	bls	c219b8c <test_EEPROM+0x2d8>
		buffer[addr] = data;
	}

	/************************************/

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );
 c219be4:	e59f01dc 	ldr	r0, [pc, #476]	; c219dc8 <Image_ZI_Limit+0x514>
 c219be8:	eb004282 	bl	c22a5f8 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c219bec:	e3a03000 	mov	r3, #0
 c219bf0:	e14b30be 	strh	r3, [fp, #-14]
 c219bf4:	ea00000c 	b	c219c2c <test_EEPROM+0x378>
		at24c04_bytewrite( i, buffer[i] );
 c219bf8:	e15b20be 	ldrh	r2, [fp, #-14]
 c219bfc:	e59f3198 	ldr	r3, [pc, #408]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219c00:	e24b100c 	sub	r1, fp, #12
 c219c04:	e0812002 	add	r2, r1, r2
 c219c08:	e0823003 	add	r3, r2, r3
 c219c0c:	e5d33000 	ldrb	r3, [r3]
 c219c10:	e15b20be 	ldrh	r2, [fp, #-14]
 c219c14:	e1a00002 	mov	r0, r2
 c219c18:	e1a01003 	mov	r1, r3
 c219c1c:	eb002f9d 	bl	c225a98 <at24c04_bytewrite>

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c219c20:	e15b30be 	ldrh	r3, [fp, #-14]
 c219c24:	e2833001 	add	r3, r3, #1
 c219c28:	e14b30be 	strh	r3, [fp, #-14]
 c219c2c:	e15b20be 	ldrh	r2, [fp, #-14]
 c219c30:	e59f3150 	ldr	r3, [pc, #336]	; c219d88 <Image_ZI_Limit+0x4d4>
 c219c34:	e1520003 	cmp	r2, r3
 c219c38:	9affffee 	bls	c219bf8 <test_EEPROM+0x344>
		at24c04_bytewrite( i, buffer[i] );
	uart0_puts( " - Escritura aleatoria (" );
 c219c3c:	e59f0188 	ldr	r0, [pc, #392]	; c219dcc <Image_ZI_Limit+0x518>
 c219c40:	eb00426c 	bl	c22a5f8 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c219c44:	e3a00c02 	mov	r0, #512	; 0x200
 c219c48:	eb00427e 	bl	c22a648 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c219c4c:	e59f013c 	ldr	r0, [pc, #316]	; c219d90 <Image_ZI_Limit+0x4dc>
 c219c50:	eb004268 	bl	c22a5f8 <uart0_puts>

	at24c04_load( buffer_aux );
 c219c54:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c219c58:	e243300c 	sub	r3, r3, #12
 c219c5c:	e243300c 	sub	r3, r3, #12
 c219c60:	e1a00003 	mov	r0, r3
 c219c64:	eb002fde 	bl	c225be4 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c219c68:	e3a03000 	mov	r3, #0
 c219c6c:	e14b30be 	strh	r3, [fp, #-14]
 c219c70:	ea000012 	b	c219cc0 <test_EEPROM+0x40c>
		if( buffer[i] != buffer_aux[i] )
 c219c74:	e15b20be 	ldrh	r2, [fp, #-14]
 c219c78:	e59f311c 	ldr	r3, [pc, #284]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219c7c:	e24b000c 	sub	r0, fp, #12
 c219c80:	e0802002 	add	r2, r0, r2
 c219c84:	e0823003 	add	r3, r2, r3
 c219c88:	e5d32000 	ldrb	r2, [r3]
 c219c8c:	e15b10be 	ldrh	r1, [fp, #-14]
 c219c90:	e59f3108 	ldr	r3, [pc, #264]	; c219da0 <Image_ZI_Limit+0x4ec>
 c219c94:	e24b000c 	sub	r0, fp, #12
 c219c98:	e0801001 	add	r1, r0, r1
 c219c9c:	e0813003 	add	r3, r1, r3
 c219ca0:	e5d33000 	ldrb	r3, [r3]
 c219ca4:	e1520003 	cmp	r2, r3
 c219ca8:	0a000001 	beq	c219cb4 <test_EEPROM+0x400>
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );
 c219cac:	e59f011c 	ldr	r0, [pc, #284]	; c219dd0 <Image_ZI_Limit+0x51c>
 c219cb0:	eb004250 	bl	c22a5f8 <uart0_puts>
	uart0_puts( " - Escritura aleatoria (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c219cb4:	e15b30be 	ldrh	r3, [fp, #-14]
 c219cb8:	e2833001 	add	r3, r3, #1
 c219cbc:	e14b30be 	strh	r3, [fp, #-14]
 c219cc0:	e15b20be 	ldrh	r2, [fp, #-14]
 c219cc4:	e59f30bc 	ldr	r3, [pc, #188]	; c219d88 <Image_ZI_Limit+0x4d4>
 c219cc8:	e1520003 	cmp	r2, r3
 c219ccc:	9affffe8 	bls	c219c74 <test_EEPROM+0x3c0>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );

	/************************************/

	at24c04_store( buffer );
 c219cd0:	e24b3f86 	sub	r3, fp, #536	; 0x218
 c219cd4:	e1a00003 	mov	r0, r3
 c219cd8:	eb002fef 	bl	c225c9c <at24c04_store>
	uart0_puts( " - Escritura secuencial (" );
 c219cdc:	e59f00f0 	ldr	r0, [pc, #240]	; c219dd4 <Image_ZI_Limit+0x520>
 c219ce0:	eb004244 	bl	c22a5f8 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c219ce4:	e3a00c02 	mov	r0, #512	; 0x200
 c219ce8:	eb004256 	bl	c22a648 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c219cec:	e59f009c 	ldr	r0, [pc, #156]	; c219d90 <Image_ZI_Limit+0x4dc>
 c219cf0:	eb004240 	bl	c22a5f8 <uart0_puts>

	at24c04_load( buffer_aux );
 c219cf4:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c219cf8:	e243300c 	sub	r3, r3, #12
 c219cfc:	e243300c 	sub	r3, r3, #12
 c219d00:	e1a00003 	mov	r0, r3
 c219d04:	eb002fb6 	bl	c225be4 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c219d08:	e3a03000 	mov	r3, #0
 c219d0c:	e14b30be 	strh	r3, [fp, #-14]
 c219d10:	ea000012 	b	c219d60 <test_EEPROM+0x4ac>
		if( buffer[i] != buffer_aux[i] )
 c219d14:	e15b20be 	ldrh	r2, [fp, #-14]
 c219d18:	e59f307c 	ldr	r3, [pc, #124]	; c219d9c <Image_ZI_Limit+0x4e8>
 c219d1c:	e24b100c 	sub	r1, fp, #12
 c219d20:	e0812002 	add	r2, r1, r2
 c219d24:	e0823003 	add	r3, r2, r3
 c219d28:	e5d32000 	ldrb	r2, [r3]
 c219d2c:	e15b10be 	ldrh	r1, [fp, #-14]
 c219d30:	e59f3068 	ldr	r3, [pc, #104]	; c219da0 <Image_ZI_Limit+0x4ec>
 c219d34:	e24b000c 	sub	r0, fp, #12
 c219d38:	e0801001 	add	r1, r0, r1
 c219d3c:	e0813003 	add	r3, r1, r3
 c219d40:	e5d33000 	ldrb	r3, [r3]
 c219d44:	e1520003 	cmp	r2, r3
 c219d48:	0a000001 	beq	c219d54 <test_EEPROM+0x4a0>
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );
 c219d4c:	e59f0084 	ldr	r0, [pc, #132]	; c219dd8 <Image_ZI_Limit+0x524>
 c219d50:	eb004228 	bl	c22a5f8 <uart0_puts>
	uart0_puts( " - Escritura secuencial (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c219d54:	e15b30be 	ldrh	r3, [fp, #-14]
 c219d58:	e2833001 	add	r3, r3, #1
 c219d5c:	e14b30be 	strh	r3, [fp, #-14]
 c219d60:	e15b20be 	ldrh	r2, [fp, #-14]
 c219d64:	e59f301c 	ldr	r3, [pc, #28]	; c219d88 <Image_ZI_Limit+0x4d4>
 c219d68:	e1520003 	cmp	r2, r3
 c219d6c:	9affffe8 	bls	c219d14 <test_EEPROM+0x460>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );

	/************************************/

	uart0_puts( "\nApague la placa y vuelva a cargar y ejecutar el programa.\n" );
 c219d70:	e59f0064 	ldr	r0, [pc, #100]	; c219ddc <Image_ZI_Limit+0x528>
 c219d74:	eb00421f 	bl	c22a5f8 <uart0_puts>
}
 c219d78:	e24bd00c 	sub	sp, fp, #12
 c219d7c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c219d80:	e12fff1e 	bx	lr
 c219d84:	0c100148 	.word	0x0c100148
 c219d88:	000001ff 	.word	0x000001ff
 c219d8c:	0c100180 	.word	0x0c100180
 c219d90:	0c100198 	.word	0x0c100198
 c219d94:	0c1001a4 	.word	0x0c1001a4
 c219d98:	0c1001bc 	.word	0x0c1001bc
 c219d9c:	fffffdf4 	.word	0xfffffdf4
 c219da0:	fffffbf4 	.word	0xfffffbf4
 c219da4:	0c1001c4 	.word	0x0c1001c4
 c219da8:	0c100200 	.word	0x0c100200
 c219dac:	0c100244 	.word	0x0c100244
 c219db0:	0c100248 	.word	0x0c100248
 c219db4:	0c10024c 	.word	0x0c10024c
 c219db8:	0c100250 	.word	0x0c100250
 c219dbc:	0c100254 	.word	0x0c100254
 c219dc0:	0c100294 	.word	0x0c100294
 c219dc4:	0c1002c0 	.word	0x0c1002c0
 c219dc8:	0c1002e4 	.word	0x0c1002e4
 c219dcc:	0c100320 	.word	0x0c100320
 c219dd0:	0c10033c 	.word	0x0c10033c
 c219dd4:	0c100364 	.word	0x0c100364
 c219dd8:	0c100380 	.word	0x0c100380
 c219ddc:	0c1003a8 	.word	0x0c1003a8

0c219de0 <test_WAV>:

#define REC_BUFFER      ((int16 *)0x0c700000)
#define REC_SIZE        (320000)  /* (5,0 s) * (2 canales) * (2 B/canal) * (16000 muestras/s) = 320000 B  */

void test_WAV( void )
{
 c219de0:	e1a0c00d 	mov	ip, sp
 c219de4:	e92dd800 	push	{fp, ip, lr, pc}
 c219de8:	e24cb004 	sub	fp, ip, #4
 c219dec:	e24dd008 	sub	sp, sp, #8
    uint8 vol;
    boolean flag;

    uda1341ts_init();
 c219df0:	eb00433e 	bl	c22aaf0 <uda1341ts_init>

    /************************************/

    uart0_puts( "\n\nReproducción de audio no comprimido (estéreo, 16b, 16KHz) por pooling:\n" );
 c219df4:	e59f0598 	ldr	r0, [pc, #1432]	; c21a394 <test_WAV+0x5b4>
 c219df8:	eb0041fe 	bl	c22a5f8 <uart0_puts>

    iis_init( IIS_POLLING );
 c219dfc:	e3a00002 	mov	r0, #2
 c219e00:	eb0032f2 	bl	c2269d0 <iis_init>

    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche... " );
 c219e04:	e59f058c 	ldr	r0, [pc, #1420]	; c21a398 <test_WAV+0x5b8>
 c219e08:	eb0041fa 	bl	c22a5f8 <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c219e0c:	e3a00020 	mov	r0, #32
 c219e10:	eb0043b5 	bl	c22acec <uda1341ts_setvol>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c219e14:	e59f0580 	ldr	r0, [pc, #1408]	; c21a39c <test_WAV+0x5bc>
 c219e18:	e59f1580 	ldr	r1, [pc, #1408]	; c21a3a0 <test_WAV+0x5c0>
 c219e1c:	e3a02000 	mov	r2, #0
 c219e20:	eb00336b 	bl	c226bd4 <iis_play>
    uart0_puts( "OK\n" );
 c219e24:	e59f0578 	ldr	r0, [pc, #1400]	; c21a3a4 <test_WAV+0x5c4>
 c219e28:	eb0041f2 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche... " );
 c219e2c:	e59f0574 	ldr	r0, [pc, #1396]	; c21a3a8 <test_WAV+0x5c8>
 c219e30:	eb0041f0 	bl	c22a5f8 <uart0_puts>
    for( vol=0; vol<63; vol++ )
 c219e34:	e3a03000 	mov	r3, #0
 c219e38:	e54b300d 	strb	r3, [fp, #-13]
 c219e3c:	ea000009 	b	c219e68 <test_WAV+0x88>
    {
        uda1341ts_setvol( vol );
 c219e40:	e55b300d 	ldrb	r3, [fp, #-13]
 c219e44:	e1a00003 	mov	r0, r3
 c219e48:	eb0043a7 	bl	c22acec <uda1341ts_setvol>
        iis_play( DTMF1, DTMF_SIZE, FALSE );
 c219e4c:	e59f0558 	ldr	r0, [pc, #1368]	; c21a3ac <test_WAV+0x5cc>
 c219e50:	e3a01c19 	mov	r1, #6400	; 0x1900
 c219e54:	e3a02000 	mov	r2, #0
 c219e58:	eb00335d 	bl	c226bd4 <iis_play>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche... " );
    for( vol=0; vol<63; vol++ )
 c219e5c:	e55b300d 	ldrb	r3, [fp, #-13]
 c219e60:	e2833001 	add	r3, r3, #1
 c219e64:	e54b300d 	strb	r3, [fp, #-13]
 c219e68:	e55b300d 	ldrb	r3, [fp, #-13]
 c219e6c:	e353003e 	cmp	r3, #62	; 0x3e
 c219e70:	9afffff2 	bls	c219e40 <test_WAV+0x60>
    {
        uda1341ts_setvol( vol );
        iis_play( DTMF1, DTMF_SIZE, FALSE );
    }
    uart0_puts( "OK\n" );
 c219e74:	e59f0528 	ldr	r0, [pc, #1320]	; c21a3a4 <test_WAV+0x5c4>
 c219e78:	eb0041de 	bl	c22a5f8 <uart0_puts>
    uda1341ts_setvol( VOL_MAX );
 c219e7c:	e3a0003f 	mov	r0, #63	; 0x3f
 c219e80:	eb004399 	bl	c22acec <uda1341ts_setvol>
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
    uart0_puts( "OK\n" );
	*/
    /************************************/

    uart0_puts( "\nReproducción de audio no comprimido (estéreo, 16b, 16KHz) por DMA:\n" );
 c219e84:	e59f0524 	ldr	r0, [pc, #1316]	; c21a3b0 <test_WAV+0x5d0>
 c219e88:	eb0041da 	bl	c22a5f8 <uart0_puts>

    iis_init( IIS_DMA );
 c219e8c:	e3a00001 	mov	r0, #1
 c219e90:	eb0032ce 	bl	c2269d0 <iis_init>

    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche..." );
 c219e94:	e59f0518 	ldr	r0, [pc, #1304]	; c21a3b4 <test_WAV+0x5d4>
 c219e98:	eb0041d6 	bl	c22a5f8 <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c219e9c:	e3a00020 	mov	r0, #32
 c219ea0:	eb004391 	bl	c22acec <uda1341ts_setvol>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c219ea4:	e59f04f0 	ldr	r0, [pc, #1264]	; c21a39c <test_WAV+0x5bc>
 c219ea8:	e59f14f0 	ldr	r1, [pc, #1264]	; c21a3a0 <test_WAV+0x5c0>
 c219eac:	e3a02000 	mov	r2, #0
 c219eb0:	eb003347 	bl	c226bd4 <iis_play>
    while( iis_status() )
 c219eb4:	ea000003 	b	c219ec8 <test_WAV+0xe8>
    {
        Delay(500);
 c219eb8:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c219ebc:	eb0043ac 	bl	c22ad74 <Delay>
        uart0_putchar( '.' );
 c219ec0:	e3a0002e 	mov	r0, #46	; 0x2e
 c219ec4:	eb0041a5 	bl	c22a560 <uart0_putchar>
    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche..." );
    uda1341ts_setvol( VOL_MED );
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
    while( iis_status() )
 c219ec8:	eb003416 	bl	c226f28 <iis_status>
 c219ecc:	e1a03000 	mov	r3, r0
 c219ed0:	e3530000 	cmp	r3, #0
 c219ed4:	1afffff7 	bne	c219eb8 <test_WAV+0xd8>
    {
        Delay(500);
        uart0_putchar( '.' );
    }
    uart0_puts( " OK\n" );
 c219ed8:	e59f04d8 	ldr	r0, [pc, #1240]	; c21a3b8 <test_WAV+0x5d8>
 c219edc:	eb0041c5 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche..." );
 c219ee0:	e59f04d4 	ldr	r0, [pc, #1236]	; c21a3bc <test_WAV+0x5dc>
 c219ee4:	eb0041c3 	bl	c22a5f8 <uart0_puts>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c219ee8:	e59f04ac 	ldr	r0, [pc, #1196]	; c21a39c <test_WAV+0x5bc>
 c219eec:	e59f14ac 	ldr	r1, [pc, #1196]	; c21a3a0 <test_WAV+0x5c0>
 c219ef0:	e3a02000 	mov	r2, #0
 c219ef4:	eb003336 	bl	c226bd4 <iis_play>
    vol = 0;
 c219ef8:	e3a03000 	mov	r3, #0
 c219efc:	e54b300d 	strb	r3, [fp, #-13]
    while( iis_status() )
 c219f00:	ea00000d 	b	c219f3c <test_WAV+0x15c>
    {
        uda1341ts_setvol( vol );
 c219f04:	e55b300d 	ldrb	r3, [fp, #-13]
 c219f08:	e1a00003 	mov	r0, r3
 c219f0c:	eb004376 	bl	c22acec <uda1341ts_setvol>
        vol = ( vol != 63 ? vol+1 : 0 );
 c219f10:	e55b300d 	ldrb	r3, [fp, #-13]
 c219f14:	e353003f 	cmp	r3, #63	; 0x3f
 c219f18:	0a000003 	beq	c219f2c <test_WAV+0x14c>
 c219f1c:	e55b300d 	ldrb	r3, [fp, #-13]
 c219f20:	e2833001 	add	r3, r3, #1
 c219f24:	e20330ff 	and	r3, r3, #255	; 0xff
 c219f28:	ea000000 	b	c219f30 <test_WAV+0x150>
 c219f2c:	e3a03000 	mov	r3, #0
 c219f30:	e54b300d 	strb	r3, [fp, #-13]
        Delay( 20 );
 c219f34:	e3a00014 	mov	r0, #20
 c219f38:	eb00438d 	bl	c22ad74 <Delay>
    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche..." );
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
    vol = 0;
    while( iis_status() )
 c219f3c:	eb0033f9 	bl	c226f28 <iis_status>
 c219f40:	e1a03000 	mov	r3, r0
 c219f44:	e3530000 	cmp	r3, #0
 c219f48:	1affffed 	bne	c219f04 <test_WAV+0x124>
    {
        uda1341ts_setvol( vol );
        vol = ( vol != 63 ? vol+1 : 0 );
        Delay( 20 );
    }
    uart0_puts( " OK\n" );
 c219f4c:	e59f0464 	ldr	r0, [pc, #1124]	; c21a3b8 <test_WAV+0x5d8>
 c219f50:	eb0041a8 	bl	c22a5f8 <uart0_puts>
    uda1341ts_setvol( VOL_MAX );
 c219f54:	e3a0003f 	mov	r0, #63	; 0x3f
 c219f58:	eb004363 	bl	c22acec <uda1341ts_setvol>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos..." );
 c219f5c:	e59f045c 	ldr	r0, [pc, #1116]	; c21a3c0 <test_WAV+0x5e0>
 c219f60:	eb0041a4 	bl	c22a5f8 <uart0_puts>
    D8Led_digit( 8 );
 c219f64:	e3a00008 	mov	r0, #8
 c219f68:	eb002d2d 	bl	c225424 <D8Led_digit>
    iis_rec( REC_BUFFER, REC_SIZE );
 c219f6c:	e3a006c7 	mov	r0, #208666624	; 0xc700000
 c219f70:	e59f144c 	ldr	r1, [pc, #1100]	; c21a3c4 <test_WAV+0x5e4>
 c219f74:	eb003382 	bl	c226d84 <iis_rec>
    while( iis_status() )
 c219f78:	ea000003 	b	c219f8c <test_WAV+0x1ac>
    {
        Delay( 500 );
 c219f7c:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c219f80:	eb00437b 	bl	c22ad74 <Delay>
        uart0_putchar( '.' );
 c219f84:	e3a0002e 	mov	r0, #46	; 0x2e
 c219f88:	eb004174 	bl	c22a560 <uart0_putchar>
    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos..." );
    D8Led_digit( 8 );
    iis_rec( REC_BUFFER, REC_SIZE );
    while( iis_status() )
 c219f8c:	eb0033e5 	bl	c226f28 <iis_status>
 c219f90:	e1a03000 	mov	r3, r0
 c219f94:	e3530000 	cmp	r3, #0
 c219f98:	1afffff7 	bne	c219f7c <test_WAV+0x19c>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    D8Led_off();
 c219f9c:	eb002d00 	bl	c2253a4 <D8Led_off>
    uart0_puts( " OK\n" );
 c219fa0:	e59f0410 	ldr	r0, [pc, #1040]	; c21a3b8 <test_WAV+0x5d8>
 c219fa4:	eb004193 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "  - Reproducción de grabación: escuche..." );
 c219fa8:	e59f0418 	ldr	r0, [pc, #1048]	; c21a3c8 <test_WAV+0x5e8>
 c219fac:	eb004191 	bl	c22a5f8 <uart0_puts>
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
 c219fb0:	e3a006c7 	mov	r0, #208666624	; 0xc700000
 c219fb4:	e59f1408 	ldr	r1, [pc, #1032]	; c21a3c4 <test_WAV+0x5e4>
 c219fb8:	e3a02000 	mov	r2, #0
 c219fbc:	eb003304 	bl	c226bd4 <iis_play>
    while( iis_status() )
 c219fc0:	ea000003 	b	c219fd4 <test_WAV+0x1f4>
    {
        Delay( 500 );
 c219fc4:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c219fc8:	eb004369 	bl	c22ad74 <Delay>
        uart0_putchar( '.' );
 c219fcc:	e3a0002e 	mov	r0, #46	; 0x2e
 c219fd0:	eb004162 	bl	c22a560 <uart0_putchar>
    }
    D8Led_off();
    uart0_puts( " OK\n" );
    uart0_puts( "  - Reproducción de grabación: escuche..." );
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
    while( iis_status() )
 c219fd4:	eb0033d3 	bl	c226f28 <iis_status>
 c219fd8:	e1a03000 	mov	r3, r0
 c219fdc:	e3530000 	cmp	r3, #0
 c219fe0:	1afffff7 	bne	c219fc4 <test_WAV+0x1e4>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    uart0_puts( " OK\n" );
 c219fe4:	e59f03cc 	ldr	r0, [pc, #972]	; c21a3b8 <test_WAV+0x5d8>
 c219fe8:	eb004182 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua: escuche...\n" );
 c219fec:	e59f03d8 	ldr	r0, [pc, #984]	; c21a3cc <test_WAV+0x5ec>
 c219ff0:	eb004180 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "    (para finalizar presione cualquier tecla)\n    " );
 c219ff4:	e59f03d4 	ldr	r0, [pc, #980]	; c21a3d0 <test_WAV+0x5f0>
 c219ff8:	eb00417e 	bl	c22a5f8 <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c219ffc:	e3a00020 	mov	r0, #32
 c21a000:	eb004339 	bl	c22acec <uda1341ts_setvol>
    iis_playWawFile( NOKIATUNE, TRUE );
 c21a004:	e59f0390 	ldr	r0, [pc, #912]	; c21a39c <test_WAV+0x5bc>
 c21a008:	e3a01001 	mov	r1, #1
 c21a00c:	eb0033d2 	bl	c226f5c <iis_playWawFile>
    while( kb_scan() < 0 )
 c21a010:	ea000003 	b	c21a024 <test_WAV+0x244>
    {
        Delay( 500 );
 c21a014:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c21a018:	eb004355 	bl	c22ad74 <Delay>
        uart0_putchar( '.' );
 c21a01c:	e3a0002e 	mov	r0, #46	; 0x2e
 c21a020:	eb00414e 	bl	c22a560 <uart0_putchar>

    uart0_puts( "  - Reproducción continua: escuche...\n" );
    uart0_puts( "    (para finalizar presione cualquier tecla)\n    " );
    uda1341ts_setvol( VOL_MED );
    iis_playWawFile( NOKIATUNE, TRUE );
    while( kb_scan() < 0 )
 c21a024:	eb00353c 	bl	c22751c <kb_scan>
 c21a028:	e1a03000 	mov	r3, r0
 c21a02c:	e3530000 	cmp	r3, #0
 c21a030:	bafffff7 	blt	c21a014 <test_WAV+0x234>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    uart0_puts("Introduce un entero:");
 c21a034:	e59f0398 	ldr	r0, [pc, #920]	; c21a3d4 <test_WAV+0x5f4>
 c21a038:	eb00416e 	bl	c22a5f8 <uart0_puts>
    uart0_getint();
 c21a03c:	eb00420a 	bl	c22a86c <uart0_getint>
    iis_pause();
 c21a040:	eb0033a0 	bl	c226ec8 <iis_pause>
    uart0_puts( " OK\n" );
 c21a044:	e59f036c 	ldr	r0, [pc, #876]	; c21a3b8 <test_WAV+0x5d8>
 c21a048:	eb00416a 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua con pause: escuche...\n" );
 c21a04c:	e59f0384 	ldr	r0, [pc, #900]	; c21a3d8 <test_WAV+0x5f8>
 c21a050:	eb004168 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
 c21a054:	e59f0380 	ldr	r0, [pc, #896]	; c21a3dc <test_WAV+0x5fc>
 c21a058:	eb004166 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
 c21a05c:	e59f037c 	ldr	r0, [pc, #892]	; c21a3e0 <test_WAV+0x600>
 c21a060:	eb004164 	bl	c22a5f8 <uart0_puts>
    iis_playWawFile( NOKIATUNE, TRUE );
 c21a064:	e59f0330 	ldr	r0, [pc, #816]	; c21a39c <test_WAV+0x5bc>
 c21a068:	e3a01001 	mov	r1, #1
 c21a06c:	eb0033ba 	bl	c226f5c <iis_playWawFile>
    flag = FALSE;
 c21a070:	e3a03000 	mov	r3, #0
 c21a074:	e54b300e 	strb	r3, [fp, #-14]
    while( kb_scan() < 0 )
 c21a078:	ea00000e 	b	c21a0b8 <test_WAV+0x2d8>
    {
        if( flag )
 c21a07c:	e55b300e 	ldrb	r3, [fp, #-14]
 c21a080:	e3530000 	cmp	r3, #0
 c21a084:	0a000003 	beq	c21a098 <test_WAV+0x2b8>
        {
            iis_continue();
 c21a088:	eb00339a 	bl	c226ef8 <iis_continue>
            uart0_puts( "    PLAY\n" );
 c21a08c:	e59f0350 	ldr	r0, [pc, #848]	; c21a3e4 <test_WAV+0x604>
 c21a090:	eb004158 	bl	c22a5f8 <uart0_puts>
 c21a094:	ea000002 	b	c21a0a4 <test_WAV+0x2c4>
        }
        else
        {
           iis_pause();
 c21a098:	eb00338a 	bl	c226ec8 <iis_pause>
           uart0_puts( "    PAUSE\n" );
 c21a09c:	e59f0344 	ldr	r0, [pc, #836]	; c21a3e8 <test_WAV+0x608>
 c21a0a0:	eb004154 	bl	c22a5f8 <uart0_puts>
        }
        flag = !flag;
 c21a0a4:	e55b300e 	ldrb	r3, [fp, #-14]
 c21a0a8:	e3530000 	cmp	r3, #0
 c21a0ac:	13a03000 	movne	r3, #0
 c21a0b0:	03a03001 	moveq	r3, #1
 c21a0b4:	e54b300e 	strb	r3, [fp, #-14]
    uart0_puts( "  - Reproducción continua con pause: escuche...\n" );
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
    iis_playWawFile( NOKIATUNE, TRUE );
    flag = FALSE;
    while( kb_scan() < 0 )
 c21a0b8:	eb003517 	bl	c22751c <kb_scan>
 c21a0bc:	e1a03000 	mov	r3, r0
 c21a0c0:	e3530000 	cmp	r3, #0
 c21a0c4:	baffffec 	blt	c21a07c <test_WAV+0x29c>
           iis_pause();
           uart0_puts( "    PAUSE\n" );
        }
        flag = !flag;
    };
    iis_pause();
 c21a0c8:	eb00337e 	bl	c226ec8 <iis_pause>
    uart0_puts( "    ... OK\n" );
 c21a0cc:	e59f0318 	ldr	r0, [pc, #792]	; c21a3ec <test_WAV+0x60c>
 c21a0d0:	eb004148 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua con mute: escuche...\n" );
 c21a0d4:	e59f0314 	ldr	r0, [pc, #788]	; c21a3f0 <test_WAV+0x610>
 c21a0d8:	eb004146 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
 c21a0dc:	e59f02f8 	ldr	r0, [pc, #760]	; c21a3dc <test_WAV+0x5fc>
 c21a0e0:	eb004144 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
 c21a0e4:	e59f02f4 	ldr	r0, [pc, #756]	; c21a3e0 <test_WAV+0x600>
 c21a0e8:	eb004142 	bl	c22a5f8 <uart0_puts>
    iis_playWawFile( NOKIATUNE, TRUE );
 c21a0ec:	e59f02a8 	ldr	r0, [pc, #680]	; c21a39c <test_WAV+0x5bc>
 c21a0f0:	e3a01001 	mov	r1, #1
 c21a0f4:	eb003398 	bl	c226f5c <iis_playWawFile>
    flag = FALSE;
 c21a0f8:	e3a03000 	mov	r3, #0
 c21a0fc:	e54b300e 	strb	r3, [fp, #-14]
    while( kb_scan() < 0 )
 c21a100:	ea000010 	b	c21a148 <test_WAV+0x368>
    {
        if( flag )
 c21a104:	e55b300e 	ldrb	r3, [fp, #-14]
 c21a108:	e3530000 	cmp	r3, #0
 c21a10c:	0a000004 	beq	c21a124 <test_WAV+0x344>
        {
            uda1341ts_mute( MUTE_OFF );
 c21a110:	e3a00000 	mov	r0, #0
 c21a114:	eb004294 	bl	c22ab6c <uda1341ts_mute>
            uart0_puts( "    MUTE OFF\n" );
 c21a118:	e59f02d4 	ldr	r0, [pc, #724]	; c21a3f4 <test_WAV+0x614>
 c21a11c:	eb004135 	bl	c22a5f8 <uart0_puts>
 c21a120:	ea000003 	b	c21a134 <test_WAV+0x354>
        }
        else
        {
            uda1341ts_mute( MUTE_ON );
 c21a124:	e3a00001 	mov	r0, #1
 c21a128:	eb00428f 	bl	c22ab6c <uda1341ts_mute>
            uart0_puts( "    MUTE ON\n" );
 c21a12c:	e59f02c4 	ldr	r0, [pc, #708]	; c21a3f8 <test_WAV+0x618>
 c21a130:	eb004130 	bl	c22a5f8 <uart0_puts>
        }
        flag = !flag;
 c21a134:	e55b300e 	ldrb	r3, [fp, #-14]
 c21a138:	e3530000 	cmp	r3, #0
 c21a13c:	13a03000 	movne	r3, #0
 c21a140:	03a03001 	moveq	r3, #1
 c21a144:	e54b300e 	strb	r3, [fp, #-14]
    uart0_puts( "  - Reproducción continua con mute: escuche...\n" );
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
    iis_playWawFile( NOKIATUNE, TRUE );
    flag = FALSE;
    while( kb_scan() < 0 )
 c21a148:	eb0034f3 	bl	c22751c <kb_scan>
 c21a14c:	e1a03000 	mov	r3, r0
 c21a150:	e3530000 	cmp	r3, #0
 c21a154:	baffffea 	blt	c21a104 <test_WAV+0x324>
            uda1341ts_mute( MUTE_ON );
            uart0_puts( "    MUTE ON\n" );
        }
        flag = !flag;
    };
    iis_pause();
 c21a158:	eb00335a 	bl	c226ec8 <iis_pause>
    uart0_puts( "    ... OK\n" );
 c21a15c:	e59f0288 	ldr	r0, [pc, #648]	; c21a3ec <test_WAV+0x60c>
 c21a160:	eb004124 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproduccion libre de sonido: pulse el teclado y escuche...\n" );
 c21a164:	e59f0290 	ldr	r0, [pc, #656]	; c21a3fc <test_WAV+0x61c>
 c21a168:	eb004122 	bl	c22a5f8 <uart0_puts>
    while( 1 )
        switch( kb_scan() )
 c21a16c:	eb0034ea 	bl	c22751c <kb_scan>
 c21a170:	e1a03000 	mov	r3, r0
 c21a174:	e353000f 	cmp	r3, #15
 c21a178:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c21a17c:	ea000082 	b	c21a38c <test_WAV+0x5ac>
 c21a180:	0c21a1c0 	.word	0x0c21a1c0
 c21a184:	0c21a1d0 	.word	0x0c21a1d0
 c21a188:	0c21a1e0 	.word	0x0c21a1e0
 c21a18c:	0c21a1f0 	.word	0x0c21a1f0
 c21a190:	0c21a200 	.word	0x0c21a200
 c21a194:	0c21a210 	.word	0x0c21a210
 c21a198:	0c21a220 	.word	0x0c21a220
 c21a19c:	0c21a230 	.word	0x0c21a230
 c21a1a0:	0c21a264 	.word	0x0c21a264
 c21a1a4:	0c21a274 	.word	0x0c21a274
 c21a1a8:	0c21a284 	.word	0x0c21a284
 c21a1ac:	0c21a294 	.word	0x0c21a294
 c21a1b0:	0c21a2c8 	.word	0x0c21a2c8
 c21a1b4:	0c21a2d8 	.word	0x0c21a2d8
 c21a1b8:	0c21a2e8 	.word	0x0c21a2e8
 c21a1bc:	0c21a2f8 	.word	0x0c21a2f8
        {
            case 0:
                iis_playWawFile( DTMF1, FALSE );
 c21a1c0:	e59f01e4 	ldr	r0, [pc, #484]	; c21a3ac <test_WAV+0x5cc>
 c21a1c4:	e3a01000 	mov	r1, #0
 c21a1c8:	eb003363 	bl	c226f5c <iis_playWawFile>
                break;
 c21a1cc:	ea00006f 	b	c21a390 <test_WAV+0x5b0>
            case 1:
                iis_playWawFile( DTMF2, FALSE );
 c21a1d0:	e59f0228 	ldr	r0, [pc, #552]	; c21a400 <test_WAV+0x620>
 c21a1d4:	e3a01000 	mov	r1, #0
 c21a1d8:	eb00335f 	bl	c226f5c <iis_playWawFile>
                break;
 c21a1dc:	ea00006b 	b	c21a390 <test_WAV+0x5b0>
            case 2:
                iis_playWawFile( DTMF3, FALSE );
 c21a1e0:	e59f021c 	ldr	r0, [pc, #540]	; c21a404 <test_WAV+0x624>
 c21a1e4:	e3a01000 	mov	r1, #0
 c21a1e8:	eb00335b 	bl	c226f5c <iis_playWawFile>
                break;
 c21a1ec:	ea000067 	b	c21a390 <test_WAV+0x5b0>
            case 3:
                iis_playWawFile( INVITACION, FALSE );
 c21a1f0:	e59f0210 	ldr	r0, [pc, #528]	; c21a408 <test_WAV+0x628>
 c21a1f4:	e3a01000 	mov	r1, #0
 c21a1f8:	eb003357 	bl	c226f5c <iis_playWawFile>
                break;
 c21a1fc:	ea000063 	b	c21a390 <test_WAV+0x5b0>
            case 4:
                iis_playWawFile( DTMF4, FALSE );
 c21a200:	e59f0204 	ldr	r0, [pc, #516]	; c21a40c <test_WAV+0x62c>
 c21a204:	e3a01000 	mov	r1, #0
 c21a208:	eb003353 	bl	c226f5c <iis_playWawFile>
                break;
 c21a20c:	ea00005f 	b	c21a390 <test_WAV+0x5b0>
            case 5:
                iis_playWawFile( DTMF5, FALSE );
 c21a210:	e59f01f8 	ldr	r0, [pc, #504]	; c21a410 <test_WAV+0x630>
 c21a214:	e3a01000 	mov	r1, #0
 c21a218:	eb00334f 	bl	c226f5c <iis_playWawFile>
                break;
 c21a21c:	ea00005b 	b	c21a390 <test_WAV+0x5b0>
            case 6:
                iis_playWawFile( DTMF6, FALSE );
 c21a220:	e59f01ec 	ldr	r0, [pc, #492]	; c21a414 <test_WAV+0x634>
 c21a224:	e3a01000 	mov	r1, #0
 c21a228:	eb00334b 	bl	c226f5c <iis_playWawFile>
                break;
 c21a22c:	ea000057 	b	c21a390 <test_WAV+0x5b0>
            case 7:
                iis_playWawFile( LLAMADA, FALSE );
 c21a230:	e59f01e0 	ldr	r0, [pc, #480]	; c21a418 <test_WAV+0x638>
 c21a234:	e3a01000 	mov	r1, #0
 c21a238:	eb003347 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c21a23c:	e59f01d4 	ldr	r0, [pc, #468]	; c21a418 <test_WAV+0x638>
 c21a240:	e3a01000 	mov	r1, #0
 c21a244:	eb003344 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c21a248:	e59f01c8 	ldr	r0, [pc, #456]	; c21a418 <test_WAV+0x638>
 c21a24c:	e3a01000 	mov	r1, #0
 c21a250:	eb003341 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c21a254:	e59f01bc 	ldr	r0, [pc, #444]	; c21a418 <test_WAV+0x638>
 c21a258:	e3a01000 	mov	r1, #0
 c21a25c:	eb00333e 	bl	c226f5c <iis_playWawFile>
                break;
 c21a260:	ea00004a 	b	c21a390 <test_WAV+0x5b0>
            case 8:
                iis_playWawFile( DTMF7, FALSE );
 c21a264:	e59f01b0 	ldr	r0, [pc, #432]	; c21a41c <test_WAV+0x63c>
 c21a268:	e3a01000 	mov	r1, #0
 c21a26c:	eb00333a 	bl	c226f5c <iis_playWawFile>
                break;
 c21a270:	ea000046 	b	c21a390 <test_WAV+0x5b0>
            case 9:
                iis_playWawFile( DTMF8, FALSE );
 c21a274:	e59f01a4 	ldr	r0, [pc, #420]	; c21a420 <test_WAV+0x640>
 c21a278:	e3a01000 	mov	r1, #0
 c21a27c:	eb003336 	bl	c226f5c <iis_playWawFile>
                break;
 c21a280:	ea000042 	b	c21a390 <test_WAV+0x5b0>
            case 0xa:
                iis_playWawFile( DTMF9, FALSE );
 c21a284:	e59f0198 	ldr	r0, [pc, #408]	; c21a424 <test_WAV+0x644>
 c21a288:	e3a01000 	mov	r1, #0
 c21a28c:	eb003332 	bl	c226f5c <iis_playWawFile>
                break;
 c21a290:	ea00003e 	b	c21a390 <test_WAV+0x5b0>
            case 0xb:
                iis_playWawFile( CONGESTION, FALSE );
 c21a294:	e59f018c 	ldr	r0, [pc, #396]	; c21a428 <test_WAV+0x648>
 c21a298:	e3a01000 	mov	r1, #0
 c21a29c:	eb00332e 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c21a2a0:	e59f0180 	ldr	r0, [pc, #384]	; c21a428 <test_WAV+0x648>
 c21a2a4:	e3a01000 	mov	r1, #0
 c21a2a8:	eb00332b 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c21a2ac:	e59f0174 	ldr	r0, [pc, #372]	; c21a428 <test_WAV+0x648>
 c21a2b0:	e3a01000 	mov	r1, #0
 c21a2b4:	eb003328 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c21a2b8:	e59f0168 	ldr	r0, [pc, #360]	; c21a428 <test_WAV+0x648>
 c21a2bc:	e3a01000 	mov	r1, #0
 c21a2c0:	eb003325 	bl	c226f5c <iis_playWawFile>
                break;
 c21a2c4:	ea000031 	b	c21a390 <test_WAV+0x5b0>
            case 0xc:
                iis_playWawFile( DTMFSTAR, FALSE );
 c21a2c8:	e59f015c 	ldr	r0, [pc, #348]	; c21a42c <test_WAV+0x64c>
 c21a2cc:	e3a01000 	mov	r1, #0
 c21a2d0:	eb003321 	bl	c226f5c <iis_playWawFile>
                break;
 c21a2d4:	ea00002d 	b	c21a390 <test_WAV+0x5b0>
            case 0xd:
                iis_playWawFile( DTMF0, FALSE );
 c21a2d8:	e3a00531 	mov	r0, #205520896	; 0xc400000
 c21a2dc:	e3a01000 	mov	r1, #0
 c21a2e0:	eb00331d 	bl	c226f5c <iis_playWawFile>
                break;
 c21a2e4:	ea000029 	b	c21a390 <test_WAV+0x5b0>
            case 0xe:
                iis_playWawFile( DTMFSHARP, FALSE );
 c21a2e8:	e59f0140 	ldr	r0, [pc, #320]	; c21a430 <test_WAV+0x650>
 c21a2ec:	e3a01000 	mov	r1, #0
 c21a2f0:	eb003319 	bl	c226f5c <iis_playWawFile>
                break;
 c21a2f4:	ea000025 	b	c21a390 <test_WAV+0x5b0>
            case 0xf:
                iis_playWawFile( OCUPADO, FALSE );
 c21a2f8:	e59f0134 	ldr	r0, [pc, #308]	; c21a434 <test_WAV+0x654>
 c21a2fc:	e3a01000 	mov	r1, #0
 c21a300:	eb003315 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a304:	e59f0128 	ldr	r0, [pc, #296]	; c21a434 <test_WAV+0x654>
 c21a308:	e3a01000 	mov	r1, #0
 c21a30c:	eb003312 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a310:	e59f011c 	ldr	r0, [pc, #284]	; c21a434 <test_WAV+0x654>
 c21a314:	e3a01000 	mov	r1, #0
 c21a318:	eb00330f 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a31c:	e59f0110 	ldr	r0, [pc, #272]	; c21a434 <test_WAV+0x654>
 c21a320:	e3a01000 	mov	r1, #0
 c21a324:	eb00330c 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a328:	e59f0104 	ldr	r0, [pc, #260]	; c21a434 <test_WAV+0x654>
 c21a32c:	e3a01000 	mov	r1, #0
 c21a330:	eb003309 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a334:	e59f00f8 	ldr	r0, [pc, #248]	; c21a434 <test_WAV+0x654>
 c21a338:	e3a01000 	mov	r1, #0
 c21a33c:	eb003306 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a340:	e59f00ec 	ldr	r0, [pc, #236]	; c21a434 <test_WAV+0x654>
 c21a344:	e3a01000 	mov	r1, #0
 c21a348:	eb003303 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a34c:	e59f00e0 	ldr	r0, [pc, #224]	; c21a434 <test_WAV+0x654>
 c21a350:	e3a01000 	mov	r1, #0
 c21a354:	eb003300 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a358:	e59f00d4 	ldr	r0, [pc, #212]	; c21a434 <test_WAV+0x654>
 c21a35c:	e3a01000 	mov	r1, #0
 c21a360:	eb0032fd 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a364:	e59f00c8 	ldr	r0, [pc, #200]	; c21a434 <test_WAV+0x654>
 c21a368:	e3a01000 	mov	r1, #0
 c21a36c:	eb0032fa 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a370:	e59f00bc 	ldr	r0, [pc, #188]	; c21a434 <test_WAV+0x654>
 c21a374:	e3a01000 	mov	r1, #0
 c21a378:	eb0032f7 	bl	c226f5c <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c21a37c:	e59f00b0 	ldr	r0, [pc, #176]	; c21a434 <test_WAV+0x654>
 c21a380:	e3a01000 	mov	r1, #0
 c21a384:	eb0032f4 	bl	c226f5c <iis_playWawFile>
                break;
 c21a388:	ea000000 	b	c21a390 <test_WAV+0x5b0>
            default:
            	continue;
 c21a38c:	e1a00000 	nop			; (mov r0, r0)
        };
 c21a390:	eaffff75 	b	c21a16c <test_WAV+0x38c>
 c21a394:	0c1003e4 	.word	0x0c1003e4
 c21a398:	0c100430 	.word	0x0c100430
 c21a39c:	0c41a000 	.word	0x0c41a000
 c21a3a0:	00055f00 	.word	0x00055f00
 c21a3a4:	0c100460 	.word	0x0c100460
 c21a3a8:	0c100464 	.word	0x0c100464
 c21a3ac:	0c402000 	.word	0x0c402000
 c21a3b0:	0c100498 	.word	0x0c100498
 c21a3b4:	0c1004e0 	.word	0x0c1004e0
 c21a3b8:	0c100510 	.word	0x0c100510
 c21a3bc:	0c100518 	.word	0x0c100518
 c21a3c0:	0c100548 	.word	0x0c100548
 c21a3c4:	0004e200 	.word	0x0004e200
 c21a3c8:	0c10058c 	.word	0x0c10058c
 c21a3cc:	0c1005b8 	.word	0x0c1005b8
 c21a3d0:	0c1005e0 	.word	0x0c1005e0
 c21a3d4:	0c100614 	.word	0x0c100614
 c21a3d8:	0c10062c 	.word	0x0c10062c
 c21a3dc:	0c100660 	.word	0x0c100660
 c21a3e0:	0c10068c 	.word	0x0c10068c
 c21a3e4:	0c1006c8 	.word	0x0c1006c8
 c21a3e8:	0c1006d4 	.word	0x0c1006d4
 c21a3ec:	0c1006e0 	.word	0x0c1006e0
 c21a3f0:	0c1006ec 	.word	0x0c1006ec
 c21a3f4:	0c10071c 	.word	0x0c10071c
 c21a3f8:	0c10072c 	.word	0x0c10072c
 c21a3fc:	0c10073c 	.word	0x0c10073c
 c21a400:	0c404000 	.word	0x0c404000
 c21a404:	0c406000 	.word	0x0c406000
 c21a408:	0c47a000 	.word	0x0c47a000
 c21a40c:	0c408000 	.word	0x0c408000
 c21a410:	0c40a000 	.word	0x0c40a000
 c21a414:	0c40c000 	.word	0x0c40c000
 c21a418:	0c4fa000 	.word	0x0c4fa000
 c21a41c:	0c40e000 	.word	0x0c40e000
 c21a420:	0c410000 	.word	0x0c410000
 c21a424:	0c412000 	.word	0x0c412000
 c21a428:	0c54a000 	.word	0x0c54a000
 c21a42c:	0c414000 	.word	0x0c414000
 c21a430:	0c418000 	.word	0x0c418000
 c21a434:	0c56a000 	.word	0x0c56a000

0c21a438 <test_sound_effects>:
void audiodelay_put( audiodelay_t *buffer, int16 ch0, int16 ch1 );
void audiodelay_get( audiodelay_t *buffer, int16 *ch0, int16 *ch1 );


void test_sound_effects( void )
{
 c21a438:	e1a0c00d 	mov	ip, sp
 c21a43c:	e92dd800 	push	{fp, ip, lr, pc}
 c21a440:	e24cb004 	sub	fp, ip, #4
 c21a444:	e24dd010 	sub	sp, sp, #16
	uint32 i, vol;
	int16 ch0, ch1;
	int16 ch0_aux, ch1_aux;

    uda1341ts_init();
 c21a448:	eb0041a8 	bl	c22aaf0 <uda1341ts_init>
    iis_init( IIS_POLLING );
 c21a44c:	e3a00002 	mov	r0, #2
 c21a450:	eb00315e 	bl	c2269d0 <iis_init>

    /************************************/

    uart0_puts( "\n\nReproducción de sonido tabulado (LA central 440 Hz)\n" );
 c21a454:	e59f0c54 	ldr	r0, [pc, #3156]	; c21b0b0 <test_sound_effects+0xc78>
 c21a458:	eb004066 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
 c21a45c:	e59f0c50 	ldr	r0, [pc, #3152]	; c21b0b4 <test_sound_effects+0xc7c>
 c21a460:	eb004064 	bl	c22a5f8 <uart0_puts>

    /************************************/

	uart0_puts( "  - Sinusoide: escuche... " );
 c21a464:	e59f0c4c 	ldr	r0, [pc, #3148]	; c21b0b8 <test_sound_effects+0xc80>
 c21a468:	eb004062 	bl	c22a5f8 <uart0_puts>
	i = 0;
 c21a46c:	e3a03000 	mov	r3, #0
 c21a470:	e50b3010 	str	r3, [fp, #-16]
	while( kb_scan() < 0 )
 c21a474:	ea000018 	b	c21a4dc <test_sound_effects+0xa4>
	{
		iis_putSample( sine[i], sine[i] );
 c21a478:	e59f2c3c 	ldr	r2, [pc, #3132]	; c21b0bc <test_sound_effects+0xc84>
 c21a47c:	e51b3010 	ldr	r3, [fp, #-16]
 c21a480:	e1a03083 	lsl	r3, r3, #1
 c21a484:	e0823003 	add	r3, r2, r3
 c21a488:	e1d320b0 	ldrh	r2, [r3]
 c21a48c:	e59f1c28 	ldr	r1, [pc, #3112]	; c21b0bc <test_sound_effects+0xc84>
 c21a490:	e51b3010 	ldr	r3, [fp, #-16]
 c21a494:	e1a03083 	lsl	r3, r3, #1
 c21a498:	e0813003 	add	r3, r1, r3
 c21a49c:	e1d330b0 	ldrh	r3, [r3]
 c21a4a0:	e1a02802 	lsl	r2, r2, #16
 c21a4a4:	e1a02842 	asr	r2, r2, #16
 c21a4a8:	e1a03803 	lsl	r3, r3, #16
 c21a4ac:	e1a03843 	asr	r3, r3, #16
 c21a4b0:	e1a00002 	mov	r0, r2
 c21a4b4:	e1a01003 	mov	r1, r3
 c21a4b8:	eb00318a 	bl	c226ae8 <iis_putSample>
		if( ++i > WAVETABLE_SIZE )
 c21a4bc:	e51b3010 	ldr	r3, [fp, #-16]
 c21a4c0:	e2833001 	add	r3, r3, #1
 c21a4c4:	e50b3010 	str	r3, [fp, #-16]
 c21a4c8:	e51b3010 	ldr	r3, [fp, #-16]
 c21a4cc:	e3530024 	cmp	r3, #36	; 0x24
 c21a4d0:	9a000001 	bls	c21a4dc <test_sound_effects+0xa4>
			i = 0;
 c21a4d4:	e3a03000 	mov	r3, #0
 c21a4d8:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

	uart0_puts( "  - Sinusoide: escuche... " );
	i = 0;
	while( kb_scan() < 0 )
 c21a4dc:	eb00340e 	bl	c22751c <kb_scan>
 c21a4e0:	e1a03000 	mov	r3, r0
 c21a4e4:	e3530000 	cmp	r3, #0
 c21a4e8:	baffffe2 	blt	c21a478 <test_sound_effects+0x40>
		iis_putSample( sine[i], sine[i] );
		if( ++i > WAVETABLE_SIZE )
			i = 0;
	}

	uart0_getint();
 c21a4ec:	eb0040de 	bl	c22a86c <uart0_getint>
	uart0_puts( "\nOK\n" );
 c21a4f0:	e59f0bc8 	ldr	r0, [pc, #3016]	; c21b0c0 <test_sound_effects+0xc88>
 c21a4f4:	eb00403f 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Onda cuadrada: escuche... " );
 c21a4f8:	e59f0bc4 	ldr	r0, [pc, #3012]	; c21b0c4 <test_sound_effects+0xc8c>
 c21a4fc:	eb00403d 	bl	c22a5f8 <uart0_puts>
	i = 0;
 c21a500:	e3a03000 	mov	r3, #0
 c21a504:	e50b3010 	str	r3, [fp, #-16]
    while( kb_scan() < 0 )
 c21a508:	ea000018 	b	c21a570 <test_sound_effects+0x138>
    {
     	iis_putSample( square[i], square[i] );
 c21a50c:	e59f2bb4 	ldr	r2, [pc, #2996]	; c21b0c8 <test_sound_effects+0xc90>
 c21a510:	e51b3010 	ldr	r3, [fp, #-16]
 c21a514:	e1a03083 	lsl	r3, r3, #1
 c21a518:	e0823003 	add	r3, r2, r3
 c21a51c:	e1d320b0 	ldrh	r2, [r3]
 c21a520:	e59f1ba0 	ldr	r1, [pc, #2976]	; c21b0c8 <test_sound_effects+0xc90>
 c21a524:	e51b3010 	ldr	r3, [fp, #-16]
 c21a528:	e1a03083 	lsl	r3, r3, #1
 c21a52c:	e0813003 	add	r3, r1, r3
 c21a530:	e1d330b0 	ldrh	r3, [r3]
 c21a534:	e1a02802 	lsl	r2, r2, #16
 c21a538:	e1a02842 	asr	r2, r2, #16
 c21a53c:	e1a03803 	lsl	r3, r3, #16
 c21a540:	e1a03843 	asr	r3, r3, #16
 c21a544:	e1a00002 	mov	r0, r2
 c21a548:	e1a01003 	mov	r1, r3
 c21a54c:	eb003165 	bl	c226ae8 <iis_putSample>
     	if( ++i > WAVETABLE_SIZE )
 c21a550:	e51b3010 	ldr	r3, [fp, #-16]
 c21a554:	e2833001 	add	r3, r3, #1
 c21a558:	e50b3010 	str	r3, [fp, #-16]
 c21a55c:	e51b3010 	ldr	r3, [fp, #-16]
 c21a560:	e3530024 	cmp	r3, #36	; 0x24
 c21a564:	9a000001 	bls	c21a570 <test_sound_effects+0x138>
     		i = 0;
 c21a568:	e3a03000 	mov	r3, #0
 c21a56c:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

    uart0_puts( "  - Onda cuadrada: escuche... " );
	i = 0;
    while( kb_scan() < 0 )
 c21a570:	eb0033e9 	bl	c22751c <kb_scan>
 c21a574:	e1a03000 	mov	r3, r0
 c21a578:	e3530000 	cmp	r3, #0
 c21a57c:	baffffe2 	blt	c21a50c <test_sound_effects+0xd4>
    {
     	iis_putSample( square[i], square[i] );
     	if( ++i > WAVETABLE_SIZE )
     		i = 0;
    }
    uart0_getint();
 c21a580:	eb0040b9 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21a584:	e59f0b40 	ldr	r0, [pc, #2880]	; c21b0cc <test_sound_effects+0xc94>
 c21a588:	eb00401a 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Onda triangular: escuche... " );
 c21a58c:	e59f0b3c 	ldr	r0, [pc, #2876]	; c21b0d0 <test_sound_effects+0xc98>
 c21a590:	eb004018 	bl	c22a5f8 <uart0_puts>
    i = 0;
 c21a594:	e3a03000 	mov	r3, #0
 c21a598:	e50b3010 	str	r3, [fp, #-16]
	while( kb_scan() < 0 )
 c21a59c:	ea000018 	b	c21a604 <test_sound_effects+0x1cc>
    {
     	iis_putSample( triangle[i], triangle[i] );
 c21a5a0:	e59f2b2c 	ldr	r2, [pc, #2860]	; c21b0d4 <test_sound_effects+0xc9c>
 c21a5a4:	e51b3010 	ldr	r3, [fp, #-16]
 c21a5a8:	e1a03083 	lsl	r3, r3, #1
 c21a5ac:	e0823003 	add	r3, r2, r3
 c21a5b0:	e1d320b0 	ldrh	r2, [r3]
 c21a5b4:	e59f1b18 	ldr	r1, [pc, #2840]	; c21b0d4 <test_sound_effects+0xc9c>
 c21a5b8:	e51b3010 	ldr	r3, [fp, #-16]
 c21a5bc:	e1a03083 	lsl	r3, r3, #1
 c21a5c0:	e0813003 	add	r3, r1, r3
 c21a5c4:	e1d330b0 	ldrh	r3, [r3]
 c21a5c8:	e1a02802 	lsl	r2, r2, #16
 c21a5cc:	e1a02842 	asr	r2, r2, #16
 c21a5d0:	e1a03803 	lsl	r3, r3, #16
 c21a5d4:	e1a03843 	asr	r3, r3, #16
 c21a5d8:	e1a00002 	mov	r0, r2
 c21a5dc:	e1a01003 	mov	r1, r3
 c21a5e0:	eb003140 	bl	c226ae8 <iis_putSample>
     	if( ++i > WAVETABLE_SIZE )
 c21a5e4:	e51b3010 	ldr	r3, [fp, #-16]
 c21a5e8:	e2833001 	add	r3, r3, #1
 c21a5ec:	e50b3010 	str	r3, [fp, #-16]
 c21a5f0:	e51b3010 	ldr	r3, [fp, #-16]
 c21a5f4:	e3530024 	cmp	r3, #36	; 0x24
 c21a5f8:	9a000001 	bls	c21a604 <test_sound_effects+0x1cc>
     		i = 0;
 c21a5fc:	e3a03000 	mov	r3, #0
 c21a600:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

    uart0_puts( "  - Onda triangular: escuche... " );
    i = 0;
	while( kb_scan() < 0 )
 c21a604:	eb0033c4 	bl	c22751c <kb_scan>
 c21a608:	e1a03000 	mov	r3, r0
 c21a60c:	e3530000 	cmp	r3, #0
 c21a610:	baffffe2 	blt	c21a5a0 <test_sound_effects+0x168>
    {
     	iis_putSample( triangle[i], triangle[i] );
     	if( ++i > WAVETABLE_SIZE )
     		i = 0;
    }
	uart0_getint();
 c21a614:	eb004094 	bl	c22a86c <uart0_getint>
	uart0_puts( "OK\n" );
 c21a618:	e59f0aac 	ldr	r0, [pc, #2732]	; c21b0cc <test_sound_effects+0xc94>
 c21a61c:	eb003ff5 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "\nEfectos de audio (dominio temporal)\n" );
 c21a620:	e59f0ab0 	ldr	r0, [pc, #2736]	; c21b0d8 <test_sound_effects+0xca0>
 c21a624:	eb003ff3 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos... " );
 c21a628:	e59f0aac 	ldr	r0, [pc, #2732]	; c21b0dc <test_sound_effects+0xca4>
 c21a62c:	eb003ff1 	bl	c22a5f8 <uart0_puts>
    D8Led_digit( 8 );
 c21a630:	e3a00008 	mov	r0, #8
 c21a634:	eb002b7a 	bl	c225424 <D8Led_digit>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a638:	e3a03000 	mov	r3, #0
 c21a63c:	e50b3010 	str	r3, [fp, #-16]
 c21a640:	ea00000d 	b	c21a67c <test_sound_effects+0x244>
     	iis_getSample( &(buffer.ch0[i]), &(buffer.ch1[i]) );
 c21a644:	e51b3010 	ldr	r3, [fp, #-16]
 c21a648:	e1a02083 	lsl	r2, r3, #1
 c21a64c:	e59f3a8c 	ldr	r3, [pc, #2700]	; c21b0e0 <test_sound_effects+0xca8>
 c21a650:	e0822003 	add	r2, r2, r3
 c21a654:	e51b3010 	ldr	r3, [fp, #-16]
 c21a658:	e1a01083 	lsl	r1, r3, #1
 c21a65c:	e59f3a80 	ldr	r3, [pc, #2688]	; c21b0e4 <test_sound_effects+0xcac>
 c21a660:	e0813003 	add	r3, r1, r3
 c21a664:	e1a00002 	mov	r0, r2
 c21a668:	e1a01003 	mov	r1, r3
 c21a66c:	eb003137 	bl	c226b50 <iis_getSample>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos... " );
    D8Led_digit( 8 );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a670:	e51b3010 	ldr	r3, [fp, #-16]
 c21a674:	e2833001 	add	r3, r3, #1
 c21a678:	e50b3010 	str	r3, [fp, #-16]
 c21a67c:	e51b2010 	ldr	r2, [fp, #-16]
 c21a680:	e59f3a60 	ldr	r3, [pc, #2656]	; c21b0e8 <test_sound_effects+0xcb0>
 c21a684:	e1520003 	cmp	r2, r3
 c21a688:	9affffed 	bls	c21a644 <test_sound_effects+0x20c>
     	iis_getSample( &(buffer.ch0[i]), &(buffer.ch1[i]) );
    D8Led_off();
 c21a68c:	eb002b44 	bl	c2253a4 <D8Led_off>
    uart0_puts( "OK\n" );
 c21a690:	e59f0a34 	ldr	r0, [pc, #2612]	; c21b0cc <test_sound_effects+0xc94>
 c21a694:	eb003fd7 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a velocidad normal: escuche... " );
 c21a698:	e59f0a4c 	ldr	r0, [pc, #2636]	; c21b0ec <test_sound_effects+0xcb4>
 c21a69c:	eb003fd5 	bl	c22a5f8 <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a6a0:	e3a03000 	mov	r3, #0
 c21a6a4:	e50b3010 	str	r3, [fp, #-16]
 c21a6a8:	ea000015 	b	c21a704 <test_sound_effects+0x2cc>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c21a6ac:	e59f2a2c 	ldr	r2, [pc, #2604]	; c21b0e0 <test_sound_effects+0xca8>
 c21a6b0:	e51b3010 	ldr	r3, [fp, #-16]
 c21a6b4:	e1a03083 	lsl	r3, r3, #1
 c21a6b8:	e0823003 	add	r3, r2, r3
 c21a6bc:	e1d320b0 	ldrh	r2, [r3]
 c21a6c0:	e59f1a18 	ldr	r1, [pc, #2584]	; c21b0e0 <test_sound_effects+0xca8>
 c21a6c4:	e51b3010 	ldr	r3, [fp, #-16]
 c21a6c8:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c21a6cc:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a6d0:	e1a03083 	lsl	r3, r3, #1
 c21a6d4:	e0813003 	add	r3, r1, r3
 c21a6d8:	e1d330b0 	ldrh	r3, [r3]
 c21a6dc:	e1a02802 	lsl	r2, r2, #16
 c21a6e0:	e1a02842 	asr	r2, r2, #16
 c21a6e4:	e1a03803 	lsl	r3, r3, #16
 c21a6e8:	e1a03843 	asr	r3, r3, #16
 c21a6ec:	e1a00002 	mov	r0, r2
 c21a6f0:	e1a01003 	mov	r1, r3
 c21a6f4:	eb0030fb 	bl	c226ae8 <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a velocidad normal: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a6f8:	e51b3010 	ldr	r3, [fp, #-16]
 c21a6fc:	e2833001 	add	r3, r3, #1
 c21a700:	e50b3010 	str	r3, [fp, #-16]
 c21a704:	e51b2010 	ldr	r2, [fp, #-16]
 c21a708:	e59f39d8 	ldr	r3, [pc, #2520]	; c21b0e8 <test_sound_effects+0xcb0>
 c21a70c:	e1520003 	cmp	r2, r3
 c21a710:	9affffe5 	bls	c21a6ac <test_sound_effects+0x274>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );
 c21a714:	e59f09b0 	ldr	r0, [pc, #2480]	; c21b0cc <test_sound_effects+0xc94>
 c21a718:	eb003fb6 	bl	c22a5f8 <uart0_puts>

    uart0_puts( "  - Reproducción a media velocidad: escuche... " );
 c21a71c:	e59f09cc 	ldr	r0, [pc, #2508]	; c21b0f0 <test_sound_effects+0xcb8>
 c21a720:	eb003fb4 	bl	c22a5f8 <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a724:	e3a03000 	mov	r3, #0
 c21a728:	e50b3010 	str	r3, [fp, #-16]
 c21a72c:	ea000028 	b	c21a7d4 <test_sound_effects+0x39c>
    {
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );	    // cada muestra almacenada se reproduce 2 veces
 c21a730:	e59f29a8 	ldr	r2, [pc, #2472]	; c21b0e0 <test_sound_effects+0xca8>
 c21a734:	e51b3010 	ldr	r3, [fp, #-16]
 c21a738:	e1a03083 	lsl	r3, r3, #1
 c21a73c:	e0823003 	add	r3, r2, r3
 c21a740:	e1d320b0 	ldrh	r2, [r3]
 c21a744:	e59f1994 	ldr	r1, [pc, #2452]	; c21b0e0 <test_sound_effects+0xca8>
 c21a748:	e51b3010 	ldr	r3, [fp, #-16]
 c21a74c:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c21a750:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a754:	e1a03083 	lsl	r3, r3, #1
 c21a758:	e0813003 	add	r3, r1, r3
 c21a75c:	e1d330b0 	ldrh	r3, [r3]
 c21a760:	e1a02802 	lsl	r2, r2, #16
 c21a764:	e1a02842 	asr	r2, r2, #16
 c21a768:	e1a03803 	lsl	r3, r3, #16
 c21a76c:	e1a03843 	asr	r3, r3, #16
 c21a770:	e1a00002 	mov	r0, r2
 c21a774:	e1a01003 	mov	r1, r3
 c21a778:	eb0030da 	bl	c226ae8 <iis_putSample>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c21a77c:	e59f295c 	ldr	r2, [pc, #2396]	; c21b0e0 <test_sound_effects+0xca8>
 c21a780:	e51b3010 	ldr	r3, [fp, #-16]
 c21a784:	e1a03083 	lsl	r3, r3, #1
 c21a788:	e0823003 	add	r3, r2, r3
 c21a78c:	e1d320b0 	ldrh	r2, [r3]
 c21a790:	e59f1948 	ldr	r1, [pc, #2376]	; c21b0e0 <test_sound_effects+0xca8>
 c21a794:	e51b3010 	ldr	r3, [fp, #-16]
 c21a798:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c21a79c:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a7a0:	e1a03083 	lsl	r3, r3, #1
 c21a7a4:	e0813003 	add	r3, r1, r3
 c21a7a8:	e1d330b0 	ldrh	r3, [r3]
 c21a7ac:	e1a02802 	lsl	r2, r2, #16
 c21a7b0:	e1a02842 	asr	r2, r2, #16
 c21a7b4:	e1a03803 	lsl	r3, r3, #16
 c21a7b8:	e1a03843 	asr	r3, r3, #16
 c21a7bc:	e1a00002 	mov	r0, r2
 c21a7c0:	e1a01003 	mov	r1, r3
 c21a7c4:	eb0030c7 	bl	c226ae8 <iis_putSample>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );

    uart0_puts( "  - Reproducción a media velocidad: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a7c8:	e51b3010 	ldr	r3, [fp, #-16]
 c21a7cc:	e2833001 	add	r3, r3, #1
 c21a7d0:	e50b3010 	str	r3, [fp, #-16]
 c21a7d4:	e51b2010 	ldr	r2, [fp, #-16]
 c21a7d8:	e59f3908 	ldr	r3, [pc, #2312]	; c21b0e8 <test_sound_effects+0xcb0>
 c21a7dc:	e1520003 	cmp	r2, r3
 c21a7e0:	9affffd2 	bls	c21a730 <test_sound_effects+0x2f8>
    {
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );	    // cada muestra almacenada se reproduce 2 veces
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
     }
    uart0_puts( "OK\n" );
 c21a7e4:	e59f08e0 	ldr	r0, [pc, #2272]	; c21b0cc <test_sound_effects+0xc94>
 c21a7e8:	eb003f82 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a doble velocidad: escuche... " );
 c21a7ec:	e59f0900 	ldr	r0, [pc, #2304]	; c21b0f4 <test_sound_effects+0xcbc>
 c21a7f0:	eb003f80 	bl	c22a5f8 <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i+=2 )		 	// se reproduce 1 de cada 2 muestras almacenadas
 c21a7f4:	e3a03000 	mov	r3, #0
 c21a7f8:	e50b3010 	str	r3, [fp, #-16]
 c21a7fc:	ea000015 	b	c21a858 <test_sound_effects+0x420>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c21a800:	e59f28d8 	ldr	r2, [pc, #2264]	; c21b0e0 <test_sound_effects+0xca8>
 c21a804:	e51b3010 	ldr	r3, [fp, #-16]
 c21a808:	e1a03083 	lsl	r3, r3, #1
 c21a80c:	e0823003 	add	r3, r2, r3
 c21a810:	e1d320b0 	ldrh	r2, [r3]
 c21a814:	e59f18c4 	ldr	r1, [pc, #2244]	; c21b0e0 <test_sound_effects+0xca8>
 c21a818:	e51b3010 	ldr	r3, [fp, #-16]
 c21a81c:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c21a820:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a824:	e1a03083 	lsl	r3, r3, #1
 c21a828:	e0813003 	add	r3, r1, r3
 c21a82c:	e1d330b0 	ldrh	r3, [r3]
 c21a830:	e1a02802 	lsl	r2, r2, #16
 c21a834:	e1a02842 	asr	r2, r2, #16
 c21a838:	e1a03803 	lsl	r3, r3, #16
 c21a83c:	e1a03843 	asr	r3, r3, #16
 c21a840:	e1a00002 	mov	r0, r2
 c21a844:	e1a01003 	mov	r1, r3
 c21a848:	eb0030a6 	bl	c226ae8 <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a doble velocidad: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i+=2 )		 	// se reproduce 1 de cada 2 muestras almacenadas
 c21a84c:	e51b3010 	ldr	r3, [fp, #-16]
 c21a850:	e2833002 	add	r3, r3, #2
 c21a854:	e50b3010 	str	r3, [fp, #-16]
 c21a858:	e51b2010 	ldr	r2, [fp, #-16]
 c21a85c:	e59f3884 	ldr	r3, [pc, #2180]	; c21b0e8 <test_sound_effects+0xcb0>
 c21a860:	e1520003 	cmp	r2, r3
 c21a864:	9affffe5 	bls	c21a800 <test_sound_effects+0x3c8>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );
 c21a868:	e59f085c 	ldr	r0, [pc, #2140]	; c21b0cc <test_sound_effects+0xc94>
 c21a86c:	eb003f61 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción inversa: escuche... " );
 c21a870:	e59f0880 	ldr	r0, [pc, #2176]	; c21b0f8 <test_sound_effects+0xcc0>
 c21a874:	eb003f5f 	bl	c22a5f8 <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a878:	e3a03000 	mov	r3, #0
 c21a87c:	e50b3010 	str	r3, [fp, #-16]
 c21a880:	ea000019 	b	c21a8ec <test_sound_effects+0x4b4>
     	iis_putSample( buffer.ch0[AUDIOBUFFER_SIZE-i], buffer.ch1[AUDIOBUFFER_SIZE-i] );
 c21a884:	e51b3010 	ldr	r3, [fp, #-16]
 c21a888:	e2633a27 	rsb	r3, r3, #159744	; 0x27000
 c21a88c:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a890:	e59f2848 	ldr	r2, [pc, #2120]	; c21b0e0 <test_sound_effects+0xca8>
 c21a894:	e1a03083 	lsl	r3, r3, #1
 c21a898:	e0823003 	add	r3, r2, r3
 c21a89c:	e1d320b0 	ldrh	r2, [r3]
 c21a8a0:	e51b3010 	ldr	r3, [fp, #-16]
 c21a8a4:	e2633a27 	rsb	r3, r3, #159744	; 0x27000
 c21a8a8:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a8ac:	e59f182c 	ldr	r1, [pc, #2092]	; c21b0e0 <test_sound_effects+0xca8>
 c21a8b0:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c21a8b4:	e2833c01 	add	r3, r3, #256	; 0x100
 c21a8b8:	e1a03083 	lsl	r3, r3, #1
 c21a8bc:	e0813003 	add	r3, r1, r3
 c21a8c0:	e1d330b0 	ldrh	r3, [r3]
 c21a8c4:	e1a02802 	lsl	r2, r2, #16
 c21a8c8:	e1a02842 	asr	r2, r2, #16
 c21a8cc:	e1a03803 	lsl	r3, r3, #16
 c21a8d0:	e1a03843 	asr	r3, r3, #16
 c21a8d4:	e1a00002 	mov	r0, r2
 c21a8d8:	e1a01003 	mov	r1, r3
 c21a8dc:	eb003081 	bl	c226ae8 <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción inversa: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c21a8e0:	e51b3010 	ldr	r3, [fp, #-16]
 c21a8e4:	e2833001 	add	r3, r3, #1
 c21a8e8:	e50b3010 	str	r3, [fp, #-16]
 c21a8ec:	e51b2010 	ldr	r2, [fp, #-16]
 c21a8f0:	e59f37f0 	ldr	r3, [pc, #2032]	; c21b0e8 <test_sound_effects+0xcb0>
 c21a8f4:	e1520003 	cmp	r2, r3
 c21a8f8:	9affffe1 	bls	c21a884 <test_sound_effects+0x44c>
     	iis_putSample( buffer.ch0[AUDIOBUFFER_SIZE-i], buffer.ch1[AUDIOBUFFER_SIZE-i] );
    uart0_puts( "OK\n" );
 c21a8fc:	e59f07c8 	ldr	r0, [pc, #1992]	; c21b0cc <test_sound_effects+0xc94>
 c21a900:	eb003f3c 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
 c21a904:	e59f07a8 	ldr	r0, [pc, #1960]	; c21b0b4 <test_sound_effects+0xc7c>
 c21a908:	eb003f3a 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "  - Loopback: hable y escuche... " );
 c21a90c:	e59f07e8 	ldr	r0, [pc, #2024]	; c21b0fc <test_sound_effects+0xcc4>
 c21a910:	eb003f38 	bl	c22a5f8 <uart0_puts>
    while( kb_scan() < 0 )
 c21a914:	ea00000d 	b	c21a950 <test_sound_effects+0x518>
    {
     	iis_getSample( &ch0, &ch1 );
 c21a918:	e24b2012 	sub	r2, fp, #18
 c21a91c:	e24b3014 	sub	r3, fp, #20
 c21a920:	e1a00002 	mov	r0, r2
 c21a924:	e1a01003 	mov	r1, r3
 c21a928:	eb003088 	bl	c226b50 <iis_getSample>
     	iis_putSample( ch0, ch1 );
 c21a92c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21a930:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21a934:	e1a02802 	lsl	r2, r2, #16
 c21a938:	e1a02842 	asr	r2, r2, #16
 c21a93c:	e1a03803 	lsl	r3, r3, #16
 c21a940:	e1a03843 	asr	r3, r3, #16
 c21a944:	e1a00002 	mov	r0, r2
 c21a948:	e1a01003 	mov	r1, r3
 c21a94c:	eb003065 	bl	c226ae8 <iis_putSample>

    /************************************/

    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
    uart0_puts( "  - Loopback: hable y escuche... " );
    while( kb_scan() < 0 )
 c21a950:	eb0032f1 	bl	c22751c <kb_scan>
 c21a954:	e1a03000 	mov	r3, r0
 c21a958:	e3530000 	cmp	r3, #0
 c21a95c:	baffffed 	blt	c21a918 <test_sound_effects+0x4e0>
    {
     	iis_getSample( &ch0, &ch1 );
     	iis_putSample( ch0, ch1 );
    }
    uart0_getint();
 c21a960:	eb003fc1 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21a964:	e59f0760 	ldr	r0, [pc, #1888]	; c21b0cc <test_sound_effects+0xc94>
 c21a968:	eb003f22 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (8 ms): hable y escuche... " );
 c21a96c:	e59f078c 	ldr	r0, [pc, #1932]	; c21b100 <test_sound_effects+0xcc8>
 c21a970:	eb003f20 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 128 );
 c21a974:	e59f0788 	ldr	r0, [pc, #1928]	; c21b104 <test_sound_effects+0xccc>
 c21a978:	e3a01080 	mov	r1, #128	; 0x80
 c21a97c:	eb0001e7 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21a980:	ea00003f 	b	c21aa84 <test_sound_effects+0x64c>
    {
     	iis_getSample( &ch0, &ch1 );
 c21a984:	e24b2012 	sub	r2, fp, #18
 c21a988:	e24b3014 	sub	r3, fp, #20
 c21a98c:	e1a00002 	mov	r0, r2
 c21a990:	e1a01003 	mov	r1, r3
 c21a994:	eb00306d 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21a998:	e24b2016 	sub	r2, fp, #22
 c21a99c:	e24b3018 	sub	r3, fp, #24
 c21a9a0:	e59f075c 	ldr	r0, [pc, #1884]	; c21b104 <test_sound_effects+0xccc>
 c21a9a4:	e1a01002 	mov	r1, r2
 c21a9a8:	e1a02003 	mov	r2, r3
 c21a9ac:	eb00023c 	bl	c21b2a4 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c21a9b0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21a9b4:	e1a03803 	lsl	r3, r3, #16
 c21a9b8:	e1a03843 	asr	r3, r3, #16
 c21a9bc:	e1a030c3 	asr	r3, r3, #1
 c21a9c0:	e1a03803 	lsl	r3, r3, #16
 c21a9c4:	e1a03823 	lsr	r3, r3, #16
 c21a9c8:	e1a03803 	lsl	r3, r3, #16
 c21a9cc:	e1a02823 	lsr	r2, r3, #16
 c21a9d0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21a9d4:	e1a03803 	lsl	r3, r3, #16
 c21a9d8:	e1a03823 	lsr	r3, r3, #16
 c21a9dc:	e0823003 	add	r3, r2, r3
 c21a9e0:	e1a03803 	lsl	r3, r3, #16
 c21a9e4:	e1a03823 	lsr	r3, r3, #16
 c21a9e8:	e1a03803 	lsl	r3, r3, #16
 c21a9ec:	e1a03823 	lsr	r3, r3, #16
 c21a9f0:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c21a9f4:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21a9f8:	e1a03803 	lsl	r3, r3, #16
 c21a9fc:	e1a03843 	asr	r3, r3, #16
 c21aa00:	e1a030c3 	asr	r3, r3, #1
 c21aa04:	e1a03803 	lsl	r3, r3, #16
 c21aa08:	e1a03823 	lsr	r3, r3, #16
 c21aa0c:	e1a03803 	lsl	r3, r3, #16
 c21aa10:	e1a02823 	lsr	r2, r3, #16
 c21aa14:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21aa18:	e1a03803 	lsl	r3, r3, #16
 c21aa1c:	e1a03823 	lsr	r3, r3, #16
 c21aa20:	e0823003 	add	r3, r2, r3
 c21aa24:	e1a03803 	lsl	r3, r3, #16
 c21aa28:	e1a03823 	lsr	r3, r3, #16
 c21aa2c:	e1a03803 	lsl	r3, r3, #16
 c21aa30:	e1a03823 	lsr	r3, r3, #16
 c21aa34:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c21aa38:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c21aa3c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21aa40:	e1a02802 	lsl	r2, r2, #16
 c21aa44:	e1a02842 	asr	r2, r2, #16
 c21aa48:	e1a03803 	lsl	r3, r3, #16
 c21aa4c:	e1a03843 	asr	r3, r3, #16
 c21aa50:	e1a00002 	mov	r0, r2
 c21aa54:	e1a01003 	mov	r1, r3
 c21aa58:	eb003022 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21aa5c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21aa60:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21aa64:	e1a02802 	lsl	r2, r2, #16
 c21aa68:	e1a02842 	asr	r2, r2, #16
 c21aa6c:	e1a03803 	lsl	r3, r3, #16
 c21aa70:	e1a03843 	asr	r3, r3, #16
 c21aa74:	e59f0688 	ldr	r0, [pc, #1672]	; c21b104 <test_sound_effects+0xccc>
 c21aa78:	e1a01002 	mov	r1, r2
 c21aa7c:	e1a02003 	mov	r2, r3
 c21aa80:	eb0001d5 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (8 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 128 );
    while( kb_scan() < 0 )
 c21aa84:	eb0032a4 	bl	c22751c <kb_scan>
 c21aa88:	e1a03000 	mov	r3, r0
 c21aa8c:	e3530000 	cmp	r3, #0
 c21aa90:	baffffbb 	blt	c21a984 <test_sound_effects+0x54c>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c21aa94:	eb003f74 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21aa98:	e59f062c 	ldr	r0, [pc, #1580]	; c21b0cc <test_sound_effects+0xc94>
 c21aa9c:	eb003ed5 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (45 ms): hable y escuche... " );
 c21aaa0:	e59f0660 	ldr	r0, [pc, #1632]	; c21b108 <test_sound_effects+0xcd0>
 c21aaa4:	eb003ed3 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 720 );
 c21aaa8:	e59f0654 	ldr	r0, [pc, #1620]	; c21b104 <test_sound_effects+0xccc>
 c21aaac:	e3a01e2d 	mov	r1, #720	; 0x2d0
 c21aab0:	eb00019a 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21aab4:	ea00003f 	b	c21abb8 <test_sound_effects+0x780>
    {
     	iis_getSample( &ch0, &ch1 );
 c21aab8:	e24b2012 	sub	r2, fp, #18
 c21aabc:	e24b3014 	sub	r3, fp, #20
 c21aac0:	e1a00002 	mov	r0, r2
 c21aac4:	e1a01003 	mov	r1, r3
 c21aac8:	eb003020 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21aacc:	e24b2016 	sub	r2, fp, #22
 c21aad0:	e24b3018 	sub	r3, fp, #24
 c21aad4:	e59f0628 	ldr	r0, [pc, #1576]	; c21b104 <test_sound_effects+0xccc>
 c21aad8:	e1a01002 	mov	r1, r2
 c21aadc:	e1a02003 	mov	r2, r3
 c21aae0:	eb0001ef 	bl	c21b2a4 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c21aae4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21aae8:	e1a03803 	lsl	r3, r3, #16
 c21aaec:	e1a03843 	asr	r3, r3, #16
 c21aaf0:	e1a030c3 	asr	r3, r3, #1
 c21aaf4:	e1a03803 	lsl	r3, r3, #16
 c21aaf8:	e1a03823 	lsr	r3, r3, #16
 c21aafc:	e1a03803 	lsl	r3, r3, #16
 c21ab00:	e1a02823 	lsr	r2, r3, #16
 c21ab04:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21ab08:	e1a03803 	lsl	r3, r3, #16
 c21ab0c:	e1a03823 	lsr	r3, r3, #16
 c21ab10:	e0823003 	add	r3, r2, r3
 c21ab14:	e1a03803 	lsl	r3, r3, #16
 c21ab18:	e1a03823 	lsr	r3, r3, #16
 c21ab1c:	e1a03803 	lsl	r3, r3, #16
 c21ab20:	e1a03823 	lsr	r3, r3, #16
 c21ab24:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c21ab28:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21ab2c:	e1a03803 	lsl	r3, r3, #16
 c21ab30:	e1a03843 	asr	r3, r3, #16
 c21ab34:	e1a030c3 	asr	r3, r3, #1
 c21ab38:	e1a03803 	lsl	r3, r3, #16
 c21ab3c:	e1a03823 	lsr	r3, r3, #16
 c21ab40:	e1a03803 	lsl	r3, r3, #16
 c21ab44:	e1a02823 	lsr	r2, r3, #16
 c21ab48:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21ab4c:	e1a03803 	lsl	r3, r3, #16
 c21ab50:	e1a03823 	lsr	r3, r3, #16
 c21ab54:	e0823003 	add	r3, r2, r3
 c21ab58:	e1a03803 	lsl	r3, r3, #16
 c21ab5c:	e1a03823 	lsr	r3, r3, #16
 c21ab60:	e1a03803 	lsl	r3, r3, #16
 c21ab64:	e1a03823 	lsr	r3, r3, #16
 c21ab68:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c21ab6c:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c21ab70:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21ab74:	e1a02802 	lsl	r2, r2, #16
 c21ab78:	e1a02842 	asr	r2, r2, #16
 c21ab7c:	e1a03803 	lsl	r3, r3, #16
 c21ab80:	e1a03843 	asr	r3, r3, #16
 c21ab84:	e1a00002 	mov	r0, r2
 c21ab88:	e1a01003 	mov	r1, r3
 c21ab8c:	eb002fd5 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21ab90:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21ab94:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21ab98:	e1a02802 	lsl	r2, r2, #16
 c21ab9c:	e1a02842 	asr	r2, r2, #16
 c21aba0:	e1a03803 	lsl	r3, r3, #16
 c21aba4:	e1a03843 	asr	r3, r3, #16
 c21aba8:	e59f0554 	ldr	r0, [pc, #1364]	; c21b104 <test_sound_effects+0xccc>
 c21abac:	e1a01002 	mov	r1, r2
 c21abb0:	e1a02003 	mov	r2, r3
 c21abb4:	eb000188 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (45 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 720 );
    while( kb_scan() < 0 )
 c21abb8:	eb003257 	bl	c22751c <kb_scan>
 c21abbc:	e1a03000 	mov	r3, r0
 c21abc0:	e3530000 	cmp	r3, #0
 c21abc4:	baffffbb 	blt	c21aab8 <test_sound_effects+0x680>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c21abc8:	eb003f27 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21abcc:	e59f04f8 	ldr	r0, [pc, #1272]	; c21b0cc <test_sound_effects+0xc94>
 c21abd0:	eb003e88 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (85 ms): hable y escuche... " );
 c21abd4:	e59f0530 	ldr	r0, [pc, #1328]	; c21b10c <test_sound_effects+0xcd4>
 c21abd8:	eb003e86 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 1280 );
 c21abdc:	e59f0520 	ldr	r0, [pc, #1312]	; c21b104 <test_sound_effects+0xccc>
 c21abe0:	e3a01c05 	mov	r1, #1280	; 0x500
 c21abe4:	eb00014d 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21abe8:	ea00003f 	b	c21acec <test_sound_effects+0x8b4>
    {
     	iis_getSample( &ch0, &ch1 );
 c21abec:	e24b2012 	sub	r2, fp, #18
 c21abf0:	e24b3014 	sub	r3, fp, #20
 c21abf4:	e1a00002 	mov	r0, r2
 c21abf8:	e1a01003 	mov	r1, r3
 c21abfc:	eb002fd3 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21ac00:	e24b2016 	sub	r2, fp, #22
 c21ac04:	e24b3018 	sub	r3, fp, #24
 c21ac08:	e59f04f4 	ldr	r0, [pc, #1268]	; c21b104 <test_sound_effects+0xccc>
 c21ac0c:	e1a01002 	mov	r1, r2
 c21ac10:	e1a02003 	mov	r2, r3
 c21ac14:	eb0001a2 	bl	c21b2a4 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c21ac18:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21ac1c:	e1a03803 	lsl	r3, r3, #16
 c21ac20:	e1a03843 	asr	r3, r3, #16
 c21ac24:	e1a030c3 	asr	r3, r3, #1
 c21ac28:	e1a03803 	lsl	r3, r3, #16
 c21ac2c:	e1a03823 	lsr	r3, r3, #16
 c21ac30:	e1a03803 	lsl	r3, r3, #16
 c21ac34:	e1a02823 	lsr	r2, r3, #16
 c21ac38:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21ac3c:	e1a03803 	lsl	r3, r3, #16
 c21ac40:	e1a03823 	lsr	r3, r3, #16
 c21ac44:	e0823003 	add	r3, r2, r3
 c21ac48:	e1a03803 	lsl	r3, r3, #16
 c21ac4c:	e1a03823 	lsr	r3, r3, #16
 c21ac50:	e1a03803 	lsl	r3, r3, #16
 c21ac54:	e1a03823 	lsr	r3, r3, #16
 c21ac58:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c21ac5c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21ac60:	e1a03803 	lsl	r3, r3, #16
 c21ac64:	e1a03843 	asr	r3, r3, #16
 c21ac68:	e1a030c3 	asr	r3, r3, #1
 c21ac6c:	e1a03803 	lsl	r3, r3, #16
 c21ac70:	e1a03823 	lsr	r3, r3, #16
 c21ac74:	e1a03803 	lsl	r3, r3, #16
 c21ac78:	e1a02823 	lsr	r2, r3, #16
 c21ac7c:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21ac80:	e1a03803 	lsl	r3, r3, #16
 c21ac84:	e1a03823 	lsr	r3, r3, #16
 c21ac88:	e0823003 	add	r3, r2, r3
 c21ac8c:	e1a03803 	lsl	r3, r3, #16
 c21ac90:	e1a03823 	lsr	r3, r3, #16
 c21ac94:	e1a03803 	lsl	r3, r3, #16
 c21ac98:	e1a03823 	lsr	r3, r3, #16
 c21ac9c:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c21aca0:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c21aca4:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21aca8:	e1a02802 	lsl	r2, r2, #16
 c21acac:	e1a02842 	asr	r2, r2, #16
 c21acb0:	e1a03803 	lsl	r3, r3, #16
 c21acb4:	e1a03843 	asr	r3, r3, #16
 c21acb8:	e1a00002 	mov	r0, r2
 c21acbc:	e1a01003 	mov	r1, r3
 c21acc0:	eb002f88 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21acc4:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21acc8:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21accc:	e1a02802 	lsl	r2, r2, #16
 c21acd0:	e1a02842 	asr	r2, r2, #16
 c21acd4:	e1a03803 	lsl	r3, r3, #16
 c21acd8:	e1a03843 	asr	r3, r3, #16
 c21acdc:	e59f0420 	ldr	r0, [pc, #1056]	; c21b104 <test_sound_effects+0xccc>
 c21ace0:	e1a01002 	mov	r1, r2
 c21ace4:	e1a02003 	mov	r2, r3
 c21ace8:	eb00013b 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (85 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 1280 );
    while( kb_scan() < 0 )
 c21acec:	eb00320a 	bl	c22751c <kb_scan>
 c21acf0:	e1a03000 	mov	r3, r0
 c21acf4:	e3530000 	cmp	r3, #0
 c21acf8:	baffffbb 	blt	c21abec <test_sound_effects+0x7b4>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c21acfc:	eb003eda 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21ad00:	e59f03c4 	ldr	r0, [pc, #964]	; c21b0cc <test_sound_effects+0xc94>
 c21ad04:	eb003e3b 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (150 ms): hable y escuche... " );
 c21ad08:	e59f0400 	ldr	r0, [pc, #1024]	; c21b110 <test_sound_effects+0xcd8>
 c21ad0c:	eb003e39 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 2400 );
 c21ad10:	e59f03ec 	ldr	r0, [pc, #1004]	; c21b104 <test_sound_effects+0xccc>
 c21ad14:	e3a01e96 	mov	r1, #2400	; 0x960
 c21ad18:	eb000100 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21ad1c:	ea00003f 	b	c21ae20 <test_sound_effects+0x9e8>
    {
     	iis_getSample( &ch0, &ch1 );
 c21ad20:	e24b2012 	sub	r2, fp, #18
 c21ad24:	e24b3014 	sub	r3, fp, #20
 c21ad28:	e1a00002 	mov	r0, r2
 c21ad2c:	e1a01003 	mov	r1, r3
 c21ad30:	eb002f86 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21ad34:	e24b2016 	sub	r2, fp, #22
 c21ad38:	e24b3018 	sub	r3, fp, #24
 c21ad3c:	e59f03c0 	ldr	r0, [pc, #960]	; c21b104 <test_sound_effects+0xccc>
 c21ad40:	e1a01002 	mov	r1, r2
 c21ad44:	e1a02003 	mov	r2, r3
 c21ad48:	eb000155 	bl	c21b2a4 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c21ad4c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21ad50:	e1a03803 	lsl	r3, r3, #16
 c21ad54:	e1a03843 	asr	r3, r3, #16
 c21ad58:	e1a030c3 	asr	r3, r3, #1
 c21ad5c:	e1a03803 	lsl	r3, r3, #16
 c21ad60:	e1a03823 	lsr	r3, r3, #16
 c21ad64:	e1a03803 	lsl	r3, r3, #16
 c21ad68:	e1a02823 	lsr	r2, r3, #16
 c21ad6c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21ad70:	e1a03803 	lsl	r3, r3, #16
 c21ad74:	e1a03823 	lsr	r3, r3, #16
 c21ad78:	e0823003 	add	r3, r2, r3
 c21ad7c:	e1a03803 	lsl	r3, r3, #16
 c21ad80:	e1a03823 	lsr	r3, r3, #16
 c21ad84:	e1a03803 	lsl	r3, r3, #16
 c21ad88:	e1a03823 	lsr	r3, r3, #16
 c21ad8c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c21ad90:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21ad94:	e1a03803 	lsl	r3, r3, #16
 c21ad98:	e1a03843 	asr	r3, r3, #16
 c21ad9c:	e1a030c3 	asr	r3, r3, #1
 c21ada0:	e1a03803 	lsl	r3, r3, #16
 c21ada4:	e1a03823 	lsr	r3, r3, #16
 c21ada8:	e1a03803 	lsl	r3, r3, #16
 c21adac:	e1a02823 	lsr	r2, r3, #16
 c21adb0:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21adb4:	e1a03803 	lsl	r3, r3, #16
 c21adb8:	e1a03823 	lsr	r3, r3, #16
 c21adbc:	e0823003 	add	r3, r2, r3
 c21adc0:	e1a03803 	lsl	r3, r3, #16
 c21adc4:	e1a03823 	lsr	r3, r3, #16
 c21adc8:	e1a03803 	lsl	r3, r3, #16
 c21adcc:	e1a03823 	lsr	r3, r3, #16
 c21add0:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c21add4:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c21add8:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21addc:	e1a02802 	lsl	r2, r2, #16
 c21ade0:	e1a02842 	asr	r2, r2, #16
 c21ade4:	e1a03803 	lsl	r3, r3, #16
 c21ade8:	e1a03843 	asr	r3, r3, #16
 c21adec:	e1a00002 	mov	r0, r2
 c21adf0:	e1a01003 	mov	r1, r3
 c21adf4:	eb002f3b 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21adf8:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21adfc:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21ae00:	e1a02802 	lsl	r2, r2, #16
 c21ae04:	e1a02842 	asr	r2, r2, #16
 c21ae08:	e1a03803 	lsl	r3, r3, #16
 c21ae0c:	e1a03843 	asr	r3, r3, #16
 c21ae10:	e59f02ec 	ldr	r0, [pc, #748]	; c21b104 <test_sound_effects+0xccc>
 c21ae14:	e1a01002 	mov	r1, r2
 c21ae18:	e1a02003 	mov	r2, r3
 c21ae1c:	eb0000ee 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (150 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 2400 );
    while( kb_scan() < 0 )
 c21ae20:	eb0031bd 	bl	c22751c <kb_scan>
 c21ae24:	e1a03000 	mov	r3, r0
 c21ae28:	e3530000 	cmp	r3, #0
 c21ae2c:	baffffbb 	blt	c21ad20 <test_sound_effects+0x8e8>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c21ae30:	eb003e8d 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21ae34:	e59f0290 	ldr	r0, [pc, #656]	; c21b0cc <test_sound_effects+0xc94>
 c21ae38:	eb003dee 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo & fade (1 s): hable y escuche... " );
 c21ae3c:	e59f02d0 	ldr	r0, [pc, #720]	; c21b114 <test_sound_effects+0xcdc>
 c21ae40:	eb003dec 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 16000 );
 c21ae44:	e59f02b8 	ldr	r0, [pc, #696]	; c21b104 <test_sound_effects+0xccc>
 c21ae48:	e3a01dfa 	mov	r1, #16000	; 0x3e80
 c21ae4c:	eb0000b3 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21ae50:	ea00003f 	b	c21af54 <test_sound_effects+0xb1c>
    {
     	iis_getSample( &ch0, &ch1 );
 c21ae54:	e24b2012 	sub	r2, fp, #18
 c21ae58:	e24b3014 	sub	r3, fp, #20
 c21ae5c:	e1a00002 	mov	r0, r2
 c21ae60:	e1a01003 	mov	r1, r3
 c21ae64:	eb002f39 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21ae68:	e24b2016 	sub	r2, fp, #22
 c21ae6c:	e24b3018 	sub	r3, fp, #24
 c21ae70:	e59f028c 	ldr	r0, [pc, #652]	; c21b104 <test_sound_effects+0xccc>
 c21ae74:	e1a01002 	mov	r1, r2
 c21ae78:	e1a02003 	mov	r2, r3
 c21ae7c:	eb000108 	bl	c21b2a4 <audiodelay_get>
      	ch0 = ch0 + (ch0_aux >> 1);
 c21ae80:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21ae84:	e1a03803 	lsl	r3, r3, #16
 c21ae88:	e1a03843 	asr	r3, r3, #16
 c21ae8c:	e1a030c3 	asr	r3, r3, #1
 c21ae90:	e1a03803 	lsl	r3, r3, #16
 c21ae94:	e1a03823 	lsr	r3, r3, #16
 c21ae98:	e1a03803 	lsl	r3, r3, #16
 c21ae9c:	e1a02823 	lsr	r2, r3, #16
 c21aea0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21aea4:	e1a03803 	lsl	r3, r3, #16
 c21aea8:	e1a03823 	lsr	r3, r3, #16
 c21aeac:	e0823003 	add	r3, r2, r3
 c21aeb0:	e1a03803 	lsl	r3, r3, #16
 c21aeb4:	e1a03823 	lsr	r3, r3, #16
 c21aeb8:	e1a03803 	lsl	r3, r3, #16
 c21aebc:	e1a03823 	lsr	r3, r3, #16
 c21aec0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
      	ch1 = ch1 + (ch1_aux >> 1);
 c21aec4:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21aec8:	e1a03803 	lsl	r3, r3, #16
 c21aecc:	e1a03843 	asr	r3, r3, #16
 c21aed0:	e1a030c3 	asr	r3, r3, #1
 c21aed4:	e1a03803 	lsl	r3, r3, #16
 c21aed8:	e1a03823 	lsr	r3, r3, #16
 c21aedc:	e1a03803 	lsl	r3, r3, #16
 c21aee0:	e1a02823 	lsr	r2, r3, #16
 c21aee4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21aee8:	e1a03803 	lsl	r3, r3, #16
 c21aeec:	e1a03823 	lsr	r3, r3, #16
 c21aef0:	e0823003 	add	r3, r2, r3
 c21aef4:	e1a03803 	lsl	r3, r3, #16
 c21aef8:	e1a03823 	lsr	r3, r3, #16
 c21aefc:	e1a03803 	lsl	r3, r3, #16
 c21af00:	e1a03823 	lsr	r3, r3, #16
 c21af04:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
     	iis_putSample( ch0, ch1 );
 c21af08:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21af0c:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21af10:	e1a02802 	lsl	r2, r2, #16
 c21af14:	e1a02842 	asr	r2, r2, #16
 c21af18:	e1a03803 	lsl	r3, r3, #16
 c21af1c:	e1a03843 	asr	r3, r3, #16
 c21af20:	e1a00002 	mov	r0, r2
 c21af24:	e1a01003 	mov	r1, r3
 c21af28:	eb002eee 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21af2c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21af30:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21af34:	e1a02802 	lsl	r2, r2, #16
 c21af38:	e1a02842 	asr	r2, r2, #16
 c21af3c:	e1a03803 	lsl	r3, r3, #16
 c21af40:	e1a03843 	asr	r3, r3, #16
 c21af44:	e59f01b8 	ldr	r0, [pc, #440]	; c21b104 <test_sound_effects+0xccc>
 c21af48:	e1a01002 	mov	r1, r2
 c21af4c:	e1a02003 	mov	r2, r3
 c21af50:	eb0000a1 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo & fade (1 s): hable y escuche... " );
    audiodelay_init( &delay_buffer, 16000 );
    while( kb_scan() < 0 )
 c21af54:	eb003170 	bl	c22751c <kb_scan>
 c21af58:	e1a03000 	mov	r3, r0
 c21af5c:	e3530000 	cmp	r3, #0
 c21af60:	baffffbb 	blt	c21ae54 <test_sound_effects+0xa1c>
      	ch0 = ch0 + (ch0_aux >> 1);
      	ch1 = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0, ch1 );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c21af64:	eb003e40 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21af68:	e59f015c 	ldr	r0, [pc, #348]	; c21b0cc <test_sound_effects+0xc94>
 c21af6c:	eb003da1 	bl	c22a5f8 <uart0_puts>

    /************************************/

    uart0_puts( "  - Reverberación (echo & fade 100 ms): hable y escuche... " );
 c21af70:	e59f01a0 	ldr	r0, [pc, #416]	; c21b118 <test_sound_effects+0xce0>
 c21af74:	eb003d9f 	bl	c22a5f8 <uart0_puts>
    audiodelay_init( &delay_buffer, 1600 );
 c21af78:	e59f0184 	ldr	r0, [pc, #388]	; c21b104 <test_sound_effects+0xccc>
 c21af7c:	e3a01d19 	mov	r1, #1600	; 0x640
 c21af80:	eb000066 	bl	c21b120 <audiodelay_init>
    while( kb_scan() < 0 )
 c21af84:	ea00003f 	b	c21b088 <test_sound_effects+0xc50>
    {
     	iis_getSample( &ch0, &ch1 );
 c21af88:	e24b2012 	sub	r2, fp, #18
 c21af8c:	e24b3014 	sub	r3, fp, #20
 c21af90:	e1a00002 	mov	r0, r2
 c21af94:	e1a01003 	mov	r1, r3
 c21af98:	eb002eec 	bl	c226b50 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c21af9c:	e24b2016 	sub	r2, fp, #22
 c21afa0:	e24b3018 	sub	r3, fp, #24
 c21afa4:	e59f0158 	ldr	r0, [pc, #344]	; c21b104 <test_sound_effects+0xccc>
 c21afa8:	e1a01002 	mov	r1, r2
 c21afac:	e1a02003 	mov	r2, r3
 c21afb0:	eb0000bb 	bl	c21b2a4 <audiodelay_get>
      	ch0 = ch0 + (ch0_aux >> 1);
 c21afb4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21afb8:	e1a03803 	lsl	r3, r3, #16
 c21afbc:	e1a03843 	asr	r3, r3, #16
 c21afc0:	e1a030c3 	asr	r3, r3, #1
 c21afc4:	e1a03803 	lsl	r3, r3, #16
 c21afc8:	e1a03823 	lsr	r3, r3, #16
 c21afcc:	e1a03803 	lsl	r3, r3, #16
 c21afd0:	e1a02823 	lsr	r2, r3, #16
 c21afd4:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21afd8:	e1a03803 	lsl	r3, r3, #16
 c21afdc:	e1a03823 	lsr	r3, r3, #16
 c21afe0:	e0823003 	add	r3, r2, r3
 c21afe4:	e1a03803 	lsl	r3, r3, #16
 c21afe8:	e1a03823 	lsr	r3, r3, #16
 c21afec:	e1a03803 	lsl	r3, r3, #16
 c21aff0:	e1a03823 	lsr	r3, r3, #16
 c21aff4:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
      	ch1 = ch1 + (ch1_aux >> 1);
 c21aff8:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c21affc:	e1a03803 	lsl	r3, r3, #16
 c21b000:	e1a03843 	asr	r3, r3, #16
 c21b004:	e1a030c3 	asr	r3, r3, #1
 c21b008:	e1a03803 	lsl	r3, r3, #16
 c21b00c:	e1a03823 	lsr	r3, r3, #16
 c21b010:	e1a03803 	lsl	r3, r3, #16
 c21b014:	e1a02823 	lsr	r2, r3, #16
 c21b018:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21b01c:	e1a03803 	lsl	r3, r3, #16
 c21b020:	e1a03823 	lsr	r3, r3, #16
 c21b024:	e0823003 	add	r3, r2, r3
 c21b028:	e1a03803 	lsl	r3, r3, #16
 c21b02c:	e1a03823 	lsr	r3, r3, #16
 c21b030:	e1a03803 	lsl	r3, r3, #16
 c21b034:	e1a03823 	lsr	r3, r3, #16
 c21b038:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
     	iis_putSample( ch0, ch1 );
 c21b03c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21b040:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21b044:	e1a02802 	lsl	r2, r2, #16
 c21b048:	e1a02842 	asr	r2, r2, #16
 c21b04c:	e1a03803 	lsl	r3, r3, #16
 c21b050:	e1a03843 	asr	r3, r3, #16
 c21b054:	e1a00002 	mov	r0, r2
 c21b058:	e1a01003 	mov	r1, r3
 c21b05c:	eb002ea1 	bl	c226ae8 <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c21b060:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21b064:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21b068:	e1a02802 	lsl	r2, r2, #16
 c21b06c:	e1a02842 	asr	r2, r2, #16
 c21b070:	e1a03803 	lsl	r3, r3, #16
 c21b074:	e1a03843 	asr	r3, r3, #16
 c21b078:	e59f0084 	ldr	r0, [pc, #132]	; c21b104 <test_sound_effects+0xccc>
 c21b07c:	e1a01002 	mov	r1, r2
 c21b080:	e1a02003 	mov	r2, r3
 c21b084:	eb000054 	bl	c21b1dc <audiodelay_put>

    /************************************/

    uart0_puts( "  - Reverberación (echo & fade 100 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 1600 );
    while( kb_scan() < 0 )
 c21b088:	eb003123 	bl	c22751c <kb_scan>
 c21b08c:	e1a03000 	mov	r3, r0
 c21b090:	e3530000 	cmp	r3, #0
 c21b094:	baffffbb 	blt	c21af88 <test_sound_effects+0xb50>
      	ch0 = ch0 + (ch0_aux >> 1);
      	ch1 = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0, ch1 );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
     }
    uart0_getint();
 c21b098:	eb003df3 	bl	c22a86c <uart0_getint>
    uart0_puts( "OK\n" );
 c21b09c:	e59f0028 	ldr	r0, [pc, #40]	; c21b0cc <test_sound_effects+0xc94>
 c21b0a0:	eb003d54 	bl	c22a5f8 <uart0_puts>

    uart0_puts( "Going into infinite loop...\n" );
 c21b0a4:	e59f0070 	ldr	r0, [pc, #112]	; c21b11c <test_sound_effects+0xce4>
 c21b0a8:	eb003d52 	bl	c22a5f8 <uart0_puts>


    /************************************/

    while(1);
 c21b0ac:	eafffffe 	b	c21b0ac <test_sound_effects+0xc74>
 c21b0b0:	0c100780 	.word	0x0c100780
 c21b0b4:	0c1007b8 	.word	0x0c1007b8
 c21b0b8:	0c1007e4 	.word	0x0c1007e4
 c21b0bc:	0c100090 	.word	0x0c100090
 c21b0c0:	0c100800 	.word	0x0c100800
 c21b0c4:	0c100808 	.word	0x0c100808
 c21b0c8:	0c100048 	.word	0x0c100048
 c21b0cc:	0c100828 	.word	0x0c100828
 c21b0d0:	0c10082c 	.word	0x0c10082c
 c21b0d4:	0c100000 	.word	0x0c100000
 c21b0d8:	0c100850 	.word	0x0c100850
 c21b0dc:	0c100878 	.word	0x0c100878
 c21b0e0:	0c10ba24 	.word	0x0c10ba24
 c21b0e4:	0c159c24 	.word	0x0c159c24
 c21b0e8:	000270ff 	.word	0x000270ff
 c21b0ec:	0c1008bc 	.word	0x0c1008bc
 c21b0f0:	0c1008f0 	.word	0x0c1008f0
 c21b0f4:	0c100920 	.word	0x0c100920
 c21b0f8:	0c100950 	.word	0x0c100950
 c21b0fc:	0c100978 	.word	0x0c100978
 c21b100:	0c10099c 	.word	0x0c10099c
 c21b104:	0c1a7e24 	.word	0x0c1a7e24
 c21b108:	0c1009c4 	.word	0x0c1009c4
 c21b10c:	0c1009ec 	.word	0x0c1009ec
 c21b110:	0c100a14 	.word	0x0c100a14
 c21b114:	0c100a3c 	.word	0x0c100a3c
 c21b118:	0c100a68 	.word	0x0c100a68
 c21b11c:	0c100aa4 	.word	0x0c100aa4

0c21b120 <audiodelay_init>:

}

void audiodelay_init( audiodelay_t *buffer, uint16 size )
{
 c21b120:	e1a0c00d 	mov	ip, sp
 c21b124:	e92dd800 	push	{fp, ip, lr, pc}
 c21b128:	e24cb004 	sub	fp, ip, #4
 c21b12c:	e24dd010 	sub	sp, sp, #16
 c21b130:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21b134:	e1a03001 	mov	r3, r1
 c21b138:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
	uint16 i;

	for( i=0; i<size; i++ )
 c21b13c:	e3a03000 	mov	r3, #0
 c21b140:	e14b30be 	strh	r3, [fp, #-14]
 c21b144:	ea00000f 	b	c21b188 <audiodelay_init+0x68>
	{
		buffer->ch0[i] = 0;
 c21b148:	e15b30be 	ldrh	r3, [fp, #-14]
 c21b14c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21b150:	e1a03083 	lsl	r3, r3, #1
 c21b154:	e0823003 	add	r3, r2, r3
 c21b158:	e3a02000 	mov	r2, #0
 c21b15c:	e1c320b0 	strh	r2, [r3]
		buffer->ch1[i] = 0;
 c21b160:	e15b30be 	ldrh	r3, [fp, #-14]
 c21b164:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21b168:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c21b16c:	e1a03083 	lsl	r3, r3, #1
 c21b170:	e0823003 	add	r3, r2, r3
 c21b174:	e3a02000 	mov	r2, #0
 c21b178:	e1c320b0 	strh	r2, [r3]

void audiodelay_init( audiodelay_t *buffer, uint16 size )
{
	uint16 i;

	for( i=0; i<size; i++ )
 c21b17c:	e15b30be 	ldrh	r3, [fp, #-14]
 c21b180:	e2833001 	add	r3, r3, #1
 c21b184:	e14b30be 	strh	r3, [fp, #-14]
 c21b188:	e15b20be 	ldrh	r2, [fp, #-14]
 c21b18c:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21b190:	e1520003 	cmp	r2, r3
 c21b194:	3affffeb 	bcc	c21b148 <audiodelay_init+0x28>
	{
		buffer->ch0[i] = 0;
		buffer->ch1[i] = 0;
	}
	buffer->head = 0;
 c21b198:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21b19c:	e59f3030 	ldr	r3, [pc, #48]	; c21b1d4 <audiodelay_init+0xb4>
 c21b1a0:	e3a01000 	mov	r1, #0
 c21b1a4:	e18210b3 	strh	r1, [r2, r3]
	buffer->tail = 0;
 c21b1a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21b1ac:	e59f3024 	ldr	r3, [pc, #36]	; c21b1d8 <audiodelay_init+0xb8>
 c21b1b0:	e3a01000 	mov	r1, #0
 c21b1b4:	e18210b3 	strh	r1, [r2, r3]
	buffer->size = size;
 c21b1b8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21b1bc:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c21b1c0:	e15b11ba 	ldrh	r1, [fp, #-26]	; 0xffffffe6
 c21b1c4:	e18210b3 	strh	r1, [r2, r3]
}
 c21b1c8:	e24bd00c 	sub	sp, fp, #12
 c21b1cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b1d0:	e12fff1e 	bx	lr
 c21b1d4:	0001f402 	.word	0x0001f402
 c21b1d8:	0001f404 	.word	0x0001f404

0c21b1dc <audiodelay_put>:

void audiodelay_put( audiodelay_t *buffer, int16 ch0, int16 ch1 )
{
 c21b1dc:	e1a0c00d 	mov	ip, sp
 c21b1e0:	e92dd800 	push	{fp, ip, lr, pc}
 c21b1e4:	e24cb004 	sub	fp, ip, #4
 c21b1e8:	e24dd008 	sub	sp, sp, #8
 c21b1ec:	e50b0010 	str	r0, [fp, #-16]
 c21b1f0:	e1a03002 	mov	r3, r2
 c21b1f4:	e14b11b2 	strh	r1, [fp, #-18]	; 0xffffffee
 c21b1f8:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
	buffer->ch0[buffer->head] = ch0;
 c21b1fc:	e51b2010 	ldr	r2, [fp, #-16]
 c21b200:	e59f3098 	ldr	r3, [pc, #152]	; c21b2a0 <audiodelay_put+0xc4>
 c21b204:	e19230b3 	ldrh	r3, [r2, r3]
 c21b208:	e51b2010 	ldr	r2, [fp, #-16]
 c21b20c:	e1a03083 	lsl	r3, r3, #1
 c21b210:	e0823003 	add	r3, r2, r3
 c21b214:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c21b218:	e1c320b0 	strh	r2, [r3]
	buffer->ch1[buffer->head] = ch1;
 c21b21c:	e51b2010 	ldr	r2, [fp, #-16]
 c21b220:	e59f3078 	ldr	r3, [pc, #120]	; c21b2a0 <audiodelay_put+0xc4>
 c21b224:	e19230b3 	ldrh	r3, [r2, r3]
 c21b228:	e51b2010 	ldr	r2, [fp, #-16]
 c21b22c:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c21b230:	e1a03083 	lsl	r3, r3, #1
 c21b234:	e0823003 	add	r3, r2, r3
 c21b238:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c21b23c:	e1c320b0 	strh	r2, [r3]
	if( ++(buffer->head) == buffer->size )
 c21b240:	e51b2010 	ldr	r2, [fp, #-16]
 c21b244:	e59f3054 	ldr	r3, [pc, #84]	; c21b2a0 <audiodelay_put+0xc4>
 c21b248:	e19230b3 	ldrh	r3, [r2, r3]
 c21b24c:	e2833001 	add	r3, r3, #1
 c21b250:	e1a03803 	lsl	r3, r3, #16
 c21b254:	e1a01823 	lsr	r1, r3, #16
 c21b258:	e51b2010 	ldr	r2, [fp, #-16]
 c21b25c:	e59f303c 	ldr	r3, [pc, #60]	; c21b2a0 <audiodelay_put+0xc4>
 c21b260:	e18210b3 	strh	r1, [r2, r3]
 c21b264:	e51b2010 	ldr	r2, [fp, #-16]
 c21b268:	e59f3030 	ldr	r3, [pc, #48]	; c21b2a0 <audiodelay_put+0xc4>
 c21b26c:	e19220b3 	ldrh	r2, [r2, r3]
 c21b270:	e51b1010 	ldr	r1, [fp, #-16]
 c21b274:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c21b278:	e19130b3 	ldrh	r3, [r1, r3]
 c21b27c:	e1520003 	cmp	r2, r3
 c21b280:	1a000003 	bne	c21b294 <audiodelay_put+0xb8>
		buffer->head = 0;
 c21b284:	e51b2010 	ldr	r2, [fp, #-16]
 c21b288:	e59f3010 	ldr	r3, [pc, #16]	; c21b2a0 <audiodelay_put+0xc4>
 c21b28c:	e3a01000 	mov	r1, #0
 c21b290:	e18210b3 	strh	r1, [r2, r3]
}
 c21b294:	e24bd00c 	sub	sp, fp, #12
 c21b298:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b29c:	e12fff1e 	bx	lr
 c21b2a0:	0001f402 	.word	0x0001f402

0c21b2a4 <audiodelay_get>:

void audiodelay_get( audiodelay_t *buffer, int16 *ch0, int16 *ch1 )
{
 c21b2a4:	e1a0c00d 	mov	ip, sp
 c21b2a8:	e92dd800 	push	{fp, ip, lr, pc}
 c21b2ac:	e24cb004 	sub	fp, ip, #4
 c21b2b0:	e24dd010 	sub	sp, sp, #16
 c21b2b4:	e50b0010 	str	r0, [fp, #-16]
 c21b2b8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c21b2bc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	*ch0 = buffer->ch0[buffer->tail];
 c21b2c0:	e51b2010 	ldr	r2, [fp, #-16]
 c21b2c4:	e59f30a0 	ldr	r3, [pc, #160]	; c21b36c <audiodelay_get+0xc8>
 c21b2c8:	e19230b3 	ldrh	r3, [r2, r3]
 c21b2cc:	e51b2010 	ldr	r2, [fp, #-16]
 c21b2d0:	e1a03083 	lsl	r3, r3, #1
 c21b2d4:	e0823003 	add	r3, r2, r3
 c21b2d8:	e1d320b0 	ldrh	r2, [r3]
 c21b2dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21b2e0:	e1c320b0 	strh	r2, [r3]
	*ch1 = buffer->ch1[buffer->tail];
 c21b2e4:	e51b2010 	ldr	r2, [fp, #-16]
 c21b2e8:	e59f307c 	ldr	r3, [pc, #124]	; c21b36c <audiodelay_get+0xc8>
 c21b2ec:	e19230b3 	ldrh	r3, [r2, r3]
 c21b2f0:	e51b2010 	ldr	r2, [fp, #-16]
 c21b2f4:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c21b2f8:	e1a03083 	lsl	r3, r3, #1
 c21b2fc:	e0823003 	add	r3, r2, r3
 c21b300:	e1d320b0 	ldrh	r2, [r3]
 c21b304:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21b308:	e1c320b0 	strh	r2, [r3]
	if( ++(buffer->tail) == buffer->size )
 c21b30c:	e51b2010 	ldr	r2, [fp, #-16]
 c21b310:	e59f3054 	ldr	r3, [pc, #84]	; c21b36c <audiodelay_get+0xc8>
 c21b314:	e19230b3 	ldrh	r3, [r2, r3]
 c21b318:	e2833001 	add	r3, r3, #1
 c21b31c:	e1a03803 	lsl	r3, r3, #16
 c21b320:	e1a01823 	lsr	r1, r3, #16
 c21b324:	e51b2010 	ldr	r2, [fp, #-16]
 c21b328:	e59f303c 	ldr	r3, [pc, #60]	; c21b36c <audiodelay_get+0xc8>
 c21b32c:	e18210b3 	strh	r1, [r2, r3]
 c21b330:	e51b2010 	ldr	r2, [fp, #-16]
 c21b334:	e59f3030 	ldr	r3, [pc, #48]	; c21b36c <audiodelay_get+0xc8>
 c21b338:	e19220b3 	ldrh	r2, [r2, r3]
 c21b33c:	e51b1010 	ldr	r1, [fp, #-16]
 c21b340:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c21b344:	e19130b3 	ldrh	r3, [r1, r3]
 c21b348:	e1520003 	cmp	r2, r3
 c21b34c:	1a000003 	bne	c21b360 <audiodelay_get+0xbc>
		buffer->tail = 0;
 c21b350:	e51b2010 	ldr	r2, [fp, #-16]
 c21b354:	e59f3010 	ldr	r3, [pc, #16]	; c21b36c <audiodelay_get+0xc8>
 c21b358:	e3a01000 	mov	r1, #0
 c21b35c:	e18210b3 	strh	r1, [r2, r3]
}
 c21b360:	e24bd00c 	sub	sp, fp, #12
 c21b364:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b368:	e12fff1e 	bx	lr
 c21b36c:	0001f404 	.word	0x0001f404

0c21b370 <cyclic>:
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void cyclic( void )
{
 c21b370:	e1a0c00d 	mov	ip, sp
 c21b374:	e92dd800 	push	{fp, ip, lr, pc}
 c21b378:	e24cb004 	sub	fp, ip, #4
 c21b37c:	e24dd008 	sub	sp, sp, #8
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando una aplicación cyclic executive\n" );
 c21b380:	e59f0128 	ldr	r0, [pc, #296]	; c21b4b0 <cyclic+0x140>
 c21b384:	eb003c9b 	bl	c22a5f8 <uart0_puts>
    uart0_puts(     " ------------------------------------------\n\n" ) ;
 c21b388:	e59f0124 	ldr	r0, [pc, #292]	; c21b4b4 <cyclic+0x144>
 c21b38c:	eb003c99 	bl	c22a5f8 <uart0_puts>

    flagTask5 = FALSE;    /* Inicializa flags */
 c21b390:	e59f3120 	ldr	r3, [pc, #288]	; c21b4b8 <cyclic+0x148>
 c21b394:	e3a02000 	mov	r2, #0
 c21b398:	e5c32000 	strb	r2, [r3]
    flagTask6 = FALSE;
 c21b39c:	e59f3118 	ldr	r3, [pc, #280]	; c21b4bc <cyclic+0x14c>
 c21b3a0:	e3a02000 	mov	r2, #0
 c21b3a4:	e5c32000 	strb	r2, [r3]
    flagPb    = FALSE;
 c21b3a8:	e59f3110 	ldr	r3, [pc, #272]	; c21b4c0 <cyclic+0x150>
 c21b3ac:	e3a02000 	mov	r2, #0
 c21b3b0:	e5c32000 	strb	r2, [r3]
    flagTimer = FALSE;
 c21b3b4:	e59f3108 	ldr	r3, [pc, #264]	; c21b4c4 <cyclic+0x154>
 c21b3b8:	e3a02000 	mov	r2, #0
 c21b3bc:	e5c32000 	strb	r2, [r3]

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c21b3c0:	eb00265e 	bl	c224d40 <Task1>
    Task2();
 c21b3c4:	eb00267f 	bl	c224dc8 <Task2>
    Task3();
 c21b3c8:	eb0026b5 	bl	c224ea4 <Task3>
    Task4();
 c21b3cc:	eb0026fa 	bl	c224fbc <Task4>
    Task5();
 c21b3d0:	eb002734 	bl	c2250a8 <Task5>
    Task6();
 c21b3d4:	eb002775 	bl	c2251b0 <Task6>
    Task7();
 c21b3d8:	eb00279e 	bl	c225258 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c21b3dc:	e59f30e4 	ldr	r3, [pc, #228]	; c21b4c8 <cyclic+0x158>
 c21b3e0:	e59f20e4 	ldr	r2, [pc, #228]	; c21b4cc <cyclic+0x15c>
 c21b3e4:	e5832000 	str	r2, [r3]
	ic_enable(INT_EINT4567);
 c21b3e8:	e3a00015 	mov	r0, #21
 c21b3ec:	eb002fed 	bl	c2273a8 <ic_enable>

	//MINOR_PERIOD: 50ms
	tmr_set_mode(TIMER0, RELOAD);
 c21b3f0:	e3a00000 	mov	r0, #0
 c21b3f4:	e3a01001 	mov	r1, #1
 c21b3f8:	eb0039c8 	bl	c229b20 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 10);
 c21b3fc:	e3a00000 	mov	r0, #0
 c21b400:	e3a0100a 	mov	r1, #10
 c21b404:	eb0038c4 	bl	c22971c <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c21b408:	e3a00000 	mov	r0, #0
 c21b40c:	e3a01002 	mov	r1, #2
 c21b410:	eb0038f8 	bl	c2297f8 <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c21b414:	e3a00000 	mov	r0, #0
 c21b418:	e59f10b0 	ldr	r1, [pc, #176]	; c21b4d0 <cyclic+0x160>
 c21b41c:	e3a02001 	mov	r2, #1
 c21b420:	eb003943 	bl	c229934 <tmr_set_count>

	tmr_update(TIMER0);
 c21b424:	e3a00000 	mov	r0, #0
 c21b428:	eb00398e 	bl	c229a68 <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c21b42c:	e59f30a0 	ldr	r3, [pc, #160]	; c21b4d4 <cyclic+0x164>
 c21b430:	e59f20a0 	ldr	r2, [pc, #160]	; c21b4d8 <cyclic+0x168>
 c21b434:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c21b438:	e3a00000 	mov	r0, #0
 c21b43c:	eb0039fa 	bl	c229c2c <tmr_start>

	ic_enable(INT_TIMER0);
 c21b440:	e3a0000d 	mov	r0, #13
 c21b444:	eb002fd7 	bl	c2273a8 <ic_enable>
 c21b448:	ea000000 	b	c21b450 <cyclic+0xe0>
        {
        	flagTimer = FALSE;
        	(*pjobs[i])();              /* Las tareas que forman el trabajo se ejecutan en esta hebra (background) */
        	i = ( i==NUM_JOBS-1 ? 0 : i+1 );
        }
    }
 c21b44c:	e1a00000 	nop			; (mov r0, r0)

	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c21b450:	eb003e95 	bl	c22aeac <sleep>
        if( flagTimer )
 c21b454:	e59f3068 	ldr	r3, [pc, #104]	; c21b4c4 <cyclic+0x154>
 c21b458:	e5d33000 	ldrb	r3, [r3]
 c21b45c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b460:	e3530000 	cmp	r3, #0
 c21b464:	0afffff8 	beq	c21b44c <cyclic+0xdc>
        {
        	flagTimer = FALSE;
 c21b468:	e59f3054 	ldr	r3, [pc, #84]	; c21b4c4 <cyclic+0x154>
 c21b46c:	e3a02000 	mov	r2, #0
 c21b470:	e5c32000 	strb	r2, [r3]
        	(*pjobs[i])();              /* Las tareas que forman el trabajo se ejecutan en esta hebra (background) */
 c21b474:	e55b200d 	ldrb	r2, [fp, #-13]
 c21b478:	e59f305c 	ldr	r3, [pc, #92]	; c21b4dc <cyclic+0x16c>
 c21b47c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c21b480:	e1a0e00f 	mov	lr, pc
 c21b484:	e12fff13 	bx	r3
        	i = ( i==NUM_JOBS-1 ? 0 : i+1 );
 c21b488:	e55b300d 	ldrb	r3, [fp, #-13]
 c21b48c:	e35300c7 	cmp	r3, #199	; 0xc7
 c21b490:	0a000003 	beq	c21b4a4 <cyclic+0x134>
 c21b494:	e55b300d 	ldrb	r3, [fp, #-13]
 c21b498:	e2833001 	add	r3, r3, #1
 c21b49c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b4a0:	ea000000 	b	c21b4a8 <cyclic+0x138>
 c21b4a4:	e3a03000 	mov	r3, #0
 c21b4a8:	e54b300d 	strb	r3, [fp, #-13]
        }
    }
 c21b4ac:	eaffffe7 	b	c21b450 <cyclic+0xe0>
 c21b4b0:	0c100de4 	.word	0x0c100de4
 c21b4b4:	0c100e14 	.word	0x0c100e14
 c21b4b8:	0c1c722b 	.word	0x0c1c722b
 c21b4bc:	0c1c722c 	.word	0x0c1c722c
 c21b4c0:	0c1e78ac 	.word	0x0c1e78ac
 c21b4c4:	0c1c722d 	.word	0x0c1c722d
 c21b4c8:	0c7fff74 	.word	0x0c7fff74
 c21b4cc:	0c22533c 	.word	0x0c22533c
 c21b4d0:	00009c40 	.word	0x00009c40
 c21b4d4:	0c7fff54 	.word	0x0c7fff54
 c21b4d8:	0c21bdb8 	.word	0x0c21bdb8
 c21b4dc:	0c100ac4 	.word	0x0c100ac4

0c21b4e0 <JobA>:
}

/*******************************************************************/

void JobA( void )
{
 c21b4e0:	e1a0c00d 	mov	ip, sp
 c21b4e4:	e92dd800 	push	{fp, ip, lr, pc}
 c21b4e8:	e24cb004 	sub	fp, ip, #4
    Task2();
 c21b4ec:	eb002635 	bl	c224dc8 <Task2>
    Task7();
 c21b4f0:	eb002758 	bl	c225258 <Task7>
}
 c21b4f4:	e24bd00c 	sub	sp, fp, #12
 c21b4f8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b4fc:	e12fff1e 	bx	lr

0c21b500 <JobB>:

void JobB( void )
{
 c21b500:	e1a0c00d 	mov	ip, sp
 c21b504:	e92dd800 	push	{fp, ip, lr, pc}
 c21b508:	e24cb004 	sub	fp, ip, #4
    Task2();
 c21b50c:	eb00262d 	bl	c224dc8 <Task2>
    Task5();
 c21b510:	eb0026e4 	bl	c2250a8 <Task5>
    Task6();
 c21b514:	eb002725 	bl	c2251b0 <Task6>
    Task7();
 c21b518:	eb00274e 	bl	c225258 <Task7>
}
 c21b51c:	e24bd00c 	sub	sp, fp, #12
 c21b520:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b524:	e12fff1e 	bx	lr

0c21b528 <JobC>:

void JobC( void )
{
 c21b528:	e1a0c00d 	mov	ip, sp
 c21b52c:	e92dd800 	push	{fp, ip, lr, pc}
 c21b530:	e24cb004 	sub	fp, ip, #4
    Task2();
 c21b534:	eb002623 	bl	c224dc8 <Task2>
    Task5();
 c21b538:	eb0026da 	bl	c2250a8 <Task5>
    Task6();
 c21b53c:	eb00271b 	bl	c2251b0 <Task6>
    Task1();
 c21b540:	eb0025fe 	bl	c224d40 <Task1>
    Task7();
 c21b544:	eb002743 	bl	c225258 <Task7>
}
 c21b548:	e24bd00c 	sub	sp, fp, #12
 c21b54c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b550:	e12fff1e 	bx	lr

0c21b554 <JobD>:

void JobD( void )
{
 c21b554:	e1a0c00d 	mov	ip, sp
 c21b558:	e92dd800 	push	{fp, ip, lr, pc}
 c21b55c:	e24cb004 	sub	fp, ip, #4
    Task2();
 c21b560:	eb002618 	bl	c224dc8 <Task2>
    Task5();
 c21b564:	eb0026cf 	bl	c2250a8 <Task5>
    Task6();
 c21b568:	eb002710 	bl	c2251b0 <Task6>
    Task1();
 c21b56c:	eb0025f3 	bl	c224d40 <Task1>
    Task3();
 c21b570:	eb00264b 	bl	c224ea4 <Task3>
    Task7();
 c21b574:	eb002737 	bl	c225258 <Task7>
}
 c21b578:	e24bd00c 	sub	sp, fp, #12
 c21b57c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b580:	e12fff1e 	bx	lr

0c21b584 <JobE>:

void JobE( void )
{
 c21b584:	e1a0c00d 	mov	ip, sp
 c21b588:	e92dd800 	push	{fp, ip, lr, pc}
 c21b58c:	e24cb004 	sub	fp, ip, #4
    Task2();
 c21b590:	eb00260c 	bl	c224dc8 <Task2>
    Task5();
 c21b594:	eb0026c3 	bl	c2250a8 <Task5>
    Task6();
 c21b598:	eb002704 	bl	c2251b0 <Task6>
    Task1();
 c21b59c:	eb0025e7 	bl	c224d40 <Task1>
    Task3();
 c21b5a0:	eb00263f 	bl	c224ea4 <Task3>
    Task4();
 c21b5a4:	eb002684 	bl	c224fbc <Task4>
    Task7();
 c21b5a8:	eb00272a 	bl	c225258 <Task7>
}
 c21b5ac:	e24bd00c 	sub	sp, fp, #12
 c21b5b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b5b4:	e12fff1e 	bx	lr

0c21b5b8 <foreback>:
void isr_pb( void ) __attribute__ ((interrupt ("IRQ")));
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void foreback( void ) {
 c21b5b8:	e1a0c00d 	mov	ip, sp
 c21b5bc:	e92dd800 	push	{fp, ip, lr, pc}
 c21b5c0:	e24cb004 	sub	fp, ip, #4
    rtc_init();
    pbs_init();
    keypad_init();
*/

    uart0_puts( "\n\n Ejecutando una aplicación foreground/background\n" );
 c21b5c4:	e59f01e8 	ldr	r0, [pc, #488]	; c21b7b4 <foreback+0x1fc>
 c21b5c8:	eb003c0a 	bl	c22a5f8 <uart0_puts>
    uart0_puts( " -----------------------------------------------\n\n" ) ;
 c21b5cc:	e59f01e4 	ldr	r0, [pc, #484]	; c21b7b8 <foreback+0x200>
 c21b5d0:	eb003c08 	bl	c22a5f8 <uart0_puts>

    flagTask5      = FALSE;    /* Inicializa flags */
 c21b5d4:	e59f31e0 	ldr	r3, [pc, #480]	; c21b7bc <foreback+0x204>
 c21b5d8:	e3a02000 	mov	r2, #0
 c21b5dc:	e5c32000 	strb	r2, [r3]
    flagTask6      = FALSE;
 c21b5e0:	e59f31d8 	ldr	r3, [pc, #472]	; c21b7c0 <foreback+0x208>
 c21b5e4:	e3a02000 	mov	r2, #0
 c21b5e8:	e5c32000 	strb	r2, [r3]
    flagPb         = FALSE;
 c21b5ec:	e59f31d0 	ldr	r3, [pc, #464]	; c21b7c4 <foreback+0x20c>
 c21b5f0:	e3a02000 	mov	r2, #0
 c21b5f4:	e5c32000 	strb	r2, [r3]
    flagToggleLeds = FALSE;
 c21b5f8:	e59f31c8 	ldr	r3, [pc, #456]	; c21b7c8 <foreback+0x210>
 c21b5fc:	e3a02000 	mov	r2, #0
 c21b600:	e5c32000 	strb	r2, [r3]
    flagReadKeypad = FALSE;
 c21b604:	e59f31c0 	ldr	r3, [pc, #448]	; c21b7cc <foreback+0x214>
 c21b608:	e3a02000 	mov	r2, #0
 c21b60c:	e5c32000 	strb	r2, [r3]
    flagWriteRTC   = FALSE;
 c21b610:	e59f31b8 	ldr	r3, [pc, #440]	; c21b7d0 <foreback+0x218>
 c21b614:	e3a02000 	mov	r2, #0
 c21b618:	e5c32000 	strb	r2, [r3]
    flagWriteTicks = FALSE;
 c21b61c:	e59f31b0 	ldr	r3, [pc, #432]	; c21b7d4 <foreback+0x21c>
 c21b620:	e3a02000 	mov	r2, #0
 c21b624:	e5c32000 	strb	r2, [r3]

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c21b628:	eb0025c4 	bl	c224d40 <Task1>
    Task2();
 c21b62c:	eb0025e5 	bl	c224dc8 <Task2>
    Task3();
 c21b630:	eb00261b 	bl	c224ea4 <Task3>
    Task4();
 c21b634:	eb002660 	bl	c224fbc <Task4>
    Task5();
 c21b638:	eb00269a 	bl	c2250a8 <Task5>
    Task6();
 c21b63c:	eb0026db 	bl	c2251b0 <Task6>
    Task7();
 c21b640:	eb002704 	bl	c225258 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c21b644:	e59f318c 	ldr	r3, [pc, #396]	; c21b7d8 <foreback+0x220>
 c21b648:	e59f218c 	ldr	r2, [pc, #396]	; c21b7dc <foreback+0x224>
 c21b64c:	e5832000 	str	r2, [r3]
    ic_enable(INT_EINT4567);
 c21b650:	e3a00015 	mov	r0, #21
 c21b654:	eb002f53 	bl	c2273a8 <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c21b658:	e3a00000 	mov	r0, #0
 c21b65c:	e3a01001 	mov	r1, #1
 c21b660:	eb00392e 	bl	c229b20 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c21b664:	e3a00000 	mov	r0, #0
 c21b668:	e3a01001 	mov	r1, #1
 c21b66c:	eb00382a 	bl	c22971c <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c21b670:	e3a00000 	mov	r0, #0
 c21b674:	e3a01002 	mov	r1, #2
 c21b678:	eb00385e 	bl	c2297f8 <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c21b67c:	e3a00000 	mov	r0, #0
 c21b680:	e59f1158 	ldr	r1, [pc, #344]	; c21b7e0 <foreback+0x228>
 c21b684:	e3a02001 	mov	r2, #1
 c21b688:	eb0038a9 	bl	c229934 <tmr_set_count>

	tmr_update(TIMER0);
 c21b68c:	e3a00000 	mov	r0, #0
 c21b690:	eb0038f4 	bl	c229a68 <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c21b694:	e59f3148 	ldr	r3, [pc, #328]	; c21b7e4 <foreback+0x22c>
 c21b698:	e59f2148 	ldr	r2, [pc, #328]	; c21b7e8 <foreback+0x230>
 c21b69c:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c21b6a0:	e3a00000 	mov	r0, #0
 c21b6a4:	eb003960 	bl	c229c2c <tmr_start>

	ic_enable(INT_TIMER0);
 c21b6a8:	e3a0000d 	mov	r0, #13
 c21b6ac:	eb002f3d 	bl	c2273a8 <ic_enable>
 c21b6b0:	ea000000 	b	c21b6b8 <foreback+0x100>
        if( flagPb )
        {
            flagPb = FALSE;
            Task7();
        }
    }
 c21b6b4:	e1a00000 	nop			; (mov r0, r0)

	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c21b6b8:	eb003dfb 	bl	c22aeac <sleep>
        if( flagToggleLeds )            /* Las tareas se ejecutan en esta hebra (background) en orden de aparición en el código */
 c21b6bc:	e59f3104 	ldr	r3, [pc, #260]	; c21b7c8 <foreback+0x210>
 c21b6c0:	e5d33000 	ldrb	r3, [r3]
 c21b6c4:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b6c8:	e3530000 	cmp	r3, #0
 c21b6cc:	0a000003 	beq	c21b6e0 <foreback+0x128>
        {
            flagToggleLeds = FALSE;
 c21b6d0:	e59f30f0 	ldr	r3, [pc, #240]	; c21b7c8 <foreback+0x210>
 c21b6d4:	e3a02000 	mov	r2, #0
 c21b6d8:	e5c32000 	strb	r2, [r3]
            Task1();
 c21b6dc:	eb002597 	bl	c224d40 <Task1>
        }
        if( flagReadKeypad )
 c21b6e0:	e59f30e4 	ldr	r3, [pc, #228]	; c21b7cc <foreback+0x214>
 c21b6e4:	e5d33000 	ldrb	r3, [r3]
 c21b6e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b6ec:	e3530000 	cmp	r3, #0
 c21b6f0:	0a000003 	beq	c21b704 <foreback+0x14c>
        {
            flagReadKeypad = FALSE;
 c21b6f4:	e59f30d0 	ldr	r3, [pc, #208]	; c21b7cc <foreback+0x214>
 c21b6f8:	e3a02000 	mov	r2, #0
 c21b6fc:	e5c32000 	strb	r2, [r3]
            Task2();
 c21b700:	eb0025b0 	bl	c224dc8 <Task2>
        }
        if( flagWriteRTC )
 c21b704:	e59f30c4 	ldr	r3, [pc, #196]	; c21b7d0 <foreback+0x218>
 c21b708:	e5d33000 	ldrb	r3, [r3]
 c21b70c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b710:	e3530000 	cmp	r3, #0
 c21b714:	0a000003 	beq	c21b728 <foreback+0x170>
        {
            flagWriteRTC = FALSE;
 c21b718:	e59f30b0 	ldr	r3, [pc, #176]	; c21b7d0 <foreback+0x218>
 c21b71c:	e3a02000 	mov	r2, #0
 c21b720:	e5c32000 	strb	r2, [r3]
            Task3();
 c21b724:	eb0025de 	bl	c224ea4 <Task3>
        }
        if( flagWriteTicks )
 c21b728:	e59f30a4 	ldr	r3, [pc, #164]	; c21b7d4 <foreback+0x21c>
 c21b72c:	e5d33000 	ldrb	r3, [r3]
 c21b730:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b734:	e3530000 	cmp	r3, #0
 c21b738:	0a000003 	beq	c21b74c <foreback+0x194>
        {
            flagWriteTicks = FALSE;
 c21b73c:	e59f3090 	ldr	r3, [pc, #144]	; c21b7d4 <foreback+0x21c>
 c21b740:	e3a02000 	mov	r2, #0
 c21b744:	e5c32000 	strb	r2, [r3]
            Task4();
 c21b748:	eb00261b 	bl	c224fbc <Task4>
        }
        if( flagTask5 )
 c21b74c:	e59f3068 	ldr	r3, [pc, #104]	; c21b7bc <foreback+0x204>
 c21b750:	e5d33000 	ldrb	r3, [r3]
 c21b754:	e3530000 	cmp	r3, #0
 c21b758:	0a000003 	beq	c21b76c <foreback+0x1b4>
        {
            flagTask5 = FALSE;
 c21b75c:	e59f3058 	ldr	r3, [pc, #88]	; c21b7bc <foreback+0x204>
 c21b760:	e3a02000 	mov	r2, #0
 c21b764:	e5c32000 	strb	r2, [r3]
            Task5();
 c21b768:	eb00264e 	bl	c2250a8 <Task5>
        }
        if( flagTask6 )
 c21b76c:	e59f304c 	ldr	r3, [pc, #76]	; c21b7c0 <foreback+0x208>
 c21b770:	e5d33000 	ldrb	r3, [r3]
 c21b774:	e3530000 	cmp	r3, #0
 c21b778:	0a000003 	beq	c21b78c <foreback+0x1d4>
        {
            flagTask6 = FALSE;
 c21b77c:	e59f303c 	ldr	r3, [pc, #60]	; c21b7c0 <foreback+0x208>
 c21b780:	e3a02000 	mov	r2, #0
 c21b784:	e5c32000 	strb	r2, [r3]
            Task6();
 c21b788:	eb002688 	bl	c2251b0 <Task6>
        }
        if( flagPb )
 c21b78c:	e59f3030 	ldr	r3, [pc, #48]	; c21b7c4 <foreback+0x20c>
 c21b790:	e5d33000 	ldrb	r3, [r3]
 c21b794:	e20330ff 	and	r3, r3, #255	; 0xff
 c21b798:	e3530000 	cmp	r3, #0
 c21b79c:	0affffc4 	beq	c21b6b4 <foreback+0xfc>
        {
            flagPb = FALSE;
 c21b7a0:	e59f301c 	ldr	r3, [pc, #28]	; c21b7c4 <foreback+0x20c>
 c21b7a4:	e3a02000 	mov	r2, #0
 c21b7a8:	e5c32000 	strb	r2, [r3]
            Task7();
 c21b7ac:	eb0026a9 	bl	c225258 <Task7>
        }
    }
 c21b7b0:	eaffffc0 	b	c21b6b8 <foreback+0x100>
 c21b7b4:	0c100e44 	.word	0x0c100e44
 c21b7b8:	0c100e78 	.word	0x0c100e78
 c21b7bc:	0c1c722b 	.word	0x0c1c722b
 c21b7c0:	0c1c722c 	.word	0x0c1c722c
 c21b7c4:	0c1e78ac 	.word	0x0c1e78ac
 c21b7c8:	0c1c722f 	.word	0x0c1c722f
 c21b7cc:	0c1c722e 	.word	0x0c1c722e
 c21b7d0:	0c1c7231 	.word	0x0c1c7231
 c21b7d4:	0c1c7230 	.word	0x0c1c7230
 c21b7d8:	0c7fff74 	.word	0x0c7fff74
 c21b7dc:	0c22533c 	.word	0x0c22533c
 c21b7e0:	00009c40 	.word	0x00009c40
 c21b7e4:	0c7fff54 	.word	0x0c7fff54
 c21b7e8:	0c21bdb8 	.word	0x0c21bdb8

0c21b7ec <delete_task>:
#include "../intcontroller.h"

static task_t tasks[MAX_TASKS];   /* Lista ordenada de TCBs */

void delete_task( uint32 id )
{
 c21b7ec:	e1a0c00d 	mov	ip, sp
 c21b7f0:	e92dd800 	push	{fp, ip, lr, pc}
 c21b7f4:	e24cb004 	sub	fp, ip, #4
 c21b7f8:	e24dd008 	sub	sp, sp, #8
 c21b7fc:	e50b0010 	str	r0, [fp, #-16]
    tasks[id].pfunction = NULL;
 c21b800:	e59f3074 	ldr	r3, [pc, #116]	; c21b87c <delete_task+0x90>
 c21b804:	e51b2010 	ldr	r2, [fp, #-16]
 c21b808:	e3a01000 	mov	r1, #0
 c21b80c:	e7831202 	str	r1, [r3, r2, lsl #4]
    tasks[id].period = 0;
 c21b810:	e59f1064 	ldr	r1, [pc, #100]	; c21b87c <delete_task+0x90>
 c21b814:	e51b2010 	ldr	r2, [fp, #-16]
 c21b818:	e3a03004 	mov	r3, #4
 c21b81c:	e1a02202 	lsl	r2, r2, #4
 c21b820:	e0812002 	add	r2, r1, r2
 c21b824:	e0823003 	add	r3, r2, r3
 c21b828:	e3a02000 	mov	r2, #0
 c21b82c:	e5832000 	str	r2, [r3]
    tasks[id].ticks = 0;
 c21b830:	e59f1044 	ldr	r1, [pc, #68]	; c21b87c <delete_task+0x90>
 c21b834:	e51b2010 	ldr	r2, [fp, #-16]
 c21b838:	e3a03008 	mov	r3, #8
 c21b83c:	e1a02202 	lsl	r2, r2, #4
 c21b840:	e0812002 	add	r2, r1, r2
 c21b844:	e0823003 	add	r3, r2, r3
 c21b848:	e3a02000 	mov	r2, #0
 c21b84c:	e5832000 	str	r2, [r3]
    tasks[id].ready = FALSE;
 c21b850:	e59f1024 	ldr	r1, [pc, #36]	; c21b87c <delete_task+0x90>
 c21b854:	e51b2010 	ldr	r2, [fp, #-16]
 c21b858:	e3a03008 	mov	r3, #8
 c21b85c:	e1a02202 	lsl	r2, r2, #4
 c21b860:	e0812002 	add	r2, r1, r2
 c21b864:	e0823003 	add	r3, r2, r3
 c21b868:	e3a02000 	mov	r2, #0
 c21b86c:	e5c32004 	strb	r2, [r3, #4]
}
 c21b870:	e24bd00c 	sub	sp, fp, #12
 c21b874:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b878:	e12fff1e 	bx	lr
 c21b87c:	0c102358 	.word	0x0c102358

0c21b880 <create_task>:

uint32 create_task( void (*pfunction)( void ), uint32 period )
{
 c21b880:	e1a0c00d 	mov	ip, sp
 c21b884:	e92dd800 	push	{fp, ip, lr, pc}
 c21b888:	e24cb004 	sub	fp, ip, #4
 c21b88c:	e24dd010 	sub	sp, sp, #16
 c21b890:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21b894:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    uint32 id;

    for( id=0; id<MAX_TASKS && tasks[id].pfunction ; id++ ); /* Busca la primera entrada libre (con función no NULL) de la lista de TCB */
 c21b898:	e3a03000 	mov	r3, #0
 c21b89c:	e50b3010 	str	r3, [fp, #-16]
 c21b8a0:	ea000002 	b	c21b8b0 <create_task+0x30>
 c21b8a4:	e51b3010 	ldr	r3, [fp, #-16]
 c21b8a8:	e2833001 	add	r3, r3, #1
 c21b8ac:	e50b3010 	str	r3, [fp, #-16]
 c21b8b0:	e51b3010 	ldr	r3, [fp, #-16]
 c21b8b4:	e3530009 	cmp	r3, #9
 c21b8b8:	8a000004 	bhi	c21b8d0 <create_task+0x50>
 c21b8bc:	e59f309c 	ldr	r3, [pc, #156]	; c21b960 <create_task+0xe0>
 c21b8c0:	e51b2010 	ldr	r2, [fp, #-16]
 c21b8c4:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c21b8c8:	e3530000 	cmp	r3, #0
 c21b8cc:	1afffff4 	bne	c21b8a4 <create_task+0x24>

    tasks[id].pfunction = pfunction;
 c21b8d0:	e59f3088 	ldr	r3, [pc, #136]	; c21b960 <create_task+0xe0>
 c21b8d4:	e51b2010 	ldr	r2, [fp, #-16]
 c21b8d8:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c21b8dc:	e7831202 	str	r1, [r3, r2, lsl #4]
    tasks[id].period = period;
 c21b8e0:	e59f1078 	ldr	r1, [pc, #120]	; c21b960 <create_task+0xe0>
 c21b8e4:	e51b2010 	ldr	r2, [fp, #-16]
 c21b8e8:	e3a03004 	mov	r3, #4
 c21b8ec:	e1a02202 	lsl	r2, r2, #4
 c21b8f0:	e0812002 	add	r2, r1, r2
 c21b8f4:	e0823003 	add	r3, r2, r3
 c21b8f8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c21b8fc:	e5832000 	str	r2, [r3]
    tasks[id].ticks = 0;
 c21b900:	e59f1058 	ldr	r1, [pc, #88]	; c21b960 <create_task+0xe0>
 c21b904:	e51b2010 	ldr	r2, [fp, #-16]
 c21b908:	e3a03008 	mov	r3, #8
 c21b90c:	e1a02202 	lsl	r2, r2, #4
 c21b910:	e0812002 	add	r2, r1, r2
 c21b914:	e0823003 	add	r3, r2, r3
 c21b918:	e3a02000 	mov	r2, #0
 c21b91c:	e5832000 	str	r2, [r3]
    tasks[id].ready = FALSE;
 c21b920:	e59f1038 	ldr	r1, [pc, #56]	; c21b960 <create_task+0xe0>
 c21b924:	e51b2010 	ldr	r2, [fp, #-16]
 c21b928:	e3a03008 	mov	r3, #8
 c21b92c:	e1a02202 	lsl	r2, r2, #4
 c21b930:	e0812002 	add	r2, r1, r2
 c21b934:	e0823003 	add	r3, r2, r3
 c21b938:	e3a02000 	mov	r2, #0
 c21b93c:	e5c32004 	strb	r2, [r3, #4]

    (*pfunction)();     /* Asume que la primera llamada a la tarea la inicializa */
 c21b940:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21b944:	e1a0e00f 	mov	lr, pc
 c21b948:	e12fff13 	bx	r3

    return id;
 c21b94c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21b950:	e1a00003 	mov	r0, r3
 c21b954:	e24bd00c 	sub	sp, fp, #12
 c21b958:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b95c:	e12fff1e 	bx	lr
 c21b960:	0c102358 	.word	0x0c102358

0c21b964 <scheduler_init>:

void scheduler_init( void )
{
 c21b964:	e1a0c00d 	mov	ip, sp
 c21b968:	e92dd800 	push	{fp, ip, lr, pc}
 c21b96c:	e24cb004 	sub	fp, ip, #4
 c21b970:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )
 c21b974:	e3a03000 	mov	r3, #0
 c21b978:	e50b3010 	str	r3, [fp, #-16]
 c21b97c:	ea000004 	b	c21b994 <scheduler_init+0x30>
        delete_task( id );
 c21b980:	e51b0010 	ldr	r0, [fp, #-16]
 c21b984:	ebffff98 	bl	c21b7ec <delete_task>

void scheduler_init( void )
{
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )
 c21b988:	e51b3010 	ldr	r3, [fp, #-16]
 c21b98c:	e2833001 	add	r3, r3, #1
 c21b990:	e50b3010 	str	r3, [fp, #-16]
 c21b994:	e51b3010 	ldr	r3, [fp, #-16]
 c21b998:	e3530009 	cmp	r3, #9
 c21b99c:	9afffff7 	bls	c21b980 <scheduler_init+0x1c>
        delete_task( id );
}
 c21b9a0:	e24bd00c 	sub	sp, fp, #12
 c21b9a4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21b9a8:	e12fff1e 	bx	lr

0c21b9ac <scheduler>:

void scheduler( void ) /* Esta funcion es la ISR del timer0 */
{
 c21b9ac:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c21b9b0:	e1a0c00d 	mov	ip, sp
 c21b9b4:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c21b9b8:	e24cb004 	sub	fp, ip, #4
 c21b9bc:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    ic_cleanflag(INT_TIMER0);
 c21b9c0:	e3a0000d 	mov	r0, #13
 c21b9c4:	eb002eaa 	bl	c227474 <ic_cleanflag>

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c21b9c8:	e3a03000 	mov	r3, #0
 c21b9cc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 c21b9d0:	ea000036 	b	c21bab0 <scheduler+0x104>
        if( tasks[id].pfunction )
 c21b9d4:	e59f30f0 	ldr	r3, [pc, #240]	; c21bacc <scheduler+0x120>
 c21b9d8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21b9dc:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c21b9e0:	e3530000 	cmp	r3, #0
 c21b9e4:	0a00002e 	beq	c21baa4 <scheduler+0xf8>
            if( ++tasks[id].ticks == tasks[id].period ) /* Si el contador de ticks equivale a su periodo de ejecución: */
 c21b9e8:	e59f10dc 	ldr	r1, [pc, #220]	; c21bacc <scheduler+0x120>
 c21b9ec:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21b9f0:	e3a03008 	mov	r3, #8
 c21b9f4:	e1a02202 	lsl	r2, r2, #4
 c21b9f8:	e0812002 	add	r2, r1, r2
 c21b9fc:	e0823003 	add	r3, r2, r3
 c21ba00:	e5933000 	ldr	r3, [r3]
 c21ba04:	e2832001 	add	r2, r3, #1
 c21ba08:	e59f00bc 	ldr	r0, [pc, #188]	; c21bacc <scheduler+0x120>
 c21ba0c:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c21ba10:	e3a03008 	mov	r3, #8
 c21ba14:	e1a01201 	lsl	r1, r1, #4
 c21ba18:	e0801001 	add	r1, r0, r1
 c21ba1c:	e0813003 	add	r3, r1, r3
 c21ba20:	e5832000 	str	r2, [r3]
 c21ba24:	e59f10a0 	ldr	r1, [pc, #160]	; c21bacc <scheduler+0x120>
 c21ba28:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21ba2c:	e3a03008 	mov	r3, #8
 c21ba30:	e1a02202 	lsl	r2, r2, #4
 c21ba34:	e0812002 	add	r2, r1, r2
 c21ba38:	e0823003 	add	r3, r2, r3
 c21ba3c:	e5932000 	ldr	r2, [r3]
 c21ba40:	e59f0084 	ldr	r0, [pc, #132]	; c21bacc <scheduler+0x120>
 c21ba44:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c21ba48:	e3a03004 	mov	r3, #4
 c21ba4c:	e1a01201 	lsl	r1, r1, #4
 c21ba50:	e0801001 	add	r1, r0, r1
 c21ba54:	e0813003 	add	r3, r1, r3
 c21ba58:	e5933000 	ldr	r3, [r3]
 c21ba5c:	e1520003 	cmp	r2, r3
 c21ba60:	1a00000f 	bne	c21baa4 <scheduler+0xf8>
            {
                tasks[id].ticks = 0;                    /* Inicializa a 0 su contador de ticks */
 c21ba64:	e59f1060 	ldr	r1, [pc, #96]	; c21bacc <scheduler+0x120>
 c21ba68:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21ba6c:	e3a03008 	mov	r3, #8
 c21ba70:	e1a02202 	lsl	r2, r2, #4
 c21ba74:	e0812002 	add	r2, r1, r2
 c21ba78:	e0823003 	add	r3, r2, r3
 c21ba7c:	e3a02000 	mov	r2, #0
 c21ba80:	e5832000 	str	r2, [r3]
                tasks[id].ready = TRUE;                 /* Pasa la tarea a estado "preparado" */
 c21ba84:	e59f1040 	ldr	r1, [pc, #64]	; c21bacc <scheduler+0x120>
 c21ba88:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21ba8c:	e3a03008 	mov	r3, #8
 c21ba90:	e1a02202 	lsl	r2, r2, #4
 c21ba94:	e0812002 	add	r2, r1, r2
 c21ba98:	e0823003 	add	r3, r2, r3
 c21ba9c:	e3a02001 	mov	r2, #1
 c21baa0:	e5c32004 	strb	r2, [r3, #4]
{
    uint32 id;

    ic_cleanflag(INT_TIMER0);

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c21baa4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21baa8:	e2833001 	add	r3, r3, #1
 c21baac:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 c21bab0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21bab4:	e3530009 	cmp	r3, #9
 c21bab8:	9affffc5 	bls	c21b9d4 <scheduler+0x28>
            if( ++tasks[id].ticks == tasks[id].period ) /* Si el contador de ticks equivale a su periodo de ejecución: */
            {
                tasks[id].ticks = 0;                    /* Inicializa a 0 su contador de ticks */
                tasks[id].ready = TRUE;                 /* Pasa la tarea a estado "preparado" */
            }
}
 c21babc:	e24bd01c 	sub	sp, fp, #28
 c21bac0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c21bac4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c21bac8:	e25ef004 	subs	pc, lr, #4
 c21bacc:	0c102358 	.word	0x0c102358

0c21bad0 <dispacher>:

void dispacher( void )
{
 c21bad0:	e1a0c00d 	mov	ip, sp
 c21bad4:	e92dd800 	push	{fp, ip, lr, pc}
 c21bad8:	e24cb004 	sub	fp, ip, #4
 c21badc:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c21bae0:	e3a03000 	mov	r3, #0
 c21bae4:	e50b3010 	str	r3, [fp, #-16]
 c21bae8:	ea000018 	b	c21bb50 <dispacher+0x80>
        if( tasks[id].ready == TRUE )                   /* Si la tarea está en estado "preparado": */
 c21baec:	e59f1074 	ldr	r1, [pc, #116]	; c21bb68 <dispacher+0x98>
 c21baf0:	e51b2010 	ldr	r2, [fp, #-16]
 c21baf4:	e3a03008 	mov	r3, #8
 c21baf8:	e1a02202 	lsl	r2, r2, #4
 c21bafc:	e0812002 	add	r2, r1, r2
 c21bb00:	e0823003 	add	r3, r2, r3
 c21bb04:	e5d33004 	ldrb	r3, [r3, #4]
 c21bb08:	e3530001 	cmp	r3, #1
 c21bb0c:	1a00000c 	bne	c21bb44 <dispacher+0x74>
        {
            (*tasks[id].pfunction)();                   /* La ejecuta */
 c21bb10:	e59f3050 	ldr	r3, [pc, #80]	; c21bb68 <dispacher+0x98>
 c21bb14:	e51b2010 	ldr	r2, [fp, #-16]
 c21bb18:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c21bb1c:	e1a0e00f 	mov	lr, pc
 c21bb20:	e12fff13 	bx	r3
            tasks[id].ready = FALSE;                    /* Pasa la tarea a estado "no preparado" */
 c21bb24:	e59f103c 	ldr	r1, [pc, #60]	; c21bb68 <dispacher+0x98>
 c21bb28:	e51b2010 	ldr	r2, [fp, #-16]
 c21bb2c:	e3a03008 	mov	r3, #8
 c21bb30:	e1a02202 	lsl	r2, r2, #4
 c21bb34:	e0812002 	add	r2, r1, r2
 c21bb38:	e0823003 	add	r3, r2, r3
 c21bb3c:	e3a02000 	mov	r2, #0
 c21bb40:	e5c32004 	strb	r2, [r3, #4]

void dispacher( void )
{
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c21bb44:	e51b3010 	ldr	r3, [fp, #-16]
 c21bb48:	e2833001 	add	r3, r3, #1
 c21bb4c:	e50b3010 	str	r3, [fp, #-16]
 c21bb50:	e51b3010 	ldr	r3, [fp, #-16]
 c21bb54:	e3530009 	cmp	r3, #9
 c21bb58:	9affffe3 	bls	c21baec <dispacher+0x1c>
        if( tasks[id].ready == TRUE )                   /* Si la tarea está en estado "preparado": */
        {
            (*tasks[id].pfunction)();                   /* La ejecuta */
            tasks[id].ready = FALSE;                    /* Pasa la tarea a estado "no preparado" */
        }
}
 c21bb5c:	e24bd00c 	sub	sp, fp, #12
 c21bb60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21bb64:	e12fff1e 	bx	lr
 c21bb68:	0c102358 	.word	0x0c102358

0c21bb6c <non_expropiative_kernel>:
void isr_pb( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void non_expropiative_kernel( void )
{
 c21bb6c:	e1a0c00d 	mov	ip, sp
 c21bb70:	e92dd800 	push	{fp, ip, lr, pc}
 c21bb74:	e24cb004 	sub	fp, ip, #4
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando kernel de planificación no expropiativa\n" );
 c21bb78:	e59f00fc 	ldr	r0, [pc, #252]	; c21bc7c <non_expropiative_kernel+0x110>
 c21bb7c:	eb003a9d 	bl	c22a5f8 <uart0_puts>
    uart0_puts( " --------------------------------------------------\n\n" ) ;
 c21bb80:	e59f00f8 	ldr	r0, [pc, #248]	; c21bc80 <non_expropiative_kernel+0x114>
 c21bb84:	eb003a9b 	bl	c22a5f8 <uart0_puts>

    flagTask5  = FALSE;               /* Inicializa flags */
 c21bb88:	e59f30f4 	ldr	r3, [pc, #244]	; c21bc84 <non_expropiative_kernel+0x118>
 c21bb8c:	e3a02000 	mov	r2, #0
 c21bb90:	e5c32000 	strb	r2, [r3]
    flagTask6  = FALSE;
 c21bb94:	e59f30ec 	ldr	r3, [pc, #236]	; c21bc88 <non_expropiative_kernel+0x11c>
 c21bb98:	e3a02000 	mov	r2, #0
 c21bb9c:	e5c32000 	strb	r2, [r3]
    flagPb     = FALSE;
 c21bba0:	e59f30e4 	ldr	r3, [pc, #228]	; c21bc8c <non_expropiative_kernel+0x120>
 c21bba4:	e3a02000 	mov	r2, #0
 c21bba8:	e5c32000 	strb	r2, [r3]

    scheduler_init();                 /* Inicializa el kernel */
 c21bbac:	ebffff6c 	bl	c21b964 <scheduler_init>

    create_task( Task2, 5 );          /* Crea las tareas de la aplicación... */
 c21bbb0:	e59f00d8 	ldr	r0, [pc, #216]	; c21bc90 <non_expropiative_kernel+0x124>
 c21bbb4:	e3a01005 	mov	r1, #5
 c21bbb8:	ebffff30 	bl	c21b880 <create_task>
    create_task( Task7, 5 );          /* ... el kernel asigna la prioridad según orden de creación: Task2 > Task5 > Task6 > ... */
 c21bbbc:	e59f00d0 	ldr	r0, [pc, #208]	; c21bc94 <non_expropiative_kernel+0x128>
 c21bbc0:	e3a01005 	mov	r1, #5
 c21bbc4:	ebffff2d 	bl	c21b880 <create_task>
    create_task( Task5, 10 );         /* ... las tareas más frecuentes tienen mayor prioridad (criterio Rate-Monotonic-Scheduling) */
 c21bbc8:	e59f00c8 	ldr	r0, [pc, #200]	; c21bc98 <non_expropiative_kernel+0x12c>
 c21bbcc:	e3a0100a 	mov	r1, #10
 c21bbd0:	ebffff2a 	bl	c21b880 <create_task>
    create_task( Task6, 10 );
 c21bbd4:	e59f00c0 	ldr	r0, [pc, #192]	; c21bc9c <non_expropiative_kernel+0x130>
 c21bbd8:	e3a0100a 	mov	r1, #10
 c21bbdc:	ebffff27 	bl	c21b880 <create_task>
    create_task( Task1, 50 );
 c21bbe0:	e59f00b8 	ldr	r0, [pc, #184]	; c21bca0 <non_expropiative_kernel+0x134>
 c21bbe4:	e3a01032 	mov	r1, #50	; 0x32
 c21bbe8:	ebffff24 	bl	c21b880 <create_task>
    create_task( Task3, 100 );
 c21bbec:	e59f00b0 	ldr	r0, [pc, #176]	; c21bca4 <non_expropiative_kernel+0x138>
 c21bbf0:	e3a01064 	mov	r1, #100	; 0x64
 c21bbf4:	ebffff21 	bl	c21b880 <create_task>
    create_task( Task4, 1000 );
 c21bbf8:	e59f00a8 	ldr	r0, [pc, #168]	; c21bca8 <non_expropiative_kernel+0x13c>
 c21bbfc:	e3a01ffa 	mov	r1, #1000	; 0x3e8
 c21bc00:	ebffff1e 	bl	c21b880 <create_task>

    pISR_EINT4567 = (unsigned) isr_pb;
 c21bc04:	e59f30a0 	ldr	r3, [pc, #160]	; c21bcac <non_expropiative_kernel+0x140>
 c21bc08:	e59f20a0 	ldr	r2, [pc, #160]	; c21bcb0 <non_expropiative_kernel+0x144>
 c21bc0c:	e5832000 	str	r2, [r3]
   	ic_enable(INT_EINT4567);
 c21bc10:	e3a00015 	mov	r0, #21
 c21bc14:	eb002de3 	bl	c2273a8 <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c21bc18:	e3a00000 	mov	r0, #0
 c21bc1c:	e3a01001 	mov	r1, #1
 c21bc20:	eb0037be 	bl	c229b20 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c21bc24:	e3a00000 	mov	r0, #0
 c21bc28:	e3a01001 	mov	r1, #1
 c21bc2c:	eb0036ba 	bl	c22971c <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c21bc30:	e3a00000 	mov	r0, #0
 c21bc34:	e3a01002 	mov	r1, #2
 c21bc38:	eb0036ee 	bl	c2297f8 <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c21bc3c:	e3a00000 	mov	r0, #0
 c21bc40:	e59f106c 	ldr	r1, [pc, #108]	; c21bcb4 <non_expropiative_kernel+0x148>
 c21bc44:	e3a02001 	mov	r2, #1
 c21bc48:	eb003739 	bl	c229934 <tmr_set_count>

   	tmr_update(TIMER0);
 c21bc4c:	e3a00000 	mov	r0, #0
 c21bc50:	eb003784 	bl	c229a68 <tmr_update>

   	pISR_TIMER0 =(unsigned)scheduler;
 c21bc54:	e59f305c 	ldr	r3, [pc, #92]	; c21bcb8 <non_expropiative_kernel+0x14c>
 c21bc58:	e59f205c 	ldr	r2, [pc, #92]	; c21bcbc <non_expropiative_kernel+0x150>
 c21bc5c:	e5832000 	str	r2, [r3]
   	tmr_start(TIMER0);
 c21bc60:	e3a00000 	mov	r0, #0
 c21bc64:	eb0037f0 	bl	c229c2c <tmr_start>

   	ic_enable(INT_TIMER0);
 c21bc68:	e3a0000d 	mov	r0, #13
 c21bc6c:	eb002dcd 	bl	c2273a8 <ic_enable>

    while( 1 )
    {
        sleep();                /* Entra en estado IDLE, sale por interrupción */
 c21bc70:	eb003c8d 	bl	c22aeac <sleep>
        dispacher();            /* Las tareas preparadas se ejecutan en esta hebra (background) en orden de prioridad */
 c21bc74:	ebffff95 	bl	c21bad0 <dispacher>
    }
 c21bc78:	eafffffc 	b	c21bc70 <non_expropiative_kernel+0x104>
 c21bc7c:	0c100eac 	.word	0x0c100eac
 c21bc80:	0c100ee4 	.word	0x0c100ee4
 c21bc84:	0c1c722b 	.word	0x0c1c722b
 c21bc88:	0c1c722c 	.word	0x0c1c722c
 c21bc8c:	0c1e78ac 	.word	0x0c1e78ac
 c21bc90:	0c224dc8 	.word	0x0c224dc8
 c21bc94:	0c225258 	.word	0x0c225258
 c21bc98:	0c2250a8 	.word	0x0c2250a8
 c21bc9c:	0c2251b0 	.word	0x0c2251b0
 c21bca0:	0c224d40 	.word	0x0c224d40
 c21bca4:	0c224ea4 	.word	0x0c224ea4
 c21bca8:	0c224fbc 	.word	0x0c224fbc
 c21bcac:	0c7fff74 	.word	0x0c7fff74
 c21bcb0:	0c22533c 	.word	0x0c22533c
 c21bcb4:	00009c40 	.word	0x00009c40
 c21bcb8:	0c7fff54 	.word	0x0c7fff54
 c21bcbc:	0c21b9ac 	.word	0x0c21b9ac

0c21bcc0 <queue>:
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void queue( void )
{
 c21bcc0:	e1a0c00d 	mov	ip, sp
 c21bcc4:	e92dd800 	push	{fp, ip, lr, pc}
 c21bcc8:	e24cb004 	sub	fp, ip, #4
 c21bccc:	e24dd008 	sub	sp, sp, #8
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando una aplicación como cola de funciones\n" );
 c21bcd0:	e59f00c4 	ldr	r0, [pc, #196]	; c21bd9c <queue+0xdc>
 c21bcd4:	eb003a47 	bl	c22a5f8 <uart0_puts>
    uart0_puts( " ------------------------------------------------\n\n" ) ;
 c21bcd8:	e59f00c0 	ldr	r0, [pc, #192]	; c21bda0 <queue+0xe0>
 c21bcdc:	eb003a45 	bl	c22a5f8 <uart0_puts>

    fifo_init();             /* Inicializa cola de funciones */
 c21bce0:	eb000086 	bl	c21bf00 <fifo_init>

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c21bce4:	eb002415 	bl	c224d40 <Task1>
    Task2();
 c21bce8:	eb002436 	bl	c224dc8 <Task2>
    Task3();
 c21bcec:	eb00246c 	bl	c224ea4 <Task3>
    Task4();
 c21bcf0:	eb0024b1 	bl	c224fbc <Task4>
    Task5();
 c21bcf4:	eb0024eb 	bl	c2250a8 <Task5>
    Task6();
 c21bcf8:	eb00252c 	bl	c2251b0 <Task6>
    Task7();
 c21bcfc:	eb002555 	bl	c225258 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c21bd00:	e59f309c 	ldr	r3, [pc, #156]	; c21bda4 <queue+0xe4>
 c21bd04:	e59f209c 	ldr	r2, [pc, #156]	; c21bda8 <queue+0xe8>
 c21bd08:	e5832000 	str	r2, [r3]
    ic_enable(INT_EINT4567);
 c21bd0c:	e3a00015 	mov	r0, #21
 c21bd10:	eb002da4 	bl	c2273a8 <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c21bd14:	e3a00000 	mov	r0, #0
 c21bd18:	e3a01001 	mov	r1, #1
 c21bd1c:	eb00377f 	bl	c229b20 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c21bd20:	e3a00000 	mov	r0, #0
 c21bd24:	e3a01001 	mov	r1, #1
 c21bd28:	eb00367b 	bl	c22971c <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c21bd2c:	e3a00000 	mov	r0, #0
 c21bd30:	e3a01002 	mov	r1, #2
 c21bd34:	eb0036af 	bl	c2297f8 <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c21bd38:	e3a00000 	mov	r0, #0
 c21bd3c:	e59f1068 	ldr	r1, [pc, #104]	; c21bdac <queue+0xec>
 c21bd40:	e3a02001 	mov	r2, #1
 c21bd44:	eb0036fa 	bl	c229934 <tmr_set_count>

	tmr_update(TIMER0);
 c21bd48:	e3a00000 	mov	r0, #0
 c21bd4c:	eb003745 	bl	c229a68 <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c21bd50:	e59f3058 	ldr	r3, [pc, #88]	; c21bdb0 <queue+0xf0>
 c21bd54:	e59f2058 	ldr	r2, [pc, #88]	; c21bdb4 <queue+0xf4>
 c21bd58:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c21bd5c:	e3a00000 	mov	r0, #0
 c21bd60:	eb0037b1 	bl	c229c2c <tmr_start>

	ic_enable(INT_TIMER0);
 c21bd64:	e3a0000d 	mov	r0, #13
 c21bd68:	eb002d8e 	bl	c2273a8 <ic_enable>

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c21bd6c:	eb003c4e 	bl	c22aeac <sleep>
        while( !fifo_is_empty() )
 c21bd70:	ea000004 	b	c21bd88 <queue+0xc8>
        {
            pf = fifo_dequeue();
 c21bd74:	eb0000a0 	bl	c21bffc <fifo_dequeue>
 c21bd78:	e50b0010 	str	r0, [fp, #-16]
            (*pf)();                    /* Las tareas encoladas se ejecutan en esta hebra (background) en orden de encolado */
 c21bd7c:	e51b3010 	ldr	r3, [fp, #-16]
 c21bd80:	e1a0e00f 	mov	lr, pc
 c21bd84:	e12fff13 	bx	r3
	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
        while( !fifo_is_empty() )
 c21bd88:	eb0000cb 	bl	c21c0bc <fifo_is_empty>
 c21bd8c:	e1a03000 	mov	r3, r0
 c21bd90:	e3530000 	cmp	r3, #0
 c21bd94:	0afffff6 	beq	c21bd74 <queue+0xb4>
        {
            pf = fifo_dequeue();
            (*pf)();                    /* Las tareas encoladas se ejecutan en esta hebra (background) en orden de encolado */
        }
    }
 c21bd98:	eafffff3 	b	c21bd6c <queue+0xac>
 c21bd9c:	0c100f1c 	.word	0x0c100f1c
 c21bda0:	0c100f54 	.word	0x0c100f54
 c21bda4:	0c7fff74 	.word	0x0c7fff74
 c21bda8:	0c22533c 	.word	0x0c22533c
 c21bdac:	00009c40 	.word	0x00009c40
 c21bdb0:	0c7fff54 	.word	0x0c7fff54
 c21bdb4:	0c21bdb8 	.word	0x0c21bdb8

0c21bdb8 <isr_tick>:
}

#endif

void isr_tick( void )
{
 c21bdb8:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c21bdbc:	e1a0c00d 	mov	ip, sp
 c21bdc0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c21bdc4:	e24cb004 	sub	fp, ip, #4
    static uint16 cont5ticks    = 5;
    static uint16 cont50ticks   = 50;
    static uint16 cont100ticks  = 100;
    static uint16 cont1000ticks = 1000;

    if( !(--cont5ticks) )
 c21bdc8:	e59f3110 	ldr	r3, [pc, #272]	; c21bee0 <isr_tick+0x128>
 c21bdcc:	e1d330b0 	ldrh	r3, [r3]
 c21bdd0:	e2433001 	sub	r3, r3, #1
 c21bdd4:	e1a03803 	lsl	r3, r3, #16
 c21bdd8:	e1a02823 	lsr	r2, r3, #16
 c21bddc:	e59f30fc 	ldr	r3, [pc, #252]	; c21bee0 <isr_tick+0x128>
 c21bde0:	e1c320b0 	strh	r2, [r3]
 c21bde4:	e59f30f4 	ldr	r3, [pc, #244]	; c21bee0 <isr_tick+0x128>
 c21bde8:	e1d330b0 	ldrh	r3, [r3]
 c21bdec:	e3530000 	cmp	r3, #0
 c21bdf0:	1a000004 	bne	c21be08 <isr_tick+0x50>
    {
        cont5ticks = 5;
 c21bdf4:	e59f30e4 	ldr	r3, [pc, #228]	; c21bee0 <isr_tick+0x128>
 c21bdf8:	e3a02005 	mov	r2, #5
 c21bdfc:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task2 );
 c21be00:	e59f00dc 	ldr	r0, [pc, #220]	; c21bee4 <isr_tick+0x12c>
 c21be04:	eb00004d 	bl	c21bf40 <fifo_enqueue>
    }
    if( !(--cont50ticks) )
 c21be08:	e59f30d8 	ldr	r3, [pc, #216]	; c21bee8 <isr_tick+0x130>
 c21be0c:	e1d330b0 	ldrh	r3, [r3]
 c21be10:	e2433001 	sub	r3, r3, #1
 c21be14:	e1a03803 	lsl	r3, r3, #16
 c21be18:	e1a02823 	lsr	r2, r3, #16
 c21be1c:	e59f30c4 	ldr	r3, [pc, #196]	; c21bee8 <isr_tick+0x130>
 c21be20:	e1c320b0 	strh	r2, [r3]
 c21be24:	e59f30bc 	ldr	r3, [pc, #188]	; c21bee8 <isr_tick+0x130>
 c21be28:	e1d330b0 	ldrh	r3, [r3]
 c21be2c:	e3530000 	cmp	r3, #0
 c21be30:	1a000004 	bne	c21be48 <isr_tick+0x90>
    {
        cont50ticks = 50;
 c21be34:	e59f30ac 	ldr	r3, [pc, #172]	; c21bee8 <isr_tick+0x130>
 c21be38:	e3a02032 	mov	r2, #50	; 0x32
 c21be3c:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task1 );
 c21be40:	e59f00a4 	ldr	r0, [pc, #164]	; c21beec <isr_tick+0x134>
 c21be44:	eb00003d 	bl	c21bf40 <fifo_enqueue>
    }
    if( !(--cont100ticks) )
 c21be48:	e59f30a0 	ldr	r3, [pc, #160]	; c21bef0 <isr_tick+0x138>
 c21be4c:	e1d330b0 	ldrh	r3, [r3]
 c21be50:	e2433001 	sub	r3, r3, #1
 c21be54:	e1a03803 	lsl	r3, r3, #16
 c21be58:	e1a02823 	lsr	r2, r3, #16
 c21be5c:	e59f308c 	ldr	r3, [pc, #140]	; c21bef0 <isr_tick+0x138>
 c21be60:	e1c320b0 	strh	r2, [r3]
 c21be64:	e59f3084 	ldr	r3, [pc, #132]	; c21bef0 <isr_tick+0x138>
 c21be68:	e1d330b0 	ldrh	r3, [r3]
 c21be6c:	e3530000 	cmp	r3, #0
 c21be70:	1a000004 	bne	c21be88 <isr_tick+0xd0>
    {
        cont100ticks = 100;
 c21be74:	e59f3074 	ldr	r3, [pc, #116]	; c21bef0 <isr_tick+0x138>
 c21be78:	e3a02064 	mov	r2, #100	; 0x64
 c21be7c:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task3 );
 c21be80:	e59f006c 	ldr	r0, [pc, #108]	; c21bef4 <isr_tick+0x13c>
 c21be84:	eb00002d 	bl	c21bf40 <fifo_enqueue>
    }
    if( !(--cont1000ticks) )
 c21be88:	e59f3068 	ldr	r3, [pc, #104]	; c21bef8 <isr_tick+0x140>
 c21be8c:	e1d330b0 	ldrh	r3, [r3]
 c21be90:	e2433001 	sub	r3, r3, #1
 c21be94:	e1a03803 	lsl	r3, r3, #16
 c21be98:	e1a02823 	lsr	r2, r3, #16
 c21be9c:	e59f3054 	ldr	r3, [pc, #84]	; c21bef8 <isr_tick+0x140>
 c21bea0:	e1c320b0 	strh	r2, [r3]
 c21bea4:	e59f304c 	ldr	r3, [pc, #76]	; c21bef8 <isr_tick+0x140>
 c21bea8:	e1d330b0 	ldrh	r3, [r3]
 c21beac:	e3530000 	cmp	r3, #0
 c21beb0:	1a000004 	bne	c21bec8 <isr_tick+0x110>
    {
        cont1000ticks = 1000;
 c21beb4:	e59f303c 	ldr	r3, [pc, #60]	; c21bef8 <isr_tick+0x140>
 c21beb8:	e3a02ffa 	mov	r2, #1000	; 0x3e8
 c21bebc:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task4 );
 c21bec0:	e59f0034 	ldr	r0, [pc, #52]	; c21befc <isr_tick+0x144>
 c21bec4:	eb00001d 	bl	c21bf40 <fifo_enqueue>
    }

    ic_cleanflag(INT_TIMER0);
 c21bec8:	e3a0000d 	mov	r0, #13
 c21becc:	eb002d68 	bl	c227474 <ic_cleanflag>
};
 c21bed0:	e24bd01c 	sub	sp, fp, #28
 c21bed4:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c21bed8:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c21bedc:	e25ef004 	subs	pc, lr, #4
 c21bee0:	0c1000d8 	.word	0x0c1000d8
 c21bee4:	0c224dc8 	.word	0x0c224dc8
 c21bee8:	0c1000da 	.word	0x0c1000da
 c21beec:	0c224d40 	.word	0x0c224d40
 c21bef0:	0c1000dc 	.word	0x0c1000dc
 c21bef4:	0c224ea4 	.word	0x0c224ea4
 c21bef8:	0c1000de 	.word	0x0c1000de
 c21befc:	0c224fbc 	.word	0x0c224fbc

0c21bf00 <fifo_init>:


/*******************************************************************/

void fifo_init( void )
{
 c21bf00:	e1a0c00d 	mov	ip, sp
 c21bf04:	e92dd800 	push	{fp, ip, lr, pc}
 c21bf08:	e24cb004 	sub	fp, ip, #4
    fifo.head = 0;
 c21bf0c:	e59f3028 	ldr	r3, [pc, #40]	; c21bf3c <fifo_init+0x3c>
 c21bf10:	e3a02000 	mov	r2, #0
 c21bf14:	e1c320b0 	strh	r2, [r3]
    fifo.tail = 0;
 c21bf18:	e59f301c 	ldr	r3, [pc, #28]	; c21bf3c <fifo_init+0x3c>
 c21bf1c:	e3a02000 	mov	r2, #0
 c21bf20:	e1c320b2 	strh	r2, [r3, #2]
    fifo.size = 0;
 c21bf24:	e59f3010 	ldr	r3, [pc, #16]	; c21bf3c <fifo_init+0x3c>
 c21bf28:	e3a02000 	mov	r2, #0
 c21bf2c:	e1c320b4 	strh	r2, [r3, #4]
}
 c21bf30:	e24bd00c 	sub	sp, fp, #12
 c21bf34:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21bf38:	e12fff1e 	bx	lr
 c21bf3c:	0c1c7234 	.word	0x0c1c7234

0c21bf40 <fifo_enqueue>:

void fifo_enqueue( pf_t pf )
{
 c21bf40:	e1a0c00d 	mov	ip, sp
 c21bf44:	e92dd800 	push	{fp, ip, lr, pc}
 c21bf48:	e24cb004 	sub	fp, ip, #4
 c21bf4c:	e24dd008 	sub	sp, sp, #8
 c21bf50:	e50b0010 	str	r0, [fp, #-16]
    fifo.buffer[fifo.tail++] = pf;
 c21bf54:	e59f309c 	ldr	r3, [pc, #156]	; c21bff8 <fifo_enqueue+0xb8>
 c21bf58:	e1d330b2 	ldrh	r3, [r3, #2]
 c21bf5c:	e1a03803 	lsl	r3, r3, #16
 c21bf60:	e1a03823 	lsr	r3, r3, #16
 c21bf64:	e1a01003 	mov	r1, r3
 c21bf68:	e59f2088 	ldr	r2, [pc, #136]	; c21bff8 <fifo_enqueue+0xb8>
 c21bf6c:	e2811002 	add	r1, r1, #2
 c21bf70:	e51b0010 	ldr	r0, [fp, #-16]
 c21bf74:	e7820101 	str	r0, [r2, r1, lsl #2]
 c21bf78:	e2833001 	add	r3, r3, #1
 c21bf7c:	e1a03803 	lsl	r3, r3, #16
 c21bf80:	e1a02823 	lsr	r2, r3, #16
 c21bf84:	e59f306c 	ldr	r3, [pc, #108]	; c21bff8 <fifo_enqueue+0xb8>
 c21bf88:	e1c320b2 	strh	r2, [r3, #2]
    if( fifo.tail == BUFFER_LEN )
 c21bf8c:	e59f3064 	ldr	r3, [pc, #100]	; c21bff8 <fifo_enqueue+0xb8>
 c21bf90:	e1d330b2 	ldrh	r3, [r3, #2]
 c21bf94:	e1a03803 	lsl	r3, r3, #16
 c21bf98:	e1a03823 	lsr	r3, r3, #16
 c21bf9c:	e3530c02 	cmp	r3, #512	; 0x200
 c21bfa0:	1a000002 	bne	c21bfb0 <fifo_enqueue+0x70>
        fifo.tail = 0;
 c21bfa4:	e59f304c 	ldr	r3, [pc, #76]	; c21bff8 <fifo_enqueue+0xb8>
 c21bfa8:	e3a02000 	mov	r2, #0
 c21bfac:	e1c320b2 	strh	r2, [r3, #2]
    INT_DISABLE;
 c21bfb0:	e10f0000 	mrs	r0, CPSR
 c21bfb4:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21bfb8:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21bfbc:	e121f000 	msr	CPSR_c, r0
    fifo.size++;
 c21bfc0:	e59f3030 	ldr	r3, [pc, #48]	; c21bff8 <fifo_enqueue+0xb8>
 c21bfc4:	e1d330b4 	ldrh	r3, [r3, #4]
 c21bfc8:	e1a03803 	lsl	r3, r3, #16
 c21bfcc:	e1a03823 	lsr	r3, r3, #16
 c21bfd0:	e2833001 	add	r3, r3, #1
 c21bfd4:	e1a03803 	lsl	r3, r3, #16
 c21bfd8:	e1a02823 	lsr	r2, r3, #16
 c21bfdc:	e59f3014 	ldr	r3, [pc, #20]	; c21bff8 <fifo_enqueue+0xb8>
 c21bfe0:	e1c320b4 	strh	r2, [r3, #4]
    INT_ENABLE;
 c21bfe4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21bfe8:	e121f000 	msr	CPSR_c, r0
}
 c21bfec:	e24bd00c 	sub	sp, fp, #12
 c21bff0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21bff4:	e12fff1e 	bx	lr
 c21bff8:	0c1c7234 	.word	0x0c1c7234

0c21bffc <fifo_dequeue>:

pf_t fifo_dequeue( void )
{
 c21bffc:	e1a0c00d 	mov	ip, sp
 c21c000:	e92dd800 	push	{fp, ip, lr, pc}
 c21c004:	e24cb004 	sub	fp, ip, #4
 c21c008:	e24dd008 	sub	sp, sp, #8
    pf_t pf;

    pf = fifo.buffer[fifo.head++];
 c21c00c:	e59f30a4 	ldr	r3, [pc, #164]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c010:	e1d330b0 	ldrh	r3, [r3]
 c21c014:	e1a03803 	lsl	r3, r3, #16
 c21c018:	e1a03823 	lsr	r3, r3, #16
 c21c01c:	e1a01003 	mov	r1, r3
 c21c020:	e59f2090 	ldr	r2, [pc, #144]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c024:	e2811002 	add	r1, r1, #2
 c21c028:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c21c02c:	e50b2010 	str	r2, [fp, #-16]
 c21c030:	e2833001 	add	r3, r3, #1
 c21c034:	e1a03803 	lsl	r3, r3, #16
 c21c038:	e1a02823 	lsr	r2, r3, #16
 c21c03c:	e59f3074 	ldr	r3, [pc, #116]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c040:	e1c320b0 	strh	r2, [r3]
    if( fifo.head == BUFFER_LEN )
 c21c044:	e59f306c 	ldr	r3, [pc, #108]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c048:	e1d330b0 	ldrh	r3, [r3]
 c21c04c:	e1a03803 	lsl	r3, r3, #16
 c21c050:	e1a03823 	lsr	r3, r3, #16
 c21c054:	e3530c02 	cmp	r3, #512	; 0x200
 c21c058:	1a000002 	bne	c21c068 <fifo_dequeue+0x6c>
        fifo.head = 0;
 c21c05c:	e59f3054 	ldr	r3, [pc, #84]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c060:	e3a02000 	mov	r2, #0
 c21c064:	e1c320b0 	strh	r2, [r3]
    INT_DISABLE;
 c21c068:	e10f0000 	mrs	r0, CPSR
 c21c06c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c070:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c074:	e121f000 	msr	CPSR_c, r0
    fifo.size--;
 c21c078:	e59f3038 	ldr	r3, [pc, #56]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c07c:	e1d330b4 	ldrh	r3, [r3, #4]
 c21c080:	e1a03803 	lsl	r3, r3, #16
 c21c084:	e1a03823 	lsr	r3, r3, #16
 c21c088:	e2433001 	sub	r3, r3, #1
 c21c08c:	e1a03803 	lsl	r3, r3, #16
 c21c090:	e1a02823 	lsr	r2, r3, #16
 c21c094:	e59f301c 	ldr	r3, [pc, #28]	; c21c0b8 <fifo_dequeue+0xbc>
 c21c098:	e1c320b4 	strh	r2, [r3, #4]
    INT_ENABLE;
 c21c09c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c0a0:	e121f000 	msr	CPSR_c, r0
    return pf;
 c21c0a4:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21c0a8:	e1a00003 	mov	r0, r3
 c21c0ac:	e24bd00c 	sub	sp, fp, #12
 c21c0b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c0b4:	e12fff1e 	bx	lr
 c21c0b8:	0c1c7234 	.word	0x0c1c7234

0c21c0bc <fifo_is_empty>:

boolean fifo_is_empty( void )
{
 c21c0bc:	e1a0c00d 	mov	ip, sp
 c21c0c0:	e92dd800 	push	{fp, ip, lr, pc}
 c21c0c4:	e24cb004 	sub	fp, ip, #4
    return (fifo.size == 0);
 c21c0c8:	e59f3028 	ldr	r3, [pc, #40]	; c21c0f8 <fifo_is_empty+0x3c>
 c21c0cc:	e1d330b4 	ldrh	r3, [r3, #4]
 c21c0d0:	e1a03803 	lsl	r3, r3, #16
 c21c0d4:	e1a03823 	lsr	r3, r3, #16
 c21c0d8:	e3530000 	cmp	r3, #0
 c21c0dc:	13a03000 	movne	r3, #0
 c21c0e0:	03a03001 	moveq	r3, #1
 c21c0e4:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c21c0e8:	e1a00003 	mov	r0, r3
 c21c0ec:	e24bd00c 	sub	sp, fp, #12
 c21c0f0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c0f4:	e12fff1e 	bx	lr
 c21c0f8:	0c1c7234 	.word	0x0c1c7234

0c21c0fc <fifo_is_full>:

boolean fifo_is_full( void )
{
 c21c0fc:	e1a0c00d 	mov	ip, sp
 c21c100:	e92dd800 	push	{fp, ip, lr, pc}
 c21c104:	e24cb004 	sub	fp, ip, #4
    return (fifo.size == BUFFER_LEN-1);
 c21c108:	e59f302c 	ldr	r3, [pc, #44]	; c21c13c <fifo_is_full+0x40>
 c21c10c:	e1d330b4 	ldrh	r3, [r3, #4]
 c21c110:	e1a03803 	lsl	r3, r3, #16
 c21c114:	e1a02823 	lsr	r2, r3, #16
 c21c118:	e59f3020 	ldr	r3, [pc, #32]	; c21c140 <fifo_is_full+0x44>
 c21c11c:	e1520003 	cmp	r2, r3
 c21c120:	13a03000 	movne	r3, #0
 c21c124:	03a03001 	moveq	r3, #1
 c21c128:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c21c12c:	e1a00003 	mov	r0, r3
 c21c130:	e24bd00c 	sub	sp, fp, #12
 c21c134:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c138:	e12fff1e 	bx	lr
 c21c13c:	0c1c7234 	.word	0x0c1c7234
 c21c140:	000001ff 	.word	0x000001ff

0c21c144 <OSStartHighRdy>:
**
*/

OSStartHighRdy:  
  
  bl    OSTaskSwHook            /* (1) Llama a la función OSTaskSwHook() */
 c21c144:	eb0000d5 	bl	c21c4a0 <OSTaskSwHook>

  ldr   r4, =OSRunning          /* (2) OSRunning = TRUE                  */
 c21c148:	e59f40e8 	ldr	r4, [pc, #232]	; c21c238 <OSTickISRcont+0x28>
  mov   r5, #1
 c21c14c:	e3a05001 	mov	r5, #1
  strb  r5, [r4]
 c21c150:	e5c45000 	strb	r5, [r4]

  ldr   r4, =OSTCBHighRdy       /* (3) SP = OSTCBHighRdy->OSTCBStkPtr    */
 c21c154:	e59f40e0 	ldr	r4, [pc, #224]	; c21c23c <OSTickISRcont+0x2c>
  ldr   r4, [r4]
 c21c158:	e5944000 	ldr	r4, [r4]
  ldr   sp, [r4]
 c21c15c:	e594d000 	ldr	sp, [r4]

  ldmfd sp!, {r4}               /* (4) Restaura de la pila el contexto de la tarea preparada con mayor prioridad ... */
 c21c160:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
  msr   spsr, r4
 c21c164:	e169f004 	msr	SPSR_fc, r4
  ldmfd sp!, {r0-r12,lr,pc}^    /* (5) ... retorna a dicha tarea (^ copia el SPSR al CPSR a la vez que restaura el PC) */
 c21c168:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

0c21c16c <OSCtxSw>:
**
*/

OSCtxSw:

  stmfd sp!, {lr}               /* (1) Guarda en la pila el contexto de la tarea actual */
 c21c16c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  stmfd sp!, {r0-r12, lr}
 c21c170:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
  mrs   r4,  cpsr
 c21c174:	e10f4000 	mrs	r4, CPSR
  stmfd sp!, {r4}
 c21c178:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)

  ldr r4, =OSTCBCur             /* (2) OSTCBCur->OSTCBStkPtr = SP        */
 c21c17c:	e59f40bc 	ldr	r4, [pc, #188]	; c21c240 <OSTickISRcont+0x30>
  ldr r5, [r4]
 c21c180:	e5945000 	ldr	r5, [r4]
  str sp, [r5]
 c21c184:	e585d000 	str	sp, [r5]

0c21c188 <OSIntCtxSw>:

OSIntCtxSw:

  bl OSTaskSwHook               /* (3) Llama a la función OSTaskSwHook() */
 c21c188:	eb0000c4 	bl	c21c4a0 <OSTaskSwHook>

  ldr r4, =OSTCBCur             /* (4) OSTCBCur = OSTCBHighRdy           */
 c21c18c:	e59f40ac 	ldr	r4, [pc, #172]	; c21c240 <OSTickISRcont+0x30>
  ldr r5, =OSTCBHighRdy
 c21c190:	e59f50a4 	ldr	r5, [pc, #164]	; c21c23c <OSTickISRcont+0x2c>
  ldr r5, [r5]
 c21c194:	e5955000 	ldr	r5, [r5]
  str r5, [r4]
 c21c198:	e5845000 	str	r5, [r4]

  ldr  r6, =OSPrioHighRdy       /* (5) OSPrioCur = OSPrioHighRdy         */
 c21c19c:	e59f60a0 	ldr	r6, [pc, #160]	; c21c244 <OSTickISRcont+0x34>
  ldr  r7, =OSPrioCur
 c21c1a0:	e59f70a0 	ldr	r7, [pc, #160]	; c21c248 <OSTickISRcont+0x38>
  ldrb r6, [r6]
 c21c1a4:	e5d66000 	ldrb	r6, [r6]
  strb r6, [r7]
 c21c1a8:	e5c76000 	strb	r6, [r7]

  ldr sp, [r5]                  /* (6) SP = OSTCBHighRdy->OSTCBStkPtr    */
 c21c1ac:	e595d000 	ldr	sp, [r5]

  ldmfd sp!, {r4}               /* (7) Restaura de la pila el contexto de la tarea preparada con mayor prioridad y ... */
 c21c1b0:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
  msr   spsr, r4
 c21c1b4:	e169f004 	msr	SPSR_fc, r4
  ldmfd sp!, {r0-r12,lr,pc}^    /* (8) ... retorna a dicha tarea         */
 c21c1b8:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

0c21c1bc <OSTickISR>:
**
*/

OSTickISR:

  stmfd sp!, {r1-r3}           /* Apila los registros de trabajo en la pila IRQ  */
 c21c1bc:	e92d000e 	push	{r1, r2, r3}

  mov r1, sp                   /* Copia en R1 el puntero de la pila IRQ          */
 c21c1c0:	e1a0100d 	mov	r1, sp
  add sp, sp, #12              /* Ajusta el puntero del la pila IRQ a la posición que tenía antes de la interrupción (suma 12 porque ha apilado 3 registros) */
 c21c1c4:	e28dd00c 	add	sp, sp, #12
  sub r2, lr, #4               /* Copia en R2, previo ajuste, la dirección de retorno a la tarea actual (tras IRQ el PC está en <dir_actual>+4) */
 c21c1c8:	e24e2004 	sub	r2, lr, #4
  mrs r3, spsr                 /* Copia en R3 el SPSR (i.e. el CPSR de la tarea actual interrumpida) */
 c21c1cc:	e14f3000 	mrs	r3, SPSR

  msr cpsr_c, #(NOINT|SVCMODE) /* Cambia a modo SVC */
 c21c1d0:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

                               /* (1) Guarda en la pila SVC el contexto de la tarea actual              */
  stmfd sp!, {r2}              /*     - Apila la dirección de retorno a la tarea actual (previamente copiado en R2) */
 c21c1d4:	e52d2004 	push	{r2}		; (str r2, [sp, #-4]!)
  stmfd sp!, {lr}              /*     - Apila el LR de la tarea actual                                  */
 c21c1d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  stmfd sp!, {r4-r12}          /*     - Apila los registros R4-R12 de la tarea actual                   */
 c21c1dc:	e92d1ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip}
  ldmfd r1!, {r4-r6}           /*     - Copia en R4-R6 los registros R1-R3 de la tarea actual (previamente almacenados en la pila IRQ) */
 c21c1e0:	e8b10070 	ldm	r1!, {r4, r5, r6}
  stmfd sp!, {r4-r6}           /*     - Apila los registros R1-R3 de la tarea actual (anteriormente copiados en R4-R6 */
 c21c1e4:	e92d0070 	push	{r4, r5, r6}
  stmfd sp!, {r0}              /*     - Apila el registro R0 de la tarea actual                         */
 c21c1e8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
  stmfd sp!, {r3}              /*     - Apila el CPSR de la tarea actual (previamente copiado en R3)    */
 c21c1ec:	e52d3004 	push	{r3}		; (str r3, [sp, #-4]!)

  bl  OSIntEnter               /* (2) Llama a la función OSIntEnter()          */
 c21c1f0:	eb00014f 	bl	c21c734 <OSIntEnter>

  ldr  r0, =OSIntNesting       /* (3) Si OSIntNesting == 1 ...                 */
 c21c1f4:	e59f0050 	ldr	r0, [pc, #80]	; c21c24c <OSTickISRcont+0x3c>
  ldrb r0, [r0]
 c21c1f8:	e5d00000 	ldrb	r0, [r0]
  cmp  r0, #1
 c21c1fc:	e3500001 	cmp	r0, #1
  bne  OSTickISRcont
 c21c200:	1a000002 	bne	c21c210 <OSTickISRcont>
  ldr  r0, =OSTCBCur           /*     ... OSTCBCur->OSTCBStkPtr = SP           */
 c21c204:	e59f0034 	ldr	r0, [pc, #52]	; c21c240 <OSTickISRcont+0x30>
  ldr  r1, [r0]
 c21c208:	e5901000 	ldr	r1, [r0]
  str  sp, [r1]
 c21c20c:	e581d000 	str	sp, [r1]

0c21c210 <OSTickISRcont>:

OSTickISRcont:

  msr cpsr_c, #(NOINT|IRQMODE) /* Cambia a modo IRQ (para que la pila IRQ sea usada para tratar la interrupción */
 c21c210:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
  ldr r1, =I_ISPC              /* (4) Borra interrupción pendiente por timer */
 c21c214:	e59f1034 	ldr	r1, [pc, #52]	; c21c250 <OSTickISRcont+0x40>
  mov r2, #BIT_TIMER0
 c21c218:	e3a02a02 	mov	r2, #8192	; 0x2000
  str r2, [r1]
 c21c21c:	e5812000 	str	r2, [r1]
                               /* (5) Aquí opcionamente podrían habilitarse interrupciones */

  bl  OSTimeTick               /* (6) Llama a la función OSTimeTick                        */
 c21c220:	eb000255 	bl	c21cb7c <OSTimeTick>

  msr cpsr_c, #(NOINT|SVCMODE) /* Cambia a modo SVC                            */
 c21c224:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

  bl  OSIntExit                /* (6) Llama a la función OSIntExit()           */
 c21c228:	eb000157 	bl	c21c78c <OSIntExit>

                               /* Si ha vuelto de OSintExit() porque no hay una tarea preparada con mayor prioridad */
  ldmfd  sp!, {r4}             /* (7) Restaura de la pila el contexto de la tarea actual y ...                      */
 c21c22c:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
  msr   spsr, r4
 c21c230:	e169f004 	msr	SPSR_fc, r4
  ldmfd  sp!, {r0-r12,lr,pc}^  /* (9) ... retorna a dicha tarea                */
 c21c234:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^
 c21c238:	0c1c7a3d 	.word	0x0c1c7a3d
 c21c23c:	0c1c84a8 	.word	0x0c1c84a8
 c21c240:	0c1c84c4 	.word	0x0c1c84c4
 c21c244:	0c1c7a44 	.word	0x0c1c7a44
 c21c248:	0c1c7b24 	.word	0x0c1c7b24
 c21c24c:	0c1c84c0 	.word	0x0c1c84c0
 c21c250:	01e00024 	.word	0x01e00024

0c21c254 <OSInitHookBegin>:
** Esta función es llamada con las interrupciones deshabilitadas por OSInit() justo después de su inicio.
*/

#if OS_CPU_HOOKS_EN > 0
void OSInitHookBegin( void )
{
 c21c254:	e1a0c00d 	mov	ip, sp
 c21c258:	e92dd800 	push	{fp, ip, lr, pc}
 c21c25c:	e24cb004 	sub	fp, ip, #4
}
 c21c260:	e24bd00c 	sub	sp, fp, #12
 c21c264:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c268:	e12fff1e 	bx	lr

0c21c26c <OSInitHookEnd>:
** Esta función es llamada con las interrupciones deshabilitadas por OSInit() justo antes de su fin.
*/

#if OS_CPU_HOOKS_EN > 0
void OSInitHookEnd( void )
{
 c21c26c:	e1a0c00d 	mov	ip, sp
 c21c270:	e92dd800 	push	{fp, ip, lr, pc}
 c21c274:	e24cb004 	sub	fp, ip, #4
}
 c21c278:	e24bd00c 	sub	sp, fp, #12
 c21c27c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c280:	e12fff1e 	bx	lr

0c21c284 <OSTaskCreateHook>:
** Toma como argumento un puntero al TCB de la tarea recién creada.
*/

#if OS_CPU_HOOKS_EN > 0 
void OSTaskCreateHook( OS_TCB *ptcb )
{
 c21c284:	e1a0c00d 	mov	ip, sp
 c21c288:	e92dd800 	push	{fp, ip, lr, pc}
 c21c28c:	e24cb004 	sub	fp, ip, #4
 c21c290:	e24dd008 	sub	sp, sp, #8
 c21c294:	e50b0010 	str	r0, [fp, #-16]
}
 c21c298:	e24bd00c 	sub	sp, fp, #12
 c21c29c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c2a0:	e12fff1e 	bx	lr

0c21c2a4 <OSTaskDelHook>:
** Toma como argumento un puntero al TCB de la tarea borrada.
*/

#if OS_CPU_HOOKS_EN > 0 
void OSTaskDelHook( OS_TCB *ptcb )
{
 c21c2a4:	e1a0c00d 	mov	ip, sp
 c21c2a8:	e92dd800 	push	{fp, ip, lr, pc}
 c21c2ac:	e24cb004 	sub	fp, ip, #4
 c21c2b0:	e24dd008 	sub	sp, sp, #8
 c21c2b4:	e50b0010 	str	r0, [fp, #-16]
}
 c21c2b8:	e24bd00c 	sub	sp, fp, #12
 c21c2bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c2c0:	e12fff1e 	bx	lr

0c21c2c4 <OSTaskIdleHook>:
** Esta función es llamada con las interrupciones habilitadas por la tarea OS_TaskIdle().
*/

#if OS_CPU_HOOKS_EN > 0
void OSTaskIdleHook( void )
{
 c21c2c4:	e1a0c00d 	mov	ip, sp
 c21c2c8:	e92dd800 	push	{fp, ip, lr, pc}
 c21c2cc:	e24cb004 	sub	fp, ip, #4
    sleep();    /* Pone a la CPU en estado IDLE, sale por interrupción */
 c21c2d0:	eb003af5 	bl	c22aeac <sleep>
}
 c21c2d4:	e24bd00c 	sub	sp, fp, #12
 c21c2d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c2dc:	e12fff1e 	bx	lr

0c21c2e0 <OSTaskStatHook>:
** Esta función es llamada cada segundo por la tarea OSTaskStat().
*/

#if OS_CPU_HOOKS_EN > 0 
void OSTaskStatHook( void )
{
 c21c2e0:	e1a0c00d 	mov	ip, sp
 c21c2e4:	e92dd800 	push	{fp, ip, lr, pc}
 c21c2e8:	e24cb004 	sub	fp, ip, #4
}
 c21c2ec:	e24bd00c 	sub	sp, fp, #12
 c21c2f0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c2f4:	e12fff1e 	bx	lr

0c21c2f8 <OSTaskStkInit>:
**   - OS_STK *ptos           -- puntero a la cima de la pila en la que la función inicializará el contexto de la tarea
**   - INT16U opt             -- permite indicar opciones para modificar el comportamiento de la función
** Devuelve un puntero a la nueva cima de la pila
*/
OS_STK *OSTaskStkInit( void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt )
{
 c21c2f8:	e1a0c00d 	mov	ip, sp
 c21c2fc:	e92dd800 	push	{fp, ip, lr, pc}
 c21c300:	e24cb004 	sub	fp, ip, #4
 c21c304:	e24dd010 	sub	sp, sp, #16
 c21c308:	e50b0010 	str	r0, [fp, #-16]
 c21c30c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c21c310:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
 c21c314:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6

    #if OS_STK_GROWTH == 1               /* Si la pila crece de de direcciones ALTAS hacia BAJAS */

    *(ptos)   = (INT32U) task;        /* Apila el punto de entrada a la tarea                 */
 c21c318:	e51b2010 	ldr	r2, [fp, #-16]
 c21c31c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c320:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila LR                                             */
 c21c324:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c328:	e2433004 	sub	r3, r3, #4
 c21c32c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c330:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c334:	e3a02000 	mov	r2, #0
 c21c338:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R12                                            */
 c21c33c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c340:	e2433004 	sub	r3, r3, #4
 c21c344:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c348:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c34c:	e3a02000 	mov	r2, #0
 c21c350:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R11                                            */
 c21c354:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c358:	e2433004 	sub	r3, r3, #4
 c21c35c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c360:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c364:	e3a02000 	mov	r2, #0
 c21c368:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R10                                            */
 c21c36c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c370:	e2433004 	sub	r3, r3, #4
 c21c374:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c378:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c37c:	e3a02000 	mov	r2, #0
 c21c380:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R9                                             */
 c21c384:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c388:	e2433004 	sub	r3, r3, #4
 c21c38c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c390:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c394:	e3a02000 	mov	r2, #0
 c21c398:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R8                                             */
 c21c39c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3a0:	e2433004 	sub	r3, r3, #4
 c21c3a4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c3a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3ac:	e3a02000 	mov	r2, #0
 c21c3b0:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R7                                             */
 c21c3b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3b8:	e2433004 	sub	r3, r3, #4
 c21c3bc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c3c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3c4:	e3a02000 	mov	r2, #0
 c21c3c8:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R6                                             */
 c21c3cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3d0:	e2433004 	sub	r3, r3, #4
 c21c3d4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c3d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3dc:	e3a02000 	mov	r2, #0
 c21c3e0:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R5                                             */
 c21c3e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3e8:	e2433004 	sub	r3, r3, #4
 c21c3ec:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c3f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c3f4:	e3a02000 	mov	r2, #0
 c21c3f8:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R4                                             */
 c21c3fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c400:	e2433004 	sub	r3, r3, #4
 c21c404:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c408:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c40c:	e3a02000 	mov	r2, #0
 c21c410:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R3                                             */
 c21c414:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c418:	e2433004 	sub	r3, r3, #4
 c21c41c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c420:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c424:	e3a02000 	mov	r2, #0
 c21c428:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R2                                             */
 c21c42c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c430:	e2433004 	sub	r3, r3, #4
 c21c434:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c438:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c43c:	e3a02000 	mov	r2, #0
 c21c440:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) 0;           /* Apila R1                                             */
 c21c444:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c448:	e2433004 	sub	r3, r3, #4
 c21c44c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c450:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c454:	e3a02000 	mov	r2, #0
 c21c458:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) pdata;       /* Apila R0 : argumento                                 */
 c21c45c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c460:	e2433004 	sub	r3, r3, #4
 c21c464:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c468:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21c46c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c470:	e5832000 	str	r2, [r3]
    *(--ptos) = (INT32U) (0x13|0x0);  /* Apila CPSR (IRQ y FIQ habilitadas, modo SVC)         */
 c21c474:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c478:	e2433004 	sub	r3, r3, #4
 c21c47c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21c480:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c484:	e3a02013 	mov	r2, #19
 c21c488:	e5832000 	str	r2, [r3]

    return (ptos);
 c21c48c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8

#else
#error OS_STK_GROWTH no implementado
#endif

}
 c21c490:	e1a00003 	mov	r0, r3
 c21c494:	e24bd00c 	sub	sp, fp, #12
 c21c498:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c49c:	e12fff1e 	bx	lr

0c21c4a0 <OSTaskSwHook>:
**   - OS_TCB *OSTCBHighRdy que apuntará al TCB de la tarea preparada de máxima prioridad (a reanudar)
*/

#if (OS_CPU_HOOKS_EN > 0) && (OS_TASK_SW_HOOK_EN > 0)
void OSTaskSwHook( void )
{
 c21c4a0:	e1a0c00d 	mov	ip, sp
 c21c4a4:	e92dd800 	push	{fp, ip, lr, pc}
 c21c4a8:	e24cb004 	sub	fp, ip, #4
}
 c21c4ac:	e24bd00c 	sub	sp, fp, #12
 c21c4b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c4b4:	e12fff1e 	bx	lr

0c21c4b8 <OSTCBInitHook>:
** Las interrupciones pueden estar habilitadas o deshabilitadas.
** Toma como argumento un puntero al TCB de la tarea recién creada.
*/
#if OS_CPU_HOOKS_EN > 0
void OSTCBInitHook( OS_TCB *ptcb )
{
 c21c4b8:	e1a0c00d 	mov	ip, sp
 c21c4bc:	e92dd800 	push	{fp, ip, lr, pc}
 c21c4c0:	e24cb004 	sub	fp, ip, #4
 c21c4c4:	e24dd008 	sub	sp, sp, #8
 c21c4c8:	e50b0010 	str	r0, [fp, #-16]
}
 c21c4cc:	e24bd00c 	sub	sp, fp, #12
 c21c4d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c4d4:	e12fff1e 	bx	lr

0c21c4d8 <OSTimeTickHook>:
** Esta función es llamada cada tick. Las interrupciones pueden estar habilitadas o deshabilitadas.
*/

#if (OS_CPU_HOOKS_EN > 0) && (OS_TIME_TICK_HOOK_EN > 0)
void OSTimeTickHook( void )
{
 c21c4d8:	e1a0c00d 	mov	ip, sp
 c21c4dc:	e92dd800 	push	{fp, ip, lr, pc}
 c21c4e0:	e24cb004 	sub	fp, ip, #4
}
 c21c4e4:	e24bd00c 	sub	sp, fp, #12
 c21c4e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c4ec:	e12fff1e 	bx	lr

0c21c4f0 <OSEventNameGet>:
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, char *pname, INT8U *err)
{
 c21c4f0:	e1a0c00d 	mov	ip, sp
 c21c4f4:	e92dd800 	push	{fp, ip, lr, pc}
 c21c4f8:	e24cb004 	sub	fp, ip, #4
 c21c4fc:	e24dd018 	sub	sp, sp, #24
 c21c500:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21c504:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21c508:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c21c50c:	e10f0000 	mrs	r0, CPSR
 c21c510:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c514:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c518:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 c21c51c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c520:	e3530000 	cmp	r3, #0
 c21c524:	1a000006 	bne	c21c544 <OSEventNameGet+0x54>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21c528:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c52c:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PEVENT_NULL;
 c21c530:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c534:	e3a02004 	mov	r2, #4
 c21c538:	e5c32000 	strb	r2, [r3]
        return (0);
 c21c53c:	e3a03000 	mov	r3, #0
 c21c540:	ea000022 	b	c21c5d0 <OSEventNameGet+0xe0>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c21c544:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21c548:	e3530000 	cmp	r3, #0
 c21c54c:	1a000006 	bne	c21c56c <OSEventNameGet+0x7c>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21c550:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c554:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c21c558:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c55c:	e3a0200f 	mov	r2, #15
 c21c560:	e5c32000 	strb	r2, [r3]
        return (0);
 c21c564:	e3a03000 	mov	r3, #0
 c21c568:	ea000018 	b	c21c5d0 <OSEventNameGet+0xe0>
    }
#endif
    switch (pevent->OSEventType) {
 c21c56c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c570:	e5d33000 	ldrb	r3, [r3]
 c21c574:	e2433001 	sub	r3, r3, #1
 c21c578:	e3530003 	cmp	r3, #3
 c21c57c:	8a00000d 	bhi	c21c5b8 <OSEventNameGet+0xc8>
        default:
             OS_EXIT_CRITICAL();
             *err = OS_ERR_EVENT_TYPE;
             return (0);
    }
    len  = OS_StrCopy(pname, pevent->OSEventName);    /* Copy name from OS_EVENT                       */
 c21c580:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c584:	e2833010 	add	r3, r3, #16
 c21c588:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c21c58c:	e1a01003 	mov	r1, r3
 c21c590:	eb0004ec 	bl	c21d948 <OS_StrCopy>
 c21c594:	e1a03000 	mov	r3, r0
 c21c598:	e54b300d 	strb	r3, [fp, #-13]
    OS_EXIT_CRITICAL();
 c21c59c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c5a0:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c21c5a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c5a8:	e3a02000 	mov	r2, #0
 c21c5ac:	e5c32000 	strb	r2, [r3]
    return (len);
 c21c5b0:	e55b300d 	ldrb	r3, [fp, #-13]
 c21c5b4:	ea000005 	b	c21c5d0 <OSEventNameGet+0xe0>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             OS_EXIT_CRITICAL();
 c21c5b8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c5bc:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_EVENT_TYPE;
 c21c5c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c5c4:	e3a02001 	mov	r2, #1
 c21c5c8:	e5c32000 	strb	r2, [r3]
             return (0);
 c21c5cc:	e3a03000 	mov	r3, #0
    }
    len  = OS_StrCopy(pname, pevent->OSEventName);    /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *err = OS_NO_ERR;
    return (len);
}
 c21c5d0:	e1a00003 	mov	r0, r3
 c21c5d4:	e24bd00c 	sub	sp, fp, #12
 c21c5d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c5dc:	e12fff1e 	bx	lr

0c21c5e0 <OSEventNameSet>:
*********************************************************************************************************
*/

#if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, char *pname, INT8U *err)
{
 c21c5e0:	e1a0c00d 	mov	ip, sp
 c21c5e4:	e92dd800 	push	{fp, ip, lr, pc}
 c21c5e8:	e24cb004 	sub	fp, ip, #4
 c21c5ec:	e24dd018 	sub	sp, sp, #24
 c21c5f0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21c5f4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21c5f8:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c21c5fc:	e10f0000 	mrs	r0, CPSR
 c21c600:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c604:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c608:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 c21c60c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c610:	e3530000 	cmp	r3, #0
 c21c614:	1a000005 	bne	c21c630 <OSEventNameSet+0x50>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21c618:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c61c:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PEVENT_NULL;
 c21c620:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c624:	e3a02004 	mov	r2, #4
 c21c628:	e5c32000 	strb	r2, [r3]
        return;
 c21c62c:	ea00002b 	b	c21c6e0 <OSEventNameSet+0x100>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c21c630:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21c634:	e3530000 	cmp	r3, #0
 c21c638:	1a000005 	bne	c21c654 <OSEventNameSet+0x74>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21c63c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c640:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c21c644:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c648:	e3a0200f 	mov	r2, #15
 c21c64c:	e5c32000 	strb	r2, [r3]
        return;
 c21c650:	ea000022 	b	c21c6e0 <OSEventNameSet+0x100>
    }
#endif
    switch (pevent->OSEventType) {
 c21c654:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c658:	e5d33000 	ldrb	r3, [r3]
 c21c65c:	e2433001 	sub	r3, r3, #1
 c21c660:	e3530003 	cmp	r3, #3
 c21c664:	8a000007 	bhi	c21c688 <OSEventNameSet+0xa8>
        default:
             OS_EXIT_CRITICAL();
             *err = OS_ERR_EVENT_TYPE;
             return;
    }
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 c21c668:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c21c66c:	eb0004d7 	bl	c21d9d0 <OS_StrLen>
 c21c670:	e1a03000 	mov	r3, r0
 c21c674:	e54b300d 	strb	r3, [fp, #-13]
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 c21c678:	e55b300d 	ldrb	r3, [fp, #-13]
 c21c67c:	e353001f 	cmp	r3, #31
 c21c680:	8a000006 	bhi	c21c6a0 <OSEventNameSet+0xc0>
 c21c684:	ea00000b 	b	c21c6b8 <OSEventNameSet+0xd8>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             OS_EXIT_CRITICAL();
 c21c688:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c68c:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_EVENT_TYPE;
 c21c690:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c694:	e3a02001 	mov	r2, #1
 c21c698:	e5c32000 	strb	r2, [r3]
             return;
 c21c69c:	ea00000f 	b	c21c6e0 <OSEventNameSet+0x100>
    }
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
 c21c6a0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c6a4:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_EVENT_NAME_TOO_LONG;
 c21c6a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c6ac:	e3a0200c 	mov	r2, #12
 c21c6b0:	e5c32000 	strb	r2, [r3]
        return;
 c21c6b4:	ea000009 	b	c21c6e0 <OSEventNameSet+0x100>
    } 
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 c21c6b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21c6bc:	e2833010 	add	r3, r3, #16
 c21c6c0:	e1a00003 	mov	r0, r3
 c21c6c4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c21c6c8:	eb00049e 	bl	c21d948 <OS_StrCopy>
    OS_EXIT_CRITICAL();
 c21c6cc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c6d0:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c21c6d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21c6d8:	e3a02000 	mov	r2, #0
 c21c6dc:	e5c32000 	strb	r2, [r3]
}
 c21c6e0:	e24bd00c 	sub	sp, fp, #12
 c21c6e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c6e8:	e12fff1e 	bx	lr

0c21c6ec <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 c21c6ec:	e1a0c00d 	mov	ip, sp
 c21c6f0:	e92dd800 	push	{fp, ip, lr, pc}
 c21c6f4:	e24cb004 	sub	fp, ip, #4
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 c21c6f8:	ebfffed5 	bl	c21c254 <OSInitHookBegin>
#endif

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 c21c6fc:	eb000348 	bl	c21d424 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 c21c700:	eb000375 	bl	c21d4dc <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 c21c704:	eb0003d5 	bl	c21d660 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 c21c708:	eb000309 	bl	c21d334 <OS_InitEventList>

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 c21c70c:	eb000ba6 	bl	c21f5ac <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 c21c710:	eb001015 	bl	c22076c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 c21c714:	eb00180e 	bl	c222754 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 c21c718:	eb00039c 	bl	c21d590 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 c21c71c:	eb0003b5 	bl	c21d5f8 <OS_InitTaskStat>
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
 c21c720:	ebfffed1 	bl	c21c26c <OSInitHookEnd>
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
 c21c724:	eb000607 	bl	c21df48 <OSDebugInit>
#endif
}
 c21c728:	e24bd00c 	sub	sp, fp, #12
 c21c72c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c730:	e12fff1e 	bx	lr

0c21c734 <OSIntEnter>:
*                 OSIntEnter() is always called with interrupts disabled.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 c21c734:	e1a0c00d 	mov	ip, sp
 c21c738:	e92dd800 	push	{fp, ip, lr, pc}
 c21c73c:	e24cb004 	sub	fp, ip, #4
    if (OSRunning == TRUE) {
 c21c740:	e59f303c 	ldr	r3, [pc, #60]	; c21c784 <OSIntEnter+0x50>
 c21c744:	e5d33000 	ldrb	r3, [r3]
 c21c748:	e3530001 	cmp	r3, #1
 c21c74c:	1a000009 	bne	c21c778 <OSIntEnter+0x44>
        if (OSIntNesting < 255u) {
 c21c750:	e59f3030 	ldr	r3, [pc, #48]	; c21c788 <OSIntEnter+0x54>
 c21c754:	e5d33000 	ldrb	r3, [r3]
 c21c758:	e35300ff 	cmp	r3, #255	; 0xff
 c21c75c:	0a000005 	beq	c21c778 <OSIntEnter+0x44>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 c21c760:	e59f3020 	ldr	r3, [pc, #32]	; c21c788 <OSIntEnter+0x54>
 c21c764:	e5d33000 	ldrb	r3, [r3]
 c21c768:	e2833001 	add	r3, r3, #1
 c21c76c:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c770:	e59f3010 	ldr	r3, [pc, #16]	; c21c788 <OSIntEnter+0x54>
 c21c774:	e5c32000 	strb	r2, [r3]
        }
    }
}
 c21c778:	e24bd00c 	sub	sp, fp, #12
 c21c77c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c780:	e12fff1e 	bx	lr
 c21c784:	0c1c7a3d 	.word	0x0c1c7a3d
 c21c788:	0c1c84c0 	.word	0x0c1c84c0

0c21c78c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 c21c78c:	e1a0c00d 	mov	ip, sp
 c21c790:	e92dd800 	push	{fp, ip, lr, pc}
 c21c794:	e24cb004 	sub	fp, ip, #4
 c21c798:	e24dd008 	sub	sp, sp, #8
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSRunning == TRUE) {
 c21c79c:	e59f3118 	ldr	r3, [pc, #280]	; c21c8bc <OSIntExit+0x130>
 c21c7a0:	e5d33000 	ldrb	r3, [r3]
 c21c7a4:	e3530001 	cmp	r3, #1
 c21c7a8:	1a000040 	bne	c21c8b0 <OSIntExit+0x124>
        OS_ENTER_CRITICAL();
 c21c7ac:	e10f0000 	mrs	r0, CPSR
 c21c7b0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c7b4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c7b8:	e121f000 	msr	CPSR_c, r0
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 c21c7bc:	e59f30fc 	ldr	r3, [pc, #252]	; c21c8c0 <OSIntExit+0x134>
 c21c7c0:	e5d33000 	ldrb	r3, [r3]
 c21c7c4:	e3530000 	cmp	r3, #0
 c21c7c8:	0a000005 	beq	c21c7e4 <OSIntExit+0x58>
            OSIntNesting--;
 c21c7cc:	e59f30ec 	ldr	r3, [pc, #236]	; c21c8c0 <OSIntExit+0x134>
 c21c7d0:	e5d33000 	ldrb	r3, [r3]
 c21c7d4:	e2433001 	sub	r3, r3, #1
 c21c7d8:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c7dc:	e59f30dc 	ldr	r3, [pc, #220]	; c21c8c0 <OSIntExit+0x134>
 c21c7e0:	e5c32000 	strb	r2, [r3]
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 c21c7e4:	e59f30d4 	ldr	r3, [pc, #212]	; c21c8c0 <OSIntExit+0x134>
 c21c7e8:	e5d33000 	ldrb	r3, [r3]
 c21c7ec:	e3530000 	cmp	r3, #0
 c21c7f0:	1a00002c 	bne	c21c8a8 <OSIntExit+0x11c>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 c21c7f4:	e59f30c8 	ldr	r3, [pc, #200]	; c21c8c4 <OSIntExit+0x138>
 c21c7f8:	e5d33000 	ldrb	r3, [r3]
 c21c7fc:	e3530000 	cmp	r3, #0
 c21c800:	1a000028 	bne	c21c8a8 <OSIntExit+0x11c>
                y             = OSUnMapTbl[OSRdyGrp];          
 c21c804:	e59f30bc 	ldr	r3, [pc, #188]	; c21c8c8 <OSIntExit+0x13c>
 c21c808:	e5d33000 	ldrb	r3, [r3]
 c21c80c:	e59f20b8 	ldr	r2, [pc, #184]	; c21c8cc <OSIntExit+0x140>
 c21c810:	e7d23003 	ldrb	r3, [r2, r3]
 c21c814:	e54b300d 	strb	r3, [fp, #-13]
                OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 c21c818:	e55b300d 	ldrb	r3, [fp, #-13]
 c21c81c:	e1a03183 	lsl	r3, r3, #3
 c21c820:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c824:	e55b300d 	ldrb	r3, [fp, #-13]
 c21c828:	e59f10a0 	ldr	r1, [pc, #160]	; c21c8d0 <OSIntExit+0x144>
 c21c82c:	e7d13003 	ldrb	r3, [r1, r3]
 c21c830:	e59f1094 	ldr	r1, [pc, #148]	; c21c8cc <OSIntExit+0x140>
 c21c834:	e7d13003 	ldrb	r3, [r1, r3]
 c21c838:	e0823003 	add	r3, r2, r3
 c21c83c:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c840:	e59f308c 	ldr	r3, [pc, #140]	; c21c8d4 <OSIntExit+0x148>
 c21c844:	e5c32000 	strb	r2, [r3]
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 c21c848:	e59f3084 	ldr	r3, [pc, #132]	; c21c8d4 <OSIntExit+0x148>
 c21c84c:	e5d32000 	ldrb	r2, [r3]
 c21c850:	e59f3080 	ldr	r3, [pc, #128]	; c21c8d8 <OSIntExit+0x14c>
 c21c854:	e5d33000 	ldrb	r3, [r3]
 c21c858:	e1520003 	cmp	r2, r3
 c21c85c:	0a000011 	beq	c21c8a8 <OSIntExit+0x11c>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 c21c860:	e59f306c 	ldr	r3, [pc, #108]	; c21c8d4 <OSIntExit+0x148>
 c21c864:	e5d33000 	ldrb	r3, [r3]
 c21c868:	e1a02003 	mov	r2, r3
 c21c86c:	e59f3068 	ldr	r3, [pc, #104]	; c21c8dc <OSIntExit+0x150>
 c21c870:	e7932102 	ldr	r2, [r3, r2, lsl #2]
 c21c874:	e59f3064 	ldr	r3, [pc, #100]	; c21c8e0 <OSIntExit+0x154>
 c21c878:	e5832000 	str	r2, [r3]
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 c21c87c:	e59f305c 	ldr	r3, [pc, #92]	; c21c8e0 <OSIntExit+0x154>
 c21c880:	e5933000 	ldr	r3, [r3]
 c21c884:	e5932034 	ldr	r2, [r3, #52]	; 0x34
 c21c888:	e2822001 	add	r2, r2, #1
 c21c88c:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 c21c890:	e59f304c 	ldr	r3, [pc, #76]	; c21c8e4 <OSIntExit+0x158>
 c21c894:	e5933000 	ldr	r3, [r3]
 c21c898:	e2832001 	add	r2, r3, #1
 c21c89c:	e59f3040 	ldr	r3, [pc, #64]	; c21c8e4 <OSIntExit+0x158>
 c21c8a0:	e5832000 	str	r2, [r3]
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 c21c8a4:	ebfffe37 	bl	c21c188 <OSIntCtxSw>
                }
            }
        }
        OS_EXIT_CRITICAL();
 c21c8a8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c8ac:	e121f000 	msr	CPSR_c, r0
    }
}
 c21c8b0:	e24bd00c 	sub	sp, fp, #12
 c21c8b4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c8b8:	e12fff1e 	bx	lr
 c21c8bc:	0c1c7a3d 	.word	0x0c1c7a3d
 c21c8c0:	0c1c84c0 	.word	0x0c1c84c0
 c21c8c4:	0c1c7a3c 	.word	0x0c1c7a3c
 c21c8c8:	0c1c84b0 	.word	0x0c1c84b0
 c21c8cc:	0c100f90 	.word	0x0c100f90
 c21c8d0:	0c1c84b4 	.word	0x0c1c84b4
 c21c8d4:	0c1c7a44 	.word	0x0c1c7a44
 c21c8d8:	0c1c7b24 	.word	0x0c1c7b24
 c21c8dc:	0c1c97a4 	.word	0x0c1c97a4
 c21c8e0:	0c1c84a8 	.word	0x0c1c84a8
 c21c8e4:	0c1c8434 	.word	0x0c1c8434

0c21c8e8 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 c21c8e8:	e1a0c00d 	mov	ip, sp
 c21c8ec:	e92dd800 	push	{fp, ip, lr, pc}
 c21c8f0:	e24cb004 	sub	fp, ip, #4
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    if (OSRunning == TRUE) {                     /* Make sure multitasking is running                  */
 c21c8f4:	e59f3054 	ldr	r3, [pc, #84]	; c21c950 <OSSchedLock+0x68>
 c21c8f8:	e5d33000 	ldrb	r3, [r3]
 c21c8fc:	e3530001 	cmp	r3, #1
 c21c900:	1a00000f 	bne	c21c944 <OSSchedLock+0x5c>
        OS_ENTER_CRITICAL();
 c21c904:	e10f0000 	mrs	r0, CPSR
 c21c908:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c90c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c910:	e121f000 	msr	CPSR_c, r0
        if (OSLockNesting < 255u) {              /* Prevent OSLockNesting from wrapping back to 0      */
 c21c914:	e59f3038 	ldr	r3, [pc, #56]	; c21c954 <OSSchedLock+0x6c>
 c21c918:	e5d33000 	ldrb	r3, [r3]
 c21c91c:	e35300ff 	cmp	r3, #255	; 0xff
 c21c920:	0a000005 	beq	c21c93c <OSSchedLock+0x54>
            OSLockNesting++;                     /* Increment lock nesting level                       */
 c21c924:	e59f3028 	ldr	r3, [pc, #40]	; c21c954 <OSSchedLock+0x6c>
 c21c928:	e5d33000 	ldrb	r3, [r3]
 c21c92c:	e2833001 	add	r3, r3, #1
 c21c930:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c934:	e59f3018 	ldr	r3, [pc, #24]	; c21c954 <OSSchedLock+0x6c>
 c21c938:	e5c32000 	strb	r2, [r3]
        }
        OS_EXIT_CRITICAL();
 c21c93c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c940:	e121f000 	msr	CPSR_c, r0
    }
}
 c21c944:	e24bd00c 	sub	sp, fp, #12
 c21c948:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21c94c:	e12fff1e 	bx	lr
 c21c950:	0c1c7a3d 	.word	0x0c1c7a3d
 c21c954:	0c1c7a3c 	.word	0x0c1c7a3c

0c21c958 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 c21c958:	e1a0c00d 	mov	ip, sp
 c21c95c:	e92dd800 	push	{fp, ip, lr, pc}
 c21c960:	e24cb004 	sub	fp, ip, #4
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSRunning == TRUE) {                               /* Make sure multitasking is running        */
 c21c964:	e59f309c 	ldr	r3, [pc, #156]	; c21ca08 <OSSchedUnlock+0xb0>
 c21c968:	e5d33000 	ldrb	r3, [r3]
 c21c96c:	e3530001 	cmp	r3, #1
 c21c970:	1a000021 	bne	c21c9fc <OSSchedUnlock+0xa4>
        OS_ENTER_CRITICAL();
 c21c974:	e10f0000 	mrs	r0, CPSR
 c21c978:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21c97c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21c980:	e121f000 	msr	CPSR_c, r0
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 c21c984:	e59f3080 	ldr	r3, [pc, #128]	; c21ca0c <OSSchedUnlock+0xb4>
 c21c988:	e5d33000 	ldrb	r3, [r3]
 c21c98c:	e3530000 	cmp	r3, #0
 c21c990:	0a000017 	beq	c21c9f4 <OSSchedUnlock+0x9c>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 c21c994:	e59f3070 	ldr	r3, [pc, #112]	; c21ca0c <OSSchedUnlock+0xb4>
 c21c998:	e5d33000 	ldrb	r3, [r3]
 c21c99c:	e2433001 	sub	r3, r3, #1
 c21c9a0:	e20320ff 	and	r2, r3, #255	; 0xff
 c21c9a4:	e59f3060 	ldr	r3, [pc, #96]	; c21ca0c <OSSchedUnlock+0xb4>
 c21c9a8:	e5c32000 	strb	r2, [r3]
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 c21c9ac:	e59f3058 	ldr	r3, [pc, #88]	; c21ca0c <OSSchedUnlock+0xb4>
 c21c9b0:	e5d33000 	ldrb	r3, [r3]
 c21c9b4:	e3530000 	cmp	r3, #0
 c21c9b8:	1a00000a 	bne	c21c9e8 <OSSchedUnlock+0x90>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 c21c9bc:	e59f304c 	ldr	r3, [pc, #76]	; c21ca10 <OSSchedUnlock+0xb8>
 c21c9c0:	e5d33000 	ldrb	r3, [r3]
 c21c9c4:	e3530000 	cmp	r3, #0
 c21c9c8:	1a000003 	bne	c21c9dc <OSSchedUnlock+0x84>
                    OS_EXIT_CRITICAL();
 c21c9cc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c9d0:	e121f000 	msr	CPSR_c, r0
                    OS_Sched();                            /* See if a HPT is ready                    */
 c21c9d4:	eb000393 	bl	c21d828 <OS_Sched>
 c21c9d8:	ea000007 	b	c21c9fc <OSSchedUnlock+0xa4>
                } else {
                    OS_EXIT_CRITICAL();
 c21c9dc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c9e0:	e121f000 	msr	CPSR_c, r0
 c21c9e4:	ea000004 	b	c21c9fc <OSSchedUnlock+0xa4>
                }
            } else {
                OS_EXIT_CRITICAL();
 c21c9e8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c9ec:	e121f000 	msr	CPSR_c, r0
 c21c9f0:	ea000001 	b	c21c9fc <OSSchedUnlock+0xa4>
            }
        } else {
            OS_EXIT_CRITICAL();
 c21c9f4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21c9f8:	e121f000 	msr	CPSR_c, r0
        }
    }
}
 c21c9fc:	e24bd00c 	sub	sp, fp, #12
 c21ca00:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21ca04:	e12fff1e 	bx	lr
 c21ca08:	0c1c7a3d 	.word	0x0c1c7a3d
 c21ca0c:	0c1c7a3c 	.word	0x0c1c7a3c
 c21ca10:	0c1c84c0 	.word	0x0c1c84c0

0c21ca14 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 c21ca14:	e1a0c00d 	mov	ip, sp
 c21ca18:	e92dd800 	push	{fp, ip, lr, pc}
 c21ca1c:	e24cb004 	sub	fp, ip, #4
 c21ca20:	e24dd008 	sub	sp, sp, #8
    INT8U y;
    INT8U x;


    if (OSRunning == FALSE) {
 c21ca24:	e59f30a0 	ldr	r3, [pc, #160]	; c21cacc <OSStart+0xb8>
 c21ca28:	e5d33000 	ldrb	r3, [r3]
 c21ca2c:	e3530000 	cmp	r3, #0
 c21ca30:	1a000022 	bne	c21cac0 <OSStart+0xac>
        y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
 c21ca34:	e59f3094 	ldr	r3, [pc, #148]	; c21cad0 <OSStart+0xbc>
 c21ca38:	e5d33000 	ldrb	r3, [r3]
 c21ca3c:	e59f2090 	ldr	r2, [pc, #144]	; c21cad4 <OSStart+0xc0>
 c21ca40:	e7d23003 	ldrb	r3, [r2, r3]
 c21ca44:	e54b300d 	strb	r3, [fp, #-13]
        x             = OSUnMapTbl[OSRdyTbl[y]];
 c21ca48:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ca4c:	e59f2084 	ldr	r2, [pc, #132]	; c21cad8 <OSStart+0xc4>
 c21ca50:	e7d23003 	ldrb	r3, [r2, r3]
 c21ca54:	e59f2078 	ldr	r2, [pc, #120]	; c21cad4 <OSStart+0xc0>
 c21ca58:	e7d23003 	ldrb	r3, [r2, r3]
 c21ca5c:	e54b300e 	strb	r3, [fp, #-14]
        OSPrioHighRdy = (INT8U)((y << 3) + x);
 c21ca60:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ca64:	e1a03183 	lsl	r3, r3, #3
 c21ca68:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ca6c:	e55b300e 	ldrb	r3, [fp, #-14]
 c21ca70:	e0823003 	add	r3, r2, r3
 c21ca74:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ca78:	e59f305c 	ldr	r3, [pc, #92]	; c21cadc <OSStart+0xc8>
 c21ca7c:	e5c32000 	strb	r2, [r3]
        OSPrioCur     = OSPrioHighRdy;
 c21ca80:	e59f3054 	ldr	r3, [pc, #84]	; c21cadc <OSStart+0xc8>
 c21ca84:	e5d32000 	ldrb	r2, [r3]
 c21ca88:	e59f3050 	ldr	r3, [pc, #80]	; c21cae0 <OSStart+0xcc>
 c21ca8c:	e5c32000 	strb	r2, [r3]
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 c21ca90:	e59f3044 	ldr	r3, [pc, #68]	; c21cadc <OSStart+0xc8>
 c21ca94:	e5d33000 	ldrb	r3, [r3]
 c21ca98:	e1a02003 	mov	r2, r3
 c21ca9c:	e59f3040 	ldr	r3, [pc, #64]	; c21cae4 <OSStart+0xd0>
 c21caa0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
 c21caa4:	e59f303c 	ldr	r3, [pc, #60]	; c21cae8 <OSStart+0xd4>
 c21caa8:	e5832000 	str	r2, [r3]
        OSTCBCur      = OSTCBHighRdy;
 c21caac:	e59f3034 	ldr	r3, [pc, #52]	; c21cae8 <OSStart+0xd4>
 c21cab0:	e5932000 	ldr	r2, [r3]
 c21cab4:	e59f3030 	ldr	r3, [pc, #48]	; c21caec <OSStart+0xd8>
 c21cab8:	e5832000 	str	r2, [r3]
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 c21cabc:	ebfffda0 	bl	c21c144 <OSStartHighRdy>
    }
}
 c21cac0:	e24bd00c 	sub	sp, fp, #12
 c21cac4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cac8:	e12fff1e 	bx	lr
 c21cacc:	0c1c7a3d 	.word	0x0c1c7a3d
 c21cad0:	0c1c84b0 	.word	0x0c1c84b0
 c21cad4:	0c100f90 	.word	0x0c100f90
 c21cad8:	0c1c84b4 	.word	0x0c1c84b4
 c21cadc:	0c1c7a44 	.word	0x0c1c7a44
 c21cae0:	0c1c7b24 	.word	0x0c1c7b24
 c21cae4:	0c1c97a4 	.word	0x0c1c97a4
 c21cae8:	0c1c84a8 	.word	0x0c1c84a8
 c21caec:	0c1c84c4 	.word	0x0c1c84c4

0c21caf0 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 c21caf0:	e1a0c00d 	mov	ip, sp
 c21caf4:	e92dd800 	push	{fp, ip, lr, pc}
 c21caf8:	e24cb004 	sub	fp, ip, #4
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 c21cafc:	e3a00002 	mov	r0, #2
 c21cb00:	eb001e8e 	bl	c224540 <OSTimeDly>
    OS_ENTER_CRITICAL();
 c21cb04:	e10f0000 	mrs	r0, CPSR
 c21cb08:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21cb0c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21cb10:	e121f000 	msr	CPSR_c, r0
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 c21cb14:	e59f3054 	ldr	r3, [pc, #84]	; c21cb70 <OSStatInit+0x80>
 c21cb18:	e3a02000 	mov	r2, #0
 c21cb1c:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
 c21cb20:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21cb24:	e121f000 	msr	CPSR_c, r0
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 c21cb28:	e3a0000a 	mov	r0, #10
 c21cb2c:	eb001e83 	bl	c224540 <OSTimeDly>
    OS_ENTER_CRITICAL();
 c21cb30:	e10f0000 	mrs	r0, CPSR
 c21cb34:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21cb38:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21cb3c:	e121f000 	msr	CPSR_c, r0
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 c21cb40:	e59f3028 	ldr	r3, [pc, #40]	; c21cb70 <OSStatInit+0x80>
 c21cb44:	e5932000 	ldr	r2, [r3]
 c21cb48:	e59f3024 	ldr	r3, [pc, #36]	; c21cb74 <OSStatInit+0x84>
 c21cb4c:	e5832000 	str	r2, [r3]
    OSStatRdy    = TRUE;
 c21cb50:	e59f3020 	ldr	r3, [pc, #32]	; c21cb78 <OSStatInit+0x88>
 c21cb54:	e3a02001 	mov	r2, #1
 c21cb58:	e5c32000 	strb	r2, [r3]
    OS_EXIT_CRITICAL();
 c21cb5c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21cb60:	e121f000 	msr	CPSR_c, r0
}
 c21cb64:	e24bd00c 	sub	sp, fp, #12
 c21cb68:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cb6c:	e12fff1e 	bx	lr
 c21cb70:	0c1c7a40 	.word	0x0c1c7a40
 c21cb74:	0c1c8438 	.word	0x0c1c8438
 c21cb78:	0c1c97a0 	.word	0x0c1c97a0

0c21cb7c <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 c21cb7c:	e1a0c00d 	mov	ip, sp
 c21cb80:	e92dd800 	push	{fp, ip, lr, pc}
 c21cb84:	e24cb004 	sub	fp, ip, #4
 c21cb88:	e24dd008 	sub	sp, sp, #8


    cpu_sr = 0;                                            /* Prevent compiler warning                     */
#endif
#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 c21cb8c:	ebfffe51 	bl	c21c4d8 <OSTimeTickHook>
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 c21cb90:	e10f0000 	mrs	r0, CPSR
 c21cb94:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21cb98:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21cb9c:	e121f000 	msr	CPSR_c, r0
    OSTime++;
 c21cba0:	e59f31d8 	ldr	r3, [pc, #472]	; c21cd80 <OSTimeTick+0x204>
 c21cba4:	e5933000 	ldr	r3, [r3]
 c21cba8:	e2832001 	add	r2, r3, #1
 c21cbac:	e59f31cc 	ldr	r3, [pc, #460]	; c21cd80 <OSTimeTick+0x204>
 c21cbb0:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
 c21cbb4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21cbb8:	e121f000 	msr	CPSR_c, r0
#endif
    if (OSRunning == TRUE) {
 c21cbbc:	e59f31c0 	ldr	r3, [pc, #448]	; c21cd84 <OSTimeTick+0x208>
 c21cbc0:	e5d33000 	ldrb	r3, [r3]
 c21cbc4:	e3530001 	cmp	r3, #1
 c21cbc8:	1a000069 	bne	c21cd74 <OSTimeTick+0x1f8>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 c21cbcc:	e59f31b4 	ldr	r3, [pc, #436]	; c21cd88 <OSTimeTick+0x20c>
 c21cbd0:	e5d33000 	ldrb	r3, [r3]
 c21cbd4:	e3530001 	cmp	r3, #1
 c21cbd8:	0a000006 	beq	c21cbf8 <OSTimeTick+0x7c>
 c21cbdc:	e3530002 	cmp	r3, #2
 c21cbe0:	0a000007 	beq	c21cc04 <OSTimeTick+0x88>
 c21cbe4:	e3530000 	cmp	r3, #0
 c21cbe8:	1a00000b 	bne	c21cc1c <OSTimeTick+0xa0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = TRUE;
 c21cbec:	e3a03001 	mov	r3, #1
 c21cbf0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                 break;
 c21cbf4:	ea00000e 	b	c21cc34 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = FALSE;                             /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 c21cbf8:	e3a03000 	mov	r3, #0
 c21cbfc:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                 break;
 c21cc00:	ea00000b 	b	c21cc34 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = TRUE;                   /*      ... step command from uC/OS-View        */
 c21cc04:	e3a03001 	mov	r3, #1
 c21cc08:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                 OSTickStepState = OS_TICK_STEP_WAIT;
 c21cc0c:	e59f3174 	ldr	r3, [pc, #372]	; c21cd88 <OSTimeTick+0x20c>
 c21cc10:	e3a02001 	mov	r2, #1
 c21cc14:	e5c32000 	strb	r2, [r3]
                 break;
 c21cc18:	ea000005 	b	c21cc34 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = TRUE;
 c21cc1c:	e3a03001 	mov	r3, #1
 c21cc20:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                 OSTickStepState = OS_TICK_STEP_DIS;
 c21cc24:	e59f315c 	ldr	r3, [pc, #348]	; c21cd88 <OSTimeTick+0x20c>
 c21cc28:	e3a02000 	mov	r2, #0
 c21cc2c:	e5c32000 	strb	r2, [r3]
                 break;
 c21cc30:	e1a00000 	nop			; (mov r0, r0)
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
 c21cc34:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c21cc38:	e3530000 	cmp	r3, #0
 c21cc3c:	0a00004b 	beq	c21cd70 <OSTimeTick+0x1f4>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 c21cc40:	e59f3144 	ldr	r3, [pc, #324]	; c21cd8c <OSTimeTick+0x210>
 c21cc44:	e5933000 	ldr	r3, [r3]
 c21cc48:	e50b3010 	str	r3, [fp, #-16]
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
 c21cc4c:	ea000042 	b	c21cd5c <OSTimeTick+0x1e0>
            OS_ENTER_CRITICAL();
 c21cc50:	e10f0000 	mrs	r0, CPSR
 c21cc54:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21cc58:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21cc5c:	e121f000 	msr	CPSR_c, r0
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 c21cc60:	e51b3010 	ldr	r3, [fp, #-16]
 c21cc64:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
 c21cc68:	e3530000 	cmp	r3, #0
 c21cc6c:	0a000035 	beq	c21cd48 <OSTimeTick+0x1cc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 c21cc70:	e51b3010 	ldr	r3, [fp, #-16]
 c21cc74:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
 c21cc78:	e2433001 	sub	r3, r3, #1
 c21cc7c:	e1a03803 	lsl	r3, r3, #16
 c21cc80:	e1a02823 	lsr	r2, r3, #16
 c21cc84:	e51b3010 	ldr	r3, [fp, #-16]
 c21cc88:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
 c21cc8c:	e51b3010 	ldr	r3, [fp, #-16]
 c21cc90:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
 c21cc94:	e3530000 	cmp	r3, #0
 c21cc98:	1a00002a 	bne	c21cd48 <OSTimeTick+0x1cc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 c21cc9c:	e51b3010 	ldr	r3, [fp, #-16]
 c21cca0:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21cca4:	e2033037 	and	r3, r3, #55	; 0x37
 c21cca8:	e3530000 	cmp	r3, #0
 c21ccac:	0a000009 	beq	c21ccd8 <OSTimeTick+0x15c>
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
 c21ccb0:	e51b3010 	ldr	r3, [fp, #-16]
 c21ccb4:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21ccb8:	e3c33037 	bic	r3, r3, #55	; 0x37
 c21ccbc:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ccc0:	e51b3010 	ldr	r3, [fp, #-16]
 c21ccc4:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
                        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout    */
 c21ccc8:	e51b3010 	ldr	r3, [fp, #-16]
 c21cccc:	e3a02001 	mov	r2, #1
 c21ccd0:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
 c21ccd4:	ea000002 	b	c21cce4 <OSTimeTick+0x168>
                    } else {
                        ptcb->OSTCBPendTO  = FALSE;
 c21ccd8:	e51b3010 	ldr	r3, [fp, #-16]
 c21ccdc:	e3a02000 	mov	r2, #0
 c21cce0:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 c21cce4:	e51b3010 	ldr	r3, [fp, #-16]
 c21cce8:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21ccec:	e2033008 	and	r3, r3, #8
 c21ccf0:	e3530000 	cmp	r3, #0
 c21ccf4:	1a000013 	bne	c21cd48 <OSTimeTick+0x1cc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 c21ccf8:	e51b3010 	ldr	r3, [fp, #-16]
 c21ccfc:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c21cd00:	e59f3088 	ldr	r3, [pc, #136]	; c21cd90 <OSTimeTick+0x214>
 c21cd04:	e5d33000 	ldrb	r3, [r3]
 c21cd08:	e1823003 	orr	r3, r2, r3
 c21cd0c:	e20320ff 	and	r2, r3, #255	; 0xff
 c21cd10:	e59f3078 	ldr	r3, [pc, #120]	; c21cd90 <OSTimeTick+0x214>
 c21cd14:	e5c32000 	strb	r2, [r3]
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c21cd18:	e51b3010 	ldr	r3, [fp, #-16]
 c21cd1c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21cd20:	e51b2010 	ldr	r2, [fp, #-16]
 c21cd24:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c21cd28:	e59f1064 	ldr	r1, [pc, #100]	; c21cd94 <OSTimeTick+0x218>
 c21cd2c:	e7d11002 	ldrb	r1, [r1, r2]
 c21cd30:	e51b2010 	ldr	r2, [fp, #-16]
 c21cd34:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c21cd38:	e1812002 	orr	r2, r1, r2
 c21cd3c:	e20210ff 	and	r1, r2, #255	; 0xff
 c21cd40:	e59f204c 	ldr	r2, [pc, #76]	; c21cd94 <OSTimeTick+0x218>
 c21cd44:	e7c21003 	strb	r1, [r2, r3]
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 c21cd48:	e51b3010 	ldr	r3, [fp, #-16]
 c21cd4c:	e5933014 	ldr	r3, [r3, #20]
 c21cd50:	e50b3010 	str	r3, [fp, #-16]
            OS_EXIT_CRITICAL();
 c21cd54:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21cd58:	e121f000 	msr	CPSR_c, r0
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
 c21cd5c:	e51b3010 	ldr	r3, [fp, #-16]
 c21cd60:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c21cd64:	e353003f 	cmp	r3, #63	; 0x3f
 c21cd68:	1affffb8 	bne	c21cc50 <OSTimeTick+0xd4>
 c21cd6c:	ea000000 	b	c21cd74 <OSTimeTick+0x1f8>
                 step            = TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
 c21cd70:	e1a00000 	nop			; (mov r0, r0)
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 c21cd74:	e24bd00c 	sub	sp, fp, #12
 c21cd78:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cd7c:	e12fff1e 	bx	lr
 c21cd80:	0c1c84c8 	.word	0x0c1c84c8
 c21cd84:	0c1c7a3d 	.word	0x0c1c7a3d
 c21cd88:	0c1c7c30 	.word	0x0c1c7c30
 c21cd8c:	0c1c7b28 	.word	0x0c1c7b28
 c21cd90:	0c1c84b0 	.word	0x0c1c84b0
 c21cd94:	0c1c84b4 	.word	0x0c1c84b4

0c21cd98 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 c21cd98:	e1a0c00d 	mov	ip, sp
 c21cd9c:	e92dd800 	push	{fp, ip, lr, pc}
 c21cda0:	e24cb004 	sub	fp, ip, #4
    return (OS_VERSION);
 c21cda4:	e3a03f45 	mov	r3, #276	; 0x114
}
 c21cda8:	e1a00003 	mov	r0, r3
 c21cdac:	e24bd00c 	sub	sp, fp, #12
 c21cdb0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cdb4:	e12fff1e 	bx	lr

0c21cdb8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 c21cdb8:	e1a0c00d 	mov	ip, sp
 c21cdbc:	e92dd800 	push	{fp, ip, lr, pc}
 c21cdc0:	e24cb004 	sub	fp, ip, #4
}
 c21cdc4:	e24bd00c 	sub	sp, fp, #12
 c21cdc8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cdcc:	e12fff1e 	bx	lr

0c21cdd0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
 c21cdd0:	e1a0c00d 	mov	ip, sp
 c21cdd4:	e92dd800 	push	{fp, ip, lr, pc}
 c21cdd8:	e24cb004 	sub	fp, ip, #4
 c21cddc:	e24dd020 	sub	sp, sp, #32
 c21cde0:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c21cde4:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
 c21cde8:	e1a03002 	mov	r3, r2
 c21cdec:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    INT8U   bitx;
    INT8U   bity;
    INT8U   prio;


    y                      = OSUnMapTbl[pevent->OSEventGrp];   /* Find HPT waiting for message         */
 c21cdf0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21cdf4:	e5d33001 	ldrb	r3, [r3, #1]
 c21cdf8:	e59f21c8 	ldr	r2, [pc, #456]	; c21cfc8 <OS_EventTaskRdy+0x1f8>
 c21cdfc:	e7d23003 	ldrb	r3, [r2, r3]
 c21ce00:	e54b300d 	strb	r3, [fp, #-13]
    bity                   = OSMapTbl[y];
 c21ce04:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ce08:	e59f21bc 	ldr	r2, [pc, #444]	; c21cfcc <OS_EventTaskRdy+0x1fc>
 c21ce0c:	e7d23003 	ldrb	r3, [r2, r3]
 c21ce10:	e54b300e 	strb	r3, [fp, #-14]
    x                      = OSUnMapTbl[pevent->OSEventTbl[y]];
 c21ce14:	e55b200d 	ldrb	r2, [fp, #-13]
 c21ce18:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c21ce1c:	e3a03008 	mov	r3, #8
 c21ce20:	e0812002 	add	r2, r1, r2
 c21ce24:	e0823003 	add	r3, r2, r3
 c21ce28:	e5d33000 	ldrb	r3, [r3]
 c21ce2c:	e59f2194 	ldr	r2, [pc, #404]	; c21cfc8 <OS_EventTaskRdy+0x1f8>
 c21ce30:	e7d23003 	ldrb	r3, [r2, r3]
 c21ce34:	e54b300f 	strb	r3, [fp, #-15]
    bitx                   = OSMapTbl[x];
 c21ce38:	e55b300f 	ldrb	r3, [fp, #-15]
 c21ce3c:	e59f2188 	ldr	r2, [pc, #392]	; c21cfcc <OS_EventTaskRdy+0x1fc>
 c21ce40:	e7d23003 	ldrb	r3, [r2, r3]
 c21ce44:	e54b3010 	strb	r3, [fp, #-16]
    prio                   = (INT8U)((y << 3) + x);     /* Find priority of task getting the msg       */
 c21ce48:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ce4c:	e1a03183 	lsl	r3, r3, #3
 c21ce50:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ce54:	e55b300f 	ldrb	r3, [fp, #-15]
 c21ce58:	e0823003 	add	r3, r2, r3
 c21ce5c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
 c21ce60:	e55b100d 	ldrb	r1, [fp, #-13]
 c21ce64:	e55b200d 	ldrb	r2, [fp, #-13]
 c21ce68:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c21ce6c:	e3a03008 	mov	r3, #8
 c21ce70:	e0802002 	add	r2, r0, r2
 c21ce74:	e0823003 	add	r3, r2, r3
 c21ce78:	e5d33000 	ldrb	r3, [r3]
 c21ce7c:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ce80:	e55b3010 	ldrb	r3, [fp, #-16]
 c21ce84:	e1e03003 	mvn	r3, r3
 c21ce88:	e20330ff 	and	r3, r3, #255	; 0xff
 c21ce8c:	e0023003 	and	r3, r2, r3
 c21ce90:	e20330ff 	and	r3, r3, #255	; 0xff
 c21ce94:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ce98:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c21ce9c:	e3a03008 	mov	r3, #8
 c21cea0:	e0801001 	add	r1, r0, r1
 c21cea4:	e0813003 	add	r3, r1, r3
 c21cea8:	e5c32000 	strb	r2, [r3]
    if (pevent->OSEventTbl[y] == 0x00) {                
 c21ceac:	e55b200d 	ldrb	r2, [fp, #-13]
 c21ceb0:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c21ceb4:	e3a03008 	mov	r3, #8
 c21ceb8:	e0812002 	add	r2, r1, r2
 c21cebc:	e0823003 	add	r3, r2, r3
 c21cec0:	e5d33000 	ldrb	r3, [r3]
 c21cec4:	e3530000 	cmp	r3, #0
 c21cec8:	1a00000a 	bne	c21cef8 <OS_EventTaskRdy+0x128>
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
 c21cecc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21ced0:	e5d33001 	ldrb	r3, [r3, #1]
 c21ced4:	e20320ff 	and	r2, r3, #255	; 0xff
 c21ced8:	e55b300e 	ldrb	r3, [fp, #-14]
 c21cedc:	e1e03003 	mvn	r3, r3
 c21cee0:	e20330ff 	and	r3, r3, #255	; 0xff
 c21cee4:	e0023003 	and	r3, r2, r3
 c21cee8:	e20330ff 	and	r3, r3, #255	; 0xff
 c21ceec:	e20320ff 	and	r2, r3, #255	; 0xff
 c21cef0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21cef4:	e5c32001 	strb	r2, [r3, #1]
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
 c21cef8:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c21cefc:	e59f30cc 	ldr	r3, [pc, #204]	; c21cfd0 <OS_EventTaskRdy+0x200>
 c21cf00:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c21cf04:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
 c21cf08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf0c:	e3a02000 	mov	r2, #0
 c21cf10:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
 c21cf14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf18:	e3a02000 	mov	r2, #0
 c21cf1c:	e583201c 	str	r2, [r3, #28]
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
 c21cf20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf24:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
 c21cf28:	e5832020 	str	r2, [r3, #32]
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = FALSE;                       /* Cancel 'any' timeout because of post        */
 c21cf2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf30:	e3a02000 	mov	r2, #0
 c21cf34:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
 c21cf38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf3c:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21cf40:	e20320ff 	and	r2, r3, #255	; 0xff
 c21cf44:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
 c21cf48:	e1e03003 	mvn	r3, r3
 c21cf4c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21cf50:	e0023003 	and	r3, r2, r3
 c21cf54:	e20330ff 	and	r3, r3, #255	; 0xff
 c21cf58:	e20320ff 	and	r2, r3, #255	; 0xff
 c21cf5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf60:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
 c21cf64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21cf68:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21cf6c:	e3530000 	cmp	r3, #0
 c21cf70:	1a00000f 	bne	c21cfb4 <OS_EventTaskRdy+0x1e4>
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
 c21cf74:	e59f3058 	ldr	r3, [pc, #88]	; c21cfd4 <OS_EventTaskRdy+0x204>
 c21cf78:	e5d32000 	ldrb	r2, [r3]
 c21cf7c:	e55b300e 	ldrb	r3, [fp, #-14]
 c21cf80:	e1823003 	orr	r3, r2, r3
 c21cf84:	e20320ff 	and	r2, r3, #255	; 0xff
 c21cf88:	e59f3044 	ldr	r3, [pc, #68]	; c21cfd4 <OS_EventTaskRdy+0x204>
 c21cf8c:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[y]     |=  bitx;
 c21cf90:	e55b300d 	ldrb	r3, [fp, #-13]
 c21cf94:	e55b200d 	ldrb	r2, [fp, #-13]
 c21cf98:	e59f1038 	ldr	r1, [pc, #56]	; c21cfd8 <OS_EventTaskRdy+0x208>
 c21cf9c:	e7d11002 	ldrb	r1, [r1, r2]
 c21cfa0:	e55b2010 	ldrb	r2, [fp, #-16]
 c21cfa4:	e1812002 	orr	r2, r1, r2
 c21cfa8:	e20210ff 	and	r1, r2, #255	; 0xff
 c21cfac:	e59f2024 	ldr	r2, [pc, #36]	; c21cfd8 <OS_EventTaskRdy+0x208>
 c21cfb0:	e7c21003 	strb	r1, [r2, r3]
    }
    return (prio);
 c21cfb4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
}
 c21cfb8:	e1a00003 	mov	r0, r3
 c21cfbc:	e24bd00c 	sub	sp, fp, #12
 c21cfc0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21cfc4:	e12fff1e 	bx	lr
 c21cfc8:	0c100f90 	.word	0x0c100f90
 c21cfcc:	0c100f88 	.word	0x0c100f88
 c21cfd0:	0c1c97a4 	.word	0x0c1c97a4
 c21cfd4:	0c1c84b0 	.word	0x0c1c84b0
 c21cfd8:	0c1c84b4 	.word	0x0c1c84b4

0c21cfdc <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 c21cfdc:	e1a0c00d 	mov	ip, sp
 c21cfe0:	e92dd800 	push	{fp, ip, lr, pc}
 c21cfe4:	e24cb004 	sub	fp, ip, #4
 c21cfe8:	e24dd010 	sub	sp, sp, #16
 c21cfec:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
 c21cff0:	e59f3130 	ldr	r3, [pc, #304]	; c21d128 <OS_EventTaskWait+0x14c>
 c21cff4:	e5933000 	ldr	r3, [r3]
 c21cff8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21cffc:	e583201c 	str	r2, [r3, #28]
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
 c21d000:	e59f3120 	ldr	r3, [pc, #288]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d004:	e5933000 	ldr	r3, [r3]
 c21d008:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21d00c:	e54b300d 	strb	r3, [fp, #-13]
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
 c21d010:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d014:	e55b200d 	ldrb	r2, [fp, #-13]
 c21d018:	e59f110c 	ldr	r1, [pc, #268]	; c21d12c <OS_EventTaskWait+0x150>
 c21d01c:	e7d12002 	ldrb	r2, [r1, r2]
 c21d020:	e20210ff 	and	r1, r2, #255	; 0xff
 c21d024:	e59f20fc 	ldr	r2, [pc, #252]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d028:	e5922000 	ldr	r2, [r2]
 c21d02c:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c21d030:	e20220ff 	and	r2, r2, #255	; 0xff
 c21d034:	e1e02002 	mvn	r2, r2
 c21d038:	e20220ff 	and	r2, r2, #255	; 0xff
 c21d03c:	e0012002 	and	r2, r1, r2
 c21d040:	e20220ff 	and	r2, r2, #255	; 0xff
 c21d044:	e20210ff 	and	r1, r2, #255	; 0xff
 c21d048:	e59f20dc 	ldr	r2, [pc, #220]	; c21d12c <OS_EventTaskWait+0x150>
 c21d04c:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0x00) {                   
 c21d050:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d054:	e59f20d0 	ldr	r2, [pc, #208]	; c21d12c <OS_EventTaskWait+0x150>
 c21d058:	e7d23003 	ldrb	r3, [r2, r3]
 c21d05c:	e3530000 	cmp	r3, #0
 c21d060:	1a00000d 	bne	c21d09c <OS_EventTaskWait+0xc0>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 c21d064:	e59f30bc 	ldr	r3, [pc, #188]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d068:	e5933000 	ldr	r3, [r3]
 c21d06c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c21d070:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d074:	e1e03003 	mvn	r3, r3
 c21d078:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d07c:	e59f30ac 	ldr	r3, [pc, #172]	; c21d130 <OS_EventTaskWait+0x154>
 c21d080:	e5d33000 	ldrb	r3, [r3]
 c21d084:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d088:	e0023003 	and	r3, r2, r3
 c21d08c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d090:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d094:	e59f3094 	ldr	r3, [pc, #148]	; c21d130 <OS_EventTaskWait+0x154>
 c21d098:	e5c32000 	strb	r2, [r3]
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
 c21d09c:	e59f3084 	ldr	r3, [pc, #132]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d0a0:	e5933000 	ldr	r3, [r3]
 c21d0a4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21d0a8:	e1a01003 	mov	r1, r3
 c21d0ac:	e59f3074 	ldr	r3, [pc, #116]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d0b0:	e5933000 	ldr	r3, [r3]
 c21d0b4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21d0b8:	e1a02003 	mov	r2, r3
 c21d0bc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21d0c0:	e3a03008 	mov	r3, #8
 c21d0c4:	e0802002 	add	r2, r0, r2
 c21d0c8:	e0823003 	add	r3, r2, r3
 c21d0cc:	e5d32000 	ldrb	r2, [r3]
 c21d0d0:	e59f3050 	ldr	r3, [pc, #80]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d0d4:	e5933000 	ldr	r3, [r3]
 c21d0d8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c21d0dc:	e1823003 	orr	r3, r2, r3
 c21d0e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d0e4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21d0e8:	e3a03008 	mov	r3, #8
 c21d0ec:	e0801001 	add	r1, r0, r1
 c21d0f0:	e0813003 	add	r3, r1, r3
 c21d0f4:	e5c32000 	strb	r2, [r3]
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 c21d0f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d0fc:	e5d32001 	ldrb	r2, [r3, #1]
 c21d100:	e59f3020 	ldr	r3, [pc, #32]	; c21d128 <OS_EventTaskWait+0x14c>
 c21d104:	e5933000 	ldr	r3, [r3]
 c21d108:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c21d10c:	e1823003 	orr	r3, r2, r3
 c21d110:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d114:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d118:	e5c32001 	strb	r2, [r3, #1]
}
 c21d11c:	e24bd00c 	sub	sp, fp, #12
 c21d120:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d124:	e12fff1e 	bx	lr
 c21d128:	0c1c84c4 	.word	0x0c1c84c4
 c21d12c:	0c1c84b4 	.word	0x0c1c84b4
 c21d130:	0c1c84b0 	.word	0x0c1c84b0

0c21d134 <OS_EventTO>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTO (OS_EVENT *pevent)
{
 c21d134:	e1a0c00d 	mov	ip, sp
 c21d138:	e92dd800 	push	{fp, ip, lr, pc}
 c21d13c:	e24cb004 	sub	fp, ip, #4
 c21d140:	e24dd010 	sub	sp, sp, #16
 c21d144:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
 c21d148:	e59f30f4 	ldr	r3, [pc, #244]	; c21d244 <OS_EventTO+0x110>
 c21d14c:	e5933000 	ldr	r3, [r3]
 c21d150:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21d154:	e54b300d 	strb	r3, [fp, #-13]
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
 c21d158:	e55b100d 	ldrb	r1, [fp, #-13]
 c21d15c:	e55b200d 	ldrb	r2, [fp, #-13]
 c21d160:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21d164:	e3a03008 	mov	r3, #8
 c21d168:	e0802002 	add	r2, r0, r2
 c21d16c:	e0823003 	add	r3, r2, r3
 c21d170:	e5d33000 	ldrb	r3, [r3]
 c21d174:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d178:	e59f30c4 	ldr	r3, [pc, #196]	; c21d244 <OS_EventTO+0x110>
 c21d17c:	e5933000 	ldr	r3, [r3]
 c21d180:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c21d184:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d188:	e1e03003 	mvn	r3, r3
 c21d18c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d190:	e0023003 	and	r3, r2, r3
 c21d194:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d198:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d19c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21d1a0:	e3a03008 	mov	r3, #8
 c21d1a4:	e0801001 	add	r1, r0, r1
 c21d1a8:	e0813003 	add	r3, r1, r3
 c21d1ac:	e5c32000 	strb	r2, [r3]
    if (pevent->OSEventTbl[y] == 0x00) {
 c21d1b0:	e55b200d 	ldrb	r2, [fp, #-13]
 c21d1b4:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c21d1b8:	e3a03008 	mov	r3, #8
 c21d1bc:	e0812002 	add	r2, r1, r2
 c21d1c0:	e0823003 	add	r3, r2, r3
 c21d1c4:	e5d33000 	ldrb	r3, [r3]
 c21d1c8:	e3530000 	cmp	r3, #0
 c21d1cc:	1a00000d 	bne	c21d208 <OS_EventTO+0xd4>
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
 c21d1d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d1d4:	e5d33001 	ldrb	r3, [r3, #1]
 c21d1d8:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d1dc:	e59f3060 	ldr	r3, [pc, #96]	; c21d244 <OS_EventTO+0x110>
 c21d1e0:	e5933000 	ldr	r3, [r3]
 c21d1e4:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c21d1e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d1ec:	e1e03003 	mvn	r3, r3
 c21d1f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d1f4:	e0023003 	and	r3, r2, r3
 c21d1f8:	e20330ff 	and	r3, r3, #255	; 0xff
 c21d1fc:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d200:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d204:	e5c32001 	strb	r2, [r3, #1]
    }
    OSTCBCur->OSTCBPendTO   = FALSE;                   /* Clear the Pend Timeout flag                  */
 c21d208:	e59f3034 	ldr	r3, [pc, #52]	; c21d244 <OS_EventTO+0x110>
 c21d20c:	e5933000 	ldr	r3, [r3]
 c21d210:	e3a02000 	mov	r2, #0
 c21d214:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
 c21d218:	e59f3024 	ldr	r3, [pc, #36]	; c21d244 <OS_EventTO+0x110>
 c21d21c:	e5933000 	ldr	r3, [r3]
 c21d220:	e3a02000 	mov	r2, #0
 c21d224:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
 c21d228:	e59f3014 	ldr	r3, [pc, #20]	; c21d244 <OS_EventTO+0x110>
 c21d22c:	e5933000 	ldr	r3, [r3]
 c21d230:	e3a02000 	mov	r2, #0
 c21d234:	e583201c 	str	r2, [r3, #28]
}
 c21d238:	e24bd00c 	sub	sp, fp, #12
 c21d23c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d240:	e12fff1e 	bx	lr
 c21d244:	0c1c84c4 	.word	0x0c1c84c4

0c21d248 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 c21d248:	e1a0c00d 	mov	ip, sp
 c21d24c:	e92dd800 	push	{fp, ip, lr, pc}
 c21d250:	e24cb004 	sub	fp, ip, #4
 c21d254:	e24dd010 	sub	sp, sp, #16
 c21d258:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U  *ptbl;


    pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
 c21d25c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d260:	e3a02000 	mov	r2, #0
 c21d264:	e5c32001 	strb	r2, [r3, #1]
    ptbl               = &pevent->OSEventTbl[0];
 c21d268:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d26c:	e2833008 	add	r3, r3, #8
 c21d270:	e50b3010 	str	r3, [fp, #-16]

#if OS_EVENT_TBL_SIZE > 0
    *ptbl++            = 0x00;
 c21d274:	e51b3010 	ldr	r3, [fp, #-16]
 c21d278:	e3a02000 	mov	r2, #0
 c21d27c:	e5c32000 	strb	r2, [r3]
 c21d280:	e51b3010 	ldr	r3, [fp, #-16]
 c21d284:	e2833001 	add	r3, r3, #1
 c21d288:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 1
    *ptbl++            = 0x00;
 c21d28c:	e51b3010 	ldr	r3, [fp, #-16]
 c21d290:	e3a02000 	mov	r2, #0
 c21d294:	e5c32000 	strb	r2, [r3]
 c21d298:	e51b3010 	ldr	r3, [fp, #-16]
 c21d29c:	e2833001 	add	r3, r3, #1
 c21d2a0:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 2
    *ptbl++            = 0x00;
 c21d2a4:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2a8:	e3a02000 	mov	r2, #0
 c21d2ac:	e5c32000 	strb	r2, [r3]
 c21d2b0:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2b4:	e2833001 	add	r3, r3, #1
 c21d2b8:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 3
    *ptbl++            = 0x00;
 c21d2bc:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2c0:	e3a02000 	mov	r2, #0
 c21d2c4:	e5c32000 	strb	r2, [r3]
 c21d2c8:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2cc:	e2833001 	add	r3, r3, #1
 c21d2d0:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 4
    *ptbl++            = 0x00;
 c21d2d4:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2d8:	e3a02000 	mov	r2, #0
 c21d2dc:	e5c32000 	strb	r2, [r3]
 c21d2e0:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2e4:	e2833001 	add	r3, r3, #1
 c21d2e8:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 5
    *ptbl++            = 0x00;
 c21d2ec:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2f0:	e3a02000 	mov	r2, #0
 c21d2f4:	e5c32000 	strb	r2, [r3]
 c21d2f8:	e51b3010 	ldr	r3, [fp, #-16]
 c21d2fc:	e2833001 	add	r3, r3, #1
 c21d300:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 6
    *ptbl++            = 0x00;
 c21d304:	e51b3010 	ldr	r3, [fp, #-16]
 c21d308:	e3a02000 	mov	r2, #0
 c21d30c:	e5c32000 	strb	r2, [r3]
 c21d310:	e51b3010 	ldr	r3, [fp, #-16]
 c21d314:	e2833001 	add	r3, r3, #1
 c21d318:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 7
    *ptbl              = 0x00;
 c21d31c:	e51b3010 	ldr	r3, [fp, #-16]
 c21d320:	e3a02000 	mov	r2, #0
 c21d324:	e5c32000 	strb	r2, [r3]
#endif
}
 c21d328:	e24bd00c 	sub	sp, fp, #12
 c21d32c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d330:	e12fff1e 	bx	lr

0c21d334 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 c21d334:	e1a0c00d 	mov	ip, sp
 c21d338:	e92dd800 	push	{fp, ip, lr, pc}
 c21d33c:	e24cb004 	sub	fp, ip, #4
 c21d340:	e24dd010 	sub	sp, sp, #16
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 c21d344:	e59f30cc 	ldr	r3, [pc, #204]	; c21d418 <OS_InitEventList+0xe4>
 c21d348:	e1a00003 	mov	r0, r3
 c21d34c:	e3a01e1e 	mov	r1, #480	; 0x1e0
 c21d350:	eb000101 	bl	c21d75c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 c21d354:	e59f30bc 	ldr	r3, [pc, #188]	; c21d418 <OS_InitEventList+0xe4>
 c21d358:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    pevent2 = &OSEventTbl[1];
 c21d35c:	e59f30b8 	ldr	r3, [pc, #184]	; c21d41c <OS_InitEventList+0xe8>
 c21d360:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 c21d364:	e3a03000 	mov	r3, #0
 c21d368:	e14b30be 	strh	r3, [fp, #-14]
 c21d36c:	ea000014 	b	c21d3c4 <OS_InitEventList+0x90>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c21d370:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d374:	e3a02000 	mov	r2, #0
 c21d378:	e5c32000 	strb	r2, [r3]
        pevent1->OSEventPtr     = pevent2;
 c21d37c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d380:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21d384:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 c21d388:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d38c:	e3a0203f 	mov	r2, #63	; 0x3f
 c21d390:	e5c32010 	strb	r2, [r3, #16]
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 c21d394:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d398:	e3a02000 	mov	r2, #0
 c21d39c:	e5c32011 	strb	r2, [r3, #17]
#endif
        pevent1++;
 c21d3a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d3a4:	e2833030 	add	r3, r3, #48	; 0x30
 c21d3a8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        pevent2++;
 c21d3ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d3b0:	e2833030 	add	r3, r3, #48	; 0x30
 c21d3b4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 c21d3b8:	e15b30be 	ldrh	r3, [fp, #-14]
 c21d3bc:	e2833001 	add	r3, r3, #1
 c21d3c0:	e14b30be 	strh	r3, [fp, #-14]
 c21d3c4:	e15b30be 	ldrh	r3, [fp, #-14]
 c21d3c8:	e3530008 	cmp	r3, #8
 c21d3cc:	9affffe7 	bls	c21d370 <OS_InitEventList+0x3c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 c21d3d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d3d4:	e3a02000 	mov	r2, #0
 c21d3d8:	e5c32000 	strb	r2, [r3]
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 c21d3dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d3e0:	e3a02000 	mov	r2, #0
 c21d3e4:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';                  
 c21d3e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d3ec:	e3a0203f 	mov	r2, #63	; 0x3f
 c21d3f0:	e5c32010 	strb	r2, [r3, #16]
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 c21d3f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d3f8:	e3a02000 	mov	r2, #0
 c21d3fc:	e5c32011 	strb	r2, [r3, #17]
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 c21d400:	e59f3018 	ldr	r3, [pc, #24]	; c21d420 <OS_InitEventList+0xec>
 c21d404:	e59f200c 	ldr	r2, [pc, #12]	; c21d418 <OS_InitEventList+0xe4>
 c21d408:	e5832000 	str	r2, [r3]
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 c21d40c:	e24bd00c 	sub	sp, fp, #12
 c21d410:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d414:	e12fff1e 	bx	lr
 c21d418:	0c1c8ccc 	.word	0x0c1c8ccc
 c21d41c:	0c1c8cfc 	.word	0x0c1c8cfc
 c21d420:	0c1c84bc 	.word	0x0c1c84bc

0c21d424 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 c21d424:	e1a0c00d 	mov	ip, sp
 c21d428:	e92dd800 	push	{fp, ip, lr, pc}
 c21d42c:	e24cb004 	sub	fp, ip, #4
#if OS_TIME_GET_SET_EN > 0   
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 c21d430:	e59f307c 	ldr	r3, [pc, #124]	; c21d4b4 <OS_InitMisc+0x90>
 c21d434:	e3a02000 	mov	r2, #0
 c21d438:	e5832000 	str	r2, [r3]
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 c21d43c:	e59f3074 	ldr	r3, [pc, #116]	; c21d4b8 <OS_InitMisc+0x94>
 c21d440:	e3a02000 	mov	r2, #0
 c21d444:	e5c32000 	strb	r2, [r3]
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 c21d448:	e59f306c 	ldr	r3, [pc, #108]	; c21d4bc <OS_InitMisc+0x98>
 c21d44c:	e3a02000 	mov	r2, #0
 c21d450:	e5c32000 	strb	r2, [r3]

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 c21d454:	e59f3064 	ldr	r3, [pc, #100]	; c21d4c0 <OS_InitMisc+0x9c>
 c21d458:	e3a02000 	mov	r2, #0
 c21d45c:	e5c32000 	strb	r2, [r3]

    OSRunning     = FALSE;                                 /* Indicate that multitasking not started   */
 c21d460:	e59f305c 	ldr	r3, [pc, #92]	; c21d4c4 <OS_InitMisc+0xa0>
 c21d464:	e3a02000 	mov	r2, #0
 c21d468:	e5c32000 	strb	r2, [r3]
    
    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 c21d46c:	e59f3054 	ldr	r3, [pc, #84]	; c21d4c8 <OS_InitMisc+0xa4>
 c21d470:	e3a02000 	mov	r2, #0
 c21d474:	e5832000 	str	r2, [r3]
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 c21d478:	e59f304c 	ldr	r3, [pc, #76]	; c21d4cc <OS_InitMisc+0xa8>
 c21d47c:	e3a02000 	mov	r2, #0
 c21d480:	e5832000 	str	r2, [r3]

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 c21d484:	e59f3044 	ldr	r3, [pc, #68]	; c21d4d0 <OS_InitMisc+0xac>
 c21d488:	e3a02000 	mov	r2, #0
 c21d48c:	e5832000 	str	r2, [r3]
    OSIdleCtrMax  = 0L;
 c21d490:	e59f303c 	ldr	r3, [pc, #60]	; c21d4d4 <OS_InitMisc+0xb0>
 c21d494:	e3a02000 	mov	r2, #0
 c21d498:	e5832000 	str	r2, [r3]
    OSStatRdy     = FALSE;                                 /* Statistic task is not ready              */
 c21d49c:	e59f3034 	ldr	r3, [pc, #52]	; c21d4d8 <OS_InitMisc+0xb4>
 c21d4a0:	e3a02000 	mov	r2, #0
 c21d4a4:	e5c32000 	strb	r2, [r3]
#endif
}
 c21d4a8:	e24bd00c 	sub	sp, fp, #12
 c21d4ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d4b0:	e12fff1e 	bx	lr
 c21d4b4:	0c1c84c8 	.word	0x0c1c84c8
 c21d4b8:	0c1c84c0 	.word	0x0c1c84c0
 c21d4bc:	0c1c7a3c 	.word	0x0c1c7a3c
 c21d4c0:	0c1c8441 	.word	0x0c1c8441
 c21d4c4:	0c1c7a3d 	.word	0x0c1c7a3d
 c21d4c8:	0c1c8434 	.word	0x0c1c8434
 c21d4cc:	0c1c7a40 	.word	0x0c1c7a40
 c21d4d0:	0c1c98a4 	.word	0x0c1c98a4
 c21d4d4:	0c1c8438 	.word	0x0c1c8438
 c21d4d8:	0c1c97a0 	.word	0x0c1c97a0

0c21d4dc <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 c21d4dc:	e1a0c00d 	mov	ip, sp
 c21d4e0:	e92dd800 	push	{fp, ip, lr, pc}
 c21d4e4:	e24cb004 	sub	fp, ip, #4
 c21d4e8:	e24dd008 	sub	sp, sp, #8
    INT8U    i;
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
 c21d4ec:	e59f3084 	ldr	r3, [pc, #132]	; c21d578 <OS_InitRdyList+0x9c>
 c21d4f0:	e3a02000 	mov	r2, #0
 c21d4f4:	e5c32000 	strb	r2, [r3]
    prdytbl       = &OSRdyTbl[0];
 c21d4f8:	e59f307c 	ldr	r3, [pc, #124]	; c21d57c <OS_InitRdyList+0xa0>
 c21d4fc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 c21d500:	e3a03000 	mov	r3, #0
 c21d504:	e54b300d 	strb	r3, [fp, #-13]
 c21d508:	ea000008 	b	c21d530 <OS_InitRdyList+0x54>
        *prdytbl++ = 0x00;
 c21d50c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d510:	e3a02000 	mov	r2, #0
 c21d514:	e5c32000 	strb	r2, [r3]
 c21d518:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d51c:	e2833001 	add	r3, r3, #1
 c21d520:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 c21d524:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d528:	e2833001 	add	r3, r3, #1
 c21d52c:	e54b300d 	strb	r3, [fp, #-13]
 c21d530:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d534:	e3530007 	cmp	r3, #7
 c21d538:	9afffff3 	bls	c21d50c <OS_InitRdyList+0x30>
        *prdytbl++ = 0x00;
    }

    OSPrioCur     = 0;
 c21d53c:	e59f303c 	ldr	r3, [pc, #60]	; c21d580 <OS_InitRdyList+0xa4>
 c21d540:	e3a02000 	mov	r2, #0
 c21d544:	e5c32000 	strb	r2, [r3]
    OSPrioHighRdy = 0;
 c21d548:	e59f3034 	ldr	r3, [pc, #52]	; c21d584 <OS_InitRdyList+0xa8>
 c21d54c:	e3a02000 	mov	r2, #0
 c21d550:	e5c32000 	strb	r2, [r3]

    OSTCBHighRdy  = (OS_TCB *)0;                                 
 c21d554:	e59f302c 	ldr	r3, [pc, #44]	; c21d588 <OS_InitRdyList+0xac>
 c21d558:	e3a02000 	mov	r2, #0
 c21d55c:	e5832000 	str	r2, [r3]
    OSTCBCur      = (OS_TCB *)0;
 c21d560:	e59f3024 	ldr	r3, [pc, #36]	; c21d58c <OS_InitRdyList+0xb0>
 c21d564:	e3a02000 	mov	r2, #0
 c21d568:	e5832000 	str	r2, [r3]
}
 c21d56c:	e24bd00c 	sub	sp, fp, #12
 c21d570:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d574:	e12fff1e 	bx	lr
 c21d578:	0c1c84b0 	.word	0x0c1c84b0
 c21d57c:	0c1c84b4 	.word	0x0c1c84b4
 c21d580:	0c1c7b24 	.word	0x0c1c7b24
 c21d584:	0c1c7a44 	.word	0x0c1c7a44
 c21d588:	0c1c84a8 	.word	0x0c1c84a8
 c21d58c:	0c1c84c4 	.word	0x0c1c84c4

0c21d590 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 c21d590:	e1a0c00d 	mov	ip, sp
 c21d594:	e92dd800 	push	{fp, ip, lr, pc}
 c21d598:	e24cb004 	sub	fp, ip, #4
 c21d59c:	e24dd018 	sub	sp, sp, #24
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 c21d5a0:	e59f3040 	ldr	r3, [pc, #64]	; c21d5e8 <OS_InitTaskIdle+0x58>
 c21d5a4:	e58d3000 	str	r3, [sp]
 c21d5a8:	e59f303c 	ldr	r3, [pc, #60]	; c21d5ec <OS_InitTaskIdle+0x5c>
 c21d5ac:	e58d3004 	str	r3, [sp, #4]
 c21d5b0:	e3a03c02 	mov	r3, #512	; 0x200
 c21d5b4:	e58d3008 	str	r3, [sp, #8]
 c21d5b8:	e3a03000 	mov	r3, #0
 c21d5bc:	e58d300c 	str	r3, [sp, #12]
 c21d5c0:	e3a03003 	mov	r3, #3
 c21d5c4:	e58d3010 	str	r3, [sp, #16]
 c21d5c8:	e59f0020 	ldr	r0, [pc, #32]	; c21d5f0 <OS_InitTaskIdle+0x60>
 c21d5cc:	e3a01000 	mov	r1, #0
 c21d5d0:	e59f201c 	ldr	r2, [pc, #28]	; c21d5f4 <OS_InitTaskIdle+0x64>
 c21d5d4:	e3a0303f 	mov	r3, #63	; 0x3f
 c21d5d8:	eb001805 	bl	c2235f4 <OSTaskCreateExt>
                       (void *)0,
                       &OSTaskIdleStk[0],
                       OS_IDLE_PRIO);
    #endif
#endif
}
 c21d5dc:	e24bd00c 	sub	sp, fp, #12
 c21d5e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d5e4:	e12fff1e 	bx	lr
 c21d5e8:	0000ffff 	.word	0x0000ffff
 c21d5ec:	0c1c84cc 	.word	0x0c1c84cc
 c21d5f0:	0c21da2c 	.word	0x0c21da2c
 c21d5f4:	0c1c8cc8 	.word	0x0c1c8cc8

0c21d5f8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 c21d5f8:	e1a0c00d 	mov	ip, sp
 c21d5fc:	e92dd800 	push	{fp, ip, lr, pc}
 c21d600:	e24cb004 	sub	fp, ip, #4
 c21d604:	e24dd018 	sub	sp, sp, #24
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 c21d608:	e59f3040 	ldr	r3, [pc, #64]	; c21d650 <OS_InitTaskStat+0x58>
 c21d60c:	e58d3000 	str	r3, [sp]
 c21d610:	e59f303c 	ldr	r3, [pc, #60]	; c21d654 <OS_InitTaskStat+0x5c>
 c21d614:	e58d3004 	str	r3, [sp, #4]
 c21d618:	e3a03c02 	mov	r3, #512	; 0x200
 c21d61c:	e58d3008 	str	r3, [sp, #8]
 c21d620:	e3a03000 	mov	r3, #0
 c21d624:	e58d300c 	str	r3, [sp, #12]
 c21d628:	e3a03003 	mov	r3, #3
 c21d62c:	e58d3010 	str	r3, [sp, #16]
 c21d630:	e59f0020 	ldr	r0, [pc, #32]	; c21d658 <OS_InitTaskStat+0x60>
 c21d634:	e3a01000 	mov	r1, #0
 c21d638:	e59f201c 	ldr	r2, [pc, #28]	; c21d65c <OS_InitTaskStat+0x64>
 c21d63c:	e3a0303e 	mov	r3, #62	; 0x3e
 c21d640:	eb0017eb 	bl	c2235f4 <OSTaskCreateExt>
                       (void *)0,                                      /* No args passed to OS_TaskStat()*/
                       &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                       OS_STAT_PRIO);                                  /* One higher than the idle task  */
    #endif
#endif
}
 c21d644:	e24bd00c 	sub	sp, fp, #12
 c21d648:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d64c:	e12fff1e 	bx	lr
 c21d650:	0000fffe 	.word	0x0000fffe
 c21d654:	0c1c7c34 	.word	0x0c1c7c34
 c21d658:	0c21da78 	.word	0x0c21da78
 c21d65c:	0c1c8430 	.word	0x0c1c8430

0c21d660 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 c21d660:	e1a0c00d 	mov	ip, sp
 c21d664:	e92dd800 	push	{fp, ip, lr, pc}
 c21d668:	e24cb004 	sub	fp, ip, #4
 c21d66c:	e24dd010 	sub	sp, sp, #16
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 c21d670:	e59f30d0 	ldr	r3, [pc, #208]	; c21d748 <OS_InitTCBList+0xe8>
 c21d674:	e1a00003 	mov	r0, r3
 c21d678:	e3a01e8f 	mov	r1, #2288	; 0x8f0
 c21d67c:	eb000036 	bl	c21d75c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 c21d680:	e59f30c4 	ldr	r3, [pc, #196]	; c21d74c <OS_InitTCBList+0xec>
 c21d684:	e1a00003 	mov	r0, r3
 c21d688:	e3a01c01 	mov	r1, #256	; 0x100
 c21d68c:	eb000032 	bl	c21d75c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 c21d690:	e59f30b0 	ldr	r3, [pc, #176]	; c21d748 <OS_InitTCBList+0xe8>
 c21d694:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    ptcb2 = &OSTCBTbl[1];
 c21d698:	e59f30b0 	ldr	r3, [pc, #176]	; c21d750 <OS_InitTCBList+0xf0>
 c21d69c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 c21d6a0:	e3a03000 	mov	r3, #0
 c21d6a4:	e54b300d 	strb	r3, [fp, #-13]
 c21d6a8:	ea000011 	b	c21d6f4 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 c21d6ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d6b0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21d6b4:	e5832014 	str	r2, [r3, #20]
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 c21d6b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d6bc:	e3a0203f 	mov	r2, #63	; 0x3f
 c21d6c0:	e5c32048 	strb	r2, [r3, #72]	; 0x48
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 c21d6c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d6c8:	e3a02000 	mov	r2, #0
 c21d6cc:	e5c32049 	strb	r2, [r3, #73]	; 0x49
#endif
        ptcb1++;
 c21d6d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d6d4:	e2833068 	add	r3, r3, #104	; 0x68
 c21d6d8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        ptcb2++;
 c21d6dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d6e0:	e2833068 	add	r3, r3, #104	; 0x68
 c21d6e4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 c21d6e8:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d6ec:	e2833001 	add	r3, r3, #1
 c21d6f0:	e54b300d 	strb	r3, [fp, #-13]
 c21d6f4:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d6f8:	e3530014 	cmp	r3, #20
 c21d6fc:	9affffea 	bls	c21d6ac <OS_InitTCBList+0x4c>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 c21d700:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d704:	e3a02000 	mov	r2, #0
 c21d708:	e5832014 	str	r2, [r3, #20]
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 c21d70c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d710:	e3a0203f 	mov	r2, #63	; 0x3f
 c21d714:	e5c32048 	strb	r2, [r3, #72]	; 0x48
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 c21d718:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d71c:	e3a02000 	mov	r2, #0
 c21d720:	e5c32049 	strb	r2, [r3, #73]	; 0x49
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 c21d724:	e59f3028 	ldr	r3, [pc, #40]	; c21d754 <OS_InitTCBList+0xf4>
 c21d728:	e3a02000 	mov	r2, #0
 c21d72c:	e5832000 	str	r2, [r3]
    OSTCBFreeList           = &OSTCBTbl[0];
 c21d730:	e59f3020 	ldr	r3, [pc, #32]	; c21d758 <OS_InitTCBList+0xf8>
 c21d734:	e59f200c 	ldr	r2, [pc, #12]	; c21d748 <OS_InitTCBList+0xe8>
 c21d738:	e5832000 	str	r2, [r3]
}
 c21d73c:	e24bd00c 	sub	sp, fp, #12
 c21d740:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d744:	e12fff1e 	bx	lr
 c21d748:	0c1c8eac 	.word	0x0c1c8eac
 c21d74c:	0c1c97a4 	.word	0x0c1c97a4
 c21d750:	0c1c8f14 	.word	0x0c1c8f14
 c21d754:	0c1c7b28 	.word	0x0c1c7b28
 c21d758:	0c1c843c 	.word	0x0c1c843c

0c21d75c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 c21d75c:	e1a0c00d 	mov	ip, sp
 c21d760:	e92dd800 	push	{fp, ip, lr, pc}
 c21d764:	e24cb004 	sub	fp, ip, #4
 c21d768:	e24dd008 	sub	sp, sp, #8
 c21d76c:	e50b0010 	str	r0, [fp, #-16]
 c21d770:	e1a03001 	mov	r3, r1
 c21d774:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    while (size > 0) {
 c21d778:	ea000008 	b	c21d7a0 <OS_MemClr+0x44>
        *pdest++ = (INT8U)0;
 c21d77c:	e51b3010 	ldr	r3, [fp, #-16]
 c21d780:	e3a02000 	mov	r2, #0
 c21d784:	e5c32000 	strb	r2, [r3]
 c21d788:	e51b3010 	ldr	r3, [fp, #-16]
 c21d78c:	e2833001 	add	r3, r3, #1
 c21d790:	e50b3010 	str	r3, [fp, #-16]
        size--;
 c21d794:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21d798:	e2433001 	sub	r3, r3, #1
 c21d79c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 c21d7a0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c21d7a4:	e3530000 	cmp	r3, #0
 c21d7a8:	1afffff3 	bne	c21d77c <OS_MemClr+0x20>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 c21d7ac:	e24bd00c 	sub	sp, fp, #12
 c21d7b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d7b4:	e12fff1e 	bx	lr

0c21d7b8 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 c21d7b8:	e1a0c00d 	mov	ip, sp
 c21d7bc:	e92dd800 	push	{fp, ip, lr, pc}
 c21d7c0:	e24cb004 	sub	fp, ip, #4
 c21d7c4:	e24dd010 	sub	sp, sp, #16
 c21d7c8:	e50b0010 	str	r0, [fp, #-16]
 c21d7cc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c21d7d0:	e1a03002 	mov	r3, r2
 c21d7d4:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    while (size > 0) {
 c21d7d8:	ea00000c 	b	c21d810 <OS_MemCopy+0x58>
        *pdest++ = *psrc++;
 c21d7dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d7e0:	e5d32000 	ldrb	r2, [r3]
 c21d7e4:	e51b3010 	ldr	r3, [fp, #-16]
 c21d7e8:	e5c32000 	strb	r2, [r3]
 c21d7ec:	e51b3010 	ldr	r3, [fp, #-16]
 c21d7f0:	e2833001 	add	r3, r3, #1
 c21d7f4:	e50b3010 	str	r3, [fp, #-16]
 c21d7f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21d7fc:	e2833001 	add	r3, r3, #1
 c21d800:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        size--;
 c21d804:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21d808:	e2433001 	sub	r3, r3, #1
 c21d80c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 c21d810:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c21d814:	e3530000 	cmp	r3, #0
 c21d818:	1affffef 	bne	c21d7dc <OS_MemCopy+0x24>
        *pdest++ = *psrc++;
        size--;
    }
}
 c21d81c:	e24bd00c 	sub	sp, fp, #12
 c21d820:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d824:	e12fff1e 	bx	lr

0c21d828 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 c21d828:	e1a0c00d 	mov	ip, sp
 c21d82c:	e92dd800 	push	{fp, ip, lr, pc}
 c21d830:	e24cb004 	sub	fp, ip, #4
 c21d834:	e24dd008 	sub	sp, sp, #8



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
#endif    
    OS_ENTER_CRITICAL();
 c21d838:	e10f0000 	mrs	r0, CPSR
 c21d83c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21d840:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21d844:	e121f000 	msr	CPSR_c, r0
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 c21d848:	e59f30d0 	ldr	r3, [pc, #208]	; c21d920 <OS_Sched+0xf8>
 c21d84c:	e5d33000 	ldrb	r3, [r3]
 c21d850:	e3530000 	cmp	r3, #0
 c21d854:	1a00002c 	bne	c21d90c <OS_Sched+0xe4>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 c21d858:	e59f30c4 	ldr	r3, [pc, #196]	; c21d924 <OS_Sched+0xfc>
 c21d85c:	e5d33000 	ldrb	r3, [r3]
 c21d860:	e3530000 	cmp	r3, #0
 c21d864:	1a000028 	bne	c21d90c <OS_Sched+0xe4>
            y             = OSUnMapTbl[OSRdyGrp];      /* Get pointer to HPT ready to run              */
 c21d868:	e59f30b8 	ldr	r3, [pc, #184]	; c21d928 <OS_Sched+0x100>
 c21d86c:	e5d33000 	ldrb	r3, [r3]
 c21d870:	e59f20b4 	ldr	r2, [pc, #180]	; c21d92c <OS_Sched+0x104>
 c21d874:	e7d23003 	ldrb	r3, [r2, r3]
 c21d878:	e54b300d 	strb	r3, [fp, #-13]
            OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 c21d87c:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d880:	e1a03183 	lsl	r3, r3, #3
 c21d884:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d888:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d88c:	e59f109c 	ldr	r1, [pc, #156]	; c21d930 <OS_Sched+0x108>
 c21d890:	e7d13003 	ldrb	r3, [r1, r3]
 c21d894:	e59f1090 	ldr	r1, [pc, #144]	; c21d92c <OS_Sched+0x104>
 c21d898:	e7d13003 	ldrb	r3, [r1, r3]
 c21d89c:	e0823003 	add	r3, r2, r3
 c21d8a0:	e20320ff 	and	r2, r3, #255	; 0xff
 c21d8a4:	e59f3088 	ldr	r3, [pc, #136]	; c21d934 <OS_Sched+0x10c>
 c21d8a8:	e5c32000 	strb	r2, [r3]
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 c21d8ac:	e59f3080 	ldr	r3, [pc, #128]	; c21d934 <OS_Sched+0x10c>
 c21d8b0:	e5d32000 	ldrb	r2, [r3]
 c21d8b4:	e59f307c 	ldr	r3, [pc, #124]	; c21d938 <OS_Sched+0x110>
 c21d8b8:	e5d33000 	ldrb	r3, [r3]
 c21d8bc:	e1520003 	cmp	r2, r3
 c21d8c0:	0a000011 	beq	c21d90c <OS_Sched+0xe4>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 c21d8c4:	e59f3068 	ldr	r3, [pc, #104]	; c21d934 <OS_Sched+0x10c>
 c21d8c8:	e5d33000 	ldrb	r3, [r3]
 c21d8cc:	e1a02003 	mov	r2, r3
 c21d8d0:	e59f3064 	ldr	r3, [pc, #100]	; c21d93c <OS_Sched+0x114>
 c21d8d4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
 c21d8d8:	e59f3060 	ldr	r3, [pc, #96]	; c21d940 <OS_Sched+0x118>
 c21d8dc:	e5832000 	str	r2, [r3]
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 c21d8e0:	e59f3058 	ldr	r3, [pc, #88]	; c21d940 <OS_Sched+0x118>
 c21d8e4:	e5933000 	ldr	r3, [r3]
 c21d8e8:	e5932034 	ldr	r2, [r3, #52]	; 0x34
 c21d8ec:	e2822001 	add	r2, r2, #1
 c21d8f0:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 c21d8f4:	e59f3048 	ldr	r3, [pc, #72]	; c21d944 <OS_Sched+0x11c>
 c21d8f8:	e5933000 	ldr	r3, [r3]
 c21d8fc:	e2832001 	add	r2, r3, #1
 c21d900:	e59f303c 	ldr	r3, [pc, #60]	; c21d944 <OS_Sched+0x11c>
 c21d904:	e5832000 	str	r2, [r3]
                OS_TASK_SW();                          /* Perform a context switch                     */
 c21d908:	ebfffa17 	bl	c21c16c <OSCtxSw>
            }
        }
    }
    OS_EXIT_CRITICAL();
 c21d90c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21d910:	e121f000 	msr	CPSR_c, r0
}
 c21d914:	e24bd00c 	sub	sp, fp, #12
 c21d918:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d91c:	e12fff1e 	bx	lr
 c21d920:	0c1c84c0 	.word	0x0c1c84c0
 c21d924:	0c1c7a3c 	.word	0x0c1c7a3c
 c21d928:	0c1c84b0 	.word	0x0c1c84b0
 c21d92c:	0c100f90 	.word	0x0c100f90
 c21d930:	0c1c84b4 	.word	0x0c1c84b4
 c21d934:	0c1c7a44 	.word	0x0c1c7a44
 c21d938:	0c1c7b24 	.word	0x0c1c7b24
 c21d93c:	0c1c97a4 	.word	0x0c1c97a4
 c21d940:	0c1c84a8 	.word	0x0c1c84a8
 c21d944:	0c1c8434 	.word	0x0c1c8434

0c21d948 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1)
INT8U  OS_StrCopy (char *pdest, char *psrc)
{
 c21d948:	e1a0c00d 	mov	ip, sp
 c21d94c:	e92dd800 	push	{fp, ip, lr, pc}
 c21d950:	e24cb004 	sub	fp, ip, #4
 c21d954:	e24dd010 	sub	sp, sp, #16
 c21d958:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21d95c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    INT8U  len;


    len = 0;
 c21d960:	e3a03000 	mov	r3, #0
 c21d964:	e54b300d 	strb	r3, [fp, #-13]
    while (*psrc != OS_ASCII_NUL) {
 c21d968:	ea00000c 	b	c21d9a0 <OS_StrCopy+0x58>
        *pdest++ = *psrc++;
 c21d96c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21d970:	e5d32000 	ldrb	r2, [r3]
 c21d974:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d978:	e5c32000 	strb	r2, [r3]
 c21d97c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d980:	e2833001 	add	r3, r3, #1
 c21d984:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c21d988:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21d98c:	e2833001 	add	r3, r3, #1
 c21d990:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        len++;
 c21d994:	e55b300d 	ldrb	r3, [fp, #-13]
 c21d998:	e2833001 	add	r3, r3, #1
 c21d99c:	e54b300d 	strb	r3, [fp, #-13]
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 c21d9a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21d9a4:	e5d33000 	ldrb	r3, [r3]
 c21d9a8:	e3530000 	cmp	r3, #0
 c21d9ac:	1affffee 	bne	c21d96c <OS_StrCopy+0x24>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 c21d9b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d9b4:	e3a02000 	mov	r2, #0
 c21d9b8:	e5c32000 	strb	r2, [r3]
    return (len);
 c21d9bc:	e55b300d 	ldrb	r3, [fp, #-13]
}
 c21d9c0:	e1a00003 	mov	r0, r3
 c21d9c4:	e24bd00c 	sub	sp, fp, #12
 c21d9c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21d9cc:	e12fff1e 	bx	lr

0c21d9d0 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1)
INT8U  OS_StrLen (char *psrc)
{
 c21d9d0:	e1a0c00d 	mov	ip, sp
 c21d9d4:	e92dd800 	push	{fp, ip, lr, pc}
 c21d9d8:	e24cb004 	sub	fp, ip, #4
 c21d9dc:	e24dd010 	sub	sp, sp, #16
 c21d9e0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U  len;


    len = 0;
 c21d9e4:	e3a03000 	mov	r3, #0
 c21d9e8:	e54b300d 	strb	r3, [fp, #-13]
    while (*psrc != OS_ASCII_NUL) {
 c21d9ec:	ea000005 	b	c21da08 <OS_StrLen+0x38>
        psrc++;
 c21d9f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21d9f4:	e2833001 	add	r3, r3, #1
 c21d9f8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        len++;
 c21d9fc:	e55b300d 	ldrb	r3, [fp, #-13]
 c21da00:	e2833001 	add	r3, r3, #1
 c21da04:	e54b300d 	strb	r3, [fp, #-13]
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 c21da08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21da0c:	e5d33000 	ldrb	r3, [r3]
 c21da10:	e3530000 	cmp	r3, #0
 c21da14:	1afffff5 	bne	c21d9f0 <OS_StrLen+0x20>
        psrc++;
        len++;
    }
    return (len);
 c21da18:	e55b300d 	ldrb	r3, [fp, #-13]
}
 c21da1c:	e1a00003 	mov	r0, r3
 c21da20:	e24bd00c 	sub	sp, fp, #12
 c21da24:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21da28:	e12fff1e 	bx	lr

0c21da2c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *parg)
{
 c21da2c:	e1a0c00d 	mov	ip, sp
 c21da30:	e92dd800 	push	{fp, ip, lr, pc}
 c21da34:	e24cb004 	sub	fp, ip, #4
 c21da38:	e24dd008 	sub	sp, sp, #8
 c21da3c:	e50b0010 	str	r0, [fp, #-16]

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
 c21da40:	e10f0000 	mrs	r0, CPSR
 c21da44:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21da48:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21da4c:	e121f000 	msr	CPSR_c, r0
        OSIdleCtr++;
 c21da50:	e59f301c 	ldr	r3, [pc, #28]	; c21da74 <OS_TaskIdle+0x48>
 c21da54:	e5933000 	ldr	r3, [r3]
 c21da58:	e2832001 	add	r2, r3, #1
 c21da5c:	e59f3010 	ldr	r3, [pc, #16]	; c21da74 <OS_TaskIdle+0x48>
 c21da60:	e5832000 	str	r2, [r3]
        OS_EXIT_CRITICAL();
 c21da64:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21da68:	e121f000 	msr	CPSR_c, r0
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 c21da6c:	ebfffa14 	bl	c21c2c4 <OSTaskIdleHook>
    }
 c21da70:	eafffff2 	b	c21da40 <OS_TaskIdle+0x14>
 c21da74:	0c1c7a40 	.word	0x0c1c7a40

0c21da78 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *parg)
{
 c21da78:	e1a0c00d 	mov	ip, sp
 c21da7c:	e92dd800 	push	{fp, ip, lr, pc}
 c21da80:	e24cb004 	sub	fp, ip, #4
 c21da84:	e24dd018 	sub	sp, sp, #24
 c21da88:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0


    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    while (OSStatRdy == FALSE) {
 c21da8c:	ea000001 	b	c21da98 <OS_TaskStat+0x20>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 c21da90:	e3a00014 	mov	r0, #20
 c21da94:	eb001aa9 	bl	c224540 <OSTimeDly>


    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    while (OSStatRdy == FALSE) {
 c21da98:	e59f30f0 	ldr	r3, [pc, #240]	; c21db90 <OS_TaskStat+0x118>
 c21da9c:	e5d33000 	ldrb	r3, [r3]
 c21daa0:	e3530000 	cmp	r3, #0
 c21daa4:	0afffff9 	beq	c21da90 <OS_TaskStat+0x18>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    max = OSIdleCtrMax / 100L;
 c21daa8:	e59f30e4 	ldr	r3, [pc, #228]	; c21db94 <OS_TaskStat+0x11c>
 c21daac:	e5932000 	ldr	r2, [r3]
 c21dab0:	e59f30e0 	ldr	r3, [pc, #224]	; c21db98 <OS_TaskStat+0x120>
 c21dab4:	e0831392 	umull	r1, r3, r2, r3
 c21dab8:	e1a032a3 	lsr	r3, r3, #5
 c21dabc:	e50b3010 	str	r3, [fp, #-16]
    for (;;) {
        OS_ENTER_CRITICAL();
 c21dac0:	e10f0000 	mrs	r0, CPSR
 c21dac4:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21dac8:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21dacc:	e121f000 	msr	CPSR_c, r0
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 c21dad0:	e59f30c4 	ldr	r3, [pc, #196]	; c21db9c <OS_TaskStat+0x124>
 c21dad4:	e5932000 	ldr	r2, [r3]
 c21dad8:	e59f30c0 	ldr	r3, [pc, #192]	; c21dba0 <OS_TaskStat+0x128>
 c21dadc:	e5832000 	str	r2, [r3]
        run          = OSIdleCtr;
 c21dae0:	e59f30b4 	ldr	r3, [pc, #180]	; c21db9c <OS_TaskStat+0x124>
 c21dae4:	e5933000 	ldr	r3, [r3]
 c21dae8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 c21daec:	e59f30a8 	ldr	r3, [pc, #168]	; c21db9c <OS_TaskStat+0x124>
 c21daf0:	e3a02000 	mov	r2, #0
 c21daf4:	e5832000 	str	r2, [r3]
        OS_EXIT_CRITICAL();
 c21daf8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21dafc:	e121f000 	msr	CPSR_c, r0
        if (max > 0L) {
 c21db00:	e51b3010 	ldr	r3, [fp, #-16]
 c21db04:	e3530000 	cmp	r3, #0
 c21db08:	0a000012 	beq	c21db58 <OS_TaskStat+0xe0>
            usage = (INT8S)(100L - run / max);
 c21db0c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
 c21db10:	e51b1010 	ldr	r1, [fp, #-16]
 c21db14:	eb0034f0 	bl	c22aedc <__aeabi_uidiv>
 c21db18:	e1a03000 	mov	r3, r0
 c21db1c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21db20:	e2633064 	rsb	r3, r3, #100	; 0x64
 c21db24:	e20330ff 	and	r3, r3, #255	; 0xff
 c21db28:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
            if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
 c21db2c:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
 c21db30:	e3530000 	cmp	r3, #0
 c21db34:	ba000003 	blt	c21db48 <OS_TaskStat+0xd0>
                OSCPUUsage = usage;
 c21db38:	e59f3064 	ldr	r3, [pc, #100]	; c21dba4 <OS_TaskStat+0x12c>
 c21db3c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c21db40:	e5c32000 	strb	r2, [r3]
 c21db44:	ea00000c 	b	c21db7c <OS_TaskStat+0x104>
            } else {
                OSCPUUsage = 0;
 c21db48:	e59f3054 	ldr	r3, [pc, #84]	; c21dba4 <OS_TaskStat+0x12c>
 c21db4c:	e3a02000 	mov	r2, #0
 c21db50:	e5c32000 	strb	r2, [r3]
 c21db54:	ea000008 	b	c21db7c <OS_TaskStat+0x104>
            }
        } else {
            OSCPUUsage = 0;
 c21db58:	e59f3044 	ldr	r3, [pc, #68]	; c21dba4 <OS_TaskStat+0x12c>
 c21db5c:	e3a02000 	mov	r2, #0
 c21db60:	e5c32000 	strb	r2, [r3]
            max        = OSIdleCtrMax / 100L;
 c21db64:	e59f3028 	ldr	r3, [pc, #40]	; c21db94 <OS_TaskStat+0x11c>
 c21db68:	e5932000 	ldr	r2, [r3]
 c21db6c:	e59f3024 	ldr	r3, [pc, #36]	; c21db98 <OS_TaskStat+0x120>
 c21db70:	e0831392 	umull	r1, r3, r2, r3
 c21db74:	e1a032a3 	lsr	r3, r3, #5
 c21db78:	e50b3010 	str	r3, [fp, #-16]
        }
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 c21db7c:	ebfff9d7 	bl	c21c2e0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 c21db80:	eb000008 	bl	c21dba8 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 c21db84:	e3a0000a 	mov	r0, #10
 c21db88:	eb001a6c 	bl	c224540 <OSTimeDly>
    }
 c21db8c:	eaffffcb 	b	c21dac0 <OS_TaskStat+0x48>
 c21db90:	0c1c97a0 	.word	0x0c1c97a0
 c21db94:	0c1c8438 	.word	0x0c1c8438
 c21db98:	51eb851f 	.word	0x51eb851f
 c21db9c:	0c1c7a40 	.word	0x0c1c7a40
 c21dba0:	0c1c98a4 	.word	0x0c1c98a4
 c21dba4:	0c1c8440 	.word	0x0c1c8440

0c21dba8 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 c21dba8:	e1a0c00d 	mov	ip, sp
 c21dbac:	e92dd800 	push	{fp, ip, lr, pc}
 c21dbb0:	e24cb004 	sub	fp, ip, #4
 c21dbb4:	e24dd010 	sub	sp, sp, #16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_IDLE_PRIO; prio++) {
 c21dbb8:	e3a03000 	mov	r3, #0
 c21dbbc:	e54b300d 	strb	r3, [fp, #-13]
 c21dbc0:	ea000021 	b	c21dc4c <OS_TaskStatStkChk+0xa4>
        err = OSTaskStkChk(prio, &stk_data);
 c21dbc4:	e55b200d 	ldrb	r2, [fp, #-13]
 c21dbc8:	e24b301c 	sub	r3, fp, #28
 c21dbcc:	e1a00002 	mov	r0, r2
 c21dbd0:	e1a01003 	mov	r1, r3
 c21dbd4:	eb001921 	bl	c224060 <OSTaskStkChk>
 c21dbd8:	e1a03000 	mov	r3, r0
 c21dbdc:	e54b300e 	strb	r3, [fp, #-14]
        if (err == OS_NO_ERR) {
 c21dbe0:	e55b300e 	ldrb	r3, [fp, #-14]
 c21dbe4:	e3530000 	cmp	r3, #0
 c21dbe8:	1a000014 	bne	c21dc40 <OS_TaskStatStkChk+0x98>
            ptcb = OSTCBPrioTbl[prio];
 c21dbec:	e55b200d 	ldrb	r2, [fp, #-13]
 c21dbf0:	e59f306c 	ldr	r3, [pc, #108]	; c21dc64 <OS_TaskStatStkChk+0xbc>
 c21dbf4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c21dbf8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 c21dbfc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc00:	e3530000 	cmp	r3, #0
 c21dc04:	0a00000d 	beq	c21dc40 <OS_TaskStatStkChk+0x98>
                if (ptcb != (OS_TCB *)1) {                           /* ... still valid.               */
 c21dc08:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc0c:	e3530001 	cmp	r3, #1
 c21dc10:	0a00000a 	beq	c21dc40 <OS_TaskStatStkChk+0x98>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 c21dc14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc18:	e5932008 	ldr	r2, [r3, #8]
 c21dc1c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc20:	e593300c 	ldr	r3, [r3, #12]
 c21dc24:	e1a03103 	lsl	r3, r3, #2
 c21dc28:	e0822003 	add	r2, r2, r3
 c21dc2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc30:	e5832040 	str	r2, [r3, #64]	; 0x40
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = (INT32U)stk_data.OSUsed;    /* Store the number of bytes used */
 c21dc34:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21dc38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21dc3c:	e5832044 	str	r2, [r3, #68]	; 0x44
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_IDLE_PRIO; prio++) {
 c21dc40:	e55b300d 	ldrb	r3, [fp, #-13]
 c21dc44:	e2833001 	add	r3, r3, #1
 c21dc48:	e54b300d 	strb	r3, [fp, #-13]
 c21dc4c:	e55b300d 	ldrb	r3, [fp, #-13]
 c21dc50:	e353003f 	cmp	r3, #63	; 0x3f
 c21dc54:	9affffda 	bls	c21dbc4 <OS_TaskStatStkChk+0x1c>
#endif
                }
            }
        }
    }
}
 c21dc58:	e24bd00c 	sub	sp, fp, #12
 c21dc5c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21dc60:	e12fff1e 	bx	lr
 c21dc64:	0c1c97a4 	.word	0x0c1c97a4

0c21dc68 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 c21dc68:	e1a0c00d 	mov	ip, sp
 c21dc6c:	e92dd800 	push	{fp, ip, lr, pc}
 c21dc70:	e24cb004 	sub	fp, ip, #4
 c21dc74:	e24dd018 	sub	sp, sp, #24
 c21dc78:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21dc7c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c21dc80:	e1a02000 	mov	r2, r0
 c21dc84:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c21dc88:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    OS_ENTER_CRITICAL();
 c21dc8c:	e10f0000 	mrs	r0, CPSR
 c21dc90:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21dc94:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21dc98:	e121f000 	msr	CPSR_c, r0
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 c21dc9c:	e59f3288 	ldr	r3, [pc, #648]	; c21df2c <OS_TCBInit+0x2c4>
 c21dca0:	e5933000 	ldr	r3, [r3]
 c21dca4:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb != (OS_TCB *)0) {
 c21dca8:	e51b3010 	ldr	r3, [fp, #-16]
 c21dcac:	e3530000 	cmp	r3, #0
 c21dcb0:	0a000096 	beq	c21df10 <OS_TCBInit+0x2a8>
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
 c21dcb4:	e51b3010 	ldr	r3, [fp, #-16]
 c21dcb8:	e5932014 	ldr	r2, [r3, #20]
 c21dcbc:	e59f3268 	ldr	r3, [pc, #616]	; c21df2c <OS_TCBInit+0x2c4>
 c21dcc0:	e5832000 	str	r2, [r3]
        OS_EXIT_CRITICAL();
 c21dcc4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21dcc8:	e121f000 	msr	CPSR_c, r0
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
 c21dccc:	e51b3010 	ldr	r3, [fp, #-16]
 c21dcd0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c21dcd4:	e5832000 	str	r2, [r3]
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
 c21dcd8:	e51b3010 	ldr	r3, [fp, #-16]
 c21dcdc:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c21dce0:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
 c21dce4:	e51b3010 	ldr	r3, [fp, #-16]
 c21dce8:	e3a02000 	mov	r2, #0
 c21dcec:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        ptcb->OSTCBPendTO    = FALSE;                      /* Clear the Pend timeout flag              */
 c21dcf0:	e51b3010 	ldr	r3, [fp, #-16]
 c21dcf4:	e3a02000 	mov	r2, #0
 c21dcf8:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
 c21dcfc:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd00:	e3a02000 	mov	r2, #0
 c21dd04:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
 c21dd08:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd0c:	e59b2008 	ldr	r2, [fp, #8]
 c21dd10:	e5832004 	str	r2, [r3, #4]
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
 c21dd14:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd18:	e59b2004 	ldr	r2, [fp, #4]
 c21dd1c:	e583200c 	str	r2, [r3, #12]
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
 c21dd20:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd24:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c21dd28:	e5832008 	str	r2, [r3, #8]
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
 c21dd2c:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd30:	e1db20bc 	ldrh	r2, [fp, #12]
 c21dd34:	e1c321b0 	strh	r2, [r3, #16]
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
 c21dd38:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd3c:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
 c21dd40:	e1c321b2 	strh	r2, [r3, #18]
        opt                  = opt;
        id                   = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
 c21dd44:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd48:	e3a02000 	mov	r2, #0
 c21dd4c:	e5c32033 	strb	r2, [r3, #51]	; 0x33
#endif

        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
 c21dd50:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21dd54:	e1a031a3 	lsr	r3, r3, #3
 c21dd58:	e20320ff 	and	r2, r3, #255	; 0xff
 c21dd5c:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd60:	e5c32030 	strb	r2, [r3, #48]	; 0x30
        ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
 c21dd64:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd68:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21dd6c:	e59f21bc 	ldr	r2, [pc, #444]	; c21df30 <OS_TCBInit+0x2c8>
 c21dd70:	e7d22003 	ldrb	r2, [r2, r3]
 c21dd74:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd78:	e5c32032 	strb	r2, [r3, #50]	; 0x32
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
 c21dd7c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21dd80:	e2033007 	and	r3, r3, #7
 c21dd84:	e20320ff 	and	r2, r3, #255	; 0xff
 c21dd88:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd8c:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
        ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
 c21dd90:	e51b3010 	ldr	r3, [fp, #-16]
 c21dd94:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
 c21dd98:	e59f2190 	ldr	r2, [pc, #400]	; c21df30 <OS_TCBInit+0x2c8>
 c21dd9c:	e7d22003 	ldrb	r2, [r2, r3]
 c21dda0:	e51b3010 	ldr	r3, [fp, #-16]
 c21dda4:	e5c32031 	strb	r2, [r3, #49]	; 0x31

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
 c21dda8:	e51b3010 	ldr	r3, [fp, #-16]
 c21ddac:	e3a02000 	mov	r2, #0
 c21ddb0:	e583201c 	str	r2, [r3, #28]
#endif

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 c21ddb4:	e51b3010 	ldr	r3, [fp, #-16]
 c21ddb8:	e3a02000 	mov	r2, #0
 c21ddbc:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 c21ddc0:	e51b3010 	ldr	r3, [fp, #-16]
 c21ddc4:	e3a02000 	mov	r2, #0
 c21ddc8:	e5832020 	str	r2, [r3, #32]
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 c21ddcc:	e51b3010 	ldr	r3, [fp, #-16]
 c21ddd0:	e3a02000 	mov	r2, #0
 c21ddd4:	e5832034 	str	r2, [r3, #52]	; 0x34
        ptcb->OSTCBCyclesStart = 0L;
 c21ddd8:	e51b3010 	ldr	r3, [fp, #-16]
 c21dddc:	e3a02000 	mov	r2, #0
 c21dde0:	e583203c 	str	r2, [r3, #60]	; 0x3c
        ptcb->OSTCBCyclesTot   = 0L;
 c21dde4:	e51b3010 	ldr	r3, [fp, #-16]
 c21dde8:	e3a02000 	mov	r2, #0
 c21ddec:	e5832038 	str	r2, [r3, #56]	; 0x38
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 c21ddf0:	e51b3010 	ldr	r3, [fp, #-16]
 c21ddf4:	e3a02000 	mov	r2, #0
 c21ddf8:	e5832040 	str	r2, [r3, #64]	; 0x40
        ptcb->OSTCBStkUsed     = 0L;
 c21ddfc:	e51b3010 	ldr	r3, [fp, #-16]
 c21de00:	e3a02000 	mov	r2, #0
 c21de04:	e5832044 	str	r2, [r3, #68]	; 0x44
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 c21de08:	e51b3010 	ldr	r3, [fp, #-16]
 c21de0c:	e3a0203f 	mov	r2, #63	; 0x3f
 c21de10:	e5c32048 	strb	r2, [r3, #72]	; 0x48
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 c21de14:	e51b3010 	ldr	r3, [fp, #-16]
 c21de18:	e3a02000 	mov	r2, #0
 c21de1c:	e5c32049 	strb	r2, [r3, #73]	; 0x49
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
 c21de20:	e51b0010 	ldr	r0, [fp, #-16]
 c21de24:	ebfff9a3 	bl	c21c4b8 <OSTCBInitHook>
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 c21de28:	e51b0010 	ldr	r0, [fp, #-16]
 c21de2c:	ebfff914 	bl	c21c284 <OSTaskCreateHook>
        
        OS_ENTER_CRITICAL();
 c21de30:	e10f0000 	mrs	r0, CPSR
 c21de34:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21de38:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21de3c:	e121f000 	msr	CPSR_c, r0
        OSTCBPrioTbl[prio] = ptcb;
 c21de40:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c21de44:	e59f30e8 	ldr	r3, [pc, #232]	; c21df34 <OS_TCBInit+0x2cc>
 c21de48:	e51b1010 	ldr	r1, [fp, #-16]
 c21de4c:	e7831102 	str	r1, [r3, r2, lsl #2]
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 c21de50:	e59f30e0 	ldr	r3, [pc, #224]	; c21df38 <OS_TCBInit+0x2d0>
 c21de54:	e5932000 	ldr	r2, [r3]
 c21de58:	e51b3010 	ldr	r3, [fp, #-16]
 c21de5c:	e5832014 	str	r2, [r3, #20]
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 c21de60:	e51b3010 	ldr	r3, [fp, #-16]
 c21de64:	e3a02000 	mov	r2, #0
 c21de68:	e5832018 	str	r2, [r3, #24]
        if (OSTCBList != (OS_TCB *)0) {
 c21de6c:	e59f30c4 	ldr	r3, [pc, #196]	; c21df38 <OS_TCBInit+0x2d0>
 c21de70:	e5933000 	ldr	r3, [r3]
 c21de74:	e3530000 	cmp	r3, #0
 c21de78:	0a000003 	beq	c21de8c <OS_TCBInit+0x224>
            OSTCBList->OSTCBPrev = ptcb;
 c21de7c:	e59f30b4 	ldr	r3, [pc, #180]	; c21df38 <OS_TCBInit+0x2d0>
 c21de80:	e5933000 	ldr	r3, [r3]
 c21de84:	e51b2010 	ldr	r2, [fp, #-16]
 c21de88:	e5832018 	str	r2, [r3, #24]
        }
        OSTCBList               = ptcb;
 c21de8c:	e59f30a4 	ldr	r3, [pc, #164]	; c21df38 <OS_TCBInit+0x2d0>
 c21de90:	e51b2010 	ldr	r2, [fp, #-16]
 c21de94:	e5832000 	str	r2, [r3]
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 c21de98:	e51b3010 	ldr	r3, [fp, #-16]
 c21de9c:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c21dea0:	e59f3094 	ldr	r3, [pc, #148]	; c21df3c <OS_TCBInit+0x2d4>
 c21dea4:	e5d33000 	ldrb	r3, [r3]
 c21dea8:	e1823003 	orr	r3, r2, r3
 c21deac:	e20320ff 	and	r2, r3, #255	; 0xff
 c21deb0:	e59f3084 	ldr	r3, [pc, #132]	; c21df3c <OS_TCBInit+0x2d4>
 c21deb4:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c21deb8:	e51b3010 	ldr	r3, [fp, #-16]
 c21debc:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21dec0:	e51b2010 	ldr	r2, [fp, #-16]
 c21dec4:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c21dec8:	e59f1070 	ldr	r1, [pc, #112]	; c21df40 <OS_TCBInit+0x2d8>
 c21decc:	e7d11002 	ldrb	r1, [r1, r2]
 c21ded0:	e51b2010 	ldr	r2, [fp, #-16]
 c21ded4:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c21ded8:	e1812002 	orr	r2, r1, r2
 c21dedc:	e20210ff 	and	r1, r2, #255	; 0xff
 c21dee0:	e59f2058 	ldr	r2, [pc, #88]	; c21df40 <OS_TCBInit+0x2d8>
 c21dee4:	e7c21003 	strb	r1, [r2, r3]
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 c21dee8:	e59f3054 	ldr	r3, [pc, #84]	; c21df44 <OS_TCBInit+0x2dc>
 c21deec:	e5d33000 	ldrb	r3, [r3]
 c21def0:	e2833001 	add	r3, r3, #1
 c21def4:	e20320ff 	and	r2, r3, #255	; 0xff
 c21def8:	e59f3044 	ldr	r3, [pc, #68]	; c21df44 <OS_TCBInit+0x2dc>
 c21defc:	e5c32000 	strb	r2, [r3]
        OS_EXIT_CRITICAL();
 c21df00:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21df04:	e121f000 	msr	CPSR_c, r0
        return (OS_NO_ERR);
 c21df08:	e3a03000 	mov	r3, #0
 c21df0c:	ea000002 	b	c21df1c <OS_TCBInit+0x2b4>
    }
    OS_EXIT_CRITICAL();
 c21df10:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21df14:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_MORE_TCB);
 c21df18:	e3a03046 	mov	r3, #70	; 0x46
}
 c21df1c:	e1a00003 	mov	r0, r3
 c21df20:	e24bd00c 	sub	sp, fp, #12
 c21df24:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21df28:	e12fff1e 	bx	lr
 c21df2c:	0c1c843c 	.word	0x0c1c843c
 c21df30:	0c100f88 	.word	0x0c100f88
 c21df34:	0c1c97a4 	.word	0x0c1c97a4
 c21df38:	0c1c7b28 	.word	0x0c1c7b28
 c21df3c:	0c1c84b0 	.word	0x0c1c84b0
 c21df40:	0c1c84b4 	.word	0x0c1c84b4
 c21df44:	0c1c8441 	.word	0x0c1c8441

0c21df48 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 c21df48:	e1a0c00d 	mov	ip, sp
 c21df4c:	e92dd800 	push	{fp, ip, lr, pc}
 c21df50:	e24cb004 	sub	fp, ip, #4
 c21df54:	e24dd008 	sub	sp, sp, #8
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 c21df58:	e59f316c 	ldr	r3, [pc, #364]	; c21e0cc <OSDebugInit+0x184>
 c21df5c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSEndiannessTest;
 c21df60:	e59f3168 	ldr	r3, [pc, #360]	; c21e0d0 <OSDebugInit+0x188>
 c21df64:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSEventMax;
 c21df68:	e59f3164 	ldr	r3, [pc, #356]	; c21e0d4 <OSDebugInit+0x18c>
 c21df6c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSEventNameSize;
 c21df70:	e59f3160 	ldr	r3, [pc, #352]	; c21e0d8 <OSDebugInit+0x190>
 c21df74:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSEventEn;
 c21df78:	e59f315c 	ldr	r3, [pc, #348]	; c21e0dc <OSDebugInit+0x194>
 c21df7c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSEventSize;
 c21df80:	e59f3158 	ldr	r3, [pc, #344]	; c21e0e0 <OSDebugInit+0x198>
 c21df84:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSEventTblSize;
 c21df88:	e59f3154 	ldr	r3, [pc, #340]	; c21e0e4 <OSDebugInit+0x19c>
 c21df8c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSFlagEn;
 c21df90:	e59f3150 	ldr	r3, [pc, #336]	; c21e0e8 <OSDebugInit+0x1a0>
 c21df94:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSFlagGrpSize;
 c21df98:	e59f314c 	ldr	r3, [pc, #332]	; c21e0ec <OSDebugInit+0x1a4>
 c21df9c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSFlagNodeSize;
 c21dfa0:	e59f3148 	ldr	r3, [pc, #328]	; c21e0f0 <OSDebugInit+0x1a8>
 c21dfa4:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSFlagWidth;
 c21dfa8:	e59f3144 	ldr	r3, [pc, #324]	; c21e0f4 <OSDebugInit+0x1ac>
 c21dfac:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSFlagMax;
 c21dfb0:	e59f3140 	ldr	r3, [pc, #320]	; c21e0f8 <OSDebugInit+0x1b0>
 c21dfb4:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSFlagNameSize;
 c21dfb8:	e59f313c 	ldr	r3, [pc, #316]	; c21e0fc <OSDebugInit+0x1b4>
 c21dfbc:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSLowestPrio;
 c21dfc0:	e59f3138 	ldr	r3, [pc, #312]	; c21e100 <OSDebugInit+0x1b8>
 c21dfc4:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSMboxEn;
 c21dfc8:	e59f3134 	ldr	r3, [pc, #308]	; c21e104 <OSDebugInit+0x1bc>
 c21dfcc:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSMemEn;
 c21dfd0:	e59f3130 	ldr	r3, [pc, #304]	; c21e108 <OSDebugInit+0x1c0>
 c21dfd4:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSMemMax;
 c21dfd8:	e59f312c 	ldr	r3, [pc, #300]	; c21e10c <OSDebugInit+0x1c4>
 c21dfdc:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSMemNameSize;
 c21dfe0:	e59f3128 	ldr	r3, [pc, #296]	; c21e110 <OSDebugInit+0x1c8>
 c21dfe4:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSMemSize;
 c21dfe8:	e59f3124 	ldr	r3, [pc, #292]	; c21e114 <OSDebugInit+0x1cc>
 c21dfec:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSMemTblSize;
 c21dff0:	e59f3120 	ldr	r3, [pc, #288]	; c21e118 <OSDebugInit+0x1d0>
 c21dff4:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSMutexEn;
 c21dff8:	e59f311c 	ldr	r3, [pc, #284]	; c21e11c <OSDebugInit+0x1d4>
 c21dffc:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSPtrSize;
 c21e000:	e59f3118 	ldr	r3, [pc, #280]	; c21e120 <OSDebugInit+0x1d8>
 c21e004:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSQEn;
 c21e008:	e59f3114 	ldr	r3, [pc, #276]	; c21e124 <OSDebugInit+0x1dc>
 c21e00c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSQMax;
 c21e010:	e59f3110 	ldr	r3, [pc, #272]	; c21e128 <OSDebugInit+0x1e0>
 c21e014:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSQSize;
 c21e018:	e59f310c 	ldr	r3, [pc, #268]	; c21e12c <OSDebugInit+0x1e4>
 c21e01c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSRdyTblSize;
 c21e020:	e59f3108 	ldr	r3, [pc, #264]	; c21e130 <OSDebugInit+0x1e8>
 c21e024:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSSemEn;
 c21e028:	e59f3104 	ldr	r3, [pc, #260]	; c21e134 <OSDebugInit+0x1ec>
 c21e02c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSStkWidth;
 c21e030:	e59f3100 	ldr	r3, [pc, #256]	; c21e138 <OSDebugInit+0x1f0>
 c21e034:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSTaskCreateEn;
 c21e038:	e59f30fc 	ldr	r3, [pc, #252]	; c21e13c <OSDebugInit+0x1f4>
 c21e03c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskCreateExtEn;
 c21e040:	e59f30f8 	ldr	r3, [pc, #248]	; c21e140 <OSDebugInit+0x1f8>
 c21e044:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskDelEn;
 c21e048:	e59f30f4 	ldr	r3, [pc, #244]	; c21e144 <OSDebugInit+0x1fc>
 c21e04c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskIdleStkSize;
 c21e050:	e59f30f0 	ldr	r3, [pc, #240]	; c21e148 <OSDebugInit+0x200>
 c21e054:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskProfileEn;
 c21e058:	e59f30ec 	ldr	r3, [pc, #236]	; c21e14c <OSDebugInit+0x204>
 c21e05c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskMax;
 c21e060:	e59f30e8 	ldr	r3, [pc, #232]	; c21e150 <OSDebugInit+0x208>
 c21e064:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskNameSize;
 c21e068:	e59f30e4 	ldr	r3, [pc, #228]	; c21e154 <OSDebugInit+0x20c>
 c21e06c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskStatEn;
 c21e070:	e59f30e0 	ldr	r3, [pc, #224]	; c21e158 <OSDebugInit+0x210>
 c21e074:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskStatStkSize;
 c21e078:	e59f30dc 	ldr	r3, [pc, #220]	; c21e15c <OSDebugInit+0x214>
 c21e07c:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskStatStkChkEn;
 c21e080:	e59f30d8 	ldr	r3, [pc, #216]	; c21e160 <OSDebugInit+0x218>
 c21e084:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTaskSwHookEn;
 c21e088:	e59f30d4 	ldr	r3, [pc, #212]	; c21e164 <OSDebugInit+0x21c>
 c21e08c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSTCBPrioTblMax;
 c21e090:	e59f30d0 	ldr	r3, [pc, #208]	; c21e168 <OSDebugInit+0x220>
 c21e094:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTCBSize;
 c21e098:	e59f30cc 	ldr	r3, [pc, #204]	; c21e16c <OSDebugInit+0x224>
 c21e09c:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSTicksPerSec;
 c21e0a0:	e59f30c8 	ldr	r3, [pc, #200]	; c21e170 <OSDebugInit+0x228>
 c21e0a4:	e50b3010 	str	r3, [fp, #-16]
    ptemp = (void *)&OSTimeTickHookEn;
 c21e0a8:	e59f30c4 	ldr	r3, [pc, #196]	; c21e174 <OSDebugInit+0x22c>
 c21e0ac:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSVersionNbr;
 c21e0b0:	e59f30c0 	ldr	r3, [pc, #192]	; c21e178 <OSDebugInit+0x230>
 c21e0b4:	e50b3010 	str	r3, [fp, #-16]

    ptemp = (void *)&OSDataSize;
 c21e0b8:	e59f30bc 	ldr	r3, [pc, #188]	; c21e17c <OSDebugInit+0x234>
 c21e0bc:	e50b3010 	str	r3, [fp, #-16]

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 c21e0c0:	e24bd00c 	sub	sp, fp, #12
 c21e0c4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e0c8:	e12fff1e 	bx	lr
 c21e0cc:	0c101090 	.word	0x0c101090
 c21e0d0:	0c101094 	.word	0x0c101094
 c21e0d4:	0c10109a 	.word	0x0c10109a
 c21e0d8:	0c10109c 	.word	0x0c10109c
 c21e0dc:	0c101098 	.word	0x0c101098
 c21e0e0:	0c10109e 	.word	0x0c10109e
 c21e0e4:	0c1010a0 	.word	0x0c1010a0
 c21e0e8:	0c1010a2 	.word	0x0c1010a2
 c21e0ec:	0c1010a4 	.word	0x0c1010a4
 c21e0f0:	0c1010a6 	.word	0x0c1010a6
 c21e0f4:	0c1010a8 	.word	0x0c1010a8
 c21e0f8:	0c1010aa 	.word	0x0c1010aa
 c21e0fc:	0c1010ac 	.word	0x0c1010ac
 c21e100:	0c1010ae 	.word	0x0c1010ae
 c21e104:	0c1010b0 	.word	0x0c1010b0
 c21e108:	0c1010b2 	.word	0x0c1010b2
 c21e10c:	0c1010b4 	.word	0x0c1010b4
 c21e110:	0c1010b6 	.word	0x0c1010b6
 c21e114:	0c1010b8 	.word	0x0c1010b8
 c21e118:	0c1010ba 	.word	0x0c1010ba
 c21e11c:	0c1010bc 	.word	0x0c1010bc
 c21e120:	0c1010be 	.word	0x0c1010be
 c21e124:	0c1010c0 	.word	0x0c1010c0
 c21e128:	0c1010c2 	.word	0x0c1010c2
 c21e12c:	0c1010c4 	.word	0x0c1010c4
 c21e130:	0c1010c6 	.word	0x0c1010c6
 c21e134:	0c1010c8 	.word	0x0c1010c8
 c21e138:	0c1010ca 	.word	0x0c1010ca
 c21e13c:	0c1010cc 	.word	0x0c1010cc
 c21e140:	0c1010ce 	.word	0x0c1010ce
 c21e144:	0c1010d0 	.word	0x0c1010d0
 c21e148:	0c1010d2 	.word	0x0c1010d2
 c21e14c:	0c1010d4 	.word	0x0c1010d4
 c21e150:	0c1010d6 	.word	0x0c1010d6
 c21e154:	0c1010d8 	.word	0x0c1010d8
 c21e158:	0c1010da 	.word	0x0c1010da
 c21e15c:	0c1010dc 	.word	0x0c1010dc
 c21e160:	0c1010de 	.word	0x0c1010de
 c21e164:	0c1010e0 	.word	0x0c1010e0
 c21e168:	0c1010e2 	.word	0x0c1010e2
 c21e16c:	0c1010e4 	.word	0x0c1010e4
 c21e170:	0c1010e6 	.word	0x0c1010e6
 c21e174:	0c1010e8 	.word	0x0c1010e8
 c21e178:	0c1010ea 	.word	0x0c1010ea
 c21e17c:	0c1010ec 	.word	0x0c1010ec

0c21e180 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
 c21e180:	e1a0c00d 	mov	ip, sp
 c21e184:	e92dd800 	push	{fp, ip, lr, pc}
 c21e188:	e24cb004 	sub	fp, ip, #4
 c21e18c:	e24dd018 	sub	sp, sp, #24
 c21e190:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21e194:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 c21e198:	e14b11ba 	strh	r1, [fp, #-26]	; 0xffffffe6
 c21e19c:	e1a03002 	mov	r3, r2
 c21e1a0:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5


    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 c21e1a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e1a8:	e3530000 	cmp	r3, #0
 c21e1ac:	1a000004 	bne	c21e1c4 <OSFlagAccept+0x44>
        *err = OS_FLAG_INVALID_PGRP;
 c21e1b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e1b4:	e3e02069 	mvn	r2, #105	; 0x69
 c21e1b8:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21e1bc:	e3a03000 	mov	r3, #0
 c21e1c0:	ea0000b3 	b	c21e494 <OSFlagAccept+0x314>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 c21e1c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e1c8:	e5d33000 	ldrb	r3, [r3]
 c21e1cc:	e3530005 	cmp	r3, #5
 c21e1d0:	0a000004 	beq	c21e1e8 <OSFlagAccept+0x68>
        *err = OS_ERR_EVENT_TYPE;
 c21e1d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e1d8:	e3a02001 	mov	r2, #1
 c21e1dc:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21e1e0:	e3a03000 	mov	r3, #0
 c21e1e4:	ea0000aa 	b	c21e494 <OSFlagAccept+0x314>
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
 c21e1e8:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c21e1ec:	e1a03c03 	lsl	r3, r3, #24
 c21e1f0:	e1a03c43 	asr	r3, r3, #24
 c21e1f4:	e3530000 	cmp	r3, #0
 c21e1f8:	aa000005 	bge	c21e214 <OSFlagAccept+0x94>
        wait_type &= ~OS_FLAG_CONSUME;
 c21e1fc:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c21e200:	e203307f 	and	r3, r3, #127	; 0x7f
 c21e204:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
        consume    = TRUE;
 c21e208:	e3a03001 	mov	r3, #1
 c21e20c:	e54b300f 	strb	r3, [fp, #-15]
 c21e210:	ea000001 	b	c21e21c <OSFlagAccept+0x9c>
    } else {
        consume    = FALSE;
 c21e214:	e3a03000 	mov	r3, #0
 c21e218:	e54b300f 	strb	r3, [fp, #-15]
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
 c21e21c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e220:	e3a02000 	mov	r2, #0
 c21e224:	e5c32000 	strb	r2, [r3]
    OS_ENTER_CRITICAL();
 c21e228:	e10f0000 	mrs	r0, CPSR
 c21e22c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21e230:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21e234:	e121f000 	msr	CPSR_c, r0
    switch (wait_type) {
 c21e238:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c21e23c:	e3530003 	cmp	r3, #3
 c21e240:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c21e244:	ea000089 	b	c21e470 <OSFlagAccept+0x2f0>
 c21e248:	0c21e364 	.word	0x0c21e364
 c21e24c:	0c21e3ec 	.word	0x0c21e3ec
 c21e250:	0c21e258 	.word	0x0c21e258
 c21e254:	0c21e2e0 	.word	0x0c21e2e0
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
 c21e258:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e25c:	e1d320b8 	ldrh	r2, [r3, #8]
 c21e260:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e264:	e0023003 	and	r3, r2, r3
 c21e268:	e14b30be 	strh	r3, [fp, #-14]
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 c21e26c:	e15b20be 	ldrh	r2, [fp, #-14]
 c21e270:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e274:	e1520003 	cmp	r2, r3
 c21e278:	1a000012 	bne	c21e2c8 <OSFlagAccept+0x148>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21e27c:	e55b300f 	ldrb	r3, [fp, #-15]
 c21e280:	e3530001 	cmp	r3, #1
 c21e284:	1a000012 	bne	c21e2d4 <OSFlagAccept+0x154>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 c21e288:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e28c:	e1d330b8 	ldrh	r3, [r3, #8]
 c21e290:	e1a03803 	lsl	r3, r3, #16
 c21e294:	e1a02823 	lsr	r2, r3, #16
 c21e298:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e29c:	e1e03003 	mvn	r3, r3
 c21e2a0:	e1a03803 	lsl	r3, r3, #16
 c21e2a4:	e1a03823 	lsr	r3, r3, #16
 c21e2a8:	e0023003 	and	r3, r2, r3
 c21e2ac:	e1a03803 	lsl	r3, r3, #16
 c21e2b0:	e1a03823 	lsr	r3, r3, #16
 c21e2b4:	e1a03803 	lsl	r3, r3, #16
 c21e2b8:	e1a02823 	lsr	r2, r3, #16
 c21e2bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e2c0:	e1c320b8 	strh	r2, [r3, #8]
 c21e2c4:	ea000002 	b	c21e2d4 <OSFlagAccept+0x154>
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
 c21e2c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e2cc:	e3e02067 	mvn	r2, #103	; 0x67
 c21e2d0:	e5c32000 	strb	r2, [r3]
             }
             OS_EXIT_CRITICAL();
 c21e2d4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e2d8:	e121f000 	msr	CPSR_c, r0
             break;
 c21e2dc:	ea00006b 	b	c21e490 <OSFlagAccept+0x310>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
 c21e2e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e2e4:	e1d320b8 	ldrh	r2, [r3, #8]
 c21e2e8:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e2ec:	e0023003 	and	r3, r2, r3
 c21e2f0:	e14b30be 	strh	r3, [fp, #-14]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 c21e2f4:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e2f8:	e3530000 	cmp	r3, #0
 c21e2fc:	0a000012 	beq	c21e34c <OSFlagAccept+0x1cc>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21e300:	e55b300f 	ldrb	r3, [fp, #-15]
 c21e304:	e3530001 	cmp	r3, #1
 c21e308:	1a000012 	bne	c21e358 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 c21e30c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e310:	e1d330b8 	ldrh	r3, [r3, #8]
 c21e314:	e1a03803 	lsl	r3, r3, #16
 c21e318:	e1a02823 	lsr	r2, r3, #16
 c21e31c:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e320:	e1e03003 	mvn	r3, r3
 c21e324:	e1a03803 	lsl	r3, r3, #16
 c21e328:	e1a03823 	lsr	r3, r3, #16
 c21e32c:	e0023003 	and	r3, r2, r3
 c21e330:	e1a03803 	lsl	r3, r3, #16
 c21e334:	e1a03823 	lsr	r3, r3, #16
 c21e338:	e1a03803 	lsl	r3, r3, #16
 c21e33c:	e1a02823 	lsr	r2, r3, #16
 c21e340:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e344:	e1c320b8 	strh	r2, [r3, #8]
 c21e348:	ea000002 	b	c21e358 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
 c21e34c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e350:	e3e02067 	mvn	r2, #103	; 0x67
 c21e354:	e5c32000 	strb	r2, [r3]
             }
             OS_EXIT_CRITICAL();
 c21e358:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e35c:	e121f000 	msr	CPSR_c, r0
             break;
 c21e360:	ea00004a 	b	c21e490 <OSFlagAccept+0x310>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
 c21e364:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e368:	e1d330b8 	ldrh	r3, [r3, #8]
 c21e36c:	e1a03803 	lsl	r3, r3, #16
 c21e370:	e1a03823 	lsr	r3, r3, #16
 c21e374:	e1e03003 	mvn	r3, r3
 c21e378:	e1a03803 	lsl	r3, r3, #16
 c21e37c:	e1a02823 	lsr	r2, r3, #16
 c21e380:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e384:	e0023003 	and	r3, r2, r3
 c21e388:	e1a03803 	lsl	r3, r3, #16
 c21e38c:	e1a03823 	lsr	r3, r3, #16
 c21e390:	e14b30be 	strh	r3, [fp, #-14]
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 c21e394:	e15b20be 	ldrh	r2, [fp, #-14]
 c21e398:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e39c:	e1520003 	cmp	r2, r3
 c21e3a0:	1a00000b 	bne	c21e3d4 <OSFlagAccept+0x254>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21e3a4:	e55b300f 	ldrb	r3, [fp, #-15]
 c21e3a8:	e3530001 	cmp	r3, #1
 c21e3ac:	1a00000b 	bne	c21e3e0 <OSFlagAccept+0x260>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 c21e3b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e3b4:	e1d320b8 	ldrh	r2, [r3, #8]
 c21e3b8:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e3bc:	e1823003 	orr	r3, r2, r3
 c21e3c0:	e1a03803 	lsl	r3, r3, #16
 c21e3c4:	e1a02823 	lsr	r2, r3, #16
 c21e3c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e3cc:	e1c320b8 	strh	r2, [r3, #8]
 c21e3d0:	ea000002 	b	c21e3e0 <OSFlagAccept+0x260>
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
 c21e3d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e3d8:	e3e02067 	mvn	r2, #103	; 0x67
 c21e3dc:	e5c32000 	strb	r2, [r3]
             }
             OS_EXIT_CRITICAL();
 c21e3e0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e3e4:	e121f000 	msr	CPSR_c, r0
             break;
 c21e3e8:	ea000028 	b	c21e490 <OSFlagAccept+0x310>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
 c21e3ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e3f0:	e1d330b8 	ldrh	r3, [r3, #8]
 c21e3f4:	e1a03803 	lsl	r3, r3, #16
 c21e3f8:	e1a03823 	lsr	r3, r3, #16
 c21e3fc:	e1e03003 	mvn	r3, r3
 c21e400:	e1a03803 	lsl	r3, r3, #16
 c21e404:	e1a02823 	lsr	r2, r3, #16
 c21e408:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c21e40c:	e0023003 	and	r3, r2, r3
 c21e410:	e1a03803 	lsl	r3, r3, #16
 c21e414:	e1a03823 	lsr	r3, r3, #16
 c21e418:	e14b30be 	strh	r3, [fp, #-14]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 c21e41c:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e420:	e3530000 	cmp	r3, #0
 c21e424:	0a00000b 	beq	c21e458 <OSFlagAccept+0x2d8>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21e428:	e55b300f 	ldrb	r3, [fp, #-15]
 c21e42c:	e3530001 	cmp	r3, #1
 c21e430:	1a00000b 	bne	c21e464 <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 c21e434:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e438:	e1d320b8 	ldrh	r2, [r3, #8]
 c21e43c:	e15b30be 	ldrh	r3, [fp, #-14]
 c21e440:	e1823003 	orr	r3, r2, r3
 c21e444:	e1a03803 	lsl	r3, r3, #16
 c21e448:	e1a02823 	lsr	r2, r3, #16
 c21e44c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e450:	e1c320b8 	strh	r2, [r3, #8]
 c21e454:	ea000002 	b	c21e464 <OSFlagAccept+0x2e4>
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
 c21e458:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e45c:	e3e02067 	mvn	r2, #103	; 0x67
 c21e460:	e5c32000 	strb	r2, [r3]
             }
             OS_EXIT_CRITICAL();
 c21e464:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e468:	e121f000 	msr	CPSR_c, r0
             break;
 c21e46c:	ea000007 	b	c21e490 <OSFlagAccept+0x310>
#endif

        default:
             OS_EXIT_CRITICAL();
 c21e470:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e474:	e121f000 	msr	CPSR_c, r0
             flags_rdy = (OS_FLAGS)0;
 c21e478:	e3a03000 	mov	r3, #0
 c21e47c:	e14b30be 	strh	r3, [fp, #-14]
             *err      = OS_FLAG_ERR_WAIT_TYPE;
 c21e480:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e484:	e3e02068 	mvn	r2, #104	; 0x68
 c21e488:	e5c32000 	strb	r2, [r3]
             break;
 c21e48c:	e1a00000 	nop			; (mov r0, r0)
    }
    return (flags_rdy);
 c21e490:	e15b30be 	ldrh	r3, [fp, #-14]
}
 c21e494:	e1a00003 	mov	r0, r3
 c21e498:	e24bd00c 	sub	sp, fp, #12
 c21e49c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e4a0:	e12fff1e 	bx	lr

0c21e4a4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
 c21e4a4:	e1a0c00d 	mov	ip, sp
 c21e4a8:	e92dd800 	push	{fp, ip, lr, pc}
 c21e4ac:	e24cb004 	sub	fp, ip, #4
 c21e4b0:	e24dd010 	sub	sp, sp, #16
 c21e4b4:	e1a03000 	mov	r3, r0
 c21e4b8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21e4bc:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea



    cpu_sr = 0;                                     /* Prevent compiler warning                        */
#endif    
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 c21e4c0:	e59f30d8 	ldr	r3, [pc, #216]	; c21e5a0 <OSFlagCreate+0xfc>
 c21e4c4:	e5d33000 	ldrb	r3, [r3]
 c21e4c8:	e3530000 	cmp	r3, #0
 c21e4cc:	0a000004 	beq	c21e4e4 <OSFlagCreate+0x40>
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
 c21e4d0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21e4d4:	e3e02072 	mvn	r2, #114	; 0x72
 c21e4d8:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAG_GRP *)0);
 c21e4dc:	e3a03000 	mov	r3, #0
 c21e4e0:	ea00002a 	b	c21e590 <OSFlagCreate+0xec>
    }
    OS_ENTER_CRITICAL();
 c21e4e4:	e10f0000 	mrs	r0, CPSR
 c21e4e8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21e4ec:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21e4f0:	e121f000 	msr	CPSR_c, r0
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 c21e4f4:	e59f30a8 	ldr	r3, [pc, #168]	; c21e5a4 <OSFlagCreate+0x100>
 c21e4f8:	e5933000 	ldr	r3, [r3]
 c21e4fc:	e50b3010 	str	r3, [fp, #-16]
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 c21e500:	e51b3010 	ldr	r3, [fp, #-16]
 c21e504:	e3530000 	cmp	r3, #0
 c21e508:	0a00001a 	beq	c21e578 <OSFlagCreate+0xd4>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 c21e50c:	e59f3090 	ldr	r3, [pc, #144]	; c21e5a4 <OSFlagCreate+0x100>
 c21e510:	e5933000 	ldr	r3, [r3]
 c21e514:	e5933004 	ldr	r3, [r3, #4]
 c21e518:	e1a02003 	mov	r2, r3
 c21e51c:	e59f3080 	ldr	r3, [pc, #128]	; c21e5a4 <OSFlagCreate+0x100>
 c21e520:	e5832000 	str	r2, [r3]
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 c21e524:	e51b3010 	ldr	r3, [fp, #-16]
 c21e528:	e3a02005 	mov	r2, #5
 c21e52c:	e5c32000 	strb	r2, [r3]
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 c21e530:	e51b3010 	ldr	r3, [fp, #-16]
 c21e534:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c21e538:	e1c320b8 	strh	r2, [r3, #8]
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 c21e53c:	e51b3010 	ldr	r3, [fp, #-16]
 c21e540:	e3a02000 	mov	r2, #0
 c21e544:	e5832004 	str	r2, [r3, #4]
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 c21e548:	e51b3010 	ldr	r3, [fp, #-16]
 c21e54c:	e3a0203f 	mov	r2, #63	; 0x3f
 c21e550:	e5c3200a 	strb	r2, [r3, #10]
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 c21e554:	e51b3010 	ldr	r3, [fp, #-16]
 c21e558:	e3a02000 	mov	r2, #0
 c21e55c:	e5c3200b 	strb	r2, [r3, #11]
#endif
        OS_EXIT_CRITICAL();
 c21e560:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e564:	e121f000 	msr	CPSR_c, r0
        *err                 = OS_NO_ERR;
 c21e568:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21e56c:	e3a02000 	mov	r2, #0
 c21e570:	e5c32000 	strb	r2, [r3]
 c21e574:	ea000004 	b	c21e58c <OSFlagCreate+0xe8>
    } else {
        OS_EXIT_CRITICAL();
 c21e578:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e57c:	e121f000 	msr	CPSR_c, r0
        *err                 = OS_FLAG_GRP_DEPLETED;
 c21e580:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21e584:	e3e02065 	mvn	r2, #101	; 0x65
 c21e588:	e5c32000 	strb	r2, [r3]
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 c21e58c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21e590:	e1a00003 	mov	r0, r3
 c21e594:	e24bd00c 	sub	sp, fp, #12
 c21e598:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e59c:	e12fff1e 	bx	lr
 c21e5a0:	0c1c84c0 	.word	0x0c1c84c0
 c21e5a4:	0c1c979c 	.word	0x0c1c979c

0c21e5a8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)
{
 c21e5a8:	e1a0c00d 	mov	ip, sp
 c21e5ac:	e92dd800 	push	{fp, ip, lr, pc}
 c21e5b0:	e24cb004 	sub	fp, ip, #4
 c21e5b4:	e24dd018 	sub	sp, sp, #24
 c21e5b8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21e5bc:	e1a03001 	mov	r3, r1
 c21e5c0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c21e5c4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c21e5c8:	e59f3210 	ldr	r3, [pc, #528]	; c21e7e0 <OSFlagDel+0x238>
 c21e5cc:	e5d33000 	ldrb	r3, [r3]
 c21e5d0:	e3530000 	cmp	r3, #0
 c21e5d4:	0a000004 	beq	c21e5ec <OSFlagDel+0x44>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 c21e5d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e5dc:	e3e02073 	mvn	r2, #115	; 0x73
 c21e5e0:	e5c32000 	strb	r2, [r3]
        return (pgrp);
 c21e5e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e5e8:	ea000078 	b	c21e7d0 <OSFlagDel+0x228>
    }
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 c21e5ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e5f0:	e3530000 	cmp	r3, #0
 c21e5f4:	1a000004 	bne	c21e60c <OSFlagDel+0x64>
        *err = OS_FLAG_INVALID_PGRP;
 c21e5f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e5fc:	e3e02069 	mvn	r2, #105	; 0x69
 c21e600:	e5c32000 	strb	r2, [r3]
        return (pgrp);
 c21e604:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e608:	ea000070 	b	c21e7d0 <OSFlagDel+0x228>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 c21e60c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e610:	e5d33000 	ldrb	r3, [r3]
 c21e614:	e3530005 	cmp	r3, #5
 c21e618:	0a000004 	beq	c21e630 <OSFlagDel+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c21e61c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e620:	e3a02001 	mov	r2, #1
 c21e624:	e5c32000 	strb	r2, [r3]
        return (pgrp);
 c21e628:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e62c:	ea000067 	b	c21e7d0 <OSFlagDel+0x228>
    }
    OS_ENTER_CRITICAL();
 c21e630:	e10f0000 	mrs	r0, CPSR
 c21e634:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21e638:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21e63c:	e121f000 	msr	CPSR_c, r0
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 c21e640:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e644:	e5933004 	ldr	r3, [r3, #4]
 c21e648:	e3530000 	cmp	r3, #0
 c21e64c:	0a000002 	beq	c21e65c <OSFlagDel+0xb4>
        tasks_waiting = TRUE;                              /* Yes                                      */
 c21e650:	e3a03001 	mov	r3, #1
 c21e654:	e54b300d 	strb	r3, [fp, #-13]
 c21e658:	ea000001 	b	c21e664 <OSFlagDel+0xbc>
    } else {
        tasks_waiting = FALSE;                             /* No                                       */
 c21e65c:	e3a03000 	mov	r3, #0
 c21e660:	e54b300d 	strb	r3, [fp, #-13]
    }
    switch (opt) {
 c21e664:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c21e668:	e3530000 	cmp	r3, #0
 c21e66c:	0a000002 	beq	c21e67c <OSFlagDel+0xd4>
 c21e670:	e3530001 	cmp	r3, #1
 c21e674:	0a000024 	beq	c21e70c <OSFlagDel+0x164>
 c21e678:	ea00004e 	b	c21e7b8 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == FALSE) {
 c21e67c:	e55b300d 	ldrb	r3, [fp, #-13]
 c21e680:	e3530000 	cmp	r3, #0
 c21e684:	1a000019 	bne	c21e6f0 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 c21e688:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e68c:	e3a0203f 	mov	r2, #63	; 0x3f
 c21e690:	e5c3200a 	strb	r2, [r3, #10]
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 c21e694:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e698:	e3a02000 	mov	r2, #0
 c21e69c:	e5c3200b 	strb	r2, [r3, #11]
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 c21e6a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e6a4:	e3a02000 	mov	r2, #0
 c21e6a8:	e5c32000 	strb	r2, [r3]
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 c21e6ac:	e59f3130 	ldr	r3, [pc, #304]	; c21e7e4 <OSFlagDel+0x23c>
 c21e6b0:	e5932000 	ldr	r2, [r3]
 c21e6b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e6b8:	e5832004 	str	r2, [r3, #4]
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 c21e6bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e6c0:	e3a02000 	mov	r2, #0
 c21e6c4:	e1c320b8 	strh	r2, [r3, #8]
                 OSFlagFreeList       = pgrp;
 c21e6c8:	e59f3114 	ldr	r3, [pc, #276]	; c21e7e4 <OSFlagDel+0x23c>
 c21e6cc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21e6d0:	e5832000 	str	r2, [r3]
                 OS_EXIT_CRITICAL();
 c21e6d4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e6d8:	e121f000 	msr	CPSR_c, r0
                 *err                 = OS_NO_ERR;
 c21e6dc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e6e0:	e3a02000 	mov	r2, #0
 c21e6e4:	e5c32000 	strb	r2, [r3]
                 return ((OS_FLAG_GRP *)0);                /* Event Flag Group has been deleted        */
 c21e6e8:	e3a03000 	mov	r3, #0
 c21e6ec:	ea000037 	b	c21e7d0 <OSFlagDel+0x228>
             } else {
                 OS_EXIT_CRITICAL();
 c21e6f0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e6f4:	e121f000 	msr	CPSR_c, r0
                 *err                 = OS_ERR_TASK_WAITING;
 c21e6f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e6fc:	e3a02008 	mov	r2, #8
 c21e700:	e5c32000 	strb	r2, [r3]
                 return (pgrp);
 c21e704:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e708:	ea000030 	b	c21e7d0 <OSFlagDel+0x228>
             }

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 c21e70c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e710:	e5933004 	ldr	r3, [r3, #4]
 c21e714:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 c21e718:	ea000005 	b	c21e734 <OSFlagDel+0x18c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 c21e71c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
 c21e720:	e3a01000 	mov	r1, #0
 c21e724:	eb0003dc 	bl	c21f69c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 c21e728:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21e72c:	e5933000 	ldr	r3, [r3]
 c21e730:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                 return (pgrp);
             }

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 c21e734:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21e738:	e3530000 	cmp	r3, #0
 c21e73c:	1afffff6 	bne	c21e71c <OSFlagDel+0x174>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_EVENT_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 c21e740:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e744:	e3a0203f 	mov	r2, #63	; 0x3f
 c21e748:	e5c3200a 	strb	r2, [r3, #10]
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 c21e74c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e750:	e3a02000 	mov	r2, #0
 c21e754:	e5c3200b 	strb	r2, [r3, #11]
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 c21e758:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e75c:	e3a02000 	mov	r2, #0
 c21e760:	e5c32000 	strb	r2, [r3]
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 c21e764:	e59f3078 	ldr	r3, [pc, #120]	; c21e7e4 <OSFlagDel+0x23c>
 c21e768:	e5932000 	ldr	r2, [r3]
 c21e76c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e770:	e5832004 	str	r2, [r3, #4]
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 c21e774:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e778:	e3a02000 	mov	r2, #0
 c21e77c:	e1c320b8 	strh	r2, [r3, #8]
             OSFlagFreeList       = pgrp;
 c21e780:	e59f305c 	ldr	r3, [pc, #92]	; c21e7e4 <OSFlagDel+0x23c>
 c21e784:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21e788:	e5832000 	str	r2, [r3]
             OS_EXIT_CRITICAL();
 c21e78c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e790:	e121f000 	msr	CPSR_c, r0
             if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
 c21e794:	e55b300d 	ldrb	r3, [fp, #-13]
 c21e798:	e3530001 	cmp	r3, #1
 c21e79c:	1a000000 	bne	c21e7a4 <OSFlagDel+0x1fc>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 c21e7a0:	ebfffc20 	bl	c21d828 <OS_Sched>
             }
             *err = OS_NO_ERR;
 c21e7a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e7a8:	e3a02000 	mov	r2, #0
 c21e7ac:	e5c32000 	strb	r2, [r3]
             return ((OS_FLAG_GRP *)0);                    /* Event Flag Group has been deleted        */
 c21e7b0:	e3a03000 	mov	r3, #0
 c21e7b4:	ea000005 	b	c21e7d0 <OSFlagDel+0x228>

        default:
             OS_EXIT_CRITICAL();
 c21e7b8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e7bc:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_INVALID_OPT;
 c21e7c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e7c4:	e3a02007 	mov	r2, #7
 c21e7c8:	e5c32000 	strb	r2, [r3]
             return (pgrp);
 c21e7cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    }
}
 c21e7d0:	e1a00003 	mov	r0, r3
 c21e7d4:	e24bd00c 	sub	sp, fp, #12
 c21e7d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e7dc:	e12fff1e 	bx	lr
 c21e7e0:	0c1c84c0 	.word	0x0c1c84c0
 c21e7e4:	0c1c979c 	.word	0x0c1c979c

0c21e7e8 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, char *pname, INT8U *err)
{
 c21e7e8:	e1a0c00d 	mov	ip, sp
 c21e7ec:	e92dd800 	push	{fp, ip, lr, pc}
 c21e7f0:	e24cb004 	sub	fp, ip, #4
 c21e7f4:	e24dd018 	sub	sp, sp, #24
 c21e7f8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21e7fc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21e800:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c21e804:	e10f0000 	mrs	r0, CPSR
 c21e808:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21e80c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21e810:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 c21e814:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e818:	e3530000 	cmp	r3, #0
 c21e81c:	1a000006 	bne	c21e83c <OSFlagNameGet+0x54>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21e820:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e824:	e121f000 	msr	CPSR_c, r0
        *err = OS_FLAG_INVALID_PGRP;
 c21e828:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e82c:	e3e02069 	mvn	r2, #105	; 0x69
 c21e830:	e5c32000 	strb	r2, [r3]
        return (0);
 c21e834:	e3a03000 	mov	r3, #0
 c21e838:	ea000021 	b	c21e8c4 <OSFlagNameGet+0xdc>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c21e83c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21e840:	e3530000 	cmp	r3, #0
 c21e844:	1a000006 	bne	c21e864 <OSFlagNameGet+0x7c>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21e848:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e84c:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c21e850:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e854:	e3a0200f 	mov	r2, #15
 c21e858:	e5c32000 	strb	r2, [r3]
        return (0);
 c21e85c:	e3a03000 	mov	r3, #0
 c21e860:	ea000017 	b	c21e8c4 <OSFlagNameGet+0xdc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 c21e864:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e868:	e5d33000 	ldrb	r3, [r3]
 c21e86c:	e3530005 	cmp	r3, #5
 c21e870:	0a000006 	beq	c21e890 <OSFlagNameGet+0xa8>
        OS_EXIT_CRITICAL();
 c21e874:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e878:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_EVENT_TYPE;
 c21e87c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e880:	e3a02001 	mov	r2, #1
 c21e884:	e5c32000 	strb	r2, [r3]
        return (0);
 c21e888:	e3a03000 	mov	r3, #0
 c21e88c:	ea00000c 	b	c21e8c4 <OSFlagNameGet+0xdc>
    }
    len  = OS_StrCopy(pname, pgrp->OSFlagName);  /* Copy name from OS_FLAG_GRP                         */
 c21e890:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e894:	e283300a 	add	r3, r3, #10
 c21e898:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c21e89c:	e1a01003 	mov	r1, r3
 c21e8a0:	ebfffc28 	bl	c21d948 <OS_StrCopy>
 c21e8a4:	e1a03000 	mov	r3, r0
 c21e8a8:	e54b300d 	strb	r3, [fp, #-13]
    OS_EXIT_CRITICAL();
 c21e8ac:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e8b0:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c21e8b4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e8b8:	e3a02000 	mov	r2, #0
 c21e8bc:	e5c32000 	strb	r2, [r3]
    return (len);
 c21e8c0:	e55b300d 	ldrb	r3, [fp, #-13]
}
 c21e8c4:	e1a00003 	mov	r0, r3
 c21e8c8:	e24bd00c 	sub	sp, fp, #12
 c21e8cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e8d0:	e12fff1e 	bx	lr

0c21e8d4 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, char *pname, INT8U *err)
{
 c21e8d4:	e1a0c00d 	mov	ip, sp
 c21e8d8:	e92dd800 	push	{fp, ip, lr, pc}
 c21e8dc:	e24cb004 	sub	fp, ip, #4
 c21e8e0:	e24dd018 	sub	sp, sp, #24
 c21e8e4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21e8e8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21e8ec:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c21e8f0:	e10f0000 	mrs	r0, CPSR
 c21e8f4:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21e8f8:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21e8fc:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 c21e900:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e904:	e3530000 	cmp	r3, #0
 c21e908:	1a000005 	bne	c21e924 <OSFlagNameSet+0x50>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21e90c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e910:	e121f000 	msr	CPSR_c, r0
        *err = OS_FLAG_INVALID_PGRP;
 c21e914:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e918:	e3e02069 	mvn	r2, #105	; 0x69
 c21e91c:	e5c32000 	strb	r2, [r3]
        return;
 c21e920:	ea00002a 	b	c21e9d0 <OSFlagNameSet+0xfc>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c21e924:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21e928:	e3530000 	cmp	r3, #0
 c21e92c:	1a000005 	bne	c21e948 <OSFlagNameSet+0x74>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c21e930:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e934:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c21e938:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e93c:	e3a0200f 	mov	r2, #15
 c21e940:	e5c32000 	strb	r2, [r3]
        return;
 c21e944:	ea000021 	b	c21e9d0 <OSFlagNameSet+0xfc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 c21e948:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e94c:	e5d33000 	ldrb	r3, [r3]
 c21e950:	e3530005 	cmp	r3, #5
 c21e954:	0a000005 	beq	c21e970 <OSFlagNameSet+0x9c>
        OS_EXIT_CRITICAL();
 c21e958:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e95c:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_EVENT_TYPE;
 c21e960:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e964:	e3a02001 	mov	r2, #1
 c21e968:	e5c32000 	strb	r2, [r3]
        return;
 c21e96c:	ea000017 	b	c21e9d0 <OSFlagNameSet+0xfc>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 c21e970:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c21e974:	ebfffc15 	bl	c21d9d0 <OS_StrLen>
 c21e978:	e1a03000 	mov	r3, r0
 c21e97c:	e54b300d 	strb	r3, [fp, #-13]
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 c21e980:	e55b300d 	ldrb	r3, [fp, #-13]
 c21e984:	e353001f 	cmp	r3, #31
 c21e988:	9a000005 	bls	c21e9a4 <OSFlagNameSet+0xd0>
        OS_EXIT_CRITICAL();
 c21e98c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e990:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_FLAG_NAME_TOO_LONG;
 c21e994:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e998:	e3a0200d 	mov	r2, #13
 c21e99c:	e5c32000 	strb	r2, [r3]
        return;
 c21e9a0:	ea00000a 	b	c21e9d0 <OSFlagNameSet+0xfc>
    } 
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 c21e9a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21e9a8:	e283300a 	add	r3, r3, #10
 c21e9ac:	e1a00003 	mov	r0, r3
 c21e9b0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c21e9b4:	ebfffbe3 	bl	c21d948 <OS_StrCopy>
    OS_EXIT_CRITICAL();
 c21e9b8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21e9bc:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c21e9c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21e9c4:	e3a02000 	mov	r2, #0
 c21e9c8:	e5c32000 	strb	r2, [r3]
    return;
 c21e9cc:	e1a00000 	nop			; (mov r0, r0)
}
 c21e9d0:	e24bd00c 	sub	sp, fp, #12
 c21e9d4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21e9d8:	e12fff1e 	bx	lr

0c21e9dc <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
 c21e9dc:	e1a0c00d 	mov	ip, sp
 c21e9e0:	e92dd800 	push	{fp, ip, lr, pc}
 c21e9e4:	e24cb004 	sub	fp, ip, #4
 c21e9e8:	e24dd030 	sub	sp, sp, #48	; 0x30
 c21e9ec:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
 c21e9f0:	e14b12ba 	strh	r1, [fp, #-42]	; 0xffffffd6
 c21e9f4:	e54b202b 	strb	r2, [fp, #-43]	; 0xffffffd5
 c21e9f8:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c21e9fc:	e59f353c 	ldr	r3, [pc, #1340]	; c21ef40 <OSFlagPend+0x564>
 c21ea00:	e5d33000 	ldrb	r3, [r3]
 c21ea04:	e3530000 	cmp	r3, #0
 c21ea08:	0a000004 	beq	c21ea20 <OSFlagPend+0x44>
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
 c21ea0c:	e59b3004 	ldr	r3, [fp, #4]
 c21ea10:	e3a02002 	mov	r2, #2
 c21ea14:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21ea18:	e3a03000 	mov	r3, #0
 c21ea1c:	ea000143 	b	c21ef30 <OSFlagPend+0x554>
    }
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 c21ea20:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ea24:	e3530000 	cmp	r3, #0
 c21ea28:	1a000004 	bne	c21ea40 <OSFlagPend+0x64>
        *err = OS_FLAG_INVALID_PGRP;
 c21ea2c:	e59b3004 	ldr	r3, [fp, #4]
 c21ea30:	e3e02069 	mvn	r2, #105	; 0x69
 c21ea34:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21ea38:	e3a03000 	mov	r3, #0
 c21ea3c:	ea00013b 	b	c21ef30 <OSFlagPend+0x554>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 c21ea40:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ea44:	e5d33000 	ldrb	r3, [r3]
 c21ea48:	e3530005 	cmp	r3, #5
 c21ea4c:	0a000004 	beq	c21ea64 <OSFlagPend+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c21ea50:	e59b3004 	ldr	r3, [fp, #4]
 c21ea54:	e3a02001 	mov	r2, #1
 c21ea58:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21ea5c:	e3a03000 	mov	r3, #0
 c21ea60:	ea000132 	b	c21ef30 <OSFlagPend+0x554>
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
 c21ea64:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21ea68:	e1a03c03 	lsl	r3, r3, #24
 c21ea6c:	e1a03c43 	asr	r3, r3, #24
 c21ea70:	e3530000 	cmp	r3, #0
 c21ea74:	aa000005 	bge	c21ea90 <OSFlagPend+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
 c21ea78:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21ea7c:	e203307f 	and	r3, r3, #127	; 0x7f
 c21ea80:	e54b302b 	strb	r3, [fp, #-43]	; 0xffffffd5
        consume    = TRUE;
 c21ea84:	e3a03001 	mov	r3, #1
 c21ea88:	e54b300d 	strb	r3, [fp, #-13]
 c21ea8c:	ea000001 	b	c21ea98 <OSFlagPend+0xbc>
    } else {
        consume    = FALSE;
 c21ea90:	e3a03000 	mov	r3, #0
 c21ea94:	e54b300d 	strb	r3, [fp, #-13]
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 c21ea98:	e10f0000 	mrs	r0, CPSR
 c21ea9c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21eaa0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21eaa4:	e121f000 	msr	CPSR_c, r0
    switch (wait_type) {
 c21eaa8:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21eaac:	e3530003 	cmp	r3, #3
 c21eab0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c21eab4:	ea0000c1 	b	c21edc0 <OSFlagPend+0x3e4>
 c21eab8:	0c21ec44 	.word	0x0c21ec44
 c21eabc:	0c21ed04 	.word	0x0c21ed04
 c21eac0:	0c21eac8 	.word	0x0c21eac8
 c21eac4:	0c21eb88 	.word	0x0c21eb88
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
 c21eac8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eacc:	e1d320b8 	ldrh	r2, [r3, #8]
 c21ead0:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21ead4:	e0023003 	and	r3, r2, r3
 c21ead8:	e14b31b0 	strh	r3, [fp, #-16]
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 c21eadc:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21eae0:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21eae4:	e1520003 	cmp	r2, r3
 c21eae8:	1a00001c 	bne	c21eb60 <OSFlagPend+0x184>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21eaec:	e55b300d 	ldrb	r3, [fp, #-13]
 c21eaf0:	e3530001 	cmp	r3, #1
 c21eaf4:	1a00000e 	bne	c21eb34 <OSFlagPend+0x158>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 c21eaf8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eafc:	e1d330b8 	ldrh	r3, [r3, #8]
 c21eb00:	e1a03803 	lsl	r3, r3, #16
 c21eb04:	e1a02823 	lsr	r2, r3, #16
 c21eb08:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21eb0c:	e1e03003 	mvn	r3, r3
 c21eb10:	e1a03803 	lsl	r3, r3, #16
 c21eb14:	e1a03823 	lsr	r3, r3, #16
 c21eb18:	e0023003 	and	r3, r2, r3
 c21eb1c:	e1a03803 	lsl	r3, r3, #16
 c21eb20:	e1a03823 	lsr	r3, r3, #16
 c21eb24:	e1a03803 	lsl	r3, r3, #16
 c21eb28:	e1a02823 	lsr	r2, r3, #16
 c21eb2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eb30:	e1c320b8 	strh	r2, [r3, #8]
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 c21eb34:	e59f3408 	ldr	r3, [pc, #1032]	; c21ef44 <OSFlagPend+0x568>
 c21eb38:	e5933000 	ldr	r3, [r3]
 c21eb3c:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21eb40:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
 c21eb44:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21eb48:	e121f000 	msr	CPSR_c, r0
                 *err                    = OS_NO_ERR;
 c21eb4c:	e59b3004 	ldr	r3, [fp, #4]
 c21eb50:	e3a02000 	mov	r2, #0
 c21eb54:	e5c32000 	strb	r2, [r3]
                 return (flags_rdy);
 c21eb58:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21eb5c:	ea0000f3 	b	c21ef30 <OSFlagPend+0x554>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 c21eb60:	e24b1024 	sub	r1, fp, #36	; 0x24
 c21eb64:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
 c21eb68:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21eb6c:	e15b02be 	ldrh	r0, [fp, #-46]	; 0xffffffd2
 c21eb70:	e58d0000 	str	r0, [sp]
 c21eb74:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c21eb78:	eb00021e 	bl	c21f3f8 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
 c21eb7c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21eb80:	e121f000 	msr	CPSR_c, r0
             }
             break;
 c21eb84:	ea000096 	b	c21ede4 <OSFlagPend+0x408>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
 c21eb88:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eb8c:	e1d320b8 	ldrh	r2, [r3, #8]
 c21eb90:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21eb94:	e0023003 	and	r3, r2, r3
 c21eb98:	e14b31b0 	strh	r3, [fp, #-16]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 c21eb9c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21eba0:	e3530000 	cmp	r3, #0
 c21eba4:	0a00001c 	beq	c21ec1c <OSFlagPend+0x240>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21eba8:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ebac:	e3530001 	cmp	r3, #1
 c21ebb0:	1a00000e 	bne	c21ebf0 <OSFlagPend+0x214>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 c21ebb4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ebb8:	e1d330b8 	ldrh	r3, [r3, #8]
 c21ebbc:	e1a03803 	lsl	r3, r3, #16
 c21ebc0:	e1a02823 	lsr	r2, r3, #16
 c21ebc4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ebc8:	e1e03003 	mvn	r3, r3
 c21ebcc:	e1a03803 	lsl	r3, r3, #16
 c21ebd0:	e1a03823 	lsr	r3, r3, #16
 c21ebd4:	e0023003 	and	r3, r2, r3
 c21ebd8:	e1a03803 	lsl	r3, r3, #16
 c21ebdc:	e1a03823 	lsr	r3, r3, #16
 c21ebe0:	e1a03803 	lsl	r3, r3, #16
 c21ebe4:	e1a02823 	lsr	r2, r3, #16
 c21ebe8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ebec:	e1c320b8 	strh	r2, [r3, #8]
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 c21ebf0:	e59f334c 	ldr	r3, [pc, #844]	; c21ef44 <OSFlagPend+0x568>
 c21ebf4:	e5933000 	ldr	r3, [r3]
 c21ebf8:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21ebfc:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
 c21ec00:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ec04:	e121f000 	msr	CPSR_c, r0
                 *err                    = OS_NO_ERR;
 c21ec08:	e59b3004 	ldr	r3, [fp, #4]
 c21ec0c:	e3a02000 	mov	r2, #0
 c21ec10:	e5c32000 	strb	r2, [r3]
                 return (flags_rdy);
 c21ec14:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ec18:	ea0000c4 	b	c21ef30 <OSFlagPend+0x554>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 c21ec1c:	e24b1024 	sub	r1, fp, #36	; 0x24
 c21ec20:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
 c21ec24:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21ec28:	e15b02be 	ldrh	r0, [fp, #-46]	; 0xffffffd2
 c21ec2c:	e58d0000 	str	r0, [sp]
 c21ec30:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c21ec34:	eb0001ef 	bl	c21f3f8 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
 c21ec38:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ec3c:	e121f000 	msr	CPSR_c, r0
             }
             break;
 c21ec40:	ea000067 	b	c21ede4 <OSFlagPend+0x408>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
 c21ec44:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ec48:	e1d330b8 	ldrh	r3, [r3, #8]
 c21ec4c:	e1a03803 	lsl	r3, r3, #16
 c21ec50:	e1a03823 	lsr	r3, r3, #16
 c21ec54:	e1e03003 	mvn	r3, r3
 c21ec58:	e1a03803 	lsl	r3, r3, #16
 c21ec5c:	e1a02823 	lsr	r2, r3, #16
 c21ec60:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21ec64:	e0023003 	and	r3, r2, r3
 c21ec68:	e1a03803 	lsl	r3, r3, #16
 c21ec6c:	e1a03823 	lsr	r3, r3, #16
 c21ec70:	e14b31b0 	strh	r3, [fp, #-16]
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 c21ec74:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21ec78:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21ec7c:	e1520003 	cmp	r2, r3
 c21ec80:	1a000015 	bne	c21ecdc <OSFlagPend+0x300>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21ec84:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ec88:	e3530001 	cmp	r3, #1
 c21ec8c:	1a000007 	bne	c21ecb0 <OSFlagPend+0x2d4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 c21ec90:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ec94:	e1d320b8 	ldrh	r2, [r3, #8]
 c21ec98:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ec9c:	e1823003 	orr	r3, r2, r3
 c21eca0:	e1a03803 	lsl	r3, r3, #16
 c21eca4:	e1a02823 	lsr	r2, r3, #16
 c21eca8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ecac:	e1c320b8 	strh	r2, [r3, #8]
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 c21ecb0:	e59f328c 	ldr	r3, [pc, #652]	; c21ef44 <OSFlagPend+0x568>
 c21ecb4:	e5933000 	ldr	r3, [r3]
 c21ecb8:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21ecbc:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
 c21ecc0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ecc4:	e121f000 	msr	CPSR_c, r0
                 *err                    = OS_NO_ERR;
 c21ecc8:	e59b3004 	ldr	r3, [fp, #4]
 c21eccc:	e3a02000 	mov	r2, #0
 c21ecd0:	e5c32000 	strb	r2, [r3]
                 return (flags_rdy);
 c21ecd4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ecd8:	ea000094 	b	c21ef30 <OSFlagPend+0x554>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 c21ecdc:	e24b1024 	sub	r1, fp, #36	; 0x24
 c21ece0:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
 c21ece4:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21ece8:	e15b02be 	ldrh	r0, [fp, #-46]	; 0xffffffd2
 c21ecec:	e58d0000 	str	r0, [sp]
 c21ecf0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c21ecf4:	eb0001bf 	bl	c21f3f8 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
 c21ecf8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ecfc:	e121f000 	msr	CPSR_c, r0
             }
             break;
 c21ed00:	ea000037 	b	c21ede4 <OSFlagPend+0x408>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
 c21ed04:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ed08:	e1d330b8 	ldrh	r3, [r3, #8]
 c21ed0c:	e1a03803 	lsl	r3, r3, #16
 c21ed10:	e1a03823 	lsr	r3, r3, #16
 c21ed14:	e1e03003 	mvn	r3, r3
 c21ed18:	e1a03803 	lsl	r3, r3, #16
 c21ed1c:	e1a02823 	lsr	r2, r3, #16
 c21ed20:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c21ed24:	e0023003 	and	r3, r2, r3
 c21ed28:	e1a03803 	lsl	r3, r3, #16
 c21ed2c:	e1a03823 	lsr	r3, r3, #16
 c21ed30:	e14b31b0 	strh	r3, [fp, #-16]
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 c21ed34:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ed38:	e3530000 	cmp	r3, #0
 c21ed3c:	0a000015 	beq	c21ed98 <OSFlagPend+0x3bc>
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
 c21ed40:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ed44:	e3530001 	cmp	r3, #1
 c21ed48:	1a000007 	bne	c21ed6c <OSFlagPend+0x390>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 c21ed4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ed50:	e1d320b8 	ldrh	r2, [r3, #8]
 c21ed54:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ed58:	e1823003 	orr	r3, r2, r3
 c21ed5c:	e1a03803 	lsl	r3, r3, #16
 c21ed60:	e1a02823 	lsr	r2, r3, #16
 c21ed64:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ed68:	e1c320b8 	strh	r2, [r3, #8]
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 c21ed6c:	e59f31d0 	ldr	r3, [pc, #464]	; c21ef44 <OSFlagPend+0x568>
 c21ed70:	e5933000 	ldr	r3, [r3]
 c21ed74:	e15b21b0 	ldrh	r2, [fp, #-16]
 c21ed78:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
 c21ed7c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ed80:	e121f000 	msr	CPSR_c, r0
                 *err                    = OS_NO_ERR;
 c21ed84:	e59b3004 	ldr	r3, [fp, #4]
 c21ed88:	e3a02000 	mov	r2, #0
 c21ed8c:	e5c32000 	strb	r2, [r3]
                 return (flags_rdy);
 c21ed90:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ed94:	ea000065 	b	c21ef30 <OSFlagPend+0x554>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 c21ed98:	e24b1024 	sub	r1, fp, #36	; 0x24
 c21ed9c:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
 c21eda0:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21eda4:	e15b02be 	ldrh	r0, [fp, #-46]	; 0xffffffd2
 c21eda8:	e58d0000 	str	r0, [sp]
 c21edac:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c21edb0:	eb000190 	bl	c21f3f8 <OS_FlagBlock>
                 OS_EXIT_CRITICAL();
 c21edb4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21edb8:	e121f000 	msr	CPSR_c, r0
             }
             break;
 c21edbc:	ea000008 	b	c21ede4 <OSFlagPend+0x408>
#endif

        default:
             OS_EXIT_CRITICAL();
 c21edc0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21edc4:	e121f000 	msr	CPSR_c, r0
             flags_rdy = (OS_FLAGS)0;
 c21edc8:	e3a03000 	mov	r3, #0
 c21edcc:	e14b31b0 	strh	r3, [fp, #-16]
             *err      = OS_FLAG_ERR_WAIT_TYPE;
 c21edd0:	e59b3004 	ldr	r3, [fp, #4]
 c21edd4:	e3e02068 	mvn	r2, #104	; 0x68
 c21edd8:	e5c32000 	strb	r2, [r3]
             return (flags_rdy);
 c21eddc:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ede0:	ea000052 	b	c21ef30 <OSFlagPend+0x554>
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
 c21ede4:	ebfffa8f 	bl	c21d828 <OS_Sched>
    OS_ENTER_CRITICAL();
 c21ede8:	e10f0000 	mrs	r0, CPSR
 c21edec:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21edf0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21edf4:	e121f000 	msr	CPSR_c, r0
    if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                       */
 c21edf8:	e59f3144 	ldr	r3, [pc, #324]	; c21ef44 <OSFlagPend+0x568>
 c21edfc:	e5933000 	ldr	r3, [r3]
 c21ee00:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
 c21ee04:	e3530001 	cmp	r3, #1
 c21ee08:	1a000013 	bne	c21ee5c <OSFlagPend+0x480>
        OSTCBCur->OSTCBPendTO = FALSE;
 c21ee0c:	e59f3130 	ldr	r3, [pc, #304]	; c21ef44 <OSFlagPend+0x568>
 c21ee10:	e5933000 	ldr	r3, [r3]
 c21ee14:	e3a02000 	mov	r2, #0
 c21ee18:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
        OS_FlagUnlink(&node);
 c21ee1c:	e24b3024 	sub	r3, fp, #36	; 0x24
 c21ee20:	e1a00003 	mov	r0, r3
 c21ee24:	eb00025b 	bl	c21f798 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
 c21ee28:	e59f3114 	ldr	r3, [pc, #276]	; c21ef44 <OSFlagPend+0x568>
 c21ee2c:	e5933000 	ldr	r3, [r3]
 c21ee30:	e3a02000 	mov	r2, #0
 c21ee34:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        OS_EXIT_CRITICAL();
 c21ee38:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ee3c:	e121f000 	msr	CPSR_c, r0
        flags_rdy             = (OS_FLAGS)0;
 c21ee40:	e3a03000 	mov	r3, #0
 c21ee44:	e14b31b0 	strh	r3, [fp, #-16]
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
 c21ee48:	e59b3004 	ldr	r3, [fp, #4]
 c21ee4c:	e3a0200a 	mov	r2, #10
 c21ee50:	e5c32000 	strb	r2, [r3]
        return (flags_rdy);
 c21ee54:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21ee58:	ea000034 	b	c21ef30 <OSFlagPend+0x554>
    } 
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 c21ee5c:	e59f30e0 	ldr	r3, [pc, #224]	; c21ef44 <OSFlagPend+0x568>
 c21ee60:	e5933000 	ldr	r3, [r3]
 c21ee64:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
 c21ee68:	e14b31b0 	strh	r3, [fp, #-16]
    if (consume == TRUE) {                                 /* See if we need to consume the flags      */
 c21ee6c:	e55b300d 	ldrb	r3, [fp, #-13]
 c21ee70:	e3530001 	cmp	r3, #1
 c21ee74:	1a000027 	bne	c21ef18 <OSFlagPend+0x53c>
        switch (wait_type) {
 c21ee78:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
 c21ee7c:	e3530003 	cmp	r3, #3
 c21ee80:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c21ee84:	ea00001c 	b	c21eefc <OSFlagPend+0x520>
 c21ee88:	0c21eed8 	.word	0x0c21eed8
 c21ee8c:	0c21eed8 	.word	0x0c21eed8
 c21ee90:	0c21ee98 	.word	0x0c21ee98
 c21ee94:	0c21ee98 	.word	0x0c21ee98
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 c21ee98:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21ee9c:	e1d330b8 	ldrh	r3, [r3, #8]
 c21eea0:	e1a03803 	lsl	r3, r3, #16
 c21eea4:	e1a02823 	lsr	r2, r3, #16
 c21eea8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21eeac:	e1e03003 	mvn	r3, r3
 c21eeb0:	e1a03803 	lsl	r3, r3, #16
 c21eeb4:	e1a03823 	lsr	r3, r3, #16
 c21eeb8:	e0023003 	and	r3, r2, r3
 c21eebc:	e1a03803 	lsl	r3, r3, #16
 c21eec0:	e1a03823 	lsr	r3, r3, #16
 c21eec4:	e1a03803 	lsl	r3, r3, #16
 c21eec8:	e1a02823 	lsr	r2, r3, #16
 c21eecc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eed0:	e1c320b8 	strh	r2, [r3, #8]
                 break;
 c21eed4:	ea00000f 	b	c21ef18 <OSFlagPend+0x53c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 c21eed8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eedc:	e1d320b8 	ldrh	r2, [r3, #8]
 c21eee0:	e15b31b0 	ldrh	r3, [fp, #-16]
 c21eee4:	e1823003 	orr	r3, r2, r3
 c21eee8:	e1a03803 	lsl	r3, r3, #16
 c21eeec:	e1a02823 	lsr	r2, r3, #16
 c21eef0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eef4:	e1c320b8 	strh	r2, [r3, #8]
                 break;
 c21eef8:	ea000006 	b	c21ef18 <OSFlagPend+0x53c>
#endif
            default:
                 OS_EXIT_CRITICAL();
 c21eefc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ef00:	e121f000 	msr	CPSR_c, r0
                 *err = OS_FLAG_ERR_WAIT_TYPE;
 c21ef04:	e59b3004 	ldr	r3, [fp, #4]
 c21ef08:	e3e02068 	mvn	r2, #104	; 0x68
 c21ef0c:	e5c32000 	strb	r2, [r3]
                 return ((OS_FLAGS)0);
 c21ef10:	e3a03000 	mov	r3, #0
 c21ef14:	ea000005 	b	c21ef30 <OSFlagPend+0x554>
        }
    }
    OS_EXIT_CRITICAL();
 c21ef18:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ef1c:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
 c21ef20:	e59b3004 	ldr	r3, [fp, #4]
 c21ef24:	e3a02000 	mov	r2, #0
 c21ef28:	e5c32000 	strb	r2, [r3]
    return (flags_rdy);
 c21ef2c:	e15b31b0 	ldrh	r3, [fp, #-16]
}
 c21ef30:	e1a00003 	mov	r0, r3
 c21ef34:	e24bd00c 	sub	sp, fp, #12
 c21ef38:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21ef3c:	e12fff1e 	bx	lr
 c21ef40:	0c1c84c0 	.word	0x0c1c84c0
 c21ef44:	0c1c84c4 	.word	0x0c1c84c4

0c21ef48 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 c21ef48:	e1a0c00d 	mov	ip, sp
 c21ef4c:	e92dd800 	push	{fp, ip, lr, pc}
 c21ef50:	e24cb004 	sub	fp, ip, #4
 c21ef54:	e24dd008 	sub	sp, sp, #8



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    OS_ENTER_CRITICAL();
 c21ef58:	e10f0000 	mrs	r0, CPSR
 c21ef5c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21ef60:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21ef64:	e121f000 	msr	CPSR_c, r0
    flags = OSTCBCur->OSTCBFlagsRdy;
 c21ef68:	e59f3024 	ldr	r3, [pc, #36]	; c21ef94 <OSFlagPendGetFlagsRdy+0x4c>
 c21ef6c:	e5933000 	ldr	r3, [r3]
 c21ef70:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
 c21ef74:	e14b30be 	strh	r3, [fp, #-14]
    OS_EXIT_CRITICAL();
 c21ef78:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ef7c:	e121f000 	msr	CPSR_c, r0
    return (flags);
 c21ef80:	e15b30be 	ldrh	r3, [fp, #-14]
}
 c21ef84:	e1a00003 	mov	r0, r3
 c21ef88:	e24bd00c 	sub	sp, fp, #12
 c21ef8c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21ef90:	e12fff1e 	bx	lr
 c21ef94:	0c1c84c4 	.word	0x0c1c84c4

0c21ef98 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
 c21ef98:	e1a0c00d 	mov	ip, sp
 c21ef9c:	e92dd800 	push	{fp, ip, lr, pc}
 c21efa0:	e24cb004 	sub	fp, ip, #4
 c21efa4:	e24dd020 	sub	sp, sp, #32
 c21efa8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c21efac:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
 c21efb0:	e14b12b2 	strh	r1, [fp, #-34]	; 0xffffffde
 c21efb4:	e1a03002 	mov	r3, r2
 c21efb8:	e54b3023 	strb	r3, [fp, #-35]	; 0xffffffdd


    cpu_sr = 0;                                      /* Prevent compiler warning                       */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 c21efbc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21efc0:	e3530000 	cmp	r3, #0
 c21efc4:	1a000004 	bne	c21efdc <OSFlagPost+0x44>
        *err = OS_FLAG_INVALID_PGRP;
 c21efc8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21efcc:	e3e02069 	mvn	r2, #105	; 0x69
 c21efd0:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21efd4:	e3a03000 	mov	r3, #0
 c21efd8:	ea0000da 	b	c21f348 <OSFlagPost+0x3b0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 c21efdc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21efe0:	e5d33000 	ldrb	r3, [r3]
 c21efe4:	e3530005 	cmp	r3, #5
 c21efe8:	0a000004 	beq	c21f000 <OSFlagPost+0x68>
        *err = OS_ERR_EVENT_TYPE;
 c21efec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21eff0:	e3a02001 	mov	r2, #1
 c21eff4:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21eff8:	e3a03000 	mov	r3, #0
 c21effc:	ea0000d1 	b	c21f348 <OSFlagPost+0x3b0>
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 c21f000:	e10f0000 	mrs	r0, CPSR
 c21f004:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21f008:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21f00c:	e121f000 	msr	CPSR_c, r0
    switch (opt) {
 c21f010:	e55b3023 	ldrb	r3, [fp, #-35]	; 0xffffffdd
 c21f014:	e3530000 	cmp	r3, #0
 c21f018:	0a000002 	beq	c21f028 <OSFlagPost+0x90>
 c21f01c:	e3530001 	cmp	r3, #1
 c21f020:	0a000010 	beq	c21f068 <OSFlagPost+0xd0>
 c21f024:	ea000018 	b	c21f08c <OSFlagPost+0xf4>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 c21f028:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f02c:	e1d330b8 	ldrh	r3, [r3, #8]
 c21f030:	e1a03803 	lsl	r3, r3, #16
 c21f034:	e1a02823 	lsr	r2, r3, #16
 c21f038:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
 c21f03c:	e1e03003 	mvn	r3, r3
 c21f040:	e1a03803 	lsl	r3, r3, #16
 c21f044:	e1a03823 	lsr	r3, r3, #16
 c21f048:	e0023003 	and	r3, r2, r3
 c21f04c:	e1a03803 	lsl	r3, r3, #16
 c21f050:	e1a03823 	lsr	r3, r3, #16
 c21f054:	e1a03803 	lsl	r3, r3, #16
 c21f058:	e1a02823 	lsr	r2, r3, #16
 c21f05c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f060:	e1c320b8 	strh	r2, [r3, #8]
             break;
 c21f064:	ea00000f 	b	c21f0a8 <OSFlagPost+0x110>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 c21f068:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f06c:	e1d320b8 	ldrh	r2, [r3, #8]
 c21f070:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
 c21f074:	e1823003 	orr	r3, r2, r3
 c21f078:	e1a03803 	lsl	r3, r3, #16
 c21f07c:	e1a02823 	lsr	r2, r3, #16
 c21f080:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f084:	e1c320b8 	strh	r2, [r3, #8]
             break;
 c21f088:	ea000006 	b	c21f0a8 <OSFlagPost+0x110>

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
 c21f08c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f090:	e121f000 	msr	CPSR_c, r0
             *err = OS_FLAG_INVALID_OPT;
 c21f094:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21f098:	e3e02066 	mvn	r2, #102	; 0x66
 c21f09c:	e5c32000 	strb	r2, [r3]
             return ((OS_FLAGS)0);
 c21f0a0:	e3a03000 	mov	r3, #0
 c21f0a4:	ea0000a7 	b	c21f348 <OSFlagPost+0x3b0>
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
 c21f0a8:	e3a03000 	mov	r3, #0
 c21f0ac:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 c21f0b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f0b4:	e5933004 	ldr	r3, [r3, #4]
 c21f0b8:	e50b3010 	str	r3, [fp, #-16]
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 c21f0bc:	ea00008b 	b	c21f2f0 <OSFlagPost+0x358>
        switch (pnode->OSFlagNodeWaitType) {
 c21f0c0:	e51b3010 	ldr	r3, [fp, #-16]
 c21f0c4:	e5d33012 	ldrb	r3, [r3, #18]
 c21f0c8:	e3530003 	cmp	r3, #3
 c21f0cc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c21f0d0:	ea00006d 	b	c21f28c <OSFlagPost+0x2f4>
 c21f0d4:	0c21f194 	.word	0x0c21f194
 c21f0d8:	0c21f214 	.word	0x0c21f214
 c21f0dc:	0c21f0e4 	.word	0x0c21f0e4
 c21f0e0:	0c21f140 	.word	0x0c21f140
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 c21f0e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f0e8:	e1d320b8 	ldrh	r2, [r3, #8]
 c21f0ec:	e51b3010 	ldr	r3, [fp, #-16]
 c21f0f0:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f0f4:	e0023003 	and	r3, r2, r3
 c21f0f8:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 c21f0fc:	e51b3010 	ldr	r3, [fp, #-16]
 c21f100:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f104:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c21f108:	e1520003 	cmp	r2, r3
 c21f10c:	1a000065 	bne	c21f2a8 <OSFlagPost+0x310>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 c21f110:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f114:	e51b0010 	ldr	r0, [fp, #-16]
 c21f118:	e1a01003 	mov	r1, r3
 c21f11c:	eb00015e 	bl	c21f69c <OS_FlagTaskRdy>
 c21f120:	e1a03000 	mov	r3, r0
 c21f124:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
                     if (rdy == TRUE) {                     
 c21f128:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21f12c:	e3530001 	cmp	r3, #1
 c21f130:	1a00005e 	bne	c21f2b0 <OSFlagPost+0x318>
                         sched = TRUE;                        /* When done we will reschedule          */
 c21f134:	e3a03001 	mov	r3, #1
 c21f138:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                     }
                 }
                 break;
 c21f13c:	ea000068 	b	c21f2e4 <OSFlagPost+0x34c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 c21f140:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f144:	e1d320b8 	ldrh	r2, [r3, #8]
 c21f148:	e51b3010 	ldr	r3, [fp, #-16]
 c21f14c:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f150:	e0023003 	and	r3, r2, r3
 c21f154:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
                 if (flags_rdy != (OS_FLAGS)0) {
 c21f158:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f15c:	e3530000 	cmp	r3, #0
 c21f160:	0a000054 	beq	c21f2b8 <OSFlagPost+0x320>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 c21f164:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f168:	e51b0010 	ldr	r0, [fp, #-16]
 c21f16c:	e1a01003 	mov	r1, r3
 c21f170:	eb000149 	bl	c21f69c <OS_FlagTaskRdy>
 c21f174:	e1a03000 	mov	r3, r0
 c21f178:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
                     if (rdy == TRUE) {                      
 c21f17c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21f180:	e3530001 	cmp	r3, #1
 c21f184:	1a00004d 	bne	c21f2c0 <OSFlagPost+0x328>
                         sched = TRUE;                        /* When done we will reschedule          */
 c21f188:	e3a03001 	mov	r3, #1
 c21f18c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                     }
                 }
                 break;
 c21f190:	ea000053 	b	c21f2e4 <OSFlagPost+0x34c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 c21f194:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f198:	e1d330b8 	ldrh	r3, [r3, #8]
 c21f19c:	e1a03803 	lsl	r3, r3, #16
 c21f1a0:	e1a03823 	lsr	r3, r3, #16
 c21f1a4:	e1e03003 	mvn	r3, r3
 c21f1a8:	e1a03803 	lsl	r3, r3, #16
 c21f1ac:	e1a02823 	lsr	r2, r3, #16
 c21f1b0:	e51b3010 	ldr	r3, [fp, #-16]
 c21f1b4:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f1b8:	e1a03803 	lsl	r3, r3, #16
 c21f1bc:	e1a03823 	lsr	r3, r3, #16
 c21f1c0:	e0023003 	and	r3, r2, r3
 c21f1c4:	e1a03803 	lsl	r3, r3, #16
 c21f1c8:	e1a03823 	lsr	r3, r3, #16
 c21f1cc:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 c21f1d0:	e51b3010 	ldr	r3, [fp, #-16]
 c21f1d4:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f1d8:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c21f1dc:	e1520003 	cmp	r2, r3
 c21f1e0:	1a000038 	bne	c21f2c8 <OSFlagPost+0x330>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 c21f1e4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f1e8:	e51b0010 	ldr	r0, [fp, #-16]
 c21f1ec:	e1a01003 	mov	r1, r3
 c21f1f0:	eb000129 	bl	c21f69c <OS_FlagTaskRdy>
 c21f1f4:	e1a03000 	mov	r3, r0
 c21f1f8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
                     if (rdy == TRUE) {                       
 c21f1fc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21f200:	e3530001 	cmp	r3, #1
 c21f204:	1a000031 	bne	c21f2d0 <OSFlagPost+0x338>
                         sched = TRUE;                        /* When done we will reschedule          */
 c21f208:	e3a03001 	mov	r3, #1
 c21f20c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                     }
                 }
                 break;
 c21f210:	ea000033 	b	c21f2e4 <OSFlagPost+0x34c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
 c21f214:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f218:	e1d330b8 	ldrh	r3, [r3, #8]
 c21f21c:	e1a03803 	lsl	r3, r3, #16
 c21f220:	e1a03823 	lsr	r3, r3, #16
 c21f224:	e1e03003 	mvn	r3, r3
 c21f228:	e1a03803 	lsl	r3, r3, #16
 c21f22c:	e1a02823 	lsr	r2, r3, #16
 c21f230:	e51b3010 	ldr	r3, [fp, #-16]
 c21f234:	e1d331b0 	ldrh	r3, [r3, #16]
 c21f238:	e1a03803 	lsl	r3, r3, #16
 c21f23c:	e1a03823 	lsr	r3, r3, #16
 c21f240:	e0023003 	and	r3, r2, r3
 c21f244:	e1a03803 	lsl	r3, r3, #16
 c21f248:	e1a03823 	lsr	r3, r3, #16
 c21f24c:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
                 if (flags_rdy != (OS_FLAGS)0) {
 c21f250:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f254:	e3530000 	cmp	r3, #0
 c21f258:	0a00001e 	beq	c21f2d8 <OSFlagPost+0x340>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 c21f25c:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c21f260:	e51b0010 	ldr	r0, [fp, #-16]
 c21f264:	e1a01003 	mov	r1, r3
 c21f268:	eb00010b 	bl	c21f69c <OS_FlagTaskRdy>
 c21f26c:	e1a03000 	mov	r3, r0
 c21f270:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
                     if (rdy == TRUE) {                       
 c21f274:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21f278:	e3530001 	cmp	r3, #1
 c21f27c:	1a000017 	bne	c21f2e0 <OSFlagPost+0x348>
                         sched = TRUE;                        /* When done we will reschedule          */
 c21f280:	e3a03001 	mov	r3, #1
 c21f284:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                     }
                 }
                 break;
 c21f288:	ea000015 	b	c21f2e4 <OSFlagPost+0x34c>
#endif
            default:
                 OS_EXIT_CRITICAL();
 c21f28c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f290:	e121f000 	msr	CPSR_c, r0
                 *err = OS_FLAG_ERR_WAIT_TYPE;
 c21f294:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21f298:	e3e02068 	mvn	r2, #104	; 0x68
 c21f29c:	e5c32000 	strb	r2, [r3]
                 return ((OS_FLAGS)0);
 c21f2a0:	e3a03000 	mov	r3, #0
 c21f2a4:	ea000027 	b	c21f348 <OSFlagPost+0x3b0>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                     
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
 c21f2a8:	e1a00000 	nop			; (mov r0, r0)
 c21f2ac:	ea00000c 	b	c21f2e4 <OSFlagPost+0x34c>
 c21f2b0:	e1a00000 	nop			; (mov r0, r0)
 c21f2b4:	ea00000a 	b	c21f2e4 <OSFlagPost+0x34c>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                      
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
 c21f2b8:	e1a00000 	nop			; (mov r0, r0)
 c21f2bc:	ea000008 	b	c21f2e4 <OSFlagPost+0x34c>
 c21f2c0:	e1a00000 	nop			; (mov r0, r0)
 c21f2c4:	ea000006 	b	c21f2e4 <OSFlagPost+0x34c>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                       
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
 c21f2c8:	e1a00000 	nop			; (mov r0, r0)
 c21f2cc:	ea000004 	b	c21f2e4 <OSFlagPost+0x34c>
 c21f2d0:	e1a00000 	nop			; (mov r0, r0)
 c21f2d4:	ea000002 	b	c21f2e4 <OSFlagPost+0x34c>
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                       
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
 c21f2d8:	e1a00000 	nop			; (mov r0, r0)
 c21f2dc:	ea000000 	b	c21f2e4 <OSFlagPost+0x34c>
 c21f2e0:	e1a00000 	nop			; (mov r0, r0)
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 c21f2e4:	e51b3010 	ldr	r3, [fp, #-16]
 c21f2e8:	e5933000 	ldr	r3, [r3]
 c21f2ec:	e50b3010 	str	r3, [fp, #-16]
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 c21f2f0:	e51b3010 	ldr	r3, [fp, #-16]
 c21f2f4:	e3530000 	cmp	r3, #0
 c21f2f8:	1affff70 	bne	c21f0c0 <OSFlagPost+0x128>
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
 c21f2fc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f300:	e121f000 	msr	CPSR_c, r0
    if (sched == TRUE) {
 c21f304:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c21f308:	e3530001 	cmp	r3, #1
 c21f30c:	1a000000 	bne	c21f314 <OSFlagPost+0x37c>
        OS_Sched();
 c21f310:	ebfff944 	bl	c21d828 <OS_Sched>
    }
    OS_ENTER_CRITICAL();
 c21f314:	e10f0000 	mrs	r0, CPSR
 c21f318:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21f31c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21f320:	e121f000 	msr	CPSR_c, r0
    flags_cur = pgrp->OSFlagFlags;
 c21f324:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f328:	e1d330b8 	ldrh	r3, [r3, #8]
 c21f32c:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
    OS_EXIT_CRITICAL();
 c21f330:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f334:	e121f000 	msr	CPSR_c, r0
    *err      = OS_NO_ERR;
 c21f338:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c21f33c:	e3a02000 	mov	r2, #0
 c21f340:	e5c32000 	strb	r2, [r3]
    return (flags_cur);
 c21f344:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
}
 c21f348:	e1a00003 	mov	r0, r3
 c21f34c:	e24bd00c 	sub	sp, fp, #12
 c21f350:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f354:	e12fff1e 	bx	lr

0c21f358 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *err)
{
 c21f358:	e1a0c00d 	mov	ip, sp
 c21f35c:	e92dd800 	push	{fp, ip, lr, pc}
 c21f360:	e24cb004 	sub	fp, ip, #4
 c21f364:	e24dd010 	sub	sp, sp, #16
 c21f368:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21f36c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                   /* Prevent compiler warning                          */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 c21f370:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f374:	e3530000 	cmp	r3, #0
 c21f378:	1a000004 	bne	c21f390 <OSFlagQuery+0x38>
        *err = OS_FLAG_INVALID_PGRP;
 c21f37c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f380:	e3e02069 	mvn	r2, #105	; 0x69
 c21f384:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21f388:	e3a03000 	mov	r3, #0
 c21f38c:	ea000015 	b	c21f3e8 <OSFlagQuery+0x90>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 c21f390:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f394:	e5d33000 	ldrb	r3, [r3]
 c21f398:	e3530005 	cmp	r3, #5
 c21f39c:	0a000004 	beq	c21f3b4 <OSFlagQuery+0x5c>
        *err = OS_ERR_EVENT_TYPE;
 c21f3a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f3a4:	e3a02001 	mov	r2, #1
 c21f3a8:	e5c32000 	strb	r2, [r3]
        return ((OS_FLAGS)0);
 c21f3ac:	e3a03000 	mov	r3, #0
 c21f3b0:	ea00000c 	b	c21f3e8 <OSFlagQuery+0x90>
    }
    OS_ENTER_CRITICAL();
 c21f3b4:	e10f0000 	mrs	r0, CPSR
 c21f3b8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21f3bc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21f3c0:	e121f000 	msr	CPSR_c, r0
    flags = pgrp->OSFlagFlags;
 c21f3c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f3c8:	e1d330b8 	ldrh	r3, [r3, #8]
 c21f3cc:	e14b30be 	strh	r3, [fp, #-14]
    OS_EXIT_CRITICAL();
 c21f3d0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f3d4:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c21f3d8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f3dc:	e3a02000 	mov	r2, #0
 c21f3e0:	e5c32000 	strb	r2, [r3]
    return (flags);                               /* Return the current value of the event flags       */
 c21f3e4:	e15b30be 	ldrh	r3, [fp, #-14]
}
 c21f3e8:	e1a00003 	mov	r0, r3
 c21f3ec:	e24bd00c 	sub	sp, fp, #12
 c21f3f0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f3f4:	e12fff1e 	bx	lr

0c21f3f8 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 c21f3f8:	e1a0c00d 	mov	ip, sp
 c21f3fc:	e92dd800 	push	{fp, ip, lr, pc}
 c21f400:	e24cb004 	sub	fp, ip, #4
 c21f404:	e24dd018 	sub	sp, sp, #24
 c21f408:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21f40c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c21f410:	e14b21be 	strh	r2, [fp, #-30]	; 0xffffffe2
 c21f414:	e54b301f 	strb	r3, [fp, #-31]	; 0xffffffe1
    OS_FLAG_NODE  *pnode_next;
	INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 c21f418:	e59f3180 	ldr	r3, [pc, #384]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f41c:	e5933000 	ldr	r3, [r3]
 c21f420:	e59f2178 	ldr	r2, [pc, #376]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f424:	e5922000 	ldr	r2, [r2]
 c21f428:	e5d2202c 	ldrb	r2, [r2, #44]	; 0x2c
 c21f42c:	e3822020 	orr	r2, r2, #32
 c21f430:	e20220ff 	and	r2, r2, #255	; 0xff
 c21f434:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO     = FALSE;
 c21f438:	e59f3160 	ldr	r3, [pc, #352]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f43c:	e5933000 	ldr	r3, [r3]
 c21f440:	e3a02000 	mov	r2, #0
 c21f444:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 c21f448:	e59f3150 	ldr	r3, [pc, #336]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f44c:	e5933000 	ldr	r3, [r3]
 c21f450:	e1db20b4 	ldrh	r2, [fp, #4]
 c21f454:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
 c21f458:	e59f3140 	ldr	r3, [pc, #320]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f45c:	e5933000 	ldr	r3, [r3]
 c21f460:	e3a02000 	mov	r2, #0
 c21f464:	e583201c 	str	r2, [r3, #28]
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 c21f468:	e59f3130 	ldr	r3, [pc, #304]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f46c:	e5933000 	ldr	r3, [r3]
 c21f470:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c21f474:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 c21f478:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f47c:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
 c21f480:	e1c321b0 	strh	r2, [r3, #16]
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 c21f484:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f488:	e55b201f 	ldrb	r2, [fp, #-31]	; 0xffffffe1
 c21f48c:	e5c32012 	strb	r2, [r3, #18]
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 c21f490:	e59f3108 	ldr	r3, [pc, #264]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f494:	e5932000 	ldr	r2, [r3]
 c21f498:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f49c:	e5832008 	str	r2, [r3, #8]
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 c21f4a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f4a4:	e5932004 	ldr	r2, [r3, #4]
 c21f4a8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f4ac:	e5832000 	str	r2, [r3]
    pnode->OSFlagNodePrev     = (void *)0;
 c21f4b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f4b4:	e3a02000 	mov	r2, #0
 c21f4b8:	e5832004 	str	r2, [r3, #4]
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 c21f4bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f4c0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21f4c4:	e583200c 	str	r2, [r3, #12]
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 c21f4c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f4cc:	e5933004 	ldr	r3, [r3, #4]
 c21f4d0:	e50b3010 	str	r3, [fp, #-16]
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 c21f4d4:	e51b3010 	ldr	r3, [fp, #-16]
 c21f4d8:	e3530000 	cmp	r3, #0
 c21f4dc:	0a000002 	beq	c21f4ec <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 c21f4e0:	e51b3010 	ldr	r3, [fp, #-16]
 c21f4e4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c21f4e8:	e5832004 	str	r2, [r3, #4]
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 c21f4ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f4f0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c21f4f4:	e5832004 	str	r2, [r3, #4]
                                                      
    y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
 c21f4f8:	e59f30a0 	ldr	r3, [pc, #160]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f4fc:	e5933000 	ldr	r3, [r3]
 c21f500:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21f504:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 c21f508:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c21f50c:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c21f510:	e59f108c 	ldr	r1, [pc, #140]	; c21f5a4 <OS_FlagBlock+0x1ac>
 c21f514:	e7d12002 	ldrb	r2, [r1, r2]
 c21f518:	e20210ff 	and	r1, r2, #255	; 0xff
 c21f51c:	e59f207c 	ldr	r2, [pc, #124]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f520:	e5922000 	ldr	r2, [r2]
 c21f524:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c21f528:	e20220ff 	and	r2, r2, #255	; 0xff
 c21f52c:	e1e02002 	mvn	r2, r2
 c21f530:	e20220ff 	and	r2, r2, #255	; 0xff
 c21f534:	e0012002 	and	r2, r1, r2
 c21f538:	e20220ff 	and	r2, r2, #255	; 0xff
 c21f53c:	e20210ff 	and	r1, r2, #255	; 0xff
 c21f540:	e59f205c 	ldr	r2, [pc, #92]	; c21f5a4 <OS_FlagBlock+0x1ac>
 c21f544:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0x00) {
 c21f548:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c21f54c:	e59f2050 	ldr	r2, [pc, #80]	; c21f5a4 <OS_FlagBlock+0x1ac>
 c21f550:	e7d23003 	ldrb	r3, [r2, r3]
 c21f554:	e3530000 	cmp	r3, #0
 c21f558:	1a00000d 	bne	c21f594 <OS_FlagBlock+0x19c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 c21f55c:	e59f303c 	ldr	r3, [pc, #60]	; c21f5a0 <OS_FlagBlock+0x1a8>
 c21f560:	e5933000 	ldr	r3, [r3]
 c21f564:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c21f568:	e20330ff 	and	r3, r3, #255	; 0xff
 c21f56c:	e1e03003 	mvn	r3, r3
 c21f570:	e20320ff 	and	r2, r3, #255	; 0xff
 c21f574:	e59f302c 	ldr	r3, [pc, #44]	; c21f5a8 <OS_FlagBlock+0x1b0>
 c21f578:	e5d33000 	ldrb	r3, [r3]
 c21f57c:	e20330ff 	and	r3, r3, #255	; 0xff
 c21f580:	e0023003 	and	r3, r2, r3
 c21f584:	e20330ff 	and	r3, r3, #255	; 0xff
 c21f588:	e20320ff 	and	r2, r3, #255	; 0xff
 c21f58c:	e59f3014 	ldr	r3, [pc, #20]	; c21f5a8 <OS_FlagBlock+0x1b0>
 c21f590:	e5c32000 	strb	r2, [r3]
    }
}
 c21f594:	e24bd00c 	sub	sp, fp, #12
 c21f598:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f59c:	e12fff1e 	bx	lr
 c21f5a0:	0c1c84c4 	.word	0x0c1c84c4
 c21f5a4:	0c1c84b4 	.word	0x0c1c84b4
 c21f5a8:	0c1c84b0 	.word	0x0c1c84b0

0c21f5ac <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 c21f5ac:	e1a0c00d 	mov	ip, sp
 c21f5b0:	e92dd800 	push	{fp, ip, lr, pc}
 c21f5b4:	e24cb004 	sub	fp, ip, #4
 c21f5b8:	e24dd010 	sub	sp, sp, #16
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 c21f5bc:	e59f30cc 	ldr	r3, [pc, #204]	; c21f690 <OS_FlagInit+0xe4>
 c21f5c0:	e1a00003 	mov	r0, r3
 c21f5c4:	e3a010dc 	mov	r1, #220	; 0xdc
 c21f5c8:	ebfff863 	bl	c21d75c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 c21f5cc:	e59f30bc 	ldr	r3, [pc, #188]	; c21f690 <OS_FlagInit+0xe4>
 c21f5d0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    pgrp2 = &OSFlagTbl[1];
 c21f5d4:	e59f30b8 	ldr	r3, [pc, #184]	; c21f694 <OS_FlagInit+0xe8>
 c21f5d8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 c21f5dc:	e3a03000 	mov	r3, #0
 c21f5e0:	e14b30be 	strh	r3, [fp, #-14]
 c21f5e4:	ea000014 	b	c21f63c <OS_FlagInit+0x90>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 c21f5e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f5ec:	e3a02000 	mov	r2, #0
 c21f5f0:	e5c32000 	strb	r2, [r3]
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 c21f5f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f5f8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21f5fc:	e5832004 	str	r2, [r3, #4]
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 c21f600:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f604:	e3a0203f 	mov	r2, #63	; 0x3f
 c21f608:	e5c3200a 	strb	r2, [r3, #10]
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 c21f60c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f610:	e3a02000 	mov	r2, #0
 c21f614:	e5c3200b 	strb	r2, [r3, #11]
#endif
        pgrp1++;
 c21f618:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f61c:	e283302c 	add	r3, r3, #44	; 0x2c
 c21f620:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        pgrp2++;
 c21f624:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f628:	e283302c 	add	r3, r3, #44	; 0x2c
 c21f62c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 c21f630:	e15b30be 	ldrh	r3, [fp, #-14]
 c21f634:	e2833001 	add	r3, r3, #1
 c21f638:	e14b30be 	strh	r3, [fp, #-14]
 c21f63c:	e15b30be 	ldrh	r3, [fp, #-14]
 c21f640:	e3530003 	cmp	r3, #3
 c21f644:	9affffe7 	bls	c21f5e8 <OS_FlagInit+0x3c>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 c21f648:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f64c:	e3a02000 	mov	r2, #0
 c21f650:	e5c32000 	strb	r2, [r3]
    pgrp1->OSFlagWaitList = (void *)0;
 c21f654:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f658:	e3a02000 	mov	r2, #0
 c21f65c:	e5832004 	str	r2, [r3, #4]
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 c21f660:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f664:	e3a0203f 	mov	r2, #63	; 0x3f
 c21f668:	e5c3200a 	strb	r2, [r3, #10]
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 c21f66c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f670:	e3a02000 	mov	r2, #0
 c21f674:	e5c3200b 	strb	r2, [r3, #11]
#endif
    OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
 c21f678:	e59f3018 	ldr	r3, [pc, #24]	; c21f698 <OS_FlagInit+0xec>
 c21f67c:	e59f200c 	ldr	r2, [pc, #12]	; c21f690 <OS_FlagInit+0xe4>
 c21f680:	e5832000 	str	r2, [r3]
#endif
}
 c21f684:	e24bd00c 	sub	sp, fp, #12
 c21f688:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f68c:	e12fff1e 	bx	lr
 c21f690:	0c1c7a48 	.word	0x0c1c7a48
 c21f694:	0c1c7a74 	.word	0x0c1c7a74
 c21f698:	0c1c979c 	.word	0x0c1c979c

0c21f69c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 c21f69c:	e1a0c00d 	mov	ip, sp
 c21f6a0:	e92dd800 	push	{fp, ip, lr, pc}
 c21f6a4:	e24cb004 	sub	fp, ip, #4
 c21f6a8:	e24dd010 	sub	sp, sp, #16
 c21f6ac:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21f6b0:	e1a03001 	mov	r3, r1
 c21f6b4:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
 c21f6b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f6bc:	e5933008 	ldr	r3, [r3, #8]
 c21f6c0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    ptcb->OSTCBDly      = 0;
 c21f6c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f6c8:	e3a02000 	mov	r2, #0
 c21f6cc:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    ptcb->OSTCBFlagsRdy = flags_rdy;
 c21f6d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f6d4:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c21f6d8:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
 c21f6dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f6e0:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21f6e4:	e3c33020 	bic	r3, r3, #32
 c21f6e8:	e20320ff 	and	r2, r3, #255	; 0xff
 c21f6ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f6f0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    ptcb->OSTCBPendTO   = FALSE;
 c21f6f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f6f8:	e3a02000 	mov	r2, #0
 c21f6fc:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 c21f700:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f704:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c21f708:	e3530000 	cmp	r3, #0
 c21f70c:	1a000016 	bne	c21f76c <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 c21f710:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f714:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c21f718:	e59f3070 	ldr	r3, [pc, #112]	; c21f790 <OS_FlagTaskRdy+0xf4>
 c21f71c:	e5d33000 	ldrb	r3, [r3]
 c21f720:	e1823003 	orr	r3, r2, r3
 c21f724:	e20320ff 	and	r2, r3, #255	; 0xff
 c21f728:	e59f3060 	ldr	r3, [pc, #96]	; c21f790 <OS_FlagTaskRdy+0xf4>
 c21f72c:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c21f730:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f734:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c21f738:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21f73c:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c21f740:	e59f104c 	ldr	r1, [pc, #76]	; c21f794 <OS_FlagTaskRdy+0xf8>
 c21f744:	e7d11002 	ldrb	r1, [r1, r2]
 c21f748:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21f74c:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c21f750:	e1812002 	orr	r2, r1, r2
 c21f754:	e20210ff 	and	r1, r2, #255	; 0xff
 c21f758:	e59f2034 	ldr	r2, [pc, #52]	; c21f794 <OS_FlagTaskRdy+0xf8>
 c21f75c:	e7c21003 	strb	r1, [r2, r3]
        sched                   = TRUE;
 c21f760:	e3a03001 	mov	r3, #1
 c21f764:	e54b300d 	strb	r3, [fp, #-13]
 c21f768:	ea000001 	b	c21f774 <OS_FlagTaskRdy+0xd8>
    } else {
        sched                   = FALSE;
 c21f76c:	e3a03000 	mov	r3, #0
 c21f770:	e54b300d 	strb	r3, [fp, #-13]
    }
    OS_FlagUnlink(pnode);
 c21f774:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21f778:	eb000006 	bl	c21f798 <OS_FlagUnlink>
    return (sched);
 c21f77c:	e55b300d 	ldrb	r3, [fp, #-13]
}
 c21f780:	e1a00003 	mov	r0, r3
 c21f784:	e24bd00c 	sub	sp, fp, #12
 c21f788:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f78c:	e12fff1e 	bx	lr
 c21f790:	0c1c84b0 	.word	0x0c1c84b0
 c21f794:	0c1c84b4 	.word	0x0c1c84b4

0c21f798 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 c21f798:	e1a0c00d 	mov	ip, sp
 c21f79c:	e92dd800 	push	{fp, ip, lr, pc}
 c21f7a0:	e24cb004 	sub	fp, ip, #4
 c21f7a4:	e24dd018 	sub	sp, sp, #24
 c21f7a8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 c21f7ac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f7b0:	e5933004 	ldr	r3, [r3, #4]
 c21f7b4:	e50b3010 	str	r3, [fp, #-16]
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 c21f7b8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f7bc:	e5933000 	ldr	r3, [r3]
 c21f7c0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 c21f7c4:	e51b3010 	ldr	r3, [fp, #-16]
 c21f7c8:	e3530000 	cmp	r3, #0
 c21f7cc:	1a00000c 	bne	c21f804 <OS_FlagUnlink+0x6c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 c21f7d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f7d4:	e593300c 	ldr	r3, [r3, #12]
 c21f7d8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 c21f7dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f7e0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21f7e4:	e5832004 	str	r2, [r3, #4]
        if (pnode_next != (OS_FLAG_NODE *)0) {
 c21f7e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f7ec:	e3530000 	cmp	r3, #0
 c21f7f0:	0a00000c 	beq	c21f828 <OS_FlagUnlink+0x90>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 c21f7f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f7f8:	e3a02000 	mov	r2, #0
 c21f7fc:	e5832004 	str	r2, [r3, #4]
 c21f800:	ea000008 	b	c21f828 <OS_FlagUnlink+0x90>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 c21f804:	e51b3010 	ldr	r3, [fp, #-16]
 c21f808:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21f80c:	e5832000 	str	r2, [r3]
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 c21f810:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f814:	e3530000 	cmp	r3, #0
 c21f818:	0a000002 	beq	c21f828 <OS_FlagUnlink+0x90>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 c21f81c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21f820:	e51b2010 	ldr	r2, [fp, #-16]
 c21f824:	e5832004 	str	r2, [r3, #4]
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 c21f828:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f82c:	e5933008 	ldr	r3, [r3, #8]
 c21f830:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 c21f834:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c21f838:	e3a02000 	mov	r2, #0
 c21f83c:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif
}
 c21f840:	e24bd00c 	sub	sp, fp, #12
 c21f844:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f848:	e12fff1e 	bx	lr

0c21f84c <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
 c21f84c:	e1a0c00d 	mov	ip, sp
 c21f850:	e92dd800 	push	{fp, ip, lr, pc}
 c21f854:	e24cb004 	sub	fp, ip, #4
 c21f858:	e24dd010 	sub	sp, sp, #16
 c21f85c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8


    cpu_sr = 0;                                           /* Prevent compiler warning                  */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
 c21f860:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f864:	e3530000 	cmp	r3, #0
 c21f868:	1a000001 	bne	c21f874 <OSMboxAccept+0x28>
        return ((void *)0);
 c21f86c:	e3a03000 	mov	r3, #0
 c21f870:	ea000012 	b	c21f8c0 <OSMboxAccept+0x74>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
 c21f874:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f878:	e5d33000 	ldrb	r3, [r3]
 c21f87c:	e3530001 	cmp	r3, #1
 c21f880:	0a000001 	beq	c21f88c <OSMboxAccept+0x40>
        return ((void *)0);
 c21f884:	e3a03000 	mov	r3, #0
 c21f888:	ea00000c 	b	c21f8c0 <OSMboxAccept+0x74>
    }
    OS_ENTER_CRITICAL();
 c21f88c:	e10f0000 	mrs	r0, CPSR
 c21f890:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21f894:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21f898:	e121f000 	msr	CPSR_c, r0
    msg                = pevent->OSEventPtr;
 c21f89c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f8a0:	e5933004 	ldr	r3, [r3, #4]
 c21f8a4:	e50b3010 	str	r3, [fp, #-16]
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
 c21f8a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f8ac:	e3a02000 	mov	r2, #0
 c21f8b0:	e5832004 	str	r2, [r3, #4]
    OS_EXIT_CRITICAL();
 c21f8b4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f8b8:	e121f000 	msr	CPSR_c, r0
    return (msg);                                         /* Return the message received (or NULL)     */
 c21f8bc:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21f8c0:	e1a00003 	mov	r0, r3
 c21f8c4:	e24bd00c 	sub	sp, fp, #12
 c21f8c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f8cc:	e12fff1e 	bx	lr

0c21f8d0 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
 c21f8d0:	e1a0c00d 	mov	ip, sp
 c21f8d4:	e92dd800 	push	{fp, ip, lr, pc}
 c21f8d8:	e24cb004 	sub	fp, ip, #4
 c21f8dc:	e24dd010 	sub	sp, sp, #16
 c21f8e0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 c21f8e4:	e59f30c0 	ldr	r3, [pc, #192]	; c21f9ac <OSMboxCreate+0xdc>
 c21f8e8:	e5d33000 	ldrb	r3, [r3]
 c21f8ec:	e3530000 	cmp	r3, #0
 c21f8f0:	0a000001 	beq	c21f8fc <OSMboxCreate+0x2c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 c21f8f4:	e3a03000 	mov	r3, #0
 c21f8f8:	ea000027 	b	c21f99c <OSMboxCreate+0xcc>
    }
    OS_ENTER_CRITICAL();
 c21f8fc:	e10f0000 	mrs	r0, CPSR
 c21f900:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21f904:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21f908:	e121f000 	msr	CPSR_c, r0
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 c21f90c:	e59f309c 	ldr	r3, [pc, #156]	; c21f9b0 <OSMboxCreate+0xe0>
 c21f910:	e5933000 	ldr	r3, [r3]
 c21f914:	e50b3010 	str	r3, [fp, #-16]
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 c21f918:	e59f3090 	ldr	r3, [pc, #144]	; c21f9b0 <OSMboxCreate+0xe0>
 c21f91c:	e5933000 	ldr	r3, [r3]
 c21f920:	e3530000 	cmp	r3, #0
 c21f924:	0a000005 	beq	c21f940 <OSMboxCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 c21f928:	e59f3080 	ldr	r3, [pc, #128]	; c21f9b0 <OSMboxCreate+0xe0>
 c21f92c:	e5933000 	ldr	r3, [r3]
 c21f930:	e5933004 	ldr	r3, [r3, #4]
 c21f934:	e1a02003 	mov	r2, r3
 c21f938:	e59f3070 	ldr	r3, [pc, #112]	; c21f9b0 <OSMboxCreate+0xe0>
 c21f93c:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
 c21f940:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21f944:	e121f000 	msr	CPSR_c, r0
    if (pevent != (OS_EVENT *)0) {
 c21f948:	e51b3010 	ldr	r3, [fp, #-16]
 c21f94c:	e3530000 	cmp	r3, #0
 c21f950:	0a000010 	beq	c21f998 <OSMboxCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
 c21f954:	e51b3010 	ldr	r3, [fp, #-16]
 c21f958:	e3a02001 	mov	r2, #1
 c21f95c:	e5c32000 	strb	r2, [r3]
        pevent->OSEventCnt     = 0;
 c21f960:	e51b3010 	ldr	r3, [fp, #-16]
 c21f964:	e3a02000 	mov	r2, #0
 c21f968:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
 c21f96c:	e51b3010 	ldr	r3, [fp, #-16]
 c21f970:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21f974:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
 c21f978:	e51b3010 	ldr	r3, [fp, #-16]
 c21f97c:	e3a0203f 	mov	r2, #63	; 0x3f
 c21f980:	e5c32010 	strb	r2, [r3, #16]
        pevent->OSEventName[1] = OS_ASCII_NUL;
 c21f984:	e51b3010 	ldr	r3, [fp, #-16]
 c21f988:	e3a02000 	mov	r2, #0
 c21f98c:	e5c32011 	strb	r2, [r3, #17]
#endif
        OS_EventWaitListInit(pevent);
 c21f990:	e51b0010 	ldr	r0, [fp, #-16]
 c21f994:	ebfff62b 	bl	c21d248 <OS_EventWaitListInit>
    }
    return (pevent);                             /* Return pointer to event control block              */
 c21f998:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21f99c:	e1a00003 	mov	r0, r3
 c21f9a0:	e24bd00c 	sub	sp, fp, #12
 c21f9a4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21f9a8:	e12fff1e 	bx	lr
 c21f9ac:	0c1c84c0 	.word	0x0c1c84c0
 c21f9b0:	0c1c84bc 	.word	0x0c1c84bc

0c21f9b4 <OSMboxDel>:
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
 c21f9b4:	e1a0c00d 	mov	ip, sp
 c21f9b8:	e92dd800 	push	{fp, ip, lr, pc}
 c21f9bc:	e24cb004 	sub	fp, ip, #4
 c21f9c0:	e24dd018 	sub	sp, sp, #24
 c21f9c4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21f9c8:	e1a03001 	mov	r3, r1
 c21f9cc:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c21f9d0:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c21f9d4:	e59f3204 	ldr	r3, [pc, #516]	; c21fbe0 <OSMboxDel+0x22c>
 c21f9d8:	e5d33000 	ldrb	r3, [r3]
 c21f9dc:	e3530000 	cmp	r3, #0
 c21f9e0:	0a000004 	beq	c21f9f8 <OSMboxDel+0x44>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 c21f9e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21f9e8:	e3e02073 	mvn	r2, #115	; 0x73
 c21f9ec:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c21f9f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f9f4:	ea000075 	b	c21fbd0 <OSMboxDel+0x21c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c21f9f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21f9fc:	e3530000 	cmp	r3, #0
 c21fa00:	1a000004 	bne	c21fa18 <OSMboxDel+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c21fa04:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fa08:	e3a02004 	mov	r2, #4
 c21fa0c:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c21fa10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fa14:	ea00006d 	b	c21fbd0 <OSMboxDel+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 c21fa18:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fa1c:	e5d33000 	ldrb	r3, [r3]
 c21fa20:	e3530001 	cmp	r3, #1
 c21fa24:	0a000004 	beq	c21fa3c <OSMboxDel+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c21fa28:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fa2c:	e3a02001 	mov	r2, #1
 c21fa30:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c21fa34:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fa38:	ea000064 	b	c21fbd0 <OSMboxDel+0x21c>
    }
    OS_ENTER_CRITICAL();
 c21fa3c:	e10f0000 	mrs	r0, CPSR
 c21fa40:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21fa44:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21fa48:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                      /* See if any tasks waiting on mailbox      */
 c21fa4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fa50:	e5d33001 	ldrb	r3, [r3, #1]
 c21fa54:	e3530000 	cmp	r3, #0
 c21fa58:	0a000002 	beq	c21fa68 <OSMboxDel+0xb4>
        tasks_waiting = TRUE;                              /* Yes                                      */
 c21fa5c:	e3a03001 	mov	r3, #1
 c21fa60:	e54b300d 	strb	r3, [fp, #-13]
 c21fa64:	ea000001 	b	c21fa70 <OSMboxDel+0xbc>
    } else {
        tasks_waiting = FALSE;                             /* No                                       */
 c21fa68:	e3a03000 	mov	r3, #0
 c21fa6c:	e54b300d 	strb	r3, [fp, #-13]
    }
    switch (opt) {
 c21fa70:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c21fa74:	e3530000 	cmp	r3, #0
 c21fa78:	0a000002 	beq	c21fa88 <OSMboxDel+0xd4>
 c21fa7c:	e3530001 	cmp	r3, #1
 c21fa80:	0a000029 	beq	c21fb2c <OSMboxDel+0x178>
 c21fa84:	ea00004b 	b	c21fbb8 <OSMboxDel+0x204>
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == FALSE) {
 c21fa88:	e55b300d 	ldrb	r3, [fp, #-13]
 c21fa8c:	e3530000 	cmp	r3, #0
 c21fa90:	1a000019 	bne	c21fafc <OSMboxDel+0x148>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 c21fa94:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fa98:	e3a0203f 	mov	r2, #63	; 0x3f
 c21fa9c:	e5c32010 	strb	r2, [r3, #16]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 c21faa0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21faa4:	e3a02000 	mov	r2, #0
 c21faa8:	e5c32011 	strb	r2, [r3, #17]
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 c21faac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fab0:	e3a02000 	mov	r2, #0
 c21fab4:	e5c32000 	strb	r2, [r3]
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 c21fab8:	e59f3124 	ldr	r3, [pc, #292]	; c21fbe4 <OSMboxDel+0x230>
 c21fabc:	e5932000 	ldr	r2, [r3]
 c21fac0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fac4:	e5832004 	str	r2, [r3, #4]
                 pevent->OSEventCnt  = 0;
 c21fac8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21facc:	e3a02000 	mov	r2, #0
 c21fad0:	e1c320b2 	strh	r2, [r3, #2]
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
 c21fad4:	e59f3108 	ldr	r3, [pc, #264]	; c21fbe4 <OSMboxDel+0x230>
 c21fad8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21fadc:	e5832000 	str	r2, [r3]
                 OS_EXIT_CRITICAL();
 c21fae0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fae4:	e121f000 	msr	CPSR_c, r0
                 *err                = OS_NO_ERR;
 c21fae8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21faec:	e3a02000 	mov	r2, #0
 c21faf0:	e5c32000 	strb	r2, [r3]
                 return ((OS_EVENT *)0);                   /* Mailbox has been deleted                 */
 c21faf4:	e3a03000 	mov	r3, #0
 c21faf8:	ea000034 	b	c21fbd0 <OSMboxDel+0x21c>
             } else {
                 OS_EXIT_CRITICAL();
 c21fafc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fb00:	e121f000 	msr	CPSR_c, r0
                 *err                = OS_ERR_TASK_WAITING;
 c21fb04:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fb08:	e3a02008 	mov	r2, #8
 c21fb0c:	e5c32000 	strb	r2, [r3]
                 return (pevent);
 c21fb10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb14:	ea00002d 	b	c21fbd0 <OSMboxDel+0x21c>
             }

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX);
 c21fb18:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21fb1c:	e3a01000 	mov	r1, #0
 c21fb20:	e3a02002 	mov	r2, #2
 c21fb24:	ebfff4a9 	bl	c21cdd0 <OS_EventTaskRdy>
 c21fb28:	ea000000 	b	c21fb30 <OSMboxDel+0x17c>
                 *err                = OS_ERR_TASK_WAITING;
                 return (pevent);
             }

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for mailbox      */
 c21fb2c:	e1a00000 	nop			; (mov r0, r0)
 c21fb30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb34:	e5d33001 	ldrb	r3, [r3, #1]
 c21fb38:	e3530000 	cmp	r3, #0
 c21fb3c:	1afffff5 	bne	c21fb18 <OSMboxDel+0x164>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 c21fb40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb44:	e3a0203f 	mov	r2, #63	; 0x3f
 c21fb48:	e5c32010 	strb	r2, [r3, #16]
             pevent->OSEventName[1] = OS_ASCII_NUL;
 c21fb4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb50:	e3a02000 	mov	r2, #0
 c21fb54:	e5c32011 	strb	r2, [r3, #17]
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c21fb58:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb5c:	e3a02000 	mov	r2, #0
 c21fb60:	e5c32000 	strb	r2, [r3]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 c21fb64:	e59f3078 	ldr	r3, [pc, #120]	; c21fbe4 <OSMboxDel+0x230>
 c21fb68:	e5932000 	ldr	r2, [r3]
 c21fb6c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb70:	e5832004 	str	r2, [r3, #4]
             pevent->OSEventCnt     = 0;
 c21fb74:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fb78:	e3a02000 	mov	r2, #0
 c21fb7c:	e1c320b2 	strh	r2, [r3, #2]
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 c21fb80:	e59f305c 	ldr	r3, [pc, #92]	; c21fbe4 <OSMboxDel+0x230>
 c21fb84:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c21fb88:	e5832000 	str	r2, [r3]
             OS_EXIT_CRITICAL();
 c21fb8c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fb90:	e121f000 	msr	CPSR_c, r0
             if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
 c21fb94:	e55b300d 	ldrb	r3, [fp, #-13]
 c21fb98:	e3530001 	cmp	r3, #1
 c21fb9c:	1a000000 	bne	c21fba4 <OSMboxDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 c21fba0:	ebfff720 	bl	c21d828 <OS_Sched>
             }
             *err = OS_NO_ERR;
 c21fba4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fba8:	e3a02000 	mov	r2, #0
 c21fbac:	e5c32000 	strb	r2, [r3]
             return ((OS_EVENT *)0);                       /* Mailbox has been deleted                 */
 c21fbb0:	e3a03000 	mov	r3, #0
 c21fbb4:	ea000005 	b	c21fbd0 <OSMboxDel+0x21c>

        default:
             OS_EXIT_CRITICAL();
 c21fbb8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fbbc:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_INVALID_OPT;
 c21fbc0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fbc4:	e3a02007 	mov	r2, #7
 c21fbc8:	e5c32000 	strb	r2, [r3]
             return (pevent);
 c21fbcc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    }
}
 c21fbd0:	e1a00003 	mov	r0, r3
 c21fbd4:	e24bd00c 	sub	sp, fp, #12
 c21fbd8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21fbdc:	e12fff1e 	bx	lr
 c21fbe0:	0c1c84c0 	.word	0x0c1c84c0
 c21fbe4:	0c1c84bc 	.word	0x0c1c84bc

0c21fbe8 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
 c21fbe8:	e1a0c00d 	mov	ip, sp
 c21fbec:	e92dd800 	push	{fp, ip, lr, pc}
 c21fbf0:	e24cb004 	sub	fp, ip, #4
 c21fbf4:	e24dd018 	sub	sp, sp, #24
 c21fbf8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21fbfc:	e1a03001 	mov	r3, r1
 c21fc00:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c21fc04:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 c21fc08:	e59f31b4 	ldr	r3, [pc, #436]	; c21fdc4 <OSMboxPend+0x1dc>
 c21fc0c:	e5d33000 	ldrb	r3, [r3]
 c21fc10:	e3530000 	cmp	r3, #0
 c21fc14:	0a000004 	beq	c21fc2c <OSMboxPend+0x44>
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
 c21fc18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fc1c:	e3a02002 	mov	r2, #2
 c21fc20:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c21fc24:	e3a03000 	mov	r3, #0
 c21fc28:	ea000061 	b	c21fdb4 <OSMboxPend+0x1cc>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c21fc2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fc30:	e3530000 	cmp	r3, #0
 c21fc34:	1a000004 	bne	c21fc4c <OSMboxPend+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c21fc38:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fc3c:	e3a02004 	mov	r2, #4
 c21fc40:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c21fc44:	e3a03000 	mov	r3, #0
 c21fc48:	ea000059 	b	c21fdb4 <OSMboxPend+0x1cc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 c21fc4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fc50:	e5d33000 	ldrb	r3, [r3]
 c21fc54:	e3530001 	cmp	r3, #1
 c21fc58:	0a000004 	beq	c21fc70 <OSMboxPend+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c21fc5c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fc60:	e3a02001 	mov	r2, #1
 c21fc64:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c21fc68:	e3a03000 	mov	r3, #0
 c21fc6c:	ea000050 	b	c21fdb4 <OSMboxPend+0x1cc>
    }
    OS_ENTER_CRITICAL();
 c21fc70:	e10f0000 	mrs	r0, CPSR
 c21fc74:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21fc78:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21fc7c:	e121f000 	msr	CPSR_c, r0
    msg = pevent->OSEventPtr;
 c21fc80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fc84:	e5933004 	ldr	r3, [r3, #4]
 c21fc88:	e50b3010 	str	r3, [fp, #-16]
    if (msg != (void *)0) {                           /* See if there is already a message             */
 c21fc8c:	e51b3010 	ldr	r3, [fp, #-16]
 c21fc90:	e3530000 	cmp	r3, #0
 c21fc94:	0a000009 	beq	c21fcc0 <OSMboxPend+0xd8>
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
 c21fc98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fc9c:	e3a02000 	mov	r2, #0
 c21fca0:	e5832004 	str	r2, [r3, #4]
        OS_EXIT_CRITICAL();
 c21fca4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fca8:	e121f000 	msr	CPSR_c, r0
        *err = OS_NO_ERR;
 c21fcac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fcb0:	e3a02000 	mov	r2, #0
 c21fcb4:	e5c32000 	strb	r2, [r3]
        return (msg);                                 /* Return the message received (or NULL)         */
 c21fcb8:	e51b3010 	ldr	r3, [fp, #-16]
 c21fcbc:	ea00003c 	b	c21fdb4 <OSMboxPend+0x1cc>
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
 c21fcc0:	e59f3100 	ldr	r3, [pc, #256]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fcc4:	e5933000 	ldr	r3, [r3]
 c21fcc8:	e59f20f8 	ldr	r2, [pc, #248]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fccc:	e5922000 	ldr	r2, [r2]
 c21fcd0:	e5d2202c 	ldrb	r2, [r2, #44]	; 0x2c
 c21fcd4:	e3822002 	orr	r2, r2, #2
 c21fcd8:	e20220ff 	and	r2, r2, #255	; 0xff
 c21fcdc:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO = FALSE;
 c21fce0:	e59f30e0 	ldr	r3, [pc, #224]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fce4:	e5933000 	ldr	r3, [r3]
 c21fce8:	e3a02000 	mov	r2, #0
 c21fcec:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
 c21fcf0:	e59f30d0 	ldr	r3, [pc, #208]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fcf4:	e5933000 	ldr	r3, [r3]
 c21fcf8:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c21fcfc:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 c21fd00:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21fd04:	ebfff4b4 	bl	c21cfdc <OS_EventTaskWait>
    OS_EXIT_CRITICAL();
 c21fd08:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fd0c:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                       /* Find next highest priority task ready to run  */
 c21fd10:	ebfff6c4 	bl	c21d828 <OS_Sched>
    OS_ENTER_CRITICAL();
 c21fd14:	e10f0000 	mrs	r0, CPSR
 c21fd18:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21fd1c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21fd20:	e121f000 	msr	CPSR_c, r0
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we were given the message              */
 c21fd24:	e59f309c 	ldr	r3, [pc, #156]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fd28:	e5933000 	ldr	r3, [r3]
 c21fd2c:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
 c21fd30:	e3530001 	cmp	r3, #1
 c21fd34:	1a000008 	bne	c21fd5c <OSMboxPend+0x174>
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
 c21fd38:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c21fd3c:	ebfff4fc 	bl	c21d134 <OS_EventTO>
        OS_EXIT_CRITICAL();
 c21fd40:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fd44:	e121f000 	msr	CPSR_c, r0
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
 c21fd48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fd4c:	e3a0200a 	mov	r2, #10
 c21fd50:	e5c32000 	strb	r2, [r3]
        return ((void *)0);                           /* Return a NULL message                         */
 c21fd54:	e3a03000 	mov	r3, #0
 c21fd58:	ea000015 	b	c21fdb4 <OSMboxPend+0x1cc>
    }
    msg                     = OSTCBCur->OSTCBMsg;
 c21fd5c:	e59f3064 	ldr	r3, [pc, #100]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fd60:	e5933000 	ldr	r3, [r3]
 c21fd64:	e5933020 	ldr	r3, [r3, #32]
 c21fd68:	e50b3010 	str	r3, [fp, #-16]
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
 c21fd6c:	e59f3054 	ldr	r3, [pc, #84]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fd70:	e5933000 	ldr	r3, [r3]
 c21fd74:	e3a02000 	mov	r2, #0
 c21fd78:	e5832020 	str	r2, [r3, #32]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
 c21fd7c:	e59f3044 	ldr	r3, [pc, #68]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fd80:	e5933000 	ldr	r3, [r3]
 c21fd84:	e3a02000 	mov	r2, #0
 c21fd88:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
 c21fd8c:	e59f3034 	ldr	r3, [pc, #52]	; c21fdc8 <OSMboxPend+0x1e0>
 c21fd90:	e5933000 	ldr	r3, [r3]
 c21fd94:	e3a02000 	mov	r2, #0
 c21fd98:	e583201c 	str	r2, [r3, #28]
    OS_EXIT_CRITICAL();
 c21fd9c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fda0:	e121f000 	msr	CPSR_c, r0
    *err                    = OS_NO_ERR;
 c21fda4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c21fda8:	e3a02000 	mov	r2, #0
 c21fdac:	e5c32000 	strb	r2, [r3]
    return (msg);                                     /* Return the message received                   */
 c21fdb0:	e51b3010 	ldr	r3, [fp, #-16]
}
 c21fdb4:	e1a00003 	mov	r0, r3
 c21fdb8:	e24bd00c 	sub	sp, fp, #12
 c21fdbc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21fdc0:	e12fff1e 	bx	lr
 c21fdc4:	0c1c84c0 	.word	0x0c1c84c0
 c21fdc8:	0c1c84c4 	.word	0x0c1c84c4

0c21fdcc <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
 c21fdcc:	e1a0c00d 	mov	ip, sp
 c21fdd0:	e92dd800 	push	{fp, ip, lr, pc}
 c21fdd4:	e24cb004 	sub	fp, ip, #4
 c21fdd8:	e24dd008 	sub	sp, sp, #8
 c21fddc:	e50b0010 	str	r0, [fp, #-16]
 c21fde0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

    
    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c21fde4:	e51b3010 	ldr	r3, [fp, #-16]
 c21fde8:	e3530000 	cmp	r3, #0
 c21fdec:	1a000001 	bne	c21fdf8 <OSMboxPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c21fdf0:	e3a03004 	mov	r3, #4
 c21fdf4:	ea000029 	b	c21fea0 <OSMboxPost+0xd4>
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
 c21fdf8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21fdfc:	e3530000 	cmp	r3, #0
 c21fe00:	1a000001 	bne	c21fe0c <OSMboxPost+0x40>
        return (OS_ERR_POST_NULL_PTR);
 c21fe04:	e3a03003 	mov	r3, #3
 c21fe08:	ea000024 	b	c21fea0 <OSMboxPost+0xd4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 c21fe0c:	e51b3010 	ldr	r3, [fp, #-16]
 c21fe10:	e5d33000 	ldrb	r3, [r3]
 c21fe14:	e3530001 	cmp	r3, #1
 c21fe18:	0a000001 	beq	c21fe24 <OSMboxPost+0x58>
        return (OS_ERR_EVENT_TYPE);
 c21fe1c:	e3a03001 	mov	r3, #1
 c21fe20:	ea00001e 	b	c21fea0 <OSMboxPost+0xd4>
    }
    OS_ENTER_CRITICAL();
 c21fe24:	e10f0000 	mrs	r0, CPSR
 c21fe28:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21fe2c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21fe30:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                     /* See if any task pending on mailbox        */
 c21fe34:	e51b3010 	ldr	r3, [fp, #-16]
 c21fe38:	e5d33001 	ldrb	r3, [r3, #1]
 c21fe3c:	e3530000 	cmp	r3, #0
 c21fe40:	0a000008 	beq	c21fe68 <OSMboxPost+0x9c>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
 c21fe44:	e51b0010 	ldr	r0, [fp, #-16]
 c21fe48:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c21fe4c:	e3a02002 	mov	r2, #2
 c21fe50:	ebfff3de 	bl	c21cdd0 <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
 c21fe54:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fe58:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                   /* Find highest priority task ready to run       */
 c21fe5c:	ebfff671 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c21fe60:	e3a03000 	mov	r3, #0
 c21fe64:	ea00000d 	b	c21fea0 <OSMboxPost+0xd4>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 c21fe68:	e51b3010 	ldr	r3, [fp, #-16]
 c21fe6c:	e5933004 	ldr	r3, [r3, #4]
 c21fe70:	e3530000 	cmp	r3, #0
 c21fe74:	0a000003 	beq	c21fe88 <OSMboxPost+0xbc>
        OS_EXIT_CRITICAL();
 c21fe78:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fe7c:	e121f000 	msr	CPSR_c, r0
        return (OS_MBOX_FULL);
 c21fe80:	e3a03014 	mov	r3, #20
 c21fe84:	ea000005 	b	c21fea0 <OSMboxPost+0xd4>
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
 c21fe88:	e51b3010 	ldr	r3, [fp, #-16]
 c21fe8c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21fe90:	e5832004 	str	r2, [r3, #4]
    OS_EXIT_CRITICAL();
 c21fe94:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21fe98:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c21fe9c:	e3a03000 	mov	r3, #0
}
 c21fea0:	e1a00003 	mov	r0, r3
 c21fea4:	e24bd00c 	sub	sp, fp, #12
 c21fea8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21feac:	e12fff1e 	bx	lr

0c21feb0 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
 c21feb0:	e1a0c00d 	mov	ip, sp
 c21feb4:	e92dd800 	push	{fp, ip, lr, pc}
 c21feb8:	e24cb004 	sub	fp, ip, #4
 c21febc:	e24dd010 	sub	sp, sp, #16
 c21fec0:	e50b0010 	str	r0, [fp, #-16]
 c21fec4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c21fec8:	e1a03002 	mov	r3, r2
 c21fecc:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    

    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c21fed0:	e51b3010 	ldr	r3, [fp, #-16]
 c21fed4:	e3530000 	cmp	r3, #0
 c21fed8:	1a000001 	bne	c21fee4 <OSMboxPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 c21fedc:	e3a03004 	mov	r3, #4
 c21fee0:	ea000038 	b	c21ffc8 <OSMboxPostOpt+0x118>
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
 c21fee4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c21fee8:	e3530000 	cmp	r3, #0
 c21feec:	1a000001 	bne	c21fef8 <OSMboxPostOpt+0x48>
        return (OS_ERR_POST_NULL_PTR);
 c21fef0:	e3a03003 	mov	r3, #3
 c21fef4:	ea000033 	b	c21ffc8 <OSMboxPostOpt+0x118>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 c21fef8:	e51b3010 	ldr	r3, [fp, #-16]
 c21fefc:	e5d33000 	ldrb	r3, [r3]
 c21ff00:	e3530001 	cmp	r3, #1
 c21ff04:	0a000001 	beq	c21ff10 <OSMboxPostOpt+0x60>
        return (OS_ERR_EVENT_TYPE);
 c21ff08:	e3a03001 	mov	r3, #1
 c21ff0c:	ea00002d 	b	c21ffc8 <OSMboxPostOpt+0x118>
    }
    OS_ENTER_CRITICAL();
 c21ff10:	e10f0000 	mrs	r0, CPSR
 c21ff14:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c21ff18:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c21ff1c:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
 c21ff20:	e51b3010 	ldr	r3, [fp, #-16]
 c21ff24:	e5d33001 	ldrb	r3, [r3, #1]
 c21ff28:	e3530000 	cmp	r3, #0
 c21ff2c:	0a000017 	beq	c21ff90 <OSMboxPostOpt+0xe0>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 c21ff30:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c21ff34:	e2033001 	and	r3, r3, #1
 c21ff38:	e20330ff 	and	r3, r3, #255	; 0xff
 c21ff3c:	e3530000 	cmp	r3, #0
 c21ff40:	0a000009 	beq	c21ff6c <OSMboxPostOpt+0xbc>
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
 c21ff44:	ea000003 	b	c21ff58 <OSMboxPostOpt+0xa8>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
 c21ff48:	e51b0010 	ldr	r0, [fp, #-16]
 c21ff4c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c21ff50:	e3a02002 	mov	r2, #2
 c21ff54:	ebfff39d 	bl	c21cdd0 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
 c21ff58:	e51b3010 	ldr	r3, [fp, #-16]
 c21ff5c:	e5d33001 	ldrb	r3, [r3, #1]
 c21ff60:	e3530000 	cmp	r3, #0
 c21ff64:	1afffff7 	bne	c21ff48 <OSMboxPostOpt+0x98>
 c21ff68:	ea000003 	b	c21ff7c <OSMboxPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
 c21ff6c:	e51b0010 	ldr	r0, [fp, #-16]
 c21ff70:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c21ff74:	e3a02002 	mov	r2, #2
 c21ff78:	ebfff394 	bl	c21cdd0 <OS_EventTaskRdy>
        }
        OS_EXIT_CRITICAL();
 c21ff7c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ff80:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                            /* Find HPT ready to run                */
 c21ff84:	ebfff627 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c21ff88:	e3a03000 	mov	r3, #0
 c21ff8c:	ea00000d 	b	c21ffc8 <OSMboxPostOpt+0x118>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 c21ff90:	e51b3010 	ldr	r3, [fp, #-16]
 c21ff94:	e5933004 	ldr	r3, [r3, #4]
 c21ff98:	e3530000 	cmp	r3, #0
 c21ff9c:	0a000003 	beq	c21ffb0 <OSMboxPostOpt+0x100>
        OS_EXIT_CRITICAL();
 c21ffa0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ffa4:	e121f000 	msr	CPSR_c, r0
        return (OS_MBOX_FULL);
 c21ffa8:	e3a03014 	mov	r3, #20
 c21ffac:	ea000005 	b	c21ffc8 <OSMboxPostOpt+0x118>
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
 c21ffb0:	e51b3010 	ldr	r3, [fp, #-16]
 c21ffb4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c21ffb8:	e5832004 	str	r2, [r3, #4]
    OS_EXIT_CRITICAL();
 c21ffbc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c21ffc0:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c21ffc4:	e3a03000 	mov	r3, #0
}
 c21ffc8:	e1a00003 	mov	r0, r3
 c21ffcc:	e24bd00c 	sub	sp, fp, #12
 c21ffd0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c21ffd4:	e12fff1e 	bx	lr

0c21ffd8 <OSMboxQuery>:
*********************************************************************************************************
*/

#if OS_MBOX_QUERY_EN > 0
INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
{
 c21ffd8:	e1a0c00d 	mov	ip, sp
 c21ffdc:	e92dd800 	push	{fp, ip, lr, pc}
 c21ffe0:	e24cb004 	sub	fp, ip, #4
 c21ffe4:	e24dd010 	sub	sp, sp, #16
 c21ffe8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c21ffec:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c21fff0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c21fff4:	e3530000 	cmp	r3, #0
 c21fff8:	1a000001 	bne	c220004 <OSMboxQuery+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c21fffc:	e3a03004 	mov	r3, #4
 c220000:	ea000064 	b	c220198 <OSMboxQuery+0x1c0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 c220004:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220008:	e5d33000 	ldrb	r3, [r3]
 c22000c:	e3530001 	cmp	r3, #1
 c220010:	0a000001 	beq	c22001c <OSMboxQuery+0x44>
        return (OS_ERR_EVENT_TYPE);
 c220014:	e3a03001 	mov	r3, #1
 c220018:	ea00005e 	b	c220198 <OSMboxQuery+0x1c0>
    }
    OS_ENTER_CRITICAL();
 c22001c:	e10f0000 	mrs	r0, CPSR
 c220020:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220024:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c220028:	e121f000 	msr	CPSR_c, r0
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
 c22002c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220030:	e5d32001 	ldrb	r2, [r3, #1]
 c220034:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220038:	e5c3200c 	strb	r2, [r3, #12]
    psrc                    = &pevent->OSEventTbl[0];
 c22003c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220040:	e2833008 	add	r3, r3, #8
 c220044:	e50b3010 	str	r3, [fp, #-16]
    pdest                   = &p_mbox_data->OSEventTbl[0];
 c220048:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22004c:	e2833004 	add	r3, r3, #4
 c220050:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

#if OS_EVENT_TBL_SIZE > 0
    *pdest++ = *psrc++;
 c220054:	e51b3010 	ldr	r3, [fp, #-16]
 c220058:	e5d32000 	ldrb	r2, [r3]
 c22005c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220060:	e5c32000 	strb	r2, [r3]
 c220064:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220068:	e2833001 	add	r3, r3, #1
 c22006c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c220070:	e51b3010 	ldr	r3, [fp, #-16]
 c220074:	e2833001 	add	r3, r3, #1
 c220078:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 1
    *pdest++ = *psrc++;
 c22007c:	e51b3010 	ldr	r3, [fp, #-16]
 c220080:	e5d32000 	ldrb	r2, [r3]
 c220084:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220088:	e5c32000 	strb	r2, [r3]
 c22008c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220090:	e2833001 	add	r3, r3, #1
 c220094:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c220098:	e51b3010 	ldr	r3, [fp, #-16]
 c22009c:	e2833001 	add	r3, r3, #1
 c2200a0:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 2
    *pdest++ = *psrc++;
 c2200a4:	e51b3010 	ldr	r3, [fp, #-16]
 c2200a8:	e5d32000 	ldrb	r2, [r3]
 c2200ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2200b0:	e5c32000 	strb	r2, [r3]
 c2200b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2200b8:	e2833001 	add	r3, r3, #1
 c2200bc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2200c0:	e51b3010 	ldr	r3, [fp, #-16]
 c2200c4:	e2833001 	add	r3, r3, #1
 c2200c8:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 3
    *pdest++ = *psrc++;
 c2200cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2200d0:	e5d32000 	ldrb	r2, [r3]
 c2200d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2200d8:	e5c32000 	strb	r2, [r3]
 c2200dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2200e0:	e2833001 	add	r3, r3, #1
 c2200e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2200e8:	e51b3010 	ldr	r3, [fp, #-16]
 c2200ec:	e2833001 	add	r3, r3, #1
 c2200f0:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 4
    *pdest++ = *psrc++;
 c2200f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2200f8:	e5d32000 	ldrb	r2, [r3]
 c2200fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220100:	e5c32000 	strb	r2, [r3]
 c220104:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220108:	e2833001 	add	r3, r3, #1
 c22010c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c220110:	e51b3010 	ldr	r3, [fp, #-16]
 c220114:	e2833001 	add	r3, r3, #1
 c220118:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 5
    *pdest++ = *psrc++;
 c22011c:	e51b3010 	ldr	r3, [fp, #-16]
 c220120:	e5d32000 	ldrb	r2, [r3]
 c220124:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220128:	e5c32000 	strb	r2, [r3]
 c22012c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220130:	e2833001 	add	r3, r3, #1
 c220134:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c220138:	e51b3010 	ldr	r3, [fp, #-16]
 c22013c:	e2833001 	add	r3, r3, #1
 c220140:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 6
    *pdest++ = *psrc++;
 c220144:	e51b3010 	ldr	r3, [fp, #-16]
 c220148:	e5d32000 	ldrb	r2, [r3]
 c22014c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220150:	e5c32000 	strb	r2, [r3]
 c220154:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220158:	e2833001 	add	r3, r3, #1
 c22015c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c220160:	e51b3010 	ldr	r3, [fp, #-16]
 c220164:	e2833001 	add	r3, r3, #1
 c220168:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 7
    *pdest   = *psrc;
 c22016c:	e51b3010 	ldr	r3, [fp, #-16]
 c220170:	e5d32000 	ldrb	r2, [r3]
 c220174:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220178:	e5c32000 	strb	r2, [r3]
#endif
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
 c22017c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220180:	e5932004 	ldr	r2, [r3, #4]
 c220184:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220188:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
 c22018c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220190:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c220194:	e3a03000 	mov	r3, #0
}
 c220198:	e1a00003 	mov	r0, r3
 c22019c:	e24bd00c 	sub	sp, fp, #12
 c2201a0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2201a4:	e12fff1e 	bx	lr

0c2201a8 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *err)
{
 c2201a8:	e1a0c00d 	mov	ip, sp
 c2201ac:	e92dd800 	push	{fp, ip, lr, pc}
 c2201b0:	e24cb004 	sub	fp, ip, #4
 c2201b4:	e24dd020 	sub	sp, sp, #32
 c2201b8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c2201bc:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
 c2201c0:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
 c2201c4:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4


    cpu_sr = 0;                                       /* Prevent compiler warning                       */
#endif    
#if OS_ARG_CHK_EN > 0
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part. */
 c2201c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2201cc:	e3530000 	cmp	r3, #0
 c2201d0:	1a000004 	bne	c2201e8 <OSMemCreate+0x40>
        *err = OS_MEM_INVALID_ADDR;
 c2201d4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c2201d8:	e3a02076 	mov	r2, #118	; 0x76
 c2201dc:	e5c32000 	strb	r2, [r3]
        return ((OS_MEM *)0);
 c2201e0:	e3a03000 	mov	r3, #0
 c2201e4:	ea00005a 	b	c220354 <OSMemCreate+0x1ac>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition      */
 c2201e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2201ec:	e3530001 	cmp	r3, #1
 c2201f0:	8a000004 	bhi	c220208 <OSMemCreate+0x60>
        *err = OS_MEM_INVALID_BLKS;
 c2201f4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c2201f8:	e3a0206f 	mov	r2, #111	; 0x6f
 c2201fc:	e5c32000 	strb	r2, [r3]
        return ((OS_MEM *)0);
 c220200:	e3a03000 	mov	r3, #0
 c220204:	ea000052 	b	c220354 <OSMemCreate+0x1ac>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer      */
 c220208:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c22020c:	e3530003 	cmp	r3, #3
 c220210:	8a000004 	bhi	c220228 <OSMemCreate+0x80>
        *err = OS_MEM_INVALID_SIZE;
 c220214:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c220218:	e3a02070 	mov	r2, #112	; 0x70
 c22021c:	e5c32000 	strb	r2, [r3]
        return ((OS_MEM *)0);
 c220220:	e3a03000 	mov	r3, #0
 c220224:	ea00004a 	b	c220354 <OSMemCreate+0x1ac>
    }
#endif
    OS_ENTER_CRITICAL();
 c220228:	e10f0000 	mrs	r0, CPSR
 c22022c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220230:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c220234:	e121f000 	msr	CPSR_c, r0
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 c220238:	e59f3124 	ldr	r3, [pc, #292]	; c220364 <OSMemCreate+0x1bc>
 c22023c:	e5933000 	ldr	r3, [r3]
 c220240:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 c220244:	e59f3118 	ldr	r3, [pc, #280]	; c220364 <OSMemCreate+0x1bc>
 c220248:	e5933000 	ldr	r3, [r3]
 c22024c:	e3530000 	cmp	r3, #0
 c220250:	0a000005 	beq	c22026c <OSMemCreate+0xc4>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 c220254:	e59f3108 	ldr	r3, [pc, #264]	; c220364 <OSMemCreate+0x1bc>
 c220258:	e5933000 	ldr	r3, [r3]
 c22025c:	e5933004 	ldr	r3, [r3, #4]
 c220260:	e1a02003 	mov	r2, r3
 c220264:	e59f30f8 	ldr	r3, [pc, #248]	; c220364 <OSMemCreate+0x1bc>
 c220268:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
 c22026c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220270:	e121f000 	msr	CPSR_c, r0
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 c220274:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220278:	e3530000 	cmp	r3, #0
 c22027c:	1a000004 	bne	c220294 <OSMemCreate+0xec>
        *err = OS_MEM_INVALID_PART;
 c220280:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c220284:	e3a0206e 	mov	r2, #110	; 0x6e
 c220288:	e5c32000 	strb	r2, [r3]
        return ((OS_MEM *)0);
 c22028c:	e3a03000 	mov	r3, #0
 c220290:	ea00002f 	b	c220354 <OSMemCreate+0x1ac>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 c220294:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220298:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    pblk  = (INT8U *)((INT32U)addr + blksize);
 c22029c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c2202a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c2202a4:	e0823003 	add	r3, r2, r3
 c2202a8:	e50b3010 	str	r3, [fp, #-16]
    for (i = 0; i < (nblks - 1); i++) {
 c2202ac:	e3a03000 	mov	r3, #0
 c2202b0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c2202b4:	ea00000b 	b	c2202e8 <OSMemCreate+0x140>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 c2202b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2202bc:	e51b2010 	ldr	r2, [fp, #-16]
 c2202c0:	e5832000 	str	r2, [r3]
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 c2202c4:	e51b3010 	ldr	r3, [fp, #-16]
 c2202c8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 c2202cc:	e51b2010 	ldr	r2, [fp, #-16]
 c2202d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c2202d4:	e0823003 	add	r3, r2, r3
 c2202d8:	e50b3010 	str	r3, [fp, #-16]
        *err = OS_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 c2202dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2202e0:	e2833001 	add	r3, r3, #1
 c2202e4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c2202e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2202ec:	e2432001 	sub	r2, r3, #1
 c2202f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2202f4:	e1520003 	cmp	r2, r3
 c2202f8:	8affffee 	bhi	c2202b8 <OSMemCreate+0x110>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 c2202fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220300:	e3a02000 	mov	r2, #0
 c220304:	e5832000 	str	r2, [r3]
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 c220308:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22030c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c220310:	e5832000 	str	r2, [r3]
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 c220314:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220318:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c22031c:	e5832004 	str	r2, [r3, #4]
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 c220320:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220324:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
 c220328:	e5832010 	str	r2, [r3, #16]
    pmem->OSMemNBlks    = nblks;
 c22032c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220330:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
 c220334:	e583200c 	str	r2, [r3, #12]
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 c220338:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22033c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c220340:	e5832008 	str	r2, [r3, #8]
    *err                = OS_NO_ERR;
 c220344:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c220348:	e3a02000 	mov	r2, #0
 c22034c:	e5c32000 	strb	r2, [r3]
    return (pmem);
 c220350:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
 c220354:	e1a00003 	mov	r0, r3
 c220358:	e24bd00c 	sub	sp, fp, #12
 c22035c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220360:	e12fff1e 	bx	lr
 c220364:	0c1c8444 	.word	0x0c1c8444

0c220368 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *err)
{
 c220368:	e1a0c00d 	mov	ip, sp
 c22036c:	e92dd800 	push	{fp, ip, lr, pc}
 c220370:	e24cb004 	sub	fp, ip, #4
 c220374:	e24dd010 	sub	sp, sp, #16
 c220378:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c22037c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                       /* Prevent compiler warning                       */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition         */
 c220380:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220384:	e3530000 	cmp	r3, #0
 c220388:	1a000004 	bne	c2203a0 <OSMemGet+0x38>
        *err = OS_MEM_INVALID_PMEM;
 c22038c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220390:	e3a02074 	mov	r2, #116	; 0x74
 c220394:	e5c32000 	strb	r2, [r3]
        return ((OS_MEM *)0);
 c220398:	e3a03000 	mov	r3, #0
 c22039c:	ea000020 	b	c220424 <OSMemGet+0xbc>
    }
#endif
    OS_ENTER_CRITICAL();
 c2203a0:	e10f0000 	mrs	r0, CPSR
 c2203a4:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2203a8:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2203ac:	e121f000 	msr	CPSR_c, r0
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 c2203b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2203b4:	e5933010 	ldr	r3, [r3, #16]
 c2203b8:	e3530000 	cmp	r3, #0
 c2203bc:	0a000012 	beq	c22040c <OSMemGet+0xa4>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 c2203c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2203c4:	e5933004 	ldr	r3, [r3, #4]
 c2203c8:	e50b3010 	str	r3, [fp, #-16]
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 c2203cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2203d0:	e5932000 	ldr	r2, [r3]
 c2203d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2203d8:	e5832004 	str	r2, [r3, #4]
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 c2203dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2203e0:	e5933010 	ldr	r3, [r3, #16]
 c2203e4:	e2432001 	sub	r2, r3, #1
 c2203e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2203ec:	e5832010 	str	r2, [r3, #16]
        OS_EXIT_CRITICAL();
 c2203f0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2203f4:	e121f000 	msr	CPSR_c, r0
        *err = OS_NO_ERR;                             /*      No error                                 */
 c2203f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2203fc:	e3a02000 	mov	r2, #0
 c220400:	e5c32000 	strb	r2, [r3]
        return (pblk);                                /*      Return memory block to caller            */
 c220404:	e51b3010 	ldr	r3, [fp, #-16]
 c220408:	ea000005 	b	c220424 <OSMemGet+0xbc>
    }
    OS_EXIT_CRITICAL();
 c22040c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220410:	e121f000 	msr	CPSR_c, r0
    *err = OS_MEM_NO_FREE_BLKS;                       /* No,  Notify caller of empty memory partition  */
 c220414:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220418:	e3a02071 	mov	r2, #113	; 0x71
 c22041c:	e5c32000 	strb	r2, [r3]
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 c220420:	e3a03000 	mov	r3, #0
}
 c220424:	e1a00003 	mov	r0, r3
 c220428:	e24bd00c 	sub	sp, fp, #12
 c22042c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220430:	e12fff1e 	bx	lr

0c220434 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, char *pname, INT8U *err)
{
 c220434:	e1a0c00d 	mov	ip, sp
 c220438:	e92dd800 	push	{fp, ip, lr, pc}
 c22043c:	e24cb004 	sub	fp, ip, #4
 c220440:	e24dd018 	sub	sp, sp, #24
 c220444:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c220448:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c22044c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c220450:	e10f0000 	mrs	r0, CPSR
 c220454:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220458:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c22045c:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 c220460:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220464:	e3530000 	cmp	r3, #0
 c220468:	1a000006 	bne	c220488 <OSMemNameGet+0x54>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c22046c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220470:	e121f000 	msr	CPSR_c, r0
        *err = OS_MEM_INVALID_PMEM;
 c220474:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220478:	e3a02074 	mov	r2, #116	; 0x74
 c22047c:	e5c32000 	strb	r2, [r3]
        return (0);
 c220480:	e3a03000 	mov	r3, #0
 c220484:	ea000016 	b	c2204e4 <OSMemNameGet+0xb0>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c220488:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22048c:	e3530000 	cmp	r3, #0
 c220490:	1a000006 	bne	c2204b0 <OSMemNameGet+0x7c>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c220494:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220498:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c22049c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2204a0:	e3a0200f 	mov	r2, #15
 c2204a4:	e5c32000 	strb	r2, [r3]
        return (0);
 c2204a8:	e3a03000 	mov	r3, #0
 c2204ac:	ea00000c 	b	c2204e4 <OSMemNameGet+0xb0>
    }
#endif
    len  = OS_StrCopy(pname, pmem->OSMemName);   /* Copy name from OS_MEM                              */
 c2204b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2204b4:	e2833014 	add	r3, r3, #20
 c2204b8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c2204bc:	e1a01003 	mov	r1, r3
 c2204c0:	ebfff520 	bl	c21d948 <OS_StrCopy>
 c2204c4:	e1a03000 	mov	r3, r0
 c2204c8:	e54b300d 	strb	r3, [fp, #-13]
    OS_EXIT_CRITICAL();
 c2204cc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2204d0:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c2204d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2204d8:	e3a02000 	mov	r2, #0
 c2204dc:	e5c32000 	strb	r2, [r3]
    return (len);
 c2204e0:	e55b300d 	ldrb	r3, [fp, #-13]
}
 c2204e4:	e1a00003 	mov	r0, r3
 c2204e8:	e24bd00c 	sub	sp, fp, #12
 c2204ec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2204f0:	e12fff1e 	bx	lr

0c2204f4 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, char *pname, INT8U *err)
{
 c2204f4:	e1a0c00d 	mov	ip, sp
 c2204f8:	e92dd800 	push	{fp, ip, lr, pc}
 c2204fc:	e24cb004 	sub	fp, ip, #4
 c220500:	e24dd018 	sub	sp, sp, #24
 c220504:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c220508:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c22050c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c220510:	e10f0000 	mrs	r0, CPSR
 c220514:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220518:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c22051c:	e121f000 	msr	CPSR_c, r0
#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 c220520:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220524:	e3530000 	cmp	r3, #0
 c220528:	1a000005 	bne	c220544 <OSMemNameSet+0x50>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c22052c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220530:	e121f000 	msr	CPSR_c, r0
        *err = OS_MEM_INVALID_PMEM;
 c220534:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220538:	e3a02074 	mov	r2, #116	; 0x74
 c22053c:	e5c32000 	strb	r2, [r3]
        return;
 c220540:	ea00001f 	b	c2205c4 <OSMemNameSet+0xd0>
    }
    if (pname == (char *)0) {                    /* Is 'pname' a NULL pointer?                         */
 c220544:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220548:	e3530000 	cmp	r3, #0
 c22054c:	1a000005 	bne	c220568 <OSMemNameSet+0x74>
        OS_EXIT_CRITICAL();                      /* Yes                                                */
 c220550:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220554:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_PNAME_NULL;
 c220558:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22055c:	e3a0200f 	mov	r2, #15
 c220560:	e5c32000 	strb	r2, [r3]
        return;
 c220564:	ea000016 	b	c2205c4 <OSMemNameSet+0xd0>
    }
#endif
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 c220568:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c22056c:	ebfff517 	bl	c21d9d0 <OS_StrLen>
 c220570:	e1a03000 	mov	r3, r0
 c220574:	e54b300d 	strb	r3, [fp, #-13]
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 c220578:	e55b300d 	ldrb	r3, [fp, #-13]
 c22057c:	e353001f 	cmp	r3, #31
 c220580:	9a000005 	bls	c22059c <OSMemNameSet+0xa8>
        OS_EXIT_CRITICAL();
 c220584:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220588:	e121f000 	msr	CPSR_c, r0
        *err = OS_MEM_NAME_TOO_LONG;
 c22058c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220590:	e3a02077 	mov	r2, #119	; 0x77
 c220594:	e5c32000 	strb	r2, [r3]
        return;
 c220598:	ea000009 	b	c2205c4 <OSMemNameSet+0xd0>
    } 
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 c22059c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2205a0:	e2833014 	add	r3, r3, #20
 c2205a4:	e1a00003 	mov	r0, r3
 c2205a8:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c2205ac:	ebfff4e5 	bl	c21d948 <OS_StrCopy>
    OS_EXIT_CRITICAL();
 c2205b0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2205b4:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c2205b8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2205bc:	e3a02000 	mov	r2, #0
 c2205c0:	e5c32000 	strb	r2, [r3]
}
 c2205c4:	e24bd00c 	sub	sp, fp, #12
 c2205c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2205cc:	e12fff1e 	bx	lr

0c2205d0 <OSMemPut>:
*               OS_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 c2205d0:	e1a0c00d 	mov	ip, sp
 c2205d4:	e92dd800 	push	{fp, ip, lr, pc}
 c2205d8:	e24cb004 	sub	fp, ip, #4
 c2205dc:	e24dd008 	sub	sp, sp, #8
 c2205e0:	e50b0010 	str	r0, [fp, #-16]
 c2205e4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 c2205e8:	e51b3010 	ldr	r3, [fp, #-16]
 c2205ec:	e3530000 	cmp	r3, #0
 c2205f0:	1a000001 	bne	c2205fc <OSMemPut+0x2c>
        return (OS_MEM_INVALID_PMEM);
 c2205f4:	e3a03074 	mov	r3, #116	; 0x74
 c2205f8:	ea000021 	b	c220684 <OSMemPut+0xb4>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 c2205fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220600:	e3530000 	cmp	r3, #0
 c220604:	1a000001 	bne	c220610 <OSMemPut+0x40>
        return (OS_MEM_INVALID_PBLK);
 c220608:	e3a03073 	mov	r3, #115	; 0x73
 c22060c:	ea00001c 	b	c220684 <OSMemPut+0xb4>
    }
#endif
    OS_ENTER_CRITICAL();
 c220610:	e10f0000 	mrs	r0, CPSR
 c220614:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220618:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c22061c:	e121f000 	msr	CPSR_c, r0
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 c220620:	e51b3010 	ldr	r3, [fp, #-16]
 c220624:	e5932010 	ldr	r2, [r3, #16]
 c220628:	e51b3010 	ldr	r3, [fp, #-16]
 c22062c:	e593300c 	ldr	r3, [r3, #12]
 c220630:	e1520003 	cmp	r2, r3
 c220634:	3a000003 	bcc	c220648 <OSMemPut+0x78>
        OS_EXIT_CRITICAL();
 c220638:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22063c:	e121f000 	msr	CPSR_c, r0
        return (OS_MEM_FULL);
 c220640:	e3a03072 	mov	r3, #114	; 0x72
 c220644:	ea00000e 	b	c220684 <OSMemPut+0xb4>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 c220648:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22064c:	e51b2010 	ldr	r2, [fp, #-16]
 c220650:	e5922004 	ldr	r2, [r2, #4]
 c220654:	e5832000 	str	r2, [r3]
    pmem->OSMemFreeList = pblk;
 c220658:	e51b3010 	ldr	r3, [fp, #-16]
 c22065c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c220660:	e5832004 	str	r2, [r3, #4]
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 c220664:	e51b3010 	ldr	r3, [fp, #-16]
 c220668:	e5933010 	ldr	r3, [r3, #16]
 c22066c:	e2832001 	add	r2, r3, #1
 c220670:	e51b3010 	ldr	r3, [fp, #-16]
 c220674:	e5832010 	str	r2, [r3, #16]
    OS_EXIT_CRITICAL();
 c220678:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22067c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);                          /* Notify caller that memory block was released       */
 c220680:	e3a03000 	mov	r3, #0
}
 c220684:	e1a00003 	mov	r0, r3
 c220688:	e24bd00c 	sub	sp, fp, #12
 c22068c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220690:	e12fff1e 	bx	lr

0c220694 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 c220694:	e1a0c00d 	mov	ip, sp
 c220698:	e92dd800 	push	{fp, ip, lr, pc}
 c22069c:	e24cb004 	sub	fp, ip, #4
 c2206a0:	e24dd008 	sub	sp, sp, #8
 c2206a4:	e50b0010 	str	r0, [fp, #-16]
 c2206a8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 c2206ac:	e51b3010 	ldr	r3, [fp, #-16]
 c2206b0:	e3530000 	cmp	r3, #0
 c2206b4:	1a000001 	bne	c2206c0 <OSMemQuery+0x2c>
        return (OS_MEM_INVALID_PMEM);
 c2206b8:	e3a03074 	mov	r3, #116	; 0x74
 c2206bc:	ea000026 	b	c22075c <OSMemQuery+0xc8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 c2206c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2206c4:	e3530000 	cmp	r3, #0
 c2206c8:	1a000001 	bne	c2206d4 <OSMemQuery+0x40>
        return (OS_MEM_INVALID_PDATA);
 c2206cc:	e3a03075 	mov	r3, #117	; 0x75
 c2206d0:	ea000021 	b	c22075c <OSMemQuery+0xc8>
    }
#endif
    OS_ENTER_CRITICAL();
 c2206d4:	e10f0000 	mrs	r0, CPSR
 c2206d8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2206dc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2206e0:	e121f000 	msr	CPSR_c, r0
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 c2206e4:	e51b3010 	ldr	r3, [fp, #-16]
 c2206e8:	e5932000 	ldr	r2, [r3]
 c2206ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2206f0:	e5832000 	str	r2, [r3]
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 c2206f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2206f8:	e5932004 	ldr	r2, [r3, #4]
 c2206fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220700:	e5832004 	str	r2, [r3, #4]
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 c220704:	e51b3010 	ldr	r3, [fp, #-16]
 c220708:	e5932008 	ldr	r2, [r3, #8]
 c22070c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220710:	e5832008 	str	r2, [r3, #8]
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 c220714:	e51b3010 	ldr	r3, [fp, #-16]
 c220718:	e593200c 	ldr	r2, [r3, #12]
 c22071c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220720:	e583200c 	str	r2, [r3, #12]
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 c220724:	e51b3010 	ldr	r3, [fp, #-16]
 c220728:	e5932010 	ldr	r2, [r3, #16]
 c22072c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220730:	e5832010 	str	r2, [r3, #16]
    OS_EXIT_CRITICAL();
 c220734:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220738:	e121f000 	msr	CPSR_c, r0
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 c22073c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220740:	e593200c 	ldr	r2, [r3, #12]
 c220744:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220748:	e5933010 	ldr	r3, [r3, #16]
 c22074c:	e0632002 	rsb	r2, r3, r2
 c220750:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220754:	e5832014 	str	r2, [r3, #20]
    return (OS_NO_ERR);
 c220758:	e3a03000 	mov	r3, #0
}
 c22075c:	e1a00003 	mov	r0, r3
 c220760:	e24bd00c 	sub	sp, fp, #12
 c220764:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220768:	e12fff1e 	bx	lr

0c22076c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 c22076c:	e1a0c00d 	mov	ip, sp
 c220770:	e92dd800 	push	{fp, ip, lr, pc}
 c220774:	e24cb004 	sub	fp, ip, #4
 c220778:	e24dd008 	sub	sp, sp, #8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl)); /* Clear the memory partition table            */
 c22077c:	e59f30c8 	ldr	r3, [pc, #200]	; c22084c <OS_MemInit+0xe0>
 c220780:	e1a00003 	mov	r0, r3
 c220784:	e3a01f41 	mov	r1, #260	; 0x104
 c220788:	ebfff3f3 	bl	c21d75c <OS_MemClr>
    pmem = (OS_MEM *)&OSMemTbl[0];                      /* Point to memory control block (MCB)         */
 c22078c:	e59f30b8 	ldr	r3, [pc, #184]	; c22084c <OS_MemInit+0xe0>
 c220790:	e50b3010 	str	r3, [fp, #-16]
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {       /* Init. list of free memory partitions        */
 c220794:	e3a03000 	mov	r3, #0
 c220798:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c22079c:	ea000018 	b	c220804 <OS_MemInit+0x98>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];   /* Chain list of free partitions               */
 c2207a0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c2207a4:	e2832001 	add	r2, r3, #1
 c2207a8:	e1a03002 	mov	r3, r2
 c2207ac:	e1a03083 	lsl	r3, r3, #1
 c2207b0:	e0833002 	add	r3, r3, r2
 c2207b4:	e1a03103 	lsl	r3, r3, #2
 c2207b8:	e0833002 	add	r3, r3, r2
 c2207bc:	e1a03103 	lsl	r3, r3, #2
 c2207c0:	e1a02003 	mov	r2, r3
 c2207c4:	e59f3080 	ldr	r3, [pc, #128]	; c22084c <OS_MemInit+0xe0>
 c2207c8:	e0822003 	add	r2, r2, r3
 c2207cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2207d0:	e5832004 	str	r2, [r3, #4]
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                      /* Unknown name                                */
 c2207d4:	e51b3010 	ldr	r3, [fp, #-16]
 c2207d8:	e3a0203f 	mov	r2, #63	; 0x3f
 c2207dc:	e5c32014 	strb	r2, [r3, #20]
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 c2207e0:	e51b3010 	ldr	r3, [fp, #-16]
 c2207e4:	e3a02000 	mov	r2, #0
 c2207e8:	e5c32015 	strb	r2, [r3, #21]
#endif
        pmem++;
 c2207ec:	e51b3010 	ldr	r3, [fp, #-16]
 c2207f0:	e2833034 	add	r3, r3, #52	; 0x34
 c2207f4:	e50b3010 	str	r3, [fp, #-16]
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl)); /* Clear the memory partition table            */
    pmem = (OS_MEM *)&OSMemTbl[0];                      /* Point to memory control block (MCB)         */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {       /* Init. list of free memory partitions        */
 c2207f8:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c2207fc:	e2833001 	add	r3, r3, #1
 c220800:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c220804:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c220808:	e3530003 	cmp	r3, #3
 c22080c:	9affffe3 	bls	c2207a0 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                      /* Unknown name                                */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                    /* Initialize last node                        */
 c220810:	e51b3010 	ldr	r3, [fp, #-16]
 c220814:	e3a02000 	mov	r2, #0
 c220818:	e5832004 	str	r2, [r3, #4]
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                          /* Unknown name                                */
 c22081c:	e51b3010 	ldr	r3, [fp, #-16]
 c220820:	e3a0203f 	mov	r2, #63	; 0x3f
 c220824:	e5c32014 	strb	r2, [r3, #20]
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 c220828:	e51b3010 	ldr	r3, [fp, #-16]
 c22082c:	e3a02000 	mov	r2, #0
 c220830:	e5c32015 	strb	r2, [r3, #21]
#endif

    OSMemFreeList       = (OS_MEM *)&OSMemTbl[0];       /* Point to beginning of free list             */
 c220834:	e59f3014 	ldr	r3, [pc, #20]	; c220850 <OS_MemInit+0xe4>
 c220838:	e59f200c 	ldr	r2, [pc, #12]	; c22084c <OS_MemInit+0xe0>
 c22083c:	e5832000 	str	r2, [r3]
#endif
}
 c220840:	e24bd00c 	sub	sp, fp, #12
 c220844:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220848:	e12fff1e 	bx	lr
 c22084c:	0c1c7b2c 	.word	0x0c1c7b2c
 c220850:	0c1c8444 	.word	0x0c1c8444

0c220854 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
INT8U  OSMutexAccept (OS_EVENT *pevent, INT8U *err)
{
 c220854:	e1a0c00d 	mov	ip, sp
 c220858:	e92dd800 	push	{fp, ip, lr, pc}
 c22085c:	e24cb004 	sub	fp, ip, #4
 c220860:	e24dd008 	sub	sp, sp, #8
 c220864:	e50b0010 	str	r0, [fp, #-16]
 c220868:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

    
    
    cpu_sr = 0;                                        /* Prevent compiler warning                     */
#endif    
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
 c22086c:	e59f311c 	ldr	r3, [pc, #284]	; c220990 <OSMutexAccept+0x13c>
 c220870:	e5d33000 	ldrb	r3, [r3]
 c220874:	e3530000 	cmp	r3, #0
 c220878:	0a000004 	beq	c220890 <OSMutexAccept+0x3c>
        *err = OS_ERR_PEND_ISR;
 c22087c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220880:	e3a02002 	mov	r2, #2
 c220884:	e5c32000 	strb	r2, [r3]
        return (0);
 c220888:	e3a03000 	mov	r3, #0
 c22088c:	ea00003b 	b	c220980 <OSMutexAccept+0x12c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 c220890:	e51b3010 	ldr	r3, [fp, #-16]
 c220894:	e3530000 	cmp	r3, #0
 c220898:	1a000004 	bne	c2208b0 <OSMutexAccept+0x5c>
        *err = OS_ERR_PEVENT_NULL;
 c22089c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2208a0:	e3a02004 	mov	r2, #4
 c2208a4:	e5c32000 	strb	r2, [r3]
        return (0);
 c2208a8:	e3a03000 	mov	r3, #0
 c2208ac:	ea000033 	b	c220980 <OSMutexAccept+0x12c>
    }
#endif                                                     
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
 c2208b0:	e51b3010 	ldr	r3, [fp, #-16]
 c2208b4:	e5d33000 	ldrb	r3, [r3]
 c2208b8:	e3530004 	cmp	r3, #4
 c2208bc:	0a000004 	beq	c2208d4 <OSMutexAccept+0x80>
        *err = OS_ERR_EVENT_TYPE;
 c2208c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2208c4:	e3a02001 	mov	r2, #1
 c2208c8:	e5c32000 	strb	r2, [r3]
        return (0);
 c2208cc:	e3a03000 	mov	r3, #0
 c2208d0:	ea00002a 	b	c220980 <OSMutexAccept+0x12c>
    }
    OS_ENTER_CRITICAL();							   /* Get value (0 or 1) of Mutex                  */
 c2208d4:	e10f0000 	mrs	r0, CPSR
 c2208d8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2208dc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2208e0:	e121f000 	msr	CPSR_c, r0
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {     
 c2208e4:	e51b3010 	ldr	r3, [fp, #-16]
 c2208e8:	e1d330b2 	ldrh	r3, [r3, #2]
 c2208ec:	e20330ff 	and	r3, r3, #255	; 0xff
 c2208f0:	e35300ff 	cmp	r3, #255	; 0xff
 c2208f4:	1a00001b 	bne	c220968 <OSMutexAccept+0x114>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
 c2208f8:	e51b3010 	ldr	r3, [fp, #-16]
 c2208fc:	e1d330b2 	ldrh	r3, [r3, #2]
 c220900:	e3c330ff 	bic	r3, r3, #255	; 0xff
 c220904:	e1a03803 	lsl	r3, r3, #16
 c220908:	e1a02823 	lsr	r2, r3, #16
 c22090c:	e51b3010 	ldr	r3, [fp, #-16]
 c220910:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
 c220914:	e51b3010 	ldr	r3, [fp, #-16]
 c220918:	e1d320b2 	ldrh	r2, [r3, #2]
 c22091c:	e59f3070 	ldr	r3, [pc, #112]	; c220994 <OSMutexAccept+0x140>
 c220920:	e5933000 	ldr	r3, [r3]
 c220924:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c220928:	e1823003 	orr	r3, r2, r3
 c22092c:	e1a03803 	lsl	r3, r3, #16
 c220930:	e1a02823 	lsr	r2, r3, #16
 c220934:	e51b3010 	ldr	r3, [fp, #-16]
 c220938:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
 c22093c:	e59f3050 	ldr	r3, [pc, #80]	; c220994 <OSMutexAccept+0x140>
 c220940:	e5932000 	ldr	r2, [r3]
 c220944:	e51b3010 	ldr	r3, [fp, #-16]
 c220948:	e5832004 	str	r2, [r3, #4]
        OS_EXIT_CRITICAL();
 c22094c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220950:	e121f000 	msr	CPSR_c, r0
        *err = OS_NO_ERR;
 c220954:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220958:	e3a02000 	mov	r2, #0
 c22095c:	e5c32000 	strb	r2, [r3]
        return (1);
 c220960:	e3a03001 	mov	r3, #1
 c220964:	ea000005 	b	c220980 <OSMutexAccept+0x12c>
    }
    OS_EXIT_CRITICAL();
 c220968:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22096c:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c220970:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220974:	e3a02000 	mov	r2, #0
 c220978:	e5c32000 	strb	r2, [r3]
    return (0);
 c22097c:	e3a03000 	mov	r3, #0
}
 c220980:	e1a00003 	mov	r0, r3
 c220984:	e24bd00c 	sub	sp, fp, #12
 c220988:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22098c:	e12fff1e 	bx	lr
 c220990:	0c1c84c0 	.word	0x0c1c84c0
 c220994:	0c1c84c4 	.word	0x0c1c84c4

0c220998 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *err)
{
 c220998:	e1a0c00d 	mov	ip, sp
 c22099c:	e92dd800 	push	{fp, ip, lr, pc}
 c2209a0:	e24cb004 	sub	fp, ip, #4
 c2209a4:	e24dd010 	sub	sp, sp, #16
 c2209a8:	e1a03000 	mov	r3, r0
 c2209ac:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c2209b0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c2209b4:	e59f3174 	ldr	r3, [pc, #372]	; c220b30 <OSMutexCreate+0x198>
 c2209b8:	e5d33000 	ldrb	r3, [r3]
 c2209bc:	e3530000 	cmp	r3, #0
 c2209c0:	0a000004 	beq	c2209d8 <OSMutexCreate+0x40>
        *err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE mutex from an ISR       */
 c2209c4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2209c8:	e3e02072 	mvn	r2, #114	; 0x72
 c2209cc:	e5c32000 	strb	r2, [r3]
        return ((OS_EVENT *)0);
 c2209d0:	e3a03000 	mov	r3, #0
 c2209d4:	ea000051 	b	c220b20 <OSMutexCreate+0x188>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
 c2209d8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2209dc:	e353003e 	cmp	r3, #62	; 0x3e
 c2209e0:	9a000004 	bls	c2209f8 <OSMutexCreate+0x60>
        *err = OS_PRIO_INVALID;
 c2209e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2209e8:	e3a0202a 	mov	r2, #42	; 0x2a
 c2209ec:	e5c32000 	strb	r2, [r3]
        return ((OS_EVENT *)0);
 c2209f0:	e3a03000 	mov	r3, #0
 c2209f4:	ea000049 	b	c220b20 <OSMutexCreate+0x188>
    }
#endif
    OS_ENTER_CRITICAL();
 c2209f8:	e10f0000 	mrs	r0, CPSR
 c2209fc:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220a00:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c220a04:	e121f000 	msr	CPSR_c, r0
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
 c220a08:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c220a0c:	e59f3120 	ldr	r3, [pc, #288]	; c220b34 <OSMutexCreate+0x19c>
 c220a10:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c220a14:	e3530000 	cmp	r3, #0
 c220a18:	0a000006 	beq	c220a38 <OSMutexCreate+0xa0>
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
 c220a1c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220a20:	e121f000 	msr	CPSR_c, r0
        *err = OS_PRIO_EXIST;                              /* ... inheritance priority                 */
 c220a24:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220a28:	e3a02028 	mov	r2, #40	; 0x28
 c220a2c:	e5c32000 	strb	r2, [r3]
        return ((OS_EVENT *)0);                            
 c220a30:	e3a03000 	mov	r3, #0
 c220a34:	ea000039 	b	c220b20 <OSMutexCreate+0x188>
    }
    OSTCBPrioTbl[prio] = (OS_TCB *)1;                      /* Reserve the table entry                  */
 c220a38:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c220a3c:	e59f30f0 	ldr	r3, [pc, #240]	; c220b34 <OSMutexCreate+0x19c>
 c220a40:	e3a01001 	mov	r1, #1
 c220a44:	e7831102 	str	r1, [r3, r2, lsl #2]
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
 c220a48:	e59f30e8 	ldr	r3, [pc, #232]	; c220b38 <OSMutexCreate+0x1a0>
 c220a4c:	e5933000 	ldr	r3, [r3]
 c220a50:	e50b3010 	str	r3, [fp, #-16]
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
 c220a54:	e51b3010 	ldr	r3, [fp, #-16]
 c220a58:	e3530000 	cmp	r3, #0
 c220a5c:	1a00000a 	bne	c220a8c <OSMutexCreate+0xf4>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
 c220a60:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c220a64:	e59f30c8 	ldr	r3, [pc, #200]	; c220b34 <OSMutexCreate+0x19c>
 c220a68:	e3a01000 	mov	r1, #0
 c220a6c:	e7831102 	str	r1, [r3, r2, lsl #2]
        OS_EXIT_CRITICAL();
 c220a70:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220a74:	e121f000 	msr	CPSR_c, r0
        *err               = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
 c220a78:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220a7c:	e3a02004 	mov	r2, #4
 c220a80:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c220a84:	e51b3010 	ldr	r3, [fp, #-16]
 c220a88:	ea000024 	b	c220b20 <OSMutexCreate+0x188>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
 c220a8c:	e59f30a4 	ldr	r3, [pc, #164]	; c220b38 <OSMutexCreate+0x1a0>
 c220a90:	e5933000 	ldr	r3, [r3]
 c220a94:	e5933004 	ldr	r3, [r3, #4]
 c220a98:	e1a02003 	mov	r2, r3
 c220a9c:	e59f3094 	ldr	r3, [pc, #148]	; c220b38 <OSMutexCreate+0x1a0>
 c220aa0:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
 c220aa4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220aa8:	e121f000 	msr	CPSR_c, r0
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
 c220aac:	e51b3010 	ldr	r3, [fp, #-16]
 c220ab0:	e3a02004 	mov	r2, #4
 c220ab4:	e5c32000 	strb	r2, [r3]
    pevent->OSEventCnt     = ((INT16U)prio << 8) | OS_MUTEX_AVAILABLE;  /* Resource is available       */
 c220ab8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c220abc:	e1a03403 	lsl	r3, r3, #8
 c220ac0:	e1a03803 	lsl	r3, r3, #16
 c220ac4:	e1a03823 	lsr	r3, r3, #16
 c220ac8:	e38330ff 	orr	r3, r3, #255	; 0xff
 c220acc:	e1a03803 	lsl	r3, r3, #16
 c220ad0:	e1a03823 	lsr	r3, r3, #16
 c220ad4:	e1a03803 	lsl	r3, r3, #16
 c220ad8:	e1a02823 	lsr	r2, r3, #16
 c220adc:	e51b3010 	ldr	r3, [fp, #-16]
 c220ae0:	e1c320b2 	strh	r2, [r3, #2]
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
 c220ae4:	e51b3010 	ldr	r3, [fp, #-16]
 c220ae8:	e3a02000 	mov	r2, #0
 c220aec:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
 c220af0:	e51b3010 	ldr	r3, [fp, #-16]
 c220af4:	e3a0203f 	mov	r2, #63	; 0x3f
 c220af8:	e5c32010 	strb	r2, [r3, #16]
    pevent->OSEventName[1] = OS_ASCII_NUL;
 c220afc:	e51b3010 	ldr	r3, [fp, #-16]
 c220b00:	e3a02000 	mov	r2, #0
 c220b04:	e5c32011 	strb	r2, [r3, #17]
#endif
    OS_EventWaitListInit(pevent);
 c220b08:	e51b0010 	ldr	r0, [fp, #-16]
 c220b0c:	ebfff1cd 	bl	c21d248 <OS_EventWaitListInit>
    *err                   = OS_NO_ERR;
 c220b10:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220b14:	e3a02000 	mov	r2, #0
 c220b18:	e5c32000 	strb	r2, [r3]
    return (pevent);
 c220b1c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c220b20:	e1a00003 	mov	r0, r3
 c220b24:	e24bd00c 	sub	sp, fp, #12
 c220b28:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220b2c:	e12fff1e 	bx	lr
 c220b30:	0c1c84c0 	.word	0x0c1c84c0
 c220b34:	0c1c97a4 	.word	0x0c1c97a4
 c220b38:	0c1c84bc 	.word	0x0c1c84bc

0c220b3c <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
 c220b3c:	e1a0c00d 	mov	ip, sp
 c220b40:	e92dd800 	push	{fp, ip, lr, pc}
 c220b44:	e24cb004 	sub	fp, ip, #4
 c220b48:	e24dd018 	sub	sp, sp, #24
 c220b4c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c220b50:	e1a03001 	mov	r3, r1
 c220b54:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c220b58:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c220b5c:	e59f3254 	ldr	r3, [pc, #596]	; c220db8 <OSMutexDel+0x27c>
 c220b60:	e5d33000 	ldrb	r3, [r3]
 c220b64:	e3530000 	cmp	r3, #0
 c220b68:	0a000004 	beq	c220b80 <OSMutexDel+0x44>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 c220b6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220b70:	e3e02073 	mvn	r2, #115	; 0x73
 c220b74:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c220b78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220b7c:	ea000089 	b	c220da8 <OSMutexDel+0x26c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c220b80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220b84:	e3530000 	cmp	r3, #0
 c220b88:	1a000004 	bne	c220ba0 <OSMutexDel+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c220b8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220b90:	e3a02004 	mov	r2, #4
 c220b94:	e5c32000 	strb	r2, [r3]
        return ((OS_EVENT *)0);
 c220b98:	e3a03000 	mov	r3, #0
 c220b9c:	ea000081 	b	c220da8 <OSMutexDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
 c220ba0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220ba4:	e5d33000 	ldrb	r3, [r3]
 c220ba8:	e3530004 	cmp	r3, #4
 c220bac:	0a000004 	beq	c220bc4 <OSMutexDel+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c220bb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220bb4:	e3a02001 	mov	r2, #1
 c220bb8:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c220bbc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220bc0:	ea000078 	b	c220da8 <OSMutexDel+0x26c>
    }
    OS_ENTER_CRITICAL();
 c220bc4:	e10f0000 	mrs	r0, CPSR
 c220bc8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220bcc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c220bd0:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                      /* See if any tasks waiting on mutex        */
 c220bd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220bd8:	e5d33001 	ldrb	r3, [r3, #1]
 c220bdc:	e3530000 	cmp	r3, #0
 c220be0:	0a000002 	beq	c220bf0 <OSMutexDel+0xb4>
        tasks_waiting = TRUE;                              /* Yes                                      */
 c220be4:	e3a03001 	mov	r3, #1
 c220be8:	e54b300d 	strb	r3, [fp, #-13]
 c220bec:	ea000001 	b	c220bf8 <OSMutexDel+0xbc>
    } else {
        tasks_waiting = FALSE;                             /* No                                       */
 c220bf0:	e3a03000 	mov	r3, #0
 c220bf4:	e54b300d 	strb	r3, [fp, #-13]
    }
    switch (opt) {
 c220bf8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c220bfc:	e3530000 	cmp	r3, #0
 c220c00:	0a000002 	beq	c220c10 <OSMutexDel+0xd4>
 c220c04:	e3530001 	cmp	r3, #1
 c220c08:	0a000033 	beq	c220cdc <OSMutexDel+0x1a0>
 c220c0c:	ea00005f 	b	c220d90 <OSMutexDel+0x254>
        case OS_DEL_NO_PEND:                               /* Delete mutex only if no task waiting     */
             if (tasks_waiting == FALSE) {
 c220c10:	e55b300d 	ldrb	r3, [fp, #-13]
 c220c14:	e3530000 	cmp	r3, #0
 c220c18:	1a000023 	bne	c220cac <OSMutexDel+0x170>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 c220c1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c20:	e3a0203f 	mov	r2, #63	; 0x3f
 c220c24:	e5c32010 	strb	r2, [r3, #16]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 c220c28:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c2c:	e3a02000 	mov	r2, #0
 c220c30:	e5c32011 	strb	r2, [r3, #17]
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
 c220c34:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c38:	e1d330b2 	ldrh	r3, [r3, #2]
 c220c3c:	e1a03423 	lsr	r3, r3, #8
 c220c40:	e1a03803 	lsl	r3, r3, #16
 c220c44:	e1a03823 	lsr	r3, r3, #16
 c220c48:	e54b300e 	strb	r3, [fp, #-14]
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
 c220c4c:	e55b200e 	ldrb	r2, [fp, #-14]
 c220c50:	e59f3164 	ldr	r3, [pc, #356]	; c220dbc <OSMutexDel+0x280>
 c220c54:	e3a01000 	mov	r1, #0
 c220c58:	e7831102 	str	r1, [r3, r2, lsl #2]
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 c220c5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c60:	e3a02000 	mov	r2, #0
 c220c64:	e5c32000 	strb	r2, [r3]
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 c220c68:	e59f3150 	ldr	r3, [pc, #336]	; c220dc0 <OSMutexDel+0x284>
 c220c6c:	e5932000 	ldr	r2, [r3]
 c220c70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c74:	e5832004 	str	r2, [r3, #4]
                 pevent->OSEventCnt  = 0;
 c220c78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220c7c:	e3a02000 	mov	r2, #0
 c220c80:	e1c320b2 	strh	r2, [r3, #2]
                 OSEventFreeList     = pevent;
 c220c84:	e59f3134 	ldr	r3, [pc, #308]	; c220dc0 <OSMutexDel+0x284>
 c220c88:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c220c8c:	e5832000 	str	r2, [r3]
                 OS_EXIT_CRITICAL();
 c220c90:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220c94:	e121f000 	msr	CPSR_c, r0
                 *err                = OS_NO_ERR;
 c220c98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220c9c:	e3a02000 	mov	r2, #0
 c220ca0:	e5c32000 	strb	r2, [r3]
                 return ((OS_EVENT *)0);                   /* Mutex has been deleted                   */
 c220ca4:	e3a03000 	mov	r3, #0
 c220ca8:	ea00003e 	b	c220da8 <OSMutexDel+0x26c>
             } else {
                 OS_EXIT_CRITICAL();
 c220cac:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220cb0:	e121f000 	msr	CPSR_c, r0
                 *err                = OS_ERR_TASK_WAITING;
 c220cb4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220cb8:	e3a02008 	mov	r2, #8
 c220cbc:	e5c32000 	strb	r2, [r3]
                 return (pevent);
 c220cc0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220cc4:	ea000037 	b	c220da8 <OSMutexDel+0x26c>
             }

        case OS_DEL_ALWAYS:                                /* Always delete the mutex                  */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for mutex        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
 c220cc8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c220ccc:	e3a01000 	mov	r1, #0
 c220cd0:	e3a02010 	mov	r2, #16
 c220cd4:	ebfff03d 	bl	c21cdd0 <OS_EventTaskRdy>
 c220cd8:	ea000000 	b	c220ce0 <OSMutexDel+0x1a4>
                 *err                = OS_ERR_TASK_WAITING;
                 return (pevent);
             }

        case OS_DEL_ALWAYS:                                /* Always delete the mutex                  */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for mutex        */
 c220cdc:	e1a00000 	nop			; (mov r0, r0)
 c220ce0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220ce4:	e5d33001 	ldrb	r3, [r3, #1]
 c220ce8:	e3530000 	cmp	r3, #0
 c220cec:	1afffff5 	bne	c220cc8 <OSMutexDel+0x18c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 c220cf0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220cf4:	e3a0203f 	mov	r2, #63	; 0x3f
 c220cf8:	e5c32010 	strb	r2, [r3, #16]
             pevent->OSEventName[1] = OS_ASCII_NUL;
 c220cfc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220d00:	e3a02000 	mov	r2, #0
 c220d04:	e5c32011 	strb	r2, [r3, #17]
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
 c220d08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220d0c:	e1d330b2 	ldrh	r3, [r3, #2]
 c220d10:	e1a03423 	lsr	r3, r3, #8
 c220d14:	e1a03803 	lsl	r3, r3, #16
 c220d18:	e1a03823 	lsr	r3, r3, #16
 c220d1c:	e54b300e 	strb	r3, [fp, #-14]
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
 c220d20:	e55b200e 	ldrb	r2, [fp, #-14]
 c220d24:	e59f3090 	ldr	r3, [pc, #144]	; c220dbc <OSMutexDel+0x280>
 c220d28:	e3a01000 	mov	r1, #0
 c220d2c:	e7831102 	str	r1, [r3, r2, lsl #2]
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 c220d30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220d34:	e3a02000 	mov	r2, #0
 c220d38:	e5c32000 	strb	r2, [r3]
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
 c220d3c:	e59f307c 	ldr	r3, [pc, #124]	; c220dc0 <OSMutexDel+0x284>
 c220d40:	e5932000 	ldr	r2, [r3]
 c220d44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220d48:	e5832004 	str	r2, [r3, #4]
             pevent->OSEventCnt  = 0;
 c220d4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c220d50:	e3a02000 	mov	r2, #0
 c220d54:	e1c320b2 	strh	r2, [r3, #2]
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
 c220d58:	e59f3060 	ldr	r3, [pc, #96]	; c220dc0 <OSMutexDel+0x284>
 c220d5c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c220d60:	e5832000 	str	r2, [r3]
             OS_EXIT_CRITICAL();
 c220d64:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220d68:	e121f000 	msr	CPSR_c, r0
             if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
 c220d6c:	e55b300d 	ldrb	r3, [fp, #-13]
 c220d70:	e3530001 	cmp	r3, #1
 c220d74:	1a000000 	bne	c220d7c <OSMutexDel+0x240>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 c220d78:	ebfff2aa 	bl	c21d828 <OS_Sched>
             }
             *err = OS_NO_ERR;
 c220d7c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220d80:	e3a02000 	mov	r2, #0
 c220d84:	e5c32000 	strb	r2, [r3]
             return ((OS_EVENT *)0);                       /* Mutex has been deleted                   */
 c220d88:	e3a03000 	mov	r3, #0
 c220d8c:	ea000005 	b	c220da8 <OSMutexDel+0x26c>

        default:
             OS_EXIT_CRITICAL();
 c220d90:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220d94:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_INVALID_OPT;
 c220d98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220d9c:	e3a02007 	mov	r2, #7
 c220da0:	e5c32000 	strb	r2, [r3]
             return (pevent);
 c220da4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    }
}
 c220da8:	e1a00003 	mov	r0, r3
 c220dac:	e24bd00c 	sub	sp, fp, #12
 c220db0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c220db4:	e12fff1e 	bx	lr
 c220db8:	0c1c84c0 	.word	0x0c1c84c0
 c220dbc:	0c1c97a4 	.word	0x0c1c97a4
 c220dc0:	0c1c84bc 	.word	0x0c1c84bc

0c220dc4 <OSMutexPend>:
* Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/
void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
 c220dc4:	e1a0c00d 	mov	ip, sp
 c220dc8:	e92dd800 	push	{fp, ip, lr, pc}
 c220dcc:	e24cb004 	sub	fp, ip, #4
 c220dd0:	e24dd020 	sub	sp, sp, #32
 c220dd4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c220dd8:	e1a03001 	mov	r3, r1
 c220ddc:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
 c220de0:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c220de4:	e59f34fc 	ldr	r3, [pc, #1276]	; c2212e8 <OSMutexPend+0x524>
 c220de8:	e5d33000 	ldrb	r3, [r3]
 c220dec:	e3530000 	cmp	r3, #0
 c220df0:	0a000003 	beq	c220e04 <OSMutexPend+0x40>
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
 c220df4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c220df8:	e3a02002 	mov	r2, #2
 c220dfc:	e5c32000 	strb	r2, [r3]
        return;
 c220e00:	ea000135 	b	c2212dc <OSMutexPend+0x518>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c220e04:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e08:	e3530000 	cmp	r3, #0
 c220e0c:	1a000003 	bne	c220e20 <OSMutexPend+0x5c>
        *err = OS_ERR_PEVENT_NULL;
 c220e10:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c220e14:	e3a02004 	mov	r2, #4
 c220e18:	e5c32000 	strb	r2, [r3]
        return;
 c220e1c:	ea00012e 	b	c2212dc <OSMutexPend+0x518>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
 c220e20:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e24:	e5d33000 	ldrb	r3, [r3]
 c220e28:	e3530004 	cmp	r3, #4
 c220e2c:	0a000003 	beq	c220e40 <OSMutexPend+0x7c>
        *err = OS_ERR_EVENT_TYPE;
 c220e30:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c220e34:	e3a02001 	mov	r2, #1
 c220e38:	e5c32000 	strb	r2, [r3]
        return;
 c220e3c:	ea000126 	b	c2212dc <OSMutexPend+0x518>
    }
    OS_ENTER_CRITICAL();								   /* Is Mutex available?                      */
 c220e40:	e10f0000 	mrs	r0, CPSR
 c220e44:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c220e48:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c220e4c:	e121f000 	msr	CPSR_c, r0
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 c220e50:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e54:	e1d330b2 	ldrh	r3, [r3, #2]
 c220e58:	e20330ff 	and	r3, r3, #255	; 0xff
 c220e5c:	e35300ff 	cmp	r3, #255	; 0xff
 c220e60:	1a00001a 	bne	c220ed0 <OSMutexPend+0x10c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
 c220e64:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e68:	e1d330b2 	ldrh	r3, [r3, #2]
 c220e6c:	e3c330ff 	bic	r3, r3, #255	; 0xff
 c220e70:	e1a03803 	lsl	r3, r3, #16
 c220e74:	e1a02823 	lsr	r2, r3, #16
 c220e78:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e7c:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
 c220e80:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220e84:	e1d320b2 	ldrh	r2, [r3, #2]
 c220e88:	e59f345c 	ldr	r3, [pc, #1116]	; c2212ec <OSMutexPend+0x528>
 c220e8c:	e5933000 	ldr	r3, [r3]
 c220e90:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c220e94:	e1823003 	orr	r3, r2, r3
 c220e98:	e1a03803 	lsl	r3, r3, #16
 c220e9c:	e1a02823 	lsr	r2, r3, #16
 c220ea0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220ea4:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
 c220ea8:	e59f343c 	ldr	r3, [pc, #1084]	; c2212ec <OSMutexPend+0x528>
 c220eac:	e5932000 	ldr	r2, [r3]
 c220eb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220eb4:	e5832004 	str	r2, [r3, #4]
        OS_EXIT_CRITICAL();
 c220eb8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c220ebc:	e121f000 	msr	CPSR_c, r0
        *err  = OS_NO_ERR;
 c220ec0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c220ec4:	e3a02000 	mov	r2, #0
 c220ec8:	e5c32000 	strb	r2, [r3]
        return;
 c220ecc:	ea000102 	b	c2212dc <OSMutexPend+0x518>
    }
    pip   = (INT8U)(pevent->OSEventCnt >> 8);                     /* No, Get PIP from mutex            */
 c220ed0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220ed4:	e1d330b2 	ldrh	r3, [r3, #2]
 c220ed8:	e1a03423 	lsr	r3, r3, #8
 c220edc:	e1a03803 	lsl	r3, r3, #16
 c220ee0:	e1a03823 	lsr	r3, r3, #16
 c220ee4:	e54b300e 	strb	r3, [fp, #-14]
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /*     Get priority of mutex owner   */
 c220ee8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220eec:	e1d330b2 	ldrh	r3, [r3, #2]
 c220ef0:	e54b300f 	strb	r3, [fp, #-15]
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
 c220ef4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c220ef8:	e5933004 	ldr	r3, [r3, #4]
 c220efc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (ptcb->OSTCBPrio != pip) {                                 /*     Need to promote prio of owner?*/
 c220f00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220f04:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c220f08:	e55b200e 	ldrb	r2, [fp, #-14]
 c220f0c:	e1520003 	cmp	r2, r3
 c220f10:	0a0000c2 	beq	c221220 <OSMutexPend+0x45c>
        if (mprio > OSTCBCur->OSTCBPrio) {  
 c220f14:	e59f33d0 	ldr	r3, [pc, #976]	; c2212ec <OSMutexPend+0x528>
 c220f18:	e5933000 	ldr	r3, [r3]
 c220f1c:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c220f20:	e55b200f 	ldrb	r2, [fp, #-15]
 c220f24:	e1520003 	cmp	r2, r3
 c220f28:	9a0000bc 	bls	c221220 <OSMutexPend+0x45c>
            y = ptcb->OSTCBY;                          
 c220f2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220f30:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c220f34:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0x00) {        /*     See if mutex owner is ready   */
 c220f38:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c220f3c:	e59f23ac 	ldr	r2, [pc, #940]	; c2212f0 <OSMutexPend+0x52c>
 c220f40:	e7d22003 	ldrb	r2, [r2, r3]
 c220f44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220f48:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c220f4c:	e0023003 	and	r3, r2, r3
 c220f50:	e20330ff 	and	r3, r3, #255	; 0xff
 c220f54:	e3530000 	cmp	r3, #0
 c220f58:	0a000023 	beq	c220fec <OSMutexPend+0x228>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
 c220f5c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c220f60:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c220f64:	e59f1384 	ldr	r1, [pc, #900]	; c2212f0 <OSMutexPend+0x52c>
 c220f68:	e7d12002 	ldrb	r2, [r1, r2]
 c220f6c:	e20210ff 	and	r1, r2, #255	; 0xff
 c220f70:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c220f74:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c220f78:	e20220ff 	and	r2, r2, #255	; 0xff
 c220f7c:	e1e02002 	mvn	r2, r2
 c220f80:	e20220ff 	and	r2, r2, #255	; 0xff
 c220f84:	e0012002 	and	r2, r1, r2
 c220f88:	e20220ff 	and	r2, r2, #255	; 0xff
 c220f8c:	e20210ff 	and	r1, r2, #255	; 0xff
 c220f90:	e59f2358 	ldr	r2, [pc, #856]	; c2212f0 <OSMutexPend+0x52c>
 c220f94:	e7c21003 	strb	r1, [r2, r3]
                if (OSRdyTbl[y] == 0x00) {                        /*          ... list at current prio */
 c220f98:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c220f9c:	e59f234c 	ldr	r2, [pc, #844]	; c2212f0 <OSMutexPend+0x52c>
 c220fa0:	e7d23003 	ldrb	r3, [r2, r3]
 c220fa4:	e3530000 	cmp	r3, #0
 c220fa8:	1a00000c 	bne	c220fe0 <OSMutexPend+0x21c>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
 c220fac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220fb0:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c220fb4:	e20330ff 	and	r3, r3, #255	; 0xff
 c220fb8:	e1e03003 	mvn	r3, r3
 c220fbc:	e20320ff 	and	r2, r3, #255	; 0xff
 c220fc0:	e59f332c 	ldr	r3, [pc, #812]	; c2212f4 <OSMutexPend+0x530>
 c220fc4:	e5d33000 	ldrb	r3, [r3]
 c220fc8:	e20330ff 	and	r3, r3, #255	; 0xff
 c220fcc:	e0023003 	and	r3, r2, r3
 c220fd0:	e20330ff 	and	r3, r3, #255	; 0xff
 c220fd4:	e20320ff 	and	r2, r3, #255	; 0xff
 c220fd8:	e59f3314 	ldr	r3, [pc, #788]	; c2212f4 <OSMutexPend+0x530>
 c220fdc:	e5c32000 	strb	r2, [r3]
                }
                rdy = TRUE;
 c220fe0:	e3a03001 	mov	r3, #1
 c220fe4:	e54b300d 	strb	r3, [fp, #-13]
 c220fe8:	ea000033 	b	c2210bc <OSMutexPend+0x2f8>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
 c220fec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c220ff0:	e593301c 	ldr	r3, [r3, #28]
 c220ff4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
 c220ff8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c220ffc:	e3530000 	cmp	r3, #0
 c221000:	0a00002b 	beq	c2210b4 <OSMutexPend+0x2f0>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
 c221004:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221008:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c22100c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221010:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c221014:	e1a01002 	mov	r1, r2
 c221018:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c22101c:	e3a02008 	mov	r2, #8
 c221020:	e0801001 	add	r1, r0, r1
 c221024:	e0812002 	add	r2, r1, r2
 c221028:	e5d22000 	ldrb	r2, [r2]
 c22102c:	e20210ff 	and	r1, r2, #255	; 0xff
 c221030:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221034:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c221038:	e20220ff 	and	r2, r2, #255	; 0xff
 c22103c:	e1e02002 	mvn	r2, r2
 c221040:	e20220ff 	and	r2, r2, #255	; 0xff
 c221044:	e0012002 	and	r2, r1, r2
 c221048:	e20220ff 	and	r2, r2, #255	; 0xff
 c22104c:	e20210ff 	and	r1, r2, #255	; 0xff
 c221050:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c221054:	e3a02008 	mov	r2, #8
 c221058:	e0800003 	add	r0, r0, r3
 c22105c:	e0802002 	add	r2, r0, r2
 c221060:	e5c21000 	strb	r1, [r2]
 c221064:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c221068:	e3a02008 	mov	r2, #8
 c22106c:	e0813003 	add	r3, r1, r3
 c221070:	e0833002 	add	r3, r3, r2
 c221074:	e5d33000 	ldrb	r3, [r3]
 c221078:	e3530000 	cmp	r3, #0
 c22107c:	1a00000c 	bne	c2210b4 <OSMutexPend+0x2f0>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
 c221080:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221084:	e5d33001 	ldrb	r3, [r3, #1]
 c221088:	e20320ff 	and	r2, r3, #255	; 0xff
 c22108c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221090:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c221094:	e20330ff 	and	r3, r3, #255	; 0xff
 c221098:	e1e03003 	mvn	r3, r3
 c22109c:	e20330ff 	and	r3, r3, #255	; 0xff
 c2210a0:	e0023003 	and	r3, r2, r3
 c2210a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2210a8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2210ac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2210b0:	e5c32001 	strb	r2, [r3, #1]
                    }
                }
                rdy = FALSE;                               /* No                                       */
 c2210b4:	e3a03000 	mov	r3, #0
 c2210b8:	e54b300d 	strb	r3, [fp, #-13]
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
 c2210bc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210c0:	e55b200e 	ldrb	r2, [fp, #-14]
 c2210c4:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
            ptcb->OSTCBY    = ptcb->OSTCBPrio >> 3;
 c2210c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210cc:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c2210d0:	e1a031a3 	lsr	r3, r3, #3
 c2210d4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2210d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210dc:	e5c32030 	strb	r2, [r3, #48]	; 0x30
            ptcb->OSTCBBitY = OSMapTbl[ptcb->OSTCBY];
 c2210e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210e4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c2210e8:	e59f2208 	ldr	r2, [pc, #520]	; c2212f8 <OSMutexPend+0x534>
 c2210ec:	e7d22003 	ldrb	r2, [r2, r3]
 c2210f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210f4:	e5c32032 	strb	r2, [r3, #50]	; 0x32
            ptcb->OSTCBX    = ptcb->OSTCBPrio & 0x07;
 c2210f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2210fc:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c221100:	e2033007 	and	r3, r3, #7
 c221104:	e20320ff 	and	r2, r3, #255	; 0xff
 c221108:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22110c:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
            ptcb->OSTCBBitX = OSMapTbl[ptcb->OSTCBX];
 c221110:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221114:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
 c221118:	e59f21d8 	ldr	r2, [pc, #472]	; c2212f8 <OSMutexPend+0x534>
 c22111c:	e7d22003 	ldrb	r2, [r2, r3]
 c221120:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221124:	e5c32031 	strb	r2, [r3, #49]	; 0x31
            if (rdy == TRUE) {                             /* If task was ready at owner's priority ...*/
 c221128:	e55b300d 	ldrb	r3, [fp, #-13]
 c22112c:	e3530001 	cmp	r3, #1
 c221130:	1a000014 	bne	c221188 <OSMutexPend+0x3c4>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
 c221134:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221138:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c22113c:	e59f31b0 	ldr	r3, [pc, #432]	; c2212f4 <OSMutexPend+0x530>
 c221140:	e5d33000 	ldrb	r3, [r3]
 c221144:	e1823003 	orr	r3, r2, r3
 c221148:	e20320ff 	and	r2, r3, #255	; 0xff
 c22114c:	e59f31a0 	ldr	r3, [pc, #416]	; c2212f4 <OSMutexPend+0x530>
 c221150:	e5c32000 	strb	r2, [r3]
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c221154:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221158:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c22115c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221160:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c221164:	e59f1184 	ldr	r1, [pc, #388]	; c2212f0 <OSMutexPend+0x52c>
 c221168:	e7d11002 	ldrb	r1, [r1, r2]
 c22116c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221170:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c221174:	e1812002 	orr	r2, r1, r2
 c221178:	e20210ff 	and	r1, r2, #255	; 0xff
 c22117c:	e59f216c 	ldr	r2, [pc, #364]	; c2212f0 <OSMutexPend+0x52c>
 c221180:	e7c21003 	strb	r1, [r2, r3]
 c221184:	ea000021 	b	c221210 <OSMutexPend+0x44c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
 c221188:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22118c:	e593301c 	ldr	r3, [r3, #28]
 c221190:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
                if (pevent2 != (OS_EVENT *)0) {            /* Remove from event wait list              */
 c221194:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221198:	e3530000 	cmp	r3, #0
 c22119c:	0a00001b 	beq	c221210 <OSMutexPend+0x44c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
 c2211a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2211a4:	e5d32001 	ldrb	r2, [r3, #1]
 c2211a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2211ac:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c2211b0:	e1823003 	orr	r3, r2, r3
 c2211b4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2211b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2211bc:	e5c32001 	strb	r2, [r3, #1]
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c2211c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2211c4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c2211c8:	e1a01003 	mov	r1, r3
 c2211cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2211d0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c2211d4:	e1a02003 	mov	r2, r3
 c2211d8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c2211dc:	e3a03008 	mov	r3, #8
 c2211e0:	e0802002 	add	r2, r0, r2
 c2211e4:	e0823003 	add	r3, r2, r3
 c2211e8:	e5d32000 	ldrb	r2, [r3]
 c2211ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2211f0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c2211f4:	e1823003 	orr	r3, r2, r3
 c2211f8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2211fc:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c221200:	e3a03008 	mov	r3, #8
 c221204:	e0801001 	add	r1, r0, r1
 c221208:	e0813003 	add	r3, r1, r3
 c22120c:	e5c32000 	strb	r2, [r3]
                }
            }
            OSTCBPrioTbl[pip] = (OS_TCB *)ptcb;
 c221210:	e55b200e 	ldrb	r2, [fp, #-14]
 c221214:	e59f30e0 	ldr	r3, [pc, #224]	; c2212fc <OSMutexPend+0x538>
 c221218:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c22121c:	e7831102 	str	r1, [r3, r2, lsl #2]
        }
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_MUTEX;           /* Mutex not available, pend current task        */
 c221220:	e59f30c4 	ldr	r3, [pc, #196]	; c2212ec <OSMutexPend+0x528>
 c221224:	e5933000 	ldr	r3, [r3]
 c221228:	e59f20bc 	ldr	r2, [pc, #188]	; c2212ec <OSMutexPend+0x528>
 c22122c:	e5922000 	ldr	r2, [r2]
 c221230:	e5d2202c 	ldrb	r2, [r2, #44]	; 0x2c
 c221234:	e3822010 	orr	r2, r2, #16
 c221238:	e20220ff 	and	r2, r2, #255	; 0xff
 c22123c:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = FALSE;
 c221240:	e59f30a4 	ldr	r3, [pc, #164]	; c2212ec <OSMutexPend+0x528>
 c221244:	e5933000 	ldr	r3, [r3]
 c221248:	e3a02000 	mov	r2, #0
 c22124c:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBDly     = timeout;                 /* Store timeout in current task's TCB           */
 c221250:	e59f3094 	ldr	r3, [pc, #148]	; c2212ec <OSMutexPend+0x528>
 c221254:	e5933000 	ldr	r3, [r3]
 c221258:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
 c22125c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 c221260:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c221264:	ebffef5c 	bl	c21cfdc <OS_EventTaskWait>
    OS_EXIT_CRITICAL();
 c221268:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22126c:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                       /* Find next highest priority task ready         */
 c221270:	ebfff16c 	bl	c21d828 <OS_Sched>
    OS_ENTER_CRITICAL();
 c221274:	e10f0000 	mrs	r0, CPSR
 c221278:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c22127c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221280:	e121f000 	msr	CPSR_c, r0
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timed out during the pend           */
 c221284:	e59f3060 	ldr	r3, [pc, #96]	; c2212ec <OSMutexPend+0x528>
 c221288:	e5933000 	ldr	r3, [r3]
 c22128c:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
 c221290:	e3530001 	cmp	r3, #1
 c221294:	1a000007 	bne	c2212b8 <OSMutexPend+0x4f4>
        OS_EventTO(pevent);
 c221298:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c22129c:	ebffefa4 	bl	c21d134 <OS_EventTO>
        OS_EXIT_CRITICAL();
 c2212a0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2212a4:	e121f000 	msr	CPSR_c, r0
        *err = OS_TIMEOUT;                            /* Indicate that we didn't get mutex within TO   */
 c2212a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c2212ac:	e3a0200a 	mov	r2, #10
 c2212b0:	e5c32000 	strb	r2, [r3]
        return;
 c2212b4:	ea000008 	b	c2212dc <OSMutexPend+0x518>
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
 c2212b8:	e59f302c 	ldr	r3, [pc, #44]	; c2212ec <OSMutexPend+0x528>
 c2212bc:	e5933000 	ldr	r3, [r3]
 c2212c0:	e3a02000 	mov	r2, #0
 c2212c4:	e583201c 	str	r2, [r3, #28]
    OS_EXIT_CRITICAL();
 c2212c8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2212cc:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c2212d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c2212d4:	e3a02000 	mov	r2, #0
 c2212d8:	e5c32000 	strb	r2, [r3]
}
 c2212dc:	e24bd00c 	sub	sp, fp, #12
 c2212e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2212e4:	e12fff1e 	bx	lr
 c2212e8:	0c1c84c0 	.word	0x0c1c84c0
 c2212ec:	0c1c84c4 	.word	0x0c1c84c4
 c2212f0:	0c1c84b4 	.word	0x0c1c84b4
 c2212f4:	0c1c84b0 	.word	0x0c1c84b0
 c2212f8:	0c100f88 	.word	0x0c100f88
 c2212fc:	0c1c97a4 	.word	0x0c1c97a4

0c221300 <OSMutexPost>:
*              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
 c221300:	e1a0c00d 	mov	ip, sp
 c221304:	e92dd800 	push	{fp, ip, lr, pc}
 c221308:	e24cb004 	sub	fp, ip, #4
 c22130c:	e24dd010 	sub	sp, sp, #16
 c221310:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 c221314:	e59f332c 	ldr	r3, [pc, #812]	; c221648 <OSMutexPost+0x348>
 c221318:	e5d33000 	ldrb	r3, [r3]
 c22131c:	e3530000 	cmp	r3, #0
 c221320:	0a000001 	beq	c22132c <OSMutexPost+0x2c>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
 c221324:	e3a03005 	mov	r3, #5
 c221328:	ea0000c2 	b	c221638 <OSMutexPost+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c22132c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221330:	e3530000 	cmp	r3, #0
 c221334:	1a000001 	bne	c221340 <OSMutexPost+0x40>
        return (OS_ERR_PEVENT_NULL);
 c221338:	e3a03004 	mov	r3, #4
 c22133c:	ea0000bd 	b	c221638 <OSMutexPost+0x338>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
 c221340:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221344:	e5d33000 	ldrb	r3, [r3]
 c221348:	e3530004 	cmp	r3, #4
 c22134c:	0a000001 	beq	c221358 <OSMutexPost+0x58>
        return (OS_ERR_EVENT_TYPE);
 c221350:	e3a03001 	mov	r3, #1
 c221354:	ea0000b7 	b	c221638 <OSMutexPost+0x338>
    }                                                 
    OS_ENTER_CRITICAL();
 c221358:	e10f0000 	mrs	r0, CPSR
 c22135c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c221360:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221364:	e121f000 	msr	CPSR_c, r0
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
 c221368:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22136c:	e1d330b2 	ldrh	r3, [r3, #2]
 c221370:	e1a03423 	lsr	r3, r3, #8
 c221374:	e1a03803 	lsl	r3, r3, #16
 c221378:	e1a03823 	lsr	r3, r3, #16
 c22137c:	e54b300d 	strb	r3, [fp, #-13]
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
 c221380:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221384:	e1d330b2 	ldrh	r3, [r3, #2]
 c221388:	e54b300e 	strb	r3, [fp, #-14]
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
 c22138c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221390:	e5933004 	ldr	r3, [r3, #4]
 c221394:	e1a02003 	mov	r2, r3
 c221398:	e59f32ac 	ldr	r3, [pc, #684]	; c22164c <OSMutexPost+0x34c>
 c22139c:	e5933000 	ldr	r3, [r3]
 c2213a0:	e1520003 	cmp	r2, r3
 c2213a4:	0a000003 	beq	c2213b8 <OSMutexPost+0xb8>
        OS_EXIT_CRITICAL();
 c2213a8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2213ac:	e121f000 	msr	CPSR_c, r0
        return (OS_ERR_NOT_MUTEX_OWNER);
 c2213b0:	e3a03078 	mov	r3, #120	; 0x78
 c2213b4:	ea00009f 	b	c221638 <OSMutexPost+0x338>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
 c2213b8:	e59f328c 	ldr	r3, [pc, #652]	; c22164c <OSMutexPost+0x34c>
 c2213bc:	e5933000 	ldr	r3, [r3]
 c2213c0:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c2213c4:	e55b200d 	ldrb	r2, [fp, #-13]
 c2213c8:	e1520003 	cmp	r2, r3
 c2213cc:	1a000063 	bne	c221560 <OSMutexPost+0x260>
        y            = OSTCBCur->OSTCBY;              /* Yes, Return to original priority              */
 c2213d0:	e59f3274 	ldr	r3, [pc, #628]	; c22164c <OSMutexPost+0x34c>
 c2213d4:	e5933000 	ldr	r3, [r3]
 c2213d8:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c2213dc:	e54b300f 	strb	r3, [fp, #-15]
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;          /*      Remove owner from ready list at 'pip'    */
 c2213e0:	e55b300f 	ldrb	r3, [fp, #-15]
 c2213e4:	e55b200f 	ldrb	r2, [fp, #-15]
 c2213e8:	e59f1260 	ldr	r1, [pc, #608]	; c221650 <OSMutexPost+0x350>
 c2213ec:	e7d12002 	ldrb	r2, [r1, r2]
 c2213f0:	e20210ff 	and	r1, r2, #255	; 0xff
 c2213f4:	e59f2250 	ldr	r2, [pc, #592]	; c22164c <OSMutexPost+0x34c>
 c2213f8:	e5922000 	ldr	r2, [r2]
 c2213fc:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c221400:	e20220ff 	and	r2, r2, #255	; 0xff
 c221404:	e1e02002 	mvn	r2, r2
 c221408:	e20220ff 	and	r2, r2, #255	; 0xff
 c22140c:	e0012002 	and	r2, r1, r2
 c221410:	e20220ff 	and	r2, r2, #255	; 0xff
 c221414:	e20210ff 	and	r1, r2, #255	; 0xff
 c221418:	e59f2230 	ldr	r2, [pc, #560]	; c221650 <OSMutexPost+0x350>
 c22141c:	e7c21003 	strb	r1, [r2, r3]
        if (OSRdyTbl[y] == 0) {
 c221420:	e55b300f 	ldrb	r3, [fp, #-15]
 c221424:	e59f2224 	ldr	r2, [pc, #548]	; c221650 <OSMutexPost+0x350>
 c221428:	e7d23003 	ldrb	r3, [r2, r3]
 c22142c:	e3530000 	cmp	r3, #0
 c221430:	1a00000d 	bne	c22146c <OSMutexPost+0x16c>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 c221434:	e59f3210 	ldr	r3, [pc, #528]	; c22164c <OSMutexPost+0x34c>
 c221438:	e5933000 	ldr	r3, [r3]
 c22143c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c221440:	e20330ff 	and	r3, r3, #255	; 0xff
 c221444:	e1e03003 	mvn	r3, r3
 c221448:	e20320ff 	and	r2, r3, #255	; 0xff
 c22144c:	e59f3200 	ldr	r3, [pc, #512]	; c221654 <OSMutexPost+0x354>
 c221450:	e5d33000 	ldrb	r3, [r3]
 c221454:	e20330ff 	and	r3, r3, #255	; 0xff
 c221458:	e0023003 	and	r3, r2, r3
 c22145c:	e20330ff 	and	r3, r3, #255	; 0xff
 c221460:	e20320ff 	and	r2, r3, #255	; 0xff
 c221464:	e59f31e8 	ldr	r3, [pc, #488]	; c221654 <OSMutexPost+0x354>
 c221468:	e5c32000 	strb	r2, [r3]
        }
        OSTCBCur->OSTCBPrio         = prio;
 c22146c:	e59f31d8 	ldr	r3, [pc, #472]	; c22164c <OSMutexPost+0x34c>
 c221470:	e5933000 	ldr	r3, [r3]
 c221474:	e55b200e 	ldrb	r2, [fp, #-14]
 c221478:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
        OSTCBCur->OSTCBY            = prio >> 3;
 c22147c:	e59f31c8 	ldr	r3, [pc, #456]	; c22164c <OSMutexPost+0x34c>
 c221480:	e5933000 	ldr	r3, [r3]
 c221484:	e55b200e 	ldrb	r2, [fp, #-14]
 c221488:	e1a021a2 	lsr	r2, r2, #3
 c22148c:	e20220ff 	and	r2, r2, #255	; 0xff
 c221490:	e5c32030 	strb	r2, [r3, #48]	; 0x30
        OSTCBCur->OSTCBBitY         = OSMapTbl[OSTCBCur->OSTCBY];
 c221494:	e59f31b0 	ldr	r3, [pc, #432]	; c22164c <OSMutexPost+0x34c>
 c221498:	e5933000 	ldr	r3, [r3]
 c22149c:	e59f21a8 	ldr	r2, [pc, #424]	; c22164c <OSMutexPost+0x34c>
 c2214a0:	e5922000 	ldr	r2, [r2]
 c2214a4:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c2214a8:	e59f11a8 	ldr	r1, [pc, #424]	; c221658 <OSMutexPost+0x358>
 c2214ac:	e7d12002 	ldrb	r2, [r1, r2]
 c2214b0:	e5c32032 	strb	r2, [r3, #50]	; 0x32
        OSTCBCur->OSTCBX            = prio & 0x07;
 c2214b4:	e59f3190 	ldr	r3, [pc, #400]	; c22164c <OSMutexPost+0x34c>
 c2214b8:	e5933000 	ldr	r3, [r3]
 c2214bc:	e55b200e 	ldrb	r2, [fp, #-14]
 c2214c0:	e2022007 	and	r2, r2, #7
 c2214c4:	e20220ff 	and	r2, r2, #255	; 0xff
 c2214c8:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
        OSTCBCur->OSTCBBitX         = OSMapTbl[OSTCBCur->OSTCBX];
 c2214cc:	e59f3178 	ldr	r3, [pc, #376]	; c22164c <OSMutexPost+0x34c>
 c2214d0:	e5933000 	ldr	r3, [r3]
 c2214d4:	e59f2170 	ldr	r2, [pc, #368]	; c22164c <OSMutexPost+0x34c>
 c2214d8:	e5922000 	ldr	r2, [r2]
 c2214dc:	e5d2202f 	ldrb	r2, [r2, #47]	; 0x2f
 c2214e0:	e59f1170 	ldr	r1, [pc, #368]	; c221658 <OSMutexPost+0x358>
 c2214e4:	e7d12002 	ldrb	r2, [r1, r2]
 c2214e8:	e5c32031 	strb	r2, [r3, #49]	; 0x31
        OSRdyGrp                   |= OSTCBCur->OSTCBBitY;
 c2214ec:	e59f3158 	ldr	r3, [pc, #344]	; c22164c <OSMutexPost+0x34c>
 c2214f0:	e5933000 	ldr	r3, [r3]
 c2214f4:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c2214f8:	e59f3154 	ldr	r3, [pc, #340]	; c221654 <OSMutexPost+0x354>
 c2214fc:	e5d33000 	ldrb	r3, [r3]
 c221500:	e1823003 	orr	r3, r2, r3
 c221504:	e20320ff 	and	r2, r3, #255	; 0xff
 c221508:	e59f3144 	ldr	r3, [pc, #324]	; c221654 <OSMutexPost+0x354>
 c22150c:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 c221510:	e59f3134 	ldr	r3, [pc, #308]	; c22164c <OSMutexPost+0x34c>
 c221514:	e5933000 	ldr	r3, [r3]
 c221518:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c22151c:	e59f2128 	ldr	r2, [pc, #296]	; c22164c <OSMutexPost+0x34c>
 c221520:	e5922000 	ldr	r2, [r2]
 c221524:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c221528:	e59f1120 	ldr	r1, [pc, #288]	; c221650 <OSMutexPost+0x350>
 c22152c:	e7d11002 	ldrb	r1, [r1, r2]
 c221530:	e59f2114 	ldr	r2, [pc, #276]	; c22164c <OSMutexPost+0x34c>
 c221534:	e5922000 	ldr	r2, [r2]
 c221538:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c22153c:	e1812002 	orr	r2, r1, r2
 c221540:	e20210ff 	and	r1, r2, #255	; 0xff
 c221544:	e59f2104 	ldr	r2, [pc, #260]	; c221650 <OSMutexPost+0x350>
 c221548:	e7c21003 	strb	r1, [r2, r3]
        OSTCBPrioTbl[prio]          = (OS_TCB *)OSTCBCur;
 c22154c:	e55b200e 	ldrb	r2, [fp, #-14]
 c221550:	e59f30f4 	ldr	r3, [pc, #244]	; c22164c <OSMutexPost+0x34c>
 c221554:	e5931000 	ldr	r1, [r3]
 c221558:	e59f30fc 	ldr	r3, [pc, #252]	; c22165c <OSMutexPost+0x35c>
 c22155c:	e7831102 	str	r1, [r3, r2, lsl #2]
    }
    OSTCBPrioTbl[pip] = (OS_TCB *)1;                  /* Reserve table entry                           */
 c221560:	e55b200d 	ldrb	r2, [fp, #-13]
 c221564:	e59f30f0 	ldr	r3, [pc, #240]	; c22165c <OSMutexPost+0x35c>
 c221568:	e3a01001 	mov	r1, #1
 c22156c:	e7831102 	str	r1, [r3, r2, lsl #2]
    if (pevent->OSEventGrp != 0x00) {                 /* Any task waiting for the mutex?               */
 c221570:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221574:	e5d33001 	ldrb	r3, [r3, #1]
 c221578:	e3530000 	cmp	r3, #0
 c22157c:	0a000020 	beq	c221604 <OSMutexPost+0x304>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX);
 c221580:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c221584:	e3a01000 	mov	r1, #0
 c221588:	e3a02010 	mov	r2, #16
 c22158c:	ebffee0f 	bl	c21cdd0 <OS_EventTaskRdy>
 c221590:	e1a03000 	mov	r3, r0
 c221594:	e54b300e 	strb	r3, [fp, #-14]
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
 c221598:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22159c:	e1d330b2 	ldrh	r3, [r3, #2]
 c2215a0:	e3c330ff 	bic	r3, r3, #255	; 0xff
 c2215a4:	e1a03803 	lsl	r3, r3, #16
 c2215a8:	e1a02823 	lsr	r2, r3, #16
 c2215ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2215b0:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventCnt |= prio;
 c2215b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2215b8:	e1d320b2 	ldrh	r2, [r3, #2]
 c2215bc:	e55b300e 	ldrb	r3, [fp, #-14]
 c2215c0:	e1a03803 	lsl	r3, r3, #16
 c2215c4:	e1a03823 	lsr	r3, r3, #16
 c2215c8:	e1823003 	orr	r3, r2, r3
 c2215cc:	e1a03803 	lsl	r3, r3, #16
 c2215d0:	e1a02823 	lsr	r2, r3, #16
 c2215d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2215d8:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to mutex owner's OS_TCB             */
 c2215dc:	e55b200e 	ldrb	r2, [fp, #-14]
 c2215e0:	e59f3074 	ldr	r3, [pc, #116]	; c22165c <OSMutexPost+0x35c>
 c2215e4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
 c2215e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2215ec:	e5832004 	str	r2, [r3, #4]
        OS_EXIT_CRITICAL();
 c2215f0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2215f4:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                   /*      Find highest priority task ready to run  */
 c2215f8:	ebfff08a 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c2215fc:	e3a03000 	mov	r3, #0
 c221600:	ea00000c 	b	c221638 <OSMutexPost+0x338>
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
 c221604:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221608:	e1d330b2 	ldrh	r3, [r3, #2]
 c22160c:	e38330ff 	orr	r3, r3, #255	; 0xff
 c221610:	e1a03803 	lsl	r3, r3, #16
 c221614:	e1a02823 	lsr	r2, r3, #16
 c221618:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22161c:	e1c320b2 	strh	r2, [r3, #2]
    pevent->OSEventPtr  = (void *)0;
 c221620:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221624:	e3a02000 	mov	r2, #0
 c221628:	e5832004 	str	r2, [r3, #4]
    OS_EXIT_CRITICAL();
 c22162c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221630:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c221634:	e3a03000 	mov	r3, #0
}
 c221638:	e1a00003 	mov	r0, r3
 c22163c:	e24bd00c 	sub	sp, fp, #12
 c221640:	e89d6800 	ldm	sp, {fp, sp, lr}
 c221644:	e12fff1e 	bx	lr
 c221648:	0c1c84c0 	.word	0x0c1c84c0
 c22164c:	0c1c84c4 	.word	0x0c1c84c4
 c221650:	0c1c84b4 	.word	0x0c1c84b4
 c221654:	0c1c84b0 	.word	0x0c1c84b0
 c221658:	0c100f88 	.word	0x0c100f88
 c22165c:	0c1c97a4 	.word	0x0c1c97a4

0c221660 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
 c221660:	e1a0c00d 	mov	ip, sp
 c221664:	e92dd800 	push	{fp, ip, lr, pc}
 c221668:	e24cb004 	sub	fp, ip, #4
 c22166c:	e24dd010 	sub	sp, sp, #16
 c221670:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c221674:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c221678:	e59f3214 	ldr	r3, [pc, #532]	; c221894 <OSMutexQuery+0x234>
 c22167c:	e5d33000 	ldrb	r3, [r3]
 c221680:	e3530000 	cmp	r3, #0
 c221684:	0a000001 	beq	c221690 <OSMutexQuery+0x30>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
 c221688:	e3a03006 	mov	r3, #6
 c22168c:	ea00007c 	b	c221884 <OSMutexQuery+0x224>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c221690:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221694:	e3530000 	cmp	r3, #0
 c221698:	1a000001 	bne	c2216a4 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
 c22169c:	e3a03004 	mov	r3, #4
 c2216a0:	ea000077 	b	c221884 <OSMutexQuery+0x224>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
 c2216a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2216a8:	e5d33000 	ldrb	r3, [r3]
 c2216ac:	e3530004 	cmp	r3, #4
 c2216b0:	0a000001 	beq	c2216bc <OSMutexQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
 c2216b4:	e3a03001 	mov	r3, #1
 c2216b8:	ea000071 	b	c221884 <OSMutexQuery+0x224>
    }
    OS_ENTER_CRITICAL();
 c2216bc:	e10f0000 	mrs	r0, CPSR
 c2216c0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2216c4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2216c8:	e121f000 	msr	CPSR_c, r0
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
 c2216cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2216d0:	e1d330b2 	ldrh	r3, [r3, #2]
 c2216d4:	e1a03423 	lsr	r3, r3, #8
 c2216d8:	e1a03803 	lsl	r3, r3, #16
 c2216dc:	e1a03823 	lsr	r3, r3, #16
 c2216e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2216e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2216e8:	e5c3200b 	strb	r2, [r3, #11]
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 c2216ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2216f0:	e1d330b2 	ldrh	r3, [r3, #2]
 c2216f4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2216f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2216fc:	e5c3200a 	strb	r2, [r3, #10]
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
 c221700:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221704:	e5d3300a 	ldrb	r3, [r3, #10]
 c221708:	e35300ff 	cmp	r3, #255	; 0xff
 c22170c:	1a000003 	bne	c221720 <OSMutexQuery+0xc0>
        p_mutex_data->OSValue = 1;
 c221710:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221714:	e3a02001 	mov	r2, #1
 c221718:	e5c32009 	strb	r2, [r3, #9]
 c22171c:	ea000002 	b	c22172c <OSMutexQuery+0xcc>
    } else {
        p_mutex_data->OSValue = 0;
 c221720:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221724:	e3a02000 	mov	r2, #0
 c221728:	e5c32009 	strb	r2, [r3, #9]
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
 c22172c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221730:	e5d32001 	ldrb	r2, [r3, #1]
 c221734:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221738:	e5c32008 	strb	r2, [r3, #8]
    psrc                      = &pevent->OSEventTbl[0];
 c22173c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221740:	e2833008 	add	r3, r3, #8
 c221744:	e50b3010 	str	r3, [fp, #-16]
    pdest                     = &p_mutex_data->OSEventTbl[0];
 c221748:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22174c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if OS_EVENT_TBL_SIZE > 0
    *pdest++ = *psrc++;
 c221750:	e51b3010 	ldr	r3, [fp, #-16]
 c221754:	e5d32000 	ldrb	r2, [r3]
 c221758:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22175c:	e5c32000 	strb	r2, [r3]
 c221760:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221764:	e2833001 	add	r3, r3, #1
 c221768:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22176c:	e51b3010 	ldr	r3, [fp, #-16]
 c221770:	e2833001 	add	r3, r3, #1
 c221774:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 1
    *pdest++ = *psrc++;
 c221778:	e51b3010 	ldr	r3, [fp, #-16]
 c22177c:	e5d32000 	ldrb	r2, [r3]
 c221780:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221784:	e5c32000 	strb	r2, [r3]
 c221788:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22178c:	e2833001 	add	r3, r3, #1
 c221790:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c221794:	e51b3010 	ldr	r3, [fp, #-16]
 c221798:	e2833001 	add	r3, r3, #1
 c22179c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 2
    *pdest++ = *psrc++;
 c2217a0:	e51b3010 	ldr	r3, [fp, #-16]
 c2217a4:	e5d32000 	ldrb	r2, [r3]
 c2217a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2217ac:	e5c32000 	strb	r2, [r3]
 c2217b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2217b4:	e2833001 	add	r3, r3, #1
 c2217b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2217bc:	e51b3010 	ldr	r3, [fp, #-16]
 c2217c0:	e2833001 	add	r3, r3, #1
 c2217c4:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 3
    *pdest++ = *psrc++;
 c2217c8:	e51b3010 	ldr	r3, [fp, #-16]
 c2217cc:	e5d32000 	ldrb	r2, [r3]
 c2217d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2217d4:	e5c32000 	strb	r2, [r3]
 c2217d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2217dc:	e2833001 	add	r3, r3, #1
 c2217e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2217e4:	e51b3010 	ldr	r3, [fp, #-16]
 c2217e8:	e2833001 	add	r3, r3, #1
 c2217ec:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 4
    *pdest++ = *psrc++;
 c2217f0:	e51b3010 	ldr	r3, [fp, #-16]
 c2217f4:	e5d32000 	ldrb	r2, [r3]
 c2217f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2217fc:	e5c32000 	strb	r2, [r3]
 c221800:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221804:	e2833001 	add	r3, r3, #1
 c221808:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22180c:	e51b3010 	ldr	r3, [fp, #-16]
 c221810:	e2833001 	add	r3, r3, #1
 c221814:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 5
    *pdest++ = *psrc++;
 c221818:	e51b3010 	ldr	r3, [fp, #-16]
 c22181c:	e5d32000 	ldrb	r2, [r3]
 c221820:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221824:	e5c32000 	strb	r2, [r3]
 c221828:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22182c:	e2833001 	add	r3, r3, #1
 c221830:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c221834:	e51b3010 	ldr	r3, [fp, #-16]
 c221838:	e2833001 	add	r3, r3, #1
 c22183c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 6
    *pdest++ = *psrc++;
 c221840:	e51b3010 	ldr	r3, [fp, #-16]
 c221844:	e5d32000 	ldrb	r2, [r3]
 c221848:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22184c:	e5c32000 	strb	r2, [r3]
 c221850:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221854:	e2833001 	add	r3, r3, #1
 c221858:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22185c:	e51b3010 	ldr	r3, [fp, #-16]
 c221860:	e2833001 	add	r3, r3, #1
 c221864:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 7
    *pdest   = *psrc;
 c221868:	e51b3010 	ldr	r3, [fp, #-16]
 c22186c:	e5d32000 	ldrb	r2, [r3]
 c221870:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221874:	e5c32000 	strb	r2, [r3]
#endif
    OS_EXIT_CRITICAL();
 c221878:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22187c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c221880:	e3a03000 	mov	r3, #0
}
 c221884:	e1a00003 	mov	r0, r3
 c221888:	e24bd00c 	sub	sp, fp, #12
 c22188c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c221890:	e12fff1e 	bx	lr
 c221894:	0c1c84c0 	.word	0x0c1c84c0

0c221898 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
 c221898:	e1a0c00d 	mov	ip, sp
 c22189c:	e92dd800 	push	{fp, ip, lr, pc}
 c2218a0:	e24cb004 	sub	fp, ip, #4
 c2218a4:	e24dd010 	sub	sp, sp, #16
 c2218a8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c2218ac:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 c2218b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2218b4:	e3530000 	cmp	r3, #0
 c2218b8:	1a000004 	bne	c2218d0 <OSQAccept+0x38>
        *err = OS_ERR_PEVENT_NULL;
 c2218bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2218c0:	e3a02004 	mov	r2, #4
 c2218c4:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c2218c8:	e3a03000 	mov	r3, #0
 c2218cc:	ea000037 	b	c2219b0 <OSQAccept+0x118>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 c2218d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2218d4:	e5d33000 	ldrb	r3, [r3]
 c2218d8:	e3530002 	cmp	r3, #2
 c2218dc:	0a000004 	beq	c2218f4 <OSQAccept+0x5c>
        *err = OS_ERR_EVENT_TYPE;
 c2218e0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2218e4:	e3a02001 	mov	r2, #1
 c2218e8:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c2218ec:	e3a03000 	mov	r3, #0
 c2218f0:	ea00002e 	b	c2219b0 <OSQAccept+0x118>
    }
    OS_ENTER_CRITICAL();
 c2218f4:	e10f0000 	mrs	r0, CPSR
 c2218f8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2218fc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221900:	e121f000 	msr	CPSR_c, r0
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 c221904:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221908:	e5933004 	ldr	r3, [r3, #4]
 c22190c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 c221910:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221914:	e1d331b6 	ldrh	r3, [r3, #22]
 c221918:	e3530000 	cmp	r3, #0
 c22191c:	0a00001b 	beq	c221990 <OSQAccept+0xf8>
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
 c221920:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221924:	e5933010 	ldr	r3, [r3, #16]
 c221928:	e5932000 	ldr	r2, [r3]
 c22192c:	e50b2010 	str	r2, [fp, #-16]
 c221930:	e2832004 	add	r2, r3, #4
 c221934:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221938:	e5832010 	str	r2, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 c22193c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221940:	e1d331b6 	ldrh	r3, [r3, #22]
 c221944:	e2433001 	sub	r3, r3, #1
 c221948:	e1a03803 	lsl	r3, r3, #16
 c22194c:	e1a02823 	lsr	r2, r3, #16
 c221950:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221954:	e1c321b6 	strh	r2, [r3, #22]
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 c221958:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22195c:	e5932010 	ldr	r2, [r3, #16]
 c221960:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221964:	e5933008 	ldr	r3, [r3, #8]
 c221968:	e1520003 	cmp	r2, r3
 c22196c:	1a000003 	bne	c221980 <OSQAccept+0xe8>
            pq->OSQOut = pq->OSQStart;
 c221970:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221974:	e5932004 	ldr	r2, [r3, #4]
 c221978:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22197c:	e5832010 	str	r2, [r3, #16]
        }
        *err = OS_NO_ERR;
 c221980:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221984:	e3a02000 	mov	r2, #0
 c221988:	e5c32000 	strb	r2, [r3]
 c22198c:	ea000004 	b	c2219a4 <OSQAccept+0x10c>
    } else {
        *err = OS_Q_EMPTY;
 c221990:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c221994:	e3a0201f 	mov	r2, #31
 c221998:	e5c32000 	strb	r2, [r3]
        msg  = (void *)0;                        /* Queue is empty                                     */
 c22199c:	e3a03000 	mov	r3, #0
 c2219a0:	e50b3010 	str	r3, [fp, #-16]
    }
    OS_EXIT_CRITICAL();
 c2219a4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2219a8:	e121f000 	msr	CPSR_c, r0
    return (msg);                                /* Return message received (or NULL)                  */
 c2219ac:	e51b3010 	ldr	r3, [fp, #-16]
}
 c2219b0:	e1a00003 	mov	r0, r3
 c2219b4:	e24bd00c 	sub	sp, fp, #12
 c2219b8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2219bc:	e12fff1e 	bx	lr

0c2219c0 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 c2219c0:	e1a0c00d 	mov	ip, sp
 c2219c4:	e92dd800 	push	{fp, ip, lr, pc}
 c2219c8:	e24cb004 	sub	fp, ip, #4
 c2219cc:	e24dd010 	sub	sp, sp, #16
 c2219d0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c2219d4:	e1a03001 	mov	r3, r1
 c2219d8:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 c2219dc:	e59f3188 	ldr	r3, [pc, #392]	; c221b6c <OSQCreate+0x1ac>
 c2219e0:	e5d33000 	ldrb	r3, [r3]
 c2219e4:	e3530000 	cmp	r3, #0
 c2219e8:	0a000001 	beq	c2219f4 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 c2219ec:	e3a03000 	mov	r3, #0
 c2219f0:	ea000059 	b	c221b5c <OSQCreate+0x19c>
    }
    OS_ENTER_CRITICAL();
 c2219f4:	e10f0000 	mrs	r0, CPSR
 c2219f8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2219fc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221a00:	e121f000 	msr	CPSR_c, r0
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 c221a04:	e59f3164 	ldr	r3, [pc, #356]	; c221b70 <OSQCreate+0x1b0>
 c221a08:	e5933000 	ldr	r3, [r3]
 c221a0c:	e50b3010 	str	r3, [fp, #-16]
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 c221a10:	e59f3158 	ldr	r3, [pc, #344]	; c221b70 <OSQCreate+0x1b0>
 c221a14:	e5933000 	ldr	r3, [r3]
 c221a18:	e3530000 	cmp	r3, #0
 c221a1c:	0a000005 	beq	c221a38 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 c221a20:	e59f3148 	ldr	r3, [pc, #328]	; c221b70 <OSQCreate+0x1b0>
 c221a24:	e5933000 	ldr	r3, [r3]
 c221a28:	e5933004 	ldr	r3, [r3, #4]
 c221a2c:	e1a02003 	mov	r2, r3
 c221a30:	e59f3138 	ldr	r3, [pc, #312]	; c221b70 <OSQCreate+0x1b0>
 c221a34:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
 c221a38:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221a3c:	e121f000 	msr	CPSR_c, r0
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 c221a40:	e51b3010 	ldr	r3, [fp, #-16]
 c221a44:	e3530000 	cmp	r3, #0
 c221a48:	0a000042 	beq	c221b58 <OSQCreate+0x198>
        OS_ENTER_CRITICAL();
 c221a4c:	e10f0000 	mrs	r0, CPSR
 c221a50:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c221a54:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221a58:	e121f000 	msr	CPSR_c, r0
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 c221a5c:	e59f3110 	ldr	r3, [pc, #272]	; c221b74 <OSQCreate+0x1b4>
 c221a60:	e5933000 	ldr	r3, [r3]
 c221a64:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 c221a68:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221a6c:	e3530000 	cmp	r3, #0
 c221a70:	0a00002d 	beq	c221b2c <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 c221a74:	e59f30f8 	ldr	r3, [pc, #248]	; c221b74 <OSQCreate+0x1b4>
 c221a78:	e5933000 	ldr	r3, [r3]
 c221a7c:	e5932000 	ldr	r2, [r3]
 c221a80:	e59f30ec 	ldr	r3, [pc, #236]	; c221b74 <OSQCreate+0x1b4>
 c221a84:	e5832000 	str	r2, [r3]
            OS_EXIT_CRITICAL();
 c221a88:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221a8c:	e121f000 	msr	CPSR_c, r0
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 c221a90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221a94:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221a98:	e5832004 	str	r2, [r3, #4]
            pq->OSQEnd             = &start[size];
 c221a9c:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c221aa0:	e1a03103 	lsl	r3, r3, #2
 c221aa4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221aa8:	e0822003 	add	r2, r2, r3
 c221aac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221ab0:	e5832008 	str	r2, [r3, #8]
            pq->OSQIn              = start;
 c221ab4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221ab8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221abc:	e583200c 	str	r2, [r3, #12]
            pq->OSQOut             = start;
 c221ac0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221ac4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221ac8:	e5832010 	str	r2, [r3, #16]
            pq->OSQSize            = size;
 c221acc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221ad0:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c221ad4:	e1c321b4 	strh	r2, [r3, #20]
            pq->OSQEntries         = 0;
 c221ad8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221adc:	e3a02000 	mov	r2, #0
 c221ae0:	e1c321b6 	strh	r2, [r3, #22]
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 c221ae4:	e51b3010 	ldr	r3, [fp, #-16]
 c221ae8:	e3a02002 	mov	r2, #2
 c221aec:	e5c32000 	strb	r2, [r3]
            pevent->OSEventCnt     = 0;
 c221af0:	e51b3010 	ldr	r3, [fp, #-16]
 c221af4:	e3a02000 	mov	r2, #0
 c221af8:	e1c320b2 	strh	r2, [r3, #2]
            pevent->OSEventPtr     = pq;
 c221afc:	e51b3010 	ldr	r3, [fp, #-16]
 c221b00:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221b04:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 c221b08:	e51b3010 	ldr	r3, [fp, #-16]
 c221b0c:	e3a0203f 	mov	r2, #63	; 0x3f
 c221b10:	e5c32010 	strb	r2, [r3, #16]
            pevent->OSEventName[1] = OS_ASCII_NUL;
 c221b14:	e51b3010 	ldr	r3, [fp, #-16]
 c221b18:	e3a02000 	mov	r2, #0
 c221b1c:	e5c32011 	strb	r2, [r3, #17]
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 c221b20:	e51b0010 	ldr	r0, [fp, #-16]
 c221b24:	ebffedc7 	bl	c21d248 <OS_EventWaitListInit>
 c221b28:	ea00000a 	b	c221b58 <OSQCreate+0x198>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 c221b2c:	e59f303c 	ldr	r3, [pc, #60]	; c221b70 <OSQCreate+0x1b0>
 c221b30:	e5932000 	ldr	r2, [r3]
 c221b34:	e51b3010 	ldr	r3, [fp, #-16]
 c221b38:	e5832004 	str	r2, [r3, #4]
            OSEventFreeList    = pevent;
 c221b3c:	e59f302c 	ldr	r3, [pc, #44]	; c221b70 <OSQCreate+0x1b0>
 c221b40:	e51b2010 	ldr	r2, [fp, #-16]
 c221b44:	e5832000 	str	r2, [r3]
            OS_EXIT_CRITICAL();
 c221b48:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221b4c:	e121f000 	msr	CPSR_c, r0
            pevent = (OS_EVENT *)0;
 c221b50:	e3a03000 	mov	r3, #0
 c221b54:	e50b3010 	str	r3, [fp, #-16]
        }
    }
    return (pevent);
 c221b58:	e51b3010 	ldr	r3, [fp, #-16]
}
 c221b5c:	e1a00003 	mov	r0, r3
 c221b60:	e24bd00c 	sub	sp, fp, #12
 c221b64:	e89d6800 	ldm	sp, {fp, sp, lr}
 c221b68:	e12fff1e 	bx	lr
 c221b6c:	0c1c84c0 	.word	0x0c1c84c0
 c221b70:	0c1c84bc 	.word	0x0c1c84bc
 c221b74:	0c1c84ac 	.word	0x0c1c84ac

0c221b78 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
 c221b78:	e1a0c00d 	mov	ip, sp
 c221b7c:	e92dd800 	push	{fp, ip, lr, pc}
 c221b80:	e24cb004 	sub	fp, ip, #4
 c221b84:	e24dd018 	sub	sp, sp, #24
 c221b88:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c221b8c:	e1a03001 	mov	r3, r1
 c221b90:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c221b94:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c221b98:	e59f3254 	ldr	r3, [pc, #596]	; c221df4 <OSQDel+0x27c>
 c221b9c:	e5d33000 	ldrb	r3, [r3]
 c221ba0:	e3530000 	cmp	r3, #0
 c221ba4:	0a000004 	beq	c221bbc <OSQDel+0x44>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 c221ba8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221bac:	e3e02073 	mvn	r2, #115	; 0x73
 c221bb0:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c221bb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221bb8:	ea000089 	b	c221de4 <OSQDel+0x26c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c221bbc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221bc0:	e3530000 	cmp	r3, #0
 c221bc4:	1a000004 	bne	c221bdc <OSQDel+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c221bc8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221bcc:	e3a02004 	mov	r2, #4
 c221bd0:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c221bd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221bd8:	ea000081 	b	c221de4 <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 c221bdc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221be0:	e5d33000 	ldrb	r3, [r3]
 c221be4:	e3530002 	cmp	r3, #2
 c221be8:	0a000004 	beq	c221c00 <OSQDel+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c221bec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221bf0:	e3a02001 	mov	r2, #1
 c221bf4:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c221bf8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221bfc:	ea000078 	b	c221de4 <OSQDel+0x26c>
    }
    OS_ENTER_CRITICAL();
 c221c00:	e10f0000 	mrs	r0, CPSR
 c221c04:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c221c08:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221c0c:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                      /* See if any tasks waiting on queue        */
 c221c10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221c14:	e5d33001 	ldrb	r3, [r3, #1]
 c221c18:	e3530000 	cmp	r3, #0
 c221c1c:	0a000002 	beq	c221c2c <OSQDel+0xb4>
        tasks_waiting = TRUE;                              /* Yes                                      */
 c221c20:	e3a03001 	mov	r3, #1
 c221c24:	e54b300d 	strb	r3, [fp, #-13]
 c221c28:	ea000001 	b	c221c34 <OSQDel+0xbc>
    } else {
        tasks_waiting = FALSE;                             /* No                                       */
 c221c2c:	e3a03000 	mov	r3, #0
 c221c30:	e54b300d 	strb	r3, [fp, #-13]
    }
    switch (opt) {
 c221c34:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c221c38:	e3530000 	cmp	r3, #0
 c221c3c:	0a000002 	beq	c221c4c <OSQDel+0xd4>
 c221c40:	e3530001 	cmp	r3, #1
 c221c44:	0a000033 	beq	c221d18 <OSQDel+0x1a0>
 c221c48:	ea00005f 	b	c221dcc <OSQDel+0x254>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == FALSE) {
 c221c4c:	e55b300d 	ldrb	r3, [fp, #-13]
 c221c50:	e3530000 	cmp	r3, #0
 c221c54:	1a000023 	bne	c221ce8 <OSQDel+0x170>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 c221c58:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221c5c:	e3a0203f 	mov	r2, #63	; 0x3f
 c221c60:	e5c32010 	strb	r2, [r3, #16]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 c221c64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221c68:	e3a02000 	mov	r2, #0
 c221c6c:	e5c32011 	strb	r2, [r3, #17]
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 c221c70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221c74:	e5933004 	ldr	r3, [r3, #4]
 c221c78:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                 pq->OSQPtr             = OSQFreeList;
 c221c7c:	e59f3174 	ldr	r3, [pc, #372]	; c221df8 <OSQDel+0x280>
 c221c80:	e5932000 	ldr	r2, [r3]
 c221c84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221c88:	e5832000 	str	r2, [r3]
                 OSQFreeList            = pq;
 c221c8c:	e59f3164 	ldr	r3, [pc, #356]	; c221df8 <OSQDel+0x280>
 c221c90:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221c94:	e5832000 	str	r2, [r3]
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c221c98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221c9c:	e3a02000 	mov	r2, #0
 c221ca0:	e5c32000 	strb	r2, [r3]
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 c221ca4:	e59f3150 	ldr	r3, [pc, #336]	; c221dfc <OSQDel+0x284>
 c221ca8:	e5932000 	ldr	r2, [r3]
 c221cac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221cb0:	e5832004 	str	r2, [r3, #4]
                 pevent->OSEventCnt     = 0;
 c221cb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221cb8:	e3a02000 	mov	r2, #0
 c221cbc:	e1c320b2 	strh	r2, [r3, #2]
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 c221cc0:	e59f3134 	ldr	r3, [pc, #308]	; c221dfc <OSQDel+0x284>
 c221cc4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221cc8:	e5832000 	str	r2, [r3]
                 OS_EXIT_CRITICAL();
 c221ccc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221cd0:	e121f000 	msr	CPSR_c, r0
                 *err                   = OS_NO_ERR;
 c221cd4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221cd8:	e3a02000 	mov	r2, #0
 c221cdc:	e5c32000 	strb	r2, [r3]
                 return ((OS_EVENT *)0);                   /* Queue has been deleted                   */
 c221ce0:	e3a03000 	mov	r3, #0
 c221ce4:	ea00003e 	b	c221de4 <OSQDel+0x26c>
             } else {
                 OS_EXIT_CRITICAL();
 c221ce8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221cec:	e121f000 	msr	CPSR_c, r0
                 *err                   = OS_ERR_TASK_WAITING;
 c221cf0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221cf4:	e3a02008 	mov	r2, #8
 c221cf8:	e5c32000 	strb	r2, [r3]
                 return (pevent);
 c221cfc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d00:	ea000037 	b	c221de4 <OSQDel+0x26c>
             }

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);
 c221d04:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c221d08:	e3a01000 	mov	r1, #0
 c221d0c:	e3a02004 	mov	r2, #4
 c221d10:	ebffec2e 	bl	c21cdd0 <OS_EventTaskRdy>
 c221d14:	ea000000 	b	c221d1c <OSQDel+0x1a4>
                 *err                   = OS_ERR_TASK_WAITING;
                 return (pevent);
             }

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for queue        */
 c221d18:	e1a00000 	nop			; (mov r0, r0)
 c221d1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d20:	e5d33001 	ldrb	r3, [r3, #1]
 c221d24:	e3530000 	cmp	r3, #0
 c221d28:	1afffff5 	bne	c221d04 <OSQDel+0x18c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 c221d2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d30:	e3a0203f 	mov	r2, #63	; 0x3f
 c221d34:	e5c32010 	strb	r2, [r3, #16]
             pevent->OSEventName[1] = OS_ASCII_NUL;
 c221d38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d3c:	e3a02000 	mov	r2, #0
 c221d40:	e5c32011 	strb	r2, [r3, #17]
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 c221d44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d48:	e5933004 	ldr	r3, [r3, #4]
 c221d4c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
             pq->OSQPtr             = OSQFreeList;
 c221d50:	e59f30a0 	ldr	r3, [pc, #160]	; c221df8 <OSQDel+0x280>
 c221d54:	e5932000 	ldr	r2, [r3]
 c221d58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221d5c:	e5832000 	str	r2, [r3]
             OSQFreeList            = pq;
 c221d60:	e59f3090 	ldr	r3, [pc, #144]	; c221df8 <OSQDel+0x280>
 c221d64:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c221d68:	e5832000 	str	r2, [r3]
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c221d6c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d70:	e3a02000 	mov	r2, #0
 c221d74:	e5c32000 	strb	r2, [r3]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 c221d78:	e59f307c 	ldr	r3, [pc, #124]	; c221dfc <OSQDel+0x284>
 c221d7c:	e5932000 	ldr	r2, [r3]
 c221d80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d84:	e5832004 	str	r2, [r3, #4]
             pevent->OSEventCnt     = 0;
 c221d88:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221d8c:	e3a02000 	mov	r2, #0
 c221d90:	e1c320b2 	strh	r2, [r3, #2]
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 c221d94:	e59f3060 	ldr	r3, [pc, #96]	; c221dfc <OSQDel+0x284>
 c221d98:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c221d9c:	e5832000 	str	r2, [r3]
             OS_EXIT_CRITICAL();
 c221da0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221da4:	e121f000 	msr	CPSR_c, r0
             if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
 c221da8:	e55b300d 	ldrb	r3, [fp, #-13]
 c221dac:	e3530001 	cmp	r3, #1
 c221db0:	1a000000 	bne	c221db8 <OSQDel+0x240>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 c221db4:	ebffee9b 	bl	c21d828 <OS_Sched>
             }
             *err = OS_NO_ERR;
 c221db8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221dbc:	e3a02000 	mov	r2, #0
 c221dc0:	e5c32000 	strb	r2, [r3]
             return ((OS_EVENT *)0);                       /* Queue has been deleted                   */
 c221dc4:	e3a03000 	mov	r3, #0
 c221dc8:	ea000005 	b	c221de4 <OSQDel+0x26c>

        default:
             OS_EXIT_CRITICAL();
 c221dcc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221dd0:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_INVALID_OPT;
 c221dd4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221dd8:	e3a02007 	mov	r2, #7
 c221ddc:	e5c32000 	strb	r2, [r3]
             return (pevent);
 c221de0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    }
}
 c221de4:	e1a00003 	mov	r0, r3
 c221de8:	e24bd00c 	sub	sp, fp, #12
 c221dec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c221df0:	e12fff1e 	bx	lr
 c221df4:	0c1c84c0 	.word	0x0c1c84c0
 c221df8:	0c1c84ac 	.word	0x0c1c84ac
 c221dfc:	0c1c84bc 	.word	0x0c1c84bc

0c221e00 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 c221e00:	e1a0c00d 	mov	ip, sp
 c221e04:	e92dd800 	push	{fp, ip, lr, pc}
 c221e08:	e24cb004 	sub	fp, ip, #4
 c221e0c:	e24dd010 	sub	sp, sp, #16
 c221e10:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c221e14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221e18:	e3530000 	cmp	r3, #0
 c221e1c:	1a000001 	bne	c221e28 <OSQFlush+0x28>
        return (OS_ERR_PEVENT_NULL);
 c221e20:	e3a03004 	mov	r3, #4
 c221e24:	ea00001a 	b	c221e94 <OSQFlush+0x94>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 c221e28:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221e2c:	e5d33000 	ldrb	r3, [r3]
 c221e30:	e3530002 	cmp	r3, #2
 c221e34:	0a000001 	beq	c221e40 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 c221e38:	e3a03001 	mov	r3, #1
 c221e3c:	ea000014 	b	c221e94 <OSQFlush+0x94>
    }
#endif
    OS_ENTER_CRITICAL();
 c221e40:	e10f0000 	mrs	r0, CPSR
 c221e44:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c221e48:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221e4c:	e121f000 	msr	CPSR_c, r0
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 c221e50:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221e54:	e5933004 	ldr	r3, [r3, #4]
 c221e58:	e50b3010 	str	r3, [fp, #-16]
    pq->OSQIn      = pq->OSQStart;
 c221e5c:	e51b3010 	ldr	r3, [fp, #-16]
 c221e60:	e5932004 	ldr	r2, [r3, #4]
 c221e64:	e51b3010 	ldr	r3, [fp, #-16]
 c221e68:	e583200c 	str	r2, [r3, #12]
    pq->OSQOut     = pq->OSQStart;
 c221e6c:	e51b3010 	ldr	r3, [fp, #-16]
 c221e70:	e5932004 	ldr	r2, [r3, #4]
 c221e74:	e51b3010 	ldr	r3, [fp, #-16]
 c221e78:	e5832010 	str	r2, [r3, #16]
    pq->OSQEntries = 0;
 c221e7c:	e51b3010 	ldr	r3, [fp, #-16]
 c221e80:	e3a02000 	mov	r2, #0
 c221e84:	e1c321b6 	strh	r2, [r3, #22]
    OS_EXIT_CRITICAL();
 c221e88:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221e8c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c221e90:	e3a03000 	mov	r3, #0
}
 c221e94:	e1a00003 	mov	r0, r3
 c221e98:	e24bd00c 	sub	sp, fp, #12
 c221e9c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c221ea0:	e12fff1e 	bx	lr

0c221ea4 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
 c221ea4:	e1a0c00d 	mov	ip, sp
 c221ea8:	e92dd800 	push	{fp, ip, lr, pc}
 c221eac:	e24cb004 	sub	fp, ip, #4
 c221eb0:	e24dd018 	sub	sp, sp, #24
 c221eb4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c221eb8:	e1a03001 	mov	r3, r1
 c221ebc:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c221ec0:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 c221ec4:	e59f320c 	ldr	r3, [pc, #524]	; c2220d8 <OSQPend+0x234>
 c221ec8:	e5d33000 	ldrb	r3, [r3]
 c221ecc:	e3530000 	cmp	r3, #0
 c221ed0:	0a000004 	beq	c221ee8 <OSQPend+0x44>
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
 c221ed4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221ed8:	e3a02002 	mov	r2, #2
 c221edc:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c221ee0:	e3a03000 	mov	r3, #0
 c221ee4:	ea000077 	b	c2220c8 <OSQPend+0x224>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 c221ee8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221eec:	e3530000 	cmp	r3, #0
 c221ef0:	1a000004 	bne	c221f08 <OSQPend+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c221ef4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221ef8:	e3a02004 	mov	r2, #4
 c221efc:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c221f00:	e3a03000 	mov	r3, #0
 c221f04:	ea00006f 	b	c2220c8 <OSQPend+0x224>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 c221f08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221f0c:	e5d33000 	ldrb	r3, [r3]
 c221f10:	e3530002 	cmp	r3, #2
 c221f14:	0a000004 	beq	c221f2c <OSQPend+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c221f18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221f1c:	e3a02001 	mov	r2, #1
 c221f20:	e5c32000 	strb	r2, [r3]
        return ((void *)0);
 c221f24:	e3a03000 	mov	r3, #0
 c221f28:	ea000066 	b	c2220c8 <OSQPend+0x224>
    }
#endif
    OS_ENTER_CRITICAL();
 c221f2c:	e10f0000 	mrs	r0, CPSR
 c221f30:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c221f34:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c221f38:	e121f000 	msr	CPSR_c, r0
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 c221f3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c221f40:	e5933004 	ldr	r3, [r3, #4]
 c221f44:	e50b3010 	str	r3, [fp, #-16]
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 c221f48:	e51b3010 	ldr	r3, [fp, #-16]
 c221f4c:	e1d331b6 	ldrh	r3, [r3, #22]
 c221f50:	e3530000 	cmp	r3, #0
 c221f54:	0a00001e 	beq	c221fd4 <OSQPend+0x130>
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
 c221f58:	e51b3010 	ldr	r3, [fp, #-16]
 c221f5c:	e5933010 	ldr	r3, [r3, #16]
 c221f60:	e5932000 	ldr	r2, [r3]
 c221f64:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
 c221f68:	e2832004 	add	r2, r3, #4
 c221f6c:	e51b3010 	ldr	r3, [fp, #-16]
 c221f70:	e5832010 	str	r2, [r3, #16]
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 c221f74:	e51b3010 	ldr	r3, [fp, #-16]
 c221f78:	e1d331b6 	ldrh	r3, [r3, #22]
 c221f7c:	e2433001 	sub	r3, r3, #1
 c221f80:	e1a03803 	lsl	r3, r3, #16
 c221f84:	e1a02823 	lsr	r2, r3, #16
 c221f88:	e51b3010 	ldr	r3, [fp, #-16]
 c221f8c:	e1c321b6 	strh	r2, [r3, #22]
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 c221f90:	e51b3010 	ldr	r3, [fp, #-16]
 c221f94:	e5932010 	ldr	r2, [r3, #16]
 c221f98:	e51b3010 	ldr	r3, [fp, #-16]
 c221f9c:	e5933008 	ldr	r3, [r3, #8]
 c221fa0:	e1520003 	cmp	r2, r3
 c221fa4:	1a000003 	bne	c221fb8 <OSQPend+0x114>
            pq->OSQOut = pq->OSQStart;
 c221fa8:	e51b3010 	ldr	r3, [fp, #-16]
 c221fac:	e5932004 	ldr	r2, [r3, #4]
 c221fb0:	e51b3010 	ldr	r3, [fp, #-16]
 c221fb4:	e5832010 	str	r2, [r3, #16]
        }
        OS_EXIT_CRITICAL();
 c221fb8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c221fbc:	e121f000 	msr	CPSR_c, r0
        *err = OS_NO_ERR;
 c221fc0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c221fc4:	e3a02000 	mov	r2, #0
 c221fc8:	e5c32000 	strb	r2, [r3]
        return (msg);                            /* Return message received                            */
 c221fcc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c221fd0:	ea00003c 	b	c2220c8 <OSQPend+0x224>
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
 c221fd4:	e59f3100 	ldr	r3, [pc, #256]	; c2220dc <OSQPend+0x238>
 c221fd8:	e5933000 	ldr	r3, [r3]
 c221fdc:	e59f20f8 	ldr	r2, [pc, #248]	; c2220dc <OSQPend+0x238>
 c221fe0:	e5922000 	ldr	r2, [r2]
 c221fe4:	e5d2202c 	ldrb	r2, [r2, #44]	; 0x2c
 c221fe8:	e3822004 	orr	r2, r2, #4
 c221fec:	e20220ff 	and	r2, r2, #255	; 0xff
 c221ff0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = FALSE;
 c221ff4:	e59f30e0 	ldr	r3, [pc, #224]	; c2220dc <OSQPend+0x238>
 c221ff8:	e5933000 	ldr	r3, [r3]
 c221ffc:	e3a02000 	mov	r2, #0
 c222000:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
 c222004:	e59f30d0 	ldr	r3, [pc, #208]	; c2220dc <OSQPend+0x238>
 c222008:	e5933000 	ldr	r3, [r3]
 c22200c:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c222010:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 c222014:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222018:	ebffebef 	bl	c21cfdc <OS_EventTaskWait>
    OS_EXIT_CRITICAL();
 c22201c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222020:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 c222024:	ebffedff 	bl	c21d828 <OS_Sched>
    OS_ENTER_CRITICAL();
 c222028:	e10f0000 	mrs	r0, CPSR
 c22202c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222030:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222034:	e121f000 	msr	CPSR_c, r0
    if (OSTCBCur->OSTCBPendTO == TRUE) {         /* Was task readied because of a timeout?             */
 c222038:	e59f309c 	ldr	r3, [pc, #156]	; c2220dc <OSQPend+0x238>
 c22203c:	e5933000 	ldr	r3, [r3]
 c222040:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
 c222044:	e3530001 	cmp	r3, #1
 c222048:	1a000008 	bne	c222070 <OSQPend+0x1cc>
        OS_EventTO(pevent);                      /* Yes                                                */
 c22204c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222050:	ebffec37 	bl	c21d134 <OS_EventTO>
        OS_EXIT_CRITICAL();
 c222054:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222058:	e121f000 	msr	CPSR_c, r0
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
 c22205c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222060:	e3a0200a 	mov	r2, #10
 c222064:	e5c32000 	strb	r2, [r3]
        return ((void *)0);                      /*     No message received                            */
 c222068:	e3a03000 	mov	r3, #0
 c22206c:	ea000015 	b	c2220c8 <OSQPend+0x224>
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
 c222070:	e59f3064 	ldr	r3, [pc, #100]	; c2220dc <OSQPend+0x238>
 c222074:	e5933000 	ldr	r3, [r3]
 c222078:	e5933020 	ldr	r3, [r3, #32]
 c22207c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    OSTCBCur->OSTCBMsg      = (void *)0;
 c222080:	e59f3054 	ldr	r3, [pc, #84]	; c2220dc <OSQPend+0x238>
 c222084:	e5933000 	ldr	r3, [r3]
 c222088:	e3a02000 	mov	r2, #0
 c22208c:	e5832020 	str	r2, [r3, #32]
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
 c222090:	e59f3044 	ldr	r3, [pc, #68]	; c2220dc <OSQPend+0x238>
 c222094:	e5933000 	ldr	r3, [r3]
 c222098:	e3a02000 	mov	r2, #0
 c22209c:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
 c2220a0:	e59f3034 	ldr	r3, [pc, #52]	; c2220dc <OSQPend+0x238>
 c2220a4:	e5933000 	ldr	r3, [r3]
 c2220a8:	e3a02000 	mov	r2, #0
 c2220ac:	e583201c 	str	r2, [r3, #28]
    OS_EXIT_CRITICAL();
 c2220b0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2220b4:	e121f000 	msr	CPSR_c, r0
    *err                    = OS_NO_ERR;
 c2220b8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2220bc:	e3a02000 	mov	r2, #0
 c2220c0:	e5c32000 	strb	r2, [r3]
    return (msg);                                /*     Return message received                        */
 c2220c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c2220c8:	e1a00003 	mov	r0, r3
 c2220cc:	e24bd00c 	sub	sp, fp, #12
 c2220d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2220d4:	e12fff1e 	bx	lr
 c2220d8:	0c1c84c0 	.word	0x0c1c84c0
 c2220dc:	0c1c84c4 	.word	0x0c1c84c4

0c2220e0 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
 c2220e0:	e1a0c00d 	mov	ip, sp
 c2220e4:	e92dd800 	push	{fp, ip, lr, pc}
 c2220e8:	e24cb004 	sub	fp, ip, #4
 c2220ec:	e24dd010 	sub	sp, sp, #16
 c2220f0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c2220f4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                        /* Prevent compiler warning                     */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 c2220f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2220fc:	e3530000 	cmp	r3, #0
 c222100:	1a000001 	bne	c22210c <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c222104:	e3a03004 	mov	r3, #4
 c222108:	ea00003e 	b	c222208 <OSQPost+0x128>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 c22210c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222110:	e5d33000 	ldrb	r3, [r3]
 c222114:	e3530002 	cmp	r3, #2
 c222118:	0a000001 	beq	c222124 <OSQPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 c22211c:	e3a03001 	mov	r3, #1
 c222120:	ea000038 	b	c222208 <OSQPost+0x128>
    }
    OS_ENTER_CRITICAL();
 c222124:	e10f0000 	mrs	r0, CPSR
 c222128:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c22212c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222130:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                  /* See if any task pending on queue             */
 c222134:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222138:	e5d33001 	ldrb	r3, [r3, #1]
 c22213c:	e3530000 	cmp	r3, #0
 c222140:	0a000008 	beq	c222168 <OSQPost+0x88>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
 c222144:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222148:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c22214c:	e3a02004 	mov	r2, #4
 c222150:	ebffeb1e 	bl	c21cdd0 <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
 c222154:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222158:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                    /* Find highest priority task ready to run      */
 c22215c:	ebffedb1 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c222160:	e3a03000 	mov	r3, #0
 c222164:	ea000027 	b	c222208 <OSQPost+0x128>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 c222168:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22216c:	e5933004 	ldr	r3, [r3, #4]
 c222170:	e50b3010 	str	r3, [fp, #-16]
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 c222174:	e51b3010 	ldr	r3, [fp, #-16]
 c222178:	e1d321b6 	ldrh	r2, [r3, #22]
 c22217c:	e51b3010 	ldr	r3, [fp, #-16]
 c222180:	e1d331b4 	ldrh	r3, [r3, #20]
 c222184:	e1520003 	cmp	r2, r3
 c222188:	3a000003 	bcc	c22219c <OSQPost+0xbc>
        OS_EXIT_CRITICAL();
 c22218c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222190:	e121f000 	msr	CPSR_c, r0
        return (OS_Q_FULL);
 c222194:	e3a0301e 	mov	r3, #30
 c222198:	ea00001a 	b	c222208 <OSQPost+0x128>
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
 c22219c:	e51b3010 	ldr	r3, [fp, #-16]
 c2221a0:	e593300c 	ldr	r3, [r3, #12]
 c2221a4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2221a8:	e5832000 	str	r2, [r3]
 c2221ac:	e2832004 	add	r2, r3, #4
 c2221b0:	e51b3010 	ldr	r3, [fp, #-16]
 c2221b4:	e583200c 	str	r2, [r3, #12]
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 c2221b8:	e51b3010 	ldr	r3, [fp, #-16]
 c2221bc:	e1d331b6 	ldrh	r3, [r3, #22]
 c2221c0:	e2833001 	add	r3, r3, #1
 c2221c4:	e1a03803 	lsl	r3, r3, #16
 c2221c8:	e1a02823 	lsr	r2, r3, #16
 c2221cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2221d0:	e1c321b6 	strh	r2, [r3, #22]
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 c2221d4:	e51b3010 	ldr	r3, [fp, #-16]
 c2221d8:	e593200c 	ldr	r2, [r3, #12]
 c2221dc:	e51b3010 	ldr	r3, [fp, #-16]
 c2221e0:	e5933008 	ldr	r3, [r3, #8]
 c2221e4:	e1520003 	cmp	r2, r3
 c2221e8:	1a000003 	bne	c2221fc <OSQPost+0x11c>
        pq->OSQIn = pq->OSQStart;
 c2221ec:	e51b3010 	ldr	r3, [fp, #-16]
 c2221f0:	e5932004 	ldr	r2, [r3, #4]
 c2221f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2221f8:	e583200c 	str	r2, [r3, #12]
    }
    OS_EXIT_CRITICAL();
 c2221fc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222200:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c222204:	e3a03000 	mov	r3, #0
}
 c222208:	e1a00003 	mov	r0, r3
 c22220c:	e24bd00c 	sub	sp, fp, #12
 c222210:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222214:	e12fff1e 	bx	lr

0c222218 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
 c222218:	e1a0c00d 	mov	ip, sp
 c22221c:	e92dd800 	push	{fp, ip, lr, pc}
 c222220:	e24cb004 	sub	fp, ip, #4
 c222224:	e24dd010 	sub	sp, sp, #16
 c222228:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c22222c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c222230:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222234:	e3530000 	cmp	r3, #0
 c222238:	1a000001 	bne	c222244 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c22223c:	e3a03004 	mov	r3, #4
 c222240:	ea000040 	b	c222348 <OSQPostFront+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 c222244:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222248:	e5d33000 	ldrb	r3, [r3]
 c22224c:	e3530002 	cmp	r3, #2
 c222250:	0a000001 	beq	c22225c <OSQPostFront+0x44>
        return (OS_ERR_EVENT_TYPE);
 c222254:	e3a03001 	mov	r3, #1
 c222258:	ea00003a 	b	c222348 <OSQPostFront+0x130>
    }
    OS_ENTER_CRITICAL();
 c22225c:	e10f0000 	mrs	r0, CPSR
 c222260:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222264:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222268:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 c22226c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222270:	e5d33001 	ldrb	r3, [r3, #1]
 c222274:	e3530000 	cmp	r3, #0
 c222278:	0a000008 	beq	c2222a0 <OSQPostFront+0x88>
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
 c22227c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222280:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c222284:	e3a02004 	mov	r2, #4
 c222288:	ebffead0 	bl	c21cdd0 <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
 c22228c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222290:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                   /* Find highest priority task ready to run       */
 c222294:	ebffed63 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c222298:	e3a03000 	mov	r3, #0
 c22229c:	ea000029 	b	c222348 <OSQPostFront+0x130>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 c2222a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2222a4:	e5933004 	ldr	r3, [r3, #4]
 c2222a8:	e50b3010 	str	r3, [fp, #-16]
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 c2222ac:	e51b3010 	ldr	r3, [fp, #-16]
 c2222b0:	e1d321b6 	ldrh	r2, [r3, #22]
 c2222b4:	e51b3010 	ldr	r3, [fp, #-16]
 c2222b8:	e1d331b4 	ldrh	r3, [r3, #20]
 c2222bc:	e1520003 	cmp	r2, r3
 c2222c0:	3a000003 	bcc	c2222d4 <OSQPostFront+0xbc>
        OS_EXIT_CRITICAL();
 c2222c4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2222c8:	e121f000 	msr	CPSR_c, r0
        return (OS_Q_FULL);
 c2222cc:	e3a0301e 	mov	r3, #30
 c2222d0:	ea00001c 	b	c222348 <OSQPostFront+0x130>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 c2222d4:	e51b3010 	ldr	r3, [fp, #-16]
 c2222d8:	e5932010 	ldr	r2, [r3, #16]
 c2222dc:	e51b3010 	ldr	r3, [fp, #-16]
 c2222e0:	e5933004 	ldr	r3, [r3, #4]
 c2222e4:	e1520003 	cmp	r2, r3
 c2222e8:	1a000003 	bne	c2222fc <OSQPostFront+0xe4>
        pq->OSQOut = pq->OSQEnd;
 c2222ec:	e51b3010 	ldr	r3, [fp, #-16]
 c2222f0:	e5932008 	ldr	r2, [r3, #8]
 c2222f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2222f8:	e5832010 	str	r2, [r3, #16]
    }
    pq->OSQOut--;
 c2222fc:	e51b3010 	ldr	r3, [fp, #-16]
 c222300:	e5933010 	ldr	r3, [r3, #16]
 c222304:	e2432004 	sub	r2, r3, #4
 c222308:	e51b3010 	ldr	r3, [fp, #-16]
 c22230c:	e5832010 	str	r2, [r3, #16]
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
 c222310:	e51b3010 	ldr	r3, [fp, #-16]
 c222314:	e5933010 	ldr	r3, [r3, #16]
 c222318:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c22231c:	e5832000 	str	r2, [r3]
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 c222320:	e51b3010 	ldr	r3, [fp, #-16]
 c222324:	e1d331b6 	ldrh	r3, [r3, #22]
 c222328:	e2833001 	add	r3, r3, #1
 c22232c:	e1a03803 	lsl	r3, r3, #16
 c222330:	e1a02823 	lsr	r2, r3, #16
 c222334:	e51b3010 	ldr	r3, [fp, #-16]
 c222338:	e1c321b6 	strh	r2, [r3, #22]
    OS_EXIT_CRITICAL();
 c22233c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222340:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c222344:	e3a03000 	mov	r3, #0
}
 c222348:	e1a00003 	mov	r0, r3
 c22234c:	e24bd00c 	sub	sp, fp, #12
 c222350:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222354:	e12fff1e 	bx	lr

0c222358 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
 c222358:	e1a0c00d 	mov	ip, sp
 c22235c:	e92dd800 	push	{fp, ip, lr, pc}
 c222360:	e24cb004 	sub	fp, ip, #4
 c222364:	e24dd018 	sub	sp, sp, #24
 c222368:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c22236c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c222370:	e1a03002 	mov	r3, r2
 c222374:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c222378:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22237c:	e3530000 	cmp	r3, #0
 c222380:	1a000001 	bne	c22238c <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 c222384:	e3a03004 	mov	r3, #4
 c222388:	ea000065 	b	c222524 <OSQPostOpt+0x1cc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 c22238c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222390:	e5d33000 	ldrb	r3, [r3]
 c222394:	e3530002 	cmp	r3, #2
 c222398:	0a000001 	beq	c2223a4 <OSQPostOpt+0x4c>
        return (OS_ERR_EVENT_TYPE);
 c22239c:	e3a03001 	mov	r3, #1
 c2223a0:	ea00005f 	b	c222524 <OSQPostOpt+0x1cc>
    }
    OS_ENTER_CRITICAL();
 c2223a4:	e10f0000 	mrs	r0, CPSR
 c2223a8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2223ac:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2223b0:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 c2223b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2223b8:	e5d33001 	ldrb	r3, [r3, #1]
 c2223bc:	e3530000 	cmp	r3, #0
 c2223c0:	0a000017 	beq	c222424 <OSQPostOpt+0xcc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 c2223c4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2223c8:	e2033001 	and	r3, r3, #1
 c2223cc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2223d0:	e3530000 	cmp	r3, #0
 c2223d4:	0a000009 	beq	c222400 <OSQPostOpt+0xa8>
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
 c2223d8:	ea000003 	b	c2223ec <OSQPostOpt+0x94>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
 c2223dc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c2223e0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c2223e4:	e3a02004 	mov	r2, #4
 c2223e8:	ebffea78 	bl	c21cdd0 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
 c2223ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2223f0:	e5d33001 	ldrb	r3, [r3, #1]
 c2223f4:	e3530000 	cmp	r3, #0
 c2223f8:	1afffff7 	bne	c2223dc <OSQPostOpt+0x84>
 c2223fc:	ea000003 	b	c222410 <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
 c222400:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222404:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c222408:	e3a02004 	mov	r2, #4
 c22240c:	ebffea6f 	bl	c21cdd0 <OS_EventTaskRdy>
        }
        OS_EXIT_CRITICAL();
 c222410:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222414:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                         /* Find highest priority task ready to run */
 c222418:	ebffed02 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c22241c:	e3a03000 	mov	r3, #0
 c222420:	ea00003f 	b	c222524 <OSQPostOpt+0x1cc>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 c222424:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222428:	e5933004 	ldr	r3, [r3, #4]
 c22242c:	e50b3010 	str	r3, [fp, #-16]
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 c222430:	e51b3010 	ldr	r3, [fp, #-16]
 c222434:	e1d321b6 	ldrh	r2, [r3, #22]
 c222438:	e51b3010 	ldr	r3, [fp, #-16]
 c22243c:	e1d331b4 	ldrh	r3, [r3, #20]
 c222440:	e1520003 	cmp	r2, r3
 c222444:	3a000003 	bcc	c222458 <OSQPostOpt+0x100>
        OS_EXIT_CRITICAL();
 c222448:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22244c:	e121f000 	msr	CPSR_c, r0
        return (OS_Q_FULL);
 c222450:	e3a0301e 	mov	r3, #30
 c222454:	ea000032 	b	c222524 <OSQPostOpt+0x1cc>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 c222458:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c22245c:	e2033002 	and	r3, r3, #2
 c222460:	e3530000 	cmp	r3, #0
 c222464:	0a000013 	beq	c2224b8 <OSQPostOpt+0x160>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 c222468:	e51b3010 	ldr	r3, [fp, #-16]
 c22246c:	e5932010 	ldr	r2, [r3, #16]
 c222470:	e51b3010 	ldr	r3, [fp, #-16]
 c222474:	e5933004 	ldr	r3, [r3, #4]
 c222478:	e1520003 	cmp	r2, r3
 c22247c:	1a000003 	bne	c222490 <OSQPostOpt+0x138>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 c222480:	e51b3010 	ldr	r3, [fp, #-16]
 c222484:	e5932008 	ldr	r2, [r3, #8]
 c222488:	e51b3010 	ldr	r3, [fp, #-16]
 c22248c:	e5832010 	str	r2, [r3, #16]
        }
        pq->OSQOut--;
 c222490:	e51b3010 	ldr	r3, [fp, #-16]
 c222494:	e5933010 	ldr	r3, [r3, #16]
 c222498:	e2432004 	sub	r2, r3, #4
 c22249c:	e51b3010 	ldr	r3, [fp, #-16]
 c2224a0:	e5832010 	str	r2, [r3, #16]
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
 c2224a4:	e51b3010 	ldr	r3, [fp, #-16]
 c2224a8:	e5933010 	ldr	r3, [r3, #16]
 c2224ac:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2224b0:	e5832000 	str	r2, [r3]
 c2224b4:	ea000010 	b	c2224fc <OSQPostOpt+0x1a4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
 c2224b8:	e51b3010 	ldr	r3, [fp, #-16]
 c2224bc:	e593300c 	ldr	r3, [r3, #12]
 c2224c0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2224c4:	e5832000 	str	r2, [r3]
 c2224c8:	e2832004 	add	r2, r3, #4
 c2224cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2224d0:	e583200c 	str	r2, [r3, #12]
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 c2224d4:	e51b3010 	ldr	r3, [fp, #-16]
 c2224d8:	e593200c 	ldr	r2, [r3, #12]
 c2224dc:	e51b3010 	ldr	r3, [fp, #-16]
 c2224e0:	e5933008 	ldr	r3, [r3, #8]
 c2224e4:	e1520003 	cmp	r2, r3
 c2224e8:	1a000003 	bne	c2224fc <OSQPostOpt+0x1a4>
            pq->OSQIn = pq->OSQStart;
 c2224ec:	e51b3010 	ldr	r3, [fp, #-16]
 c2224f0:	e5932004 	ldr	r2, [r3, #4]
 c2224f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2224f8:	e583200c 	str	r2, [r3, #12]
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 c2224fc:	e51b3010 	ldr	r3, [fp, #-16]
 c222500:	e1d331b6 	ldrh	r3, [r3, #22]
 c222504:	e2833001 	add	r3, r3, #1
 c222508:	e1a03803 	lsl	r3, r3, #16
 c22250c:	e1a02823 	lsr	r2, r3, #16
 c222510:	e51b3010 	ldr	r3, [fp, #-16]
 c222514:	e1c321b6 	strh	r2, [r3, #22]
    OS_EXIT_CRITICAL();
 c222518:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22251c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c222520:	e3a03000 	mov	r3, #0
}
 c222524:	e1a00003 	mov	r0, r3
 c222528:	e24bd00c 	sub	sp, fp, #12
 c22252c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222530:	e12fff1e 	bx	lr

0c222534 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 c222534:	e1a0c00d 	mov	ip, sp
 c222538:	e92dd800 	push	{fp, ip, lr, pc}
 c22253c:	e24cb004 	sub	fp, ip, #4
 c222540:	e24dd018 	sub	sp, sp, #24
 c222544:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c222548:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc


    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c22254c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222550:	e3530000 	cmp	r3, #0
 c222554:	1a000001 	bne	c222560 <OSQQuery+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c222558:	e3a03004 	mov	r3, #4
 c22255c:	ea000078 	b	c222744 <OSQQuery+0x210>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 c222560:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222564:	e5d33000 	ldrb	r3, [r3]
 c222568:	e3530002 	cmp	r3, #2
 c22256c:	0a000001 	beq	c222578 <OSQQuery+0x44>
        return (OS_ERR_EVENT_TYPE);
 c222570:	e3a03001 	mov	r3, #1
 c222574:	ea000072 	b	c222744 <OSQQuery+0x210>
    }
    OS_ENTER_CRITICAL();
 c222578:	e10f0000 	mrs	r0, CPSR
 c22257c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222580:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222584:	e121f000 	msr	CPSR_c, r0
    p_q_data->OSEventGrp = pevent->OSEventGrp;             /* Copy message queue wait list             */
 c222588:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22258c:	e5d32001 	ldrb	r2, [r3, #1]
 c222590:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c222594:	e5c32010 	strb	r2, [r3, #16]
    psrc                 = &pevent->OSEventTbl[0];
 c222598:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22259c:	e2833008 	add	r3, r3, #8
 c2225a0:	e50b3010 	str	r3, [fp, #-16]
    pdest                = &p_q_data->OSEventTbl[0];
 c2225a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2225a8:	e2833008 	add	r3, r3, #8
 c2225ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if OS_EVENT_TBL_SIZE > 0
    *pdest++ = *psrc++;
 c2225b0:	e51b3010 	ldr	r3, [fp, #-16]
 c2225b4:	e5d32000 	ldrb	r2, [r3]
 c2225b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2225bc:	e5c32000 	strb	r2, [r3]
 c2225c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2225c4:	e2833001 	add	r3, r3, #1
 c2225c8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2225cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2225d0:	e2833001 	add	r3, r3, #1
 c2225d4:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 1
    *pdest++ = *psrc++;
 c2225d8:	e51b3010 	ldr	r3, [fp, #-16]
 c2225dc:	e5d32000 	ldrb	r2, [r3]
 c2225e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2225e4:	e5c32000 	strb	r2, [r3]
 c2225e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2225ec:	e2833001 	add	r3, r3, #1
 c2225f0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2225f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2225f8:	e2833001 	add	r3, r3, #1
 c2225fc:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 2
    *pdest++ = *psrc++;
 c222600:	e51b3010 	ldr	r3, [fp, #-16]
 c222604:	e5d32000 	ldrb	r2, [r3]
 c222608:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22260c:	e5c32000 	strb	r2, [r3]
 c222610:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222614:	e2833001 	add	r3, r3, #1
 c222618:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22261c:	e51b3010 	ldr	r3, [fp, #-16]
 c222620:	e2833001 	add	r3, r3, #1
 c222624:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 3
    *pdest++ = *psrc++;
 c222628:	e51b3010 	ldr	r3, [fp, #-16]
 c22262c:	e5d32000 	ldrb	r2, [r3]
 c222630:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222634:	e5c32000 	strb	r2, [r3]
 c222638:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22263c:	e2833001 	add	r3, r3, #1
 c222640:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222644:	e51b3010 	ldr	r3, [fp, #-16]
 c222648:	e2833001 	add	r3, r3, #1
 c22264c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 4
    *pdest++ = *psrc++;
 c222650:	e51b3010 	ldr	r3, [fp, #-16]
 c222654:	e5d32000 	ldrb	r2, [r3]
 c222658:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22265c:	e5c32000 	strb	r2, [r3]
 c222660:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222664:	e2833001 	add	r3, r3, #1
 c222668:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22266c:	e51b3010 	ldr	r3, [fp, #-16]
 c222670:	e2833001 	add	r3, r3, #1
 c222674:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 5
    *pdest++ = *psrc++;
 c222678:	e51b3010 	ldr	r3, [fp, #-16]
 c22267c:	e5d32000 	ldrb	r2, [r3]
 c222680:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222684:	e5c32000 	strb	r2, [r3]
 c222688:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22268c:	e2833001 	add	r3, r3, #1
 c222690:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222694:	e51b3010 	ldr	r3, [fp, #-16]
 c222698:	e2833001 	add	r3, r3, #1
 c22269c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 6
    *pdest++ = *psrc++;
 c2226a0:	e51b3010 	ldr	r3, [fp, #-16]
 c2226a4:	e5d32000 	ldrb	r2, [r3]
 c2226a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2226ac:	e5c32000 	strb	r2, [r3]
 c2226b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2226b4:	e2833001 	add	r3, r3, #1
 c2226b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2226bc:	e51b3010 	ldr	r3, [fp, #-16]
 c2226c0:	e2833001 	add	r3, r3, #1
 c2226c4:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 7
    *pdest   = *psrc;
 c2226c8:	e51b3010 	ldr	r3, [fp, #-16]
 c2226cc:	e5d32000 	ldrb	r2, [r3]
 c2226d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2226d4:	e5c32000 	strb	r2, [r3]
#endif
    pq = (OS_Q *)pevent->OSEventPtr;
 c2226d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2226dc:	e5933004 	ldr	r3, [r3, #4]
 c2226e0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (pq->OSQEntries > 0) {
 c2226e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2226e8:	e1d331b6 	ldrh	r3, [r3, #22]
 c2226ec:	e3530000 	cmp	r3, #0
 c2226f0:	0a000005 	beq	c22270c <OSQQuery+0x1d8>
        p_q_data->OSMsg = *pq->OSQOut;                     /* Get next message to return if available  */
 c2226f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2226f8:	e5933010 	ldr	r3, [r3, #16]
 c2226fc:	e5932000 	ldr	r2, [r3]
 c222700:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c222704:	e5832000 	str	r2, [r3]
 c222708:	ea000002 	b	c222718 <OSQQuery+0x1e4>
    } else {
        p_q_data->OSMsg = (void *)0;
 c22270c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c222710:	e3a02000 	mov	r2, #0
 c222714:	e5832000 	str	r2, [r3]
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 c222718:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22271c:	e1d321b6 	ldrh	r2, [r3, #22]
 c222720:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c222724:	e1c320b4 	strh	r2, [r3, #4]
    p_q_data->OSQSize = pq->OSQSize;
 c222728:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22272c:	e1d321b4 	ldrh	r2, [r3, #20]
 c222730:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c222734:	e1c320b6 	strh	r2, [r3, #6]
    OS_EXIT_CRITICAL();
 c222738:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22273c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c222740:	e3a03000 	mov	r3, #0
}
 c222744:	e1a00003 	mov	r0, r3
 c222748:	e24bd00c 	sub	sp, fp, #12
 c22274c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222750:	e12fff1e 	bx	lr

0c222754 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 c222754:	e1a0c00d 	mov	ip, sp
 c222758:	e92dd800 	push	{fp, ip, lr, pc}
 c22275c:	e24cb004 	sub	fp, ip, #4
 c222760:	e24dd010 	sub	sp, sp, #16
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 c222764:	e59f3084 	ldr	r3, [pc, #132]	; c2227f0 <OS_QInit+0x9c>
 c222768:	e1a00003 	mov	r0, r3
 c22276c:	e3a01060 	mov	r1, #96	; 0x60
 c222770:	ebffebf9 	bl	c21d75c <OS_MemClr>
    pq1 = &OSQTbl[0];
 c222774:	e59f3074 	ldr	r3, [pc, #116]	; c2227f0 <OS_QInit+0x9c>
 c222778:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    pq2 = &OSQTbl[1];
 c22277c:	e59f3070 	ldr	r3, [pc, #112]	; c2227f4 <OS_QInit+0xa0>
 c222780:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 c222784:	e3a03000 	mov	r3, #0
 c222788:	e14b30be 	strh	r3, [fp, #-14]
 c22278c:	ea00000b 	b	c2227c0 <OS_QInit+0x6c>
        pq1->OSQPtr = pq2;
 c222790:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222794:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c222798:	e5832000 	str	r2, [r3]
        pq1++;
 c22279c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2227a0:	e2833018 	add	r3, r3, #24
 c2227a4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        pq2++;
 c2227a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2227ac:	e2833018 	add	r3, r3, #24
 c2227b0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 c2227b4:	e15b30be 	ldrh	r3, [fp, #-14]
 c2227b8:	e2833001 	add	r3, r3, #1
 c2227bc:	e14b30be 	strh	r3, [fp, #-14]
 c2227c0:	e15b30be 	ldrh	r3, [fp, #-14]
 c2227c4:	e3530002 	cmp	r3, #2
 c2227c8:	9afffff0 	bls	c222790 <OS_QInit+0x3c>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 c2227cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2227d0:	e3a02000 	mov	r2, #0
 c2227d4:	e5832000 	str	r2, [r3]
    OSQFreeList = &OSQTbl[0];
 c2227d8:	e59f3018 	ldr	r3, [pc, #24]	; c2227f8 <OS_QInit+0xa4>
 c2227dc:	e59f200c 	ldr	r2, [pc, #12]	; c2227f0 <OS_QInit+0x9c>
 c2227e0:	e5832000 	str	r2, [r3]
#endif
}
 c2227e4:	e24bd00c 	sub	sp, fp, #12
 c2227e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2227ec:	e12fff1e 	bx	lr
 c2227f0:	0c1c8448 	.word	0x0c1c8448
 c2227f4:	0c1c8460 	.word	0x0c1c8460
 c2227f8:	0c1c84ac 	.word	0x0c1c84ac

0c2227fc <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 c2227fc:	e1a0c00d 	mov	ip, sp
 c222800:	e92dd800 	push	{fp, ip, lr, pc}
 c222804:	e24cb004 	sub	fp, ip, #4
 c222808:	e24dd010 	sub	sp, sp, #16
 c22280c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c222810:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222814:	e3530000 	cmp	r3, #0
 c222818:	1a000001 	bne	c222824 <OSSemAccept+0x28>
        return (0);
 c22281c:	e3a03000 	mov	r3, #0
 c222820:	ea000019 	b	c22288c <OSSemAccept+0x90>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 c222824:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222828:	e5d33000 	ldrb	r3, [r3]
 c22282c:	e3530003 	cmp	r3, #3
 c222830:	0a000001 	beq	c22283c <OSSemAccept+0x40>
        return (0);
 c222834:	e3a03000 	mov	r3, #0
 c222838:	ea000013 	b	c22288c <OSSemAccept+0x90>
    }
    OS_ENTER_CRITICAL();
 c22283c:	e10f0000 	mrs	r0, CPSR
 c222840:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222844:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222848:	e121f000 	msr	CPSR_c, r0
    cnt = pevent->OSEventCnt;
 c22284c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222850:	e1d330b2 	ldrh	r3, [r3, #2]
 c222854:	e14b30be 	strh	r3, [fp, #-14]
    if (cnt > 0) {                                    /* See if resource is available                  */
 c222858:	e15b30be 	ldrh	r3, [fp, #-14]
 c22285c:	e3530000 	cmp	r3, #0
 c222860:	0a000006 	beq	c222880 <OSSemAccept+0x84>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 c222864:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222868:	e1d330b2 	ldrh	r3, [r3, #2]
 c22286c:	e2433001 	sub	r3, r3, #1
 c222870:	e1a03803 	lsl	r3, r3, #16
 c222874:	e1a02823 	lsr	r2, r3, #16
 c222878:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22287c:	e1c320b2 	strh	r2, [r3, #2]
    }
    OS_EXIT_CRITICAL();
 c222880:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222884:	e121f000 	msr	CPSR_c, r0
    return (cnt);                                     /* Return semaphore count                        */
 c222888:	e15b30be 	ldrh	r3, [fp, #-14]
}
 c22288c:	e1a00003 	mov	r0, r3
 c222890:	e24bd00c 	sub	sp, fp, #12
 c222894:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222898:	e12fff1e 	bx	lr

0c22289c <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 c22289c:	e1a0c00d 	mov	ip, sp
 c2228a0:	e92dd800 	push	{fp, ip, lr, pc}
 c2228a4:	e24cb004 	sub	fp, ip, #4
 c2228a8:	e24dd010 	sub	sp, sp, #16
 c2228ac:	e1a03000 	mov	r3, r0
 c2228b0:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c2228b4:	e59f30c0 	ldr	r3, [pc, #192]	; c22297c <OSSemCreate+0xe0>
 c2228b8:	e5d33000 	ldrb	r3, [r3]
 c2228bc:	e3530000 	cmp	r3, #0
 c2228c0:	0a000001 	beq	c2228cc <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 c2228c4:	e3a03000 	mov	r3, #0
 c2228c8:	ea000027 	b	c22296c <OSSemCreate+0xd0>
    }
    OS_ENTER_CRITICAL();
 c2228cc:	e10f0000 	mrs	r0, CPSR
 c2228d0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2228d4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2228d8:	e121f000 	msr	CPSR_c, r0
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 c2228dc:	e59f309c 	ldr	r3, [pc, #156]	; c222980 <OSSemCreate+0xe4>
 c2228e0:	e5933000 	ldr	r3, [r3]
 c2228e4:	e50b3010 	str	r3, [fp, #-16]
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 c2228e8:	e59f3090 	ldr	r3, [pc, #144]	; c222980 <OSSemCreate+0xe4>
 c2228ec:	e5933000 	ldr	r3, [r3]
 c2228f0:	e3530000 	cmp	r3, #0
 c2228f4:	0a000005 	beq	c222910 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 c2228f8:	e59f3080 	ldr	r3, [pc, #128]	; c222980 <OSSemCreate+0xe4>
 c2228fc:	e5933000 	ldr	r3, [r3]
 c222900:	e5933004 	ldr	r3, [r3, #4]
 c222904:	e1a02003 	mov	r2, r3
 c222908:	e59f3070 	ldr	r3, [pc, #112]	; c222980 <OSSemCreate+0xe4>
 c22290c:	e5832000 	str	r2, [r3]
    }
    OS_EXIT_CRITICAL();
 c222910:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222914:	e121f000 	msr	CPSR_c, r0
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 c222918:	e51b3010 	ldr	r3, [fp, #-16]
 c22291c:	e3530000 	cmp	r3, #0
 c222920:	0a000010 	beq	c222968 <OSSemCreate+0xcc>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 c222924:	e51b3010 	ldr	r3, [fp, #-16]
 c222928:	e3a02003 	mov	r2, #3
 c22292c:	e5c32000 	strb	r2, [r3]
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 c222930:	e51b3010 	ldr	r3, [fp, #-16]
 c222934:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c222938:	e1c320b2 	strh	r2, [r3, #2]
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 c22293c:	e51b3010 	ldr	r3, [fp, #-16]
 c222940:	e3a02000 	mov	r2, #0
 c222944:	e5832004 	str	r2, [r3, #4]
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 c222948:	e51b3010 	ldr	r3, [fp, #-16]
 c22294c:	e3a0203f 	mov	r2, #63	; 0x3f
 c222950:	e5c32010 	strb	r2, [r3, #16]
        pevent->OSEventName[1] = OS_ASCII_NUL;
 c222954:	e51b3010 	ldr	r3, [fp, #-16]
 c222958:	e3a02000 	mov	r2, #0
 c22295c:	e5c32011 	strb	r2, [r3, #17]
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 c222960:	e51b0010 	ldr	r0, [fp, #-16]
 c222964:	ebffea37 	bl	c21d248 <OS_EventWaitListInit>
    }
    return (pevent);
 c222968:	e51b3010 	ldr	r3, [fp, #-16]
}
 c22296c:	e1a00003 	mov	r0, r3
 c222970:	e24bd00c 	sub	sp, fp, #12
 c222974:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222978:	e12fff1e 	bx	lr
 c22297c:	0c1c84c0 	.word	0x0c1c84c0
 c222980:	0c1c84bc 	.word	0x0c1c84bc

0c222984 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
{
 c222984:	e1a0c00d 	mov	ip, sp
 c222988:	e92dd800 	push	{fp, ip, lr, pc}
 c22298c:	e24cb004 	sub	fp, ip, #4
 c222990:	e24dd018 	sub	sp, sp, #24
 c222994:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c222998:	e1a03001 	mov	r3, r1
 c22299c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c2229a0:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 c2229a4:	e59f3204 	ldr	r3, [pc, #516]	; c222bb0 <OSSemDel+0x22c>
 c2229a8:	e5d33000 	ldrb	r3, [r3]
 c2229ac:	e3530000 	cmp	r3, #0
 c2229b0:	0a000004 	beq	c2229c8 <OSSemDel+0x44>
        *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 c2229b4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2229b8:	e3e02073 	mvn	r2, #115	; 0x73
 c2229bc:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c2229c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2229c4:	ea000075 	b	c222ba0 <OSSemDel+0x21c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c2229c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2229cc:	e3530000 	cmp	r3, #0
 c2229d0:	1a000004 	bne	c2229e8 <OSSemDel+0x64>
        *err = OS_ERR_PEVENT_NULL;
 c2229d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2229d8:	e3a02004 	mov	r2, #4
 c2229dc:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c2229e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2229e4:	ea00006d 	b	c222ba0 <OSSemDel+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 c2229e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2229ec:	e5d33000 	ldrb	r3, [r3]
 c2229f0:	e3530003 	cmp	r3, #3
 c2229f4:	0a000004 	beq	c222a0c <OSSemDel+0x88>
        *err = OS_ERR_EVENT_TYPE;
 c2229f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c2229fc:	e3a02001 	mov	r2, #1
 c222a00:	e5c32000 	strb	r2, [r3]
        return (pevent);
 c222a04:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a08:	ea000064 	b	c222ba0 <OSSemDel+0x21c>
    }
    OS_ENTER_CRITICAL();
 c222a0c:	e10f0000 	mrs	r0, CPSR
 c222a10:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222a14:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222a18:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                      /* See if any tasks waiting on semaphore    */
 c222a1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a20:	e5d33001 	ldrb	r3, [r3, #1]
 c222a24:	e3530000 	cmp	r3, #0
 c222a28:	0a000002 	beq	c222a38 <OSSemDel+0xb4>
        tasks_waiting = TRUE;                              /* Yes                                      */
 c222a2c:	e3a03001 	mov	r3, #1
 c222a30:	e54b300d 	strb	r3, [fp, #-13]
 c222a34:	ea000001 	b	c222a40 <OSSemDel+0xbc>
    } else {
        tasks_waiting = FALSE;                             /* No                                       */
 c222a38:	e3a03000 	mov	r3, #0
 c222a3c:	e54b300d 	strb	r3, [fp, #-13]
    }
    switch (opt) {
 c222a40:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c222a44:	e3530000 	cmp	r3, #0
 c222a48:	0a000002 	beq	c222a58 <OSSemDel+0xd4>
 c222a4c:	e3530001 	cmp	r3, #1
 c222a50:	0a000029 	beq	c222afc <OSSemDel+0x178>
 c222a54:	ea00004b 	b	c222b88 <OSSemDel+0x204>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == FALSE) {
 c222a58:	e55b300d 	ldrb	r3, [fp, #-13]
 c222a5c:	e3530000 	cmp	r3, #0
 c222a60:	1a000019 	bne	c222acc <OSSemDel+0x148>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 c222a64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a68:	e3a0203f 	mov	r2, #63	; 0x3f
 c222a6c:	e5c32010 	strb	r2, [r3, #16]
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 c222a70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a74:	e3a02000 	mov	r2, #0
 c222a78:	e5c32011 	strb	r2, [r3, #17]
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c222a7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a80:	e3a02000 	mov	r2, #0
 c222a84:	e5c32000 	strb	r2, [r3]
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 c222a88:	e59f3124 	ldr	r3, [pc, #292]	; c222bb4 <OSSemDel+0x230>
 c222a8c:	e5932000 	ldr	r2, [r3]
 c222a90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a94:	e5832004 	str	r2, [r3, #4]
                 pevent->OSEventCnt     = 0;
 c222a98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222a9c:	e3a02000 	mov	r2, #0
 c222aa0:	e1c320b2 	strh	r2, [r3, #2]
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 c222aa4:	e59f3108 	ldr	r3, [pc, #264]	; c222bb4 <OSSemDel+0x230>
 c222aa8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c222aac:	e5832000 	str	r2, [r3]
                 OS_EXIT_CRITICAL();
 c222ab0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222ab4:	e121f000 	msr	CPSR_c, r0
                 *err                   = OS_NO_ERR;
 c222ab8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222abc:	e3a02000 	mov	r2, #0
 c222ac0:	e5c32000 	strb	r2, [r3]
                 return ((OS_EVENT *)0);                   /* Semaphore has been deleted               */
 c222ac4:	e3a03000 	mov	r3, #0
 c222ac8:	ea000034 	b	c222ba0 <OSSemDel+0x21c>
             } else {
                 OS_EXIT_CRITICAL();
 c222acc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222ad0:	e121f000 	msr	CPSR_c, r0
                 *err                   = OS_ERR_TASK_WAITING;
 c222ad4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222ad8:	e3a02008 	mov	r2, #8
 c222adc:	e5c32000 	strb	r2, [r3]
                 return (pevent);
 c222ae0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222ae4:	ea00002d 	b	c222ba0 <OSSemDel+0x21c>
             }

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM);
 c222ae8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c222aec:	e3a01000 	mov	r1, #0
 c222af0:	e3a02001 	mov	r2, #1
 c222af4:	ebffe8b5 	bl	c21cdd0 <OS_EventTaskRdy>
 c222af8:	ea000000 	b	c222b00 <OSSemDel+0x17c>
                 *err                   = OS_ERR_TASK_WAITING;
                 return (pevent);
             }

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for semaphore    */
 c222afc:	e1a00000 	nop			; (mov r0, r0)
 c222b00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b04:	e5d33001 	ldrb	r3, [r3, #1]
 c222b08:	e3530000 	cmp	r3, #0
 c222b0c:	1afffff5 	bne	c222ae8 <OSSemDel+0x164>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 c222b10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b14:	e3a0203f 	mov	r2, #63	; 0x3f
 c222b18:	e5c32010 	strb	r2, [r3, #16]
             pevent->OSEventName[1] = OS_ASCII_NUL;
 c222b1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b20:	e3a02000 	mov	r2, #0
 c222b24:	e5c32011 	strb	r2, [r3, #17]
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 c222b28:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b2c:	e3a02000 	mov	r2, #0
 c222b30:	e5c32000 	strb	r2, [r3]
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 c222b34:	e59f3078 	ldr	r3, [pc, #120]	; c222bb4 <OSSemDel+0x230>
 c222b38:	e5932000 	ldr	r2, [r3]
 c222b3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b40:	e5832004 	str	r2, [r3, #4]
             pevent->OSEventCnt     = 0;
 c222b44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222b48:	e3a02000 	mov	r2, #0
 c222b4c:	e1c320b2 	strh	r2, [r3, #2]
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 c222b50:	e59f305c 	ldr	r3, [pc, #92]	; c222bb4 <OSSemDel+0x230>
 c222b54:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c222b58:	e5832000 	str	r2, [r3]
             OS_EXIT_CRITICAL();
 c222b5c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222b60:	e121f000 	msr	CPSR_c, r0
             if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
 c222b64:	e55b300d 	ldrb	r3, [fp, #-13]
 c222b68:	e3530001 	cmp	r3, #1
 c222b6c:	1a000000 	bne	c222b74 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 c222b70:	ebffeb2c 	bl	c21d828 <OS_Sched>
             }
             *err = OS_NO_ERR;
 c222b74:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222b78:	e3a02000 	mov	r2, #0
 c222b7c:	e5c32000 	strb	r2, [r3]
             return ((OS_EVENT *)0);                       /* Semaphore has been deleted               */
 c222b80:	e3a03000 	mov	r3, #0
 c222b84:	ea000005 	b	c222ba0 <OSSemDel+0x21c>

        default:
             OS_EXIT_CRITICAL();
 c222b88:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222b8c:	e121f000 	msr	CPSR_c, r0
             *err = OS_ERR_INVALID_OPT;
 c222b90:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c222b94:	e3a02007 	mov	r2, #7
 c222b98:	e5c32000 	strb	r2, [r3]
             return (pevent);
 c222b9c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    }
}
 c222ba0:	e1a00003 	mov	r0, r3
 c222ba4:	e24bd00c 	sub	sp, fp, #12
 c222ba8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222bac:	e12fff1e 	bx	lr
 c222bb0:	0c1c84c0 	.word	0x0c1c84c0
 c222bb4:	0c1c84bc 	.word	0x0c1c84bc

0c222bb8 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
 c222bb8:	e1a0c00d 	mov	ip, sp
 c222bbc:	e92dd800 	push	{fp, ip, lr, pc}
 c222bc0:	e24cb004 	sub	fp, ip, #4
 c222bc4:	e24dd010 	sub	sp, sp, #16
 c222bc8:	e50b0010 	str	r0, [fp, #-16]
 c222bcc:	e1a03001 	mov	r3, r1
 c222bd0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
 c222bd4:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 c222bd8:	e59f3170 	ldr	r3, [pc, #368]	; c222d50 <OSSemPend+0x198>
 c222bdc:	e5d33000 	ldrb	r3, [r3]
 c222be0:	e3530000 	cmp	r3, #0
 c222be4:	0a000003 	beq	c222bf8 <OSSemPend+0x40>
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
 c222be8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222bec:	e3a02002 	mov	r2, #2
 c222bf0:	e5c32000 	strb	r2, [r3]
        return;
 c222bf4:	ea000052 	b	c222d44 <OSSemPend+0x18c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c222bf8:	e51b3010 	ldr	r3, [fp, #-16]
 c222bfc:	e3530000 	cmp	r3, #0
 c222c00:	1a000003 	bne	c222c14 <OSSemPend+0x5c>
        *err = OS_ERR_PEVENT_NULL;
 c222c04:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222c08:	e3a02004 	mov	r2, #4
 c222c0c:	e5c32000 	strb	r2, [r3]
        return;
 c222c10:	ea00004b 	b	c222d44 <OSSemPend+0x18c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 c222c14:	e51b3010 	ldr	r3, [fp, #-16]
 c222c18:	e5d33000 	ldrb	r3, [r3]
 c222c1c:	e3530003 	cmp	r3, #3
 c222c20:	0a000003 	beq	c222c34 <OSSemPend+0x7c>
        *err = OS_ERR_EVENT_TYPE;
 c222c24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222c28:	e3a02001 	mov	r2, #1
 c222c2c:	e5c32000 	strb	r2, [r3]
        return;
 c222c30:	ea000043 	b	c222d44 <OSSemPend+0x18c>
    }
    OS_ENTER_CRITICAL();
 c222c34:	e10f0000 	mrs	r0, CPSR
 c222c38:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222c3c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222c40:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 c222c44:	e51b3010 	ldr	r3, [fp, #-16]
 c222c48:	e1d330b2 	ldrh	r3, [r3, #2]
 c222c4c:	e3530000 	cmp	r3, #0
 c222c50:	0a00000c 	beq	c222c88 <OSSemPend+0xd0>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 c222c54:	e51b3010 	ldr	r3, [fp, #-16]
 c222c58:	e1d330b2 	ldrh	r3, [r3, #2]
 c222c5c:	e2433001 	sub	r3, r3, #1
 c222c60:	e1a03803 	lsl	r3, r3, #16
 c222c64:	e1a02823 	lsr	r2, r3, #16
 c222c68:	e51b3010 	ldr	r3, [fp, #-16]
 c222c6c:	e1c320b2 	strh	r2, [r3, #2]
        OS_EXIT_CRITICAL();
 c222c70:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222c74:	e121f000 	msr	CPSR_c, r0
        *err = OS_NO_ERR;
 c222c78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222c7c:	e3a02000 	mov	r2, #0
 c222c80:	e5c32000 	strb	r2, [r3]
        return;
 c222c84:	ea00002e 	b	c222d44 <OSSemPend+0x18c>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
 c222c88:	e59f30c4 	ldr	r3, [pc, #196]	; c222d54 <OSSemPend+0x19c>
 c222c8c:	e5933000 	ldr	r3, [r3]
 c222c90:	e59f20bc 	ldr	r2, [pc, #188]	; c222d54 <OSSemPend+0x19c>
 c222c94:	e5922000 	ldr	r2, [r2]
 c222c98:	e5d2202c 	ldrb	r2, [r2, #44]	; 0x2c
 c222c9c:	e3822001 	orr	r2, r2, #1
 c222ca0:	e20220ff 	and	r2, r2, #255	; 0xff
 c222ca4:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OSTCBCur->OSTCBPendTO  = FALSE;
 c222ca8:	e59f30a4 	ldr	r3, [pc, #164]	; c222d54 <OSSemPend+0x19c>
 c222cac:	e5933000 	ldr	r3, [r3]
 c222cb0:	e3a02000 	mov	r2, #0
 c222cb4:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
 c222cb8:	e59f3094 	ldr	r3, [pc, #148]	; c222d54 <OSSemPend+0x19c>
 c222cbc:	e5933000 	ldr	r3, [r3]
 c222cc0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c222cc4:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 c222cc8:	e51b0010 	ldr	r0, [fp, #-16]
 c222ccc:	ebffe8c2 	bl	c21cfdc <OS_EventTaskWait>
    OS_EXIT_CRITICAL();
 c222cd0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222cd4:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                       /* Find next highest priority task ready         */
 c222cd8:	ebffead2 	bl	c21d828 <OS_Sched>
    OS_ENTER_CRITICAL();
 c222cdc:	e10f0000 	mrs	r0, CPSR
 c222ce0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222ce4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222ce8:	e121f000 	msr	CPSR_c, r0
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timedout                            */
 c222cec:	e59f3060 	ldr	r3, [pc, #96]	; c222d54 <OSSemPend+0x19c>
 c222cf0:	e5933000 	ldr	r3, [r3]
 c222cf4:	e5d3302d 	ldrb	r3, [r3, #45]	; 0x2d
 c222cf8:	e3530001 	cmp	r3, #1
 c222cfc:	1a000007 	bne	c222d20 <OSSemPend+0x168>
        OS_EventTO(pevent);
 c222d00:	e51b0010 	ldr	r0, [fp, #-16]
 c222d04:	ebffe90a 	bl	c21d134 <OS_EventTO>
        OS_EXIT_CRITICAL();
 c222d08:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222d0c:	e121f000 	msr	CPSR_c, r0
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
 c222d10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222d14:	e3a0200a 	mov	r2, #10
 c222d18:	e5c32000 	strb	r2, [r3]
        return;
 c222d1c:	ea000008 	b	c222d44 <OSSemPend+0x18c>
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
 c222d20:	e59f302c 	ldr	r3, [pc, #44]	; c222d54 <OSSemPend+0x19c>
 c222d24:	e5933000 	ldr	r3, [r3]
 c222d28:	e3a02000 	mov	r2, #0
 c222d2c:	e583201c 	str	r2, [r3, #28]
    OS_EXIT_CRITICAL();
 c222d30:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222d34:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c222d38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222d3c:	e3a02000 	mov	r2, #0
 c222d40:	e5c32000 	strb	r2, [r3]
}
 c222d44:	e24bd00c 	sub	sp, fp, #12
 c222d48:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222d4c:	e12fff1e 	bx	lr
 c222d50:	0c1c84c0 	.word	0x0c1c84c0
 c222d54:	0c1c84c4 	.word	0x0c1c84c4

0c222d58 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 c222d58:	e1a0c00d 	mov	ip, sp
 c222d5c:	e92dd800 	push	{fp, ip, lr, pc}
 c222d60:	e24cb004 	sub	fp, ip, #4
 c222d64:	e24dd008 	sub	sp, sp, #8
 c222d68:	e50b0010 	str	r0, [fp, #-16]


    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c222d6c:	e51b3010 	ldr	r3, [fp, #-16]
 c222d70:	e3530000 	cmp	r3, #0
 c222d74:	1a000001 	bne	c222d80 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 c222d78:	e3a03004 	mov	r3, #4
 c222d7c:	ea000029 	b	c222e28 <OSSemPost+0xd0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 c222d80:	e51b3010 	ldr	r3, [fp, #-16]
 c222d84:	e5d33000 	ldrb	r3, [r3]
 c222d88:	e3530003 	cmp	r3, #3
 c222d8c:	0a000001 	beq	c222d98 <OSSemPost+0x40>
        return (OS_ERR_EVENT_TYPE);
 c222d90:	e3a03001 	mov	r3, #1
 c222d94:	ea000023 	b	c222e28 <OSSemPost+0xd0>
    }
    OS_ENTER_CRITICAL();
 c222d98:	e10f0000 	mrs	r0, CPSR
 c222d9c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222da0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222da4:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventGrp != 0x00) {                          /* See if any task waiting for semaphore*/
 c222da8:	e51b3010 	ldr	r3, [fp, #-16]
 c222dac:	e5d33001 	ldrb	r3, [r3, #1]
 c222db0:	e3530000 	cmp	r3, #0
 c222db4:	0a000008 	beq	c222ddc <OSSemPost+0x84>
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
 c222db8:	e51b0010 	ldr	r0, [fp, #-16]
 c222dbc:	e3a01000 	mov	r1, #0
 c222dc0:	e3a02001 	mov	r2, #1
 c222dc4:	ebffe801 	bl	c21cdd0 <OS_EventTaskRdy>
        OS_EXIT_CRITICAL();
 c222dc8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222dcc:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                            /* Find HPT ready to run                */
 c222dd0:	ebffea94 	bl	c21d828 <OS_Sched>
        return (OS_NO_ERR);
 c222dd4:	e3a03000 	mov	r3, #0
 c222dd8:	ea000012 	b	c222e28 <OSSemPost+0xd0>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 c222ddc:	e51b3010 	ldr	r3, [fp, #-16]
 c222de0:	e1d320b2 	ldrh	r2, [r3, #2]
 c222de4:	e59f304c 	ldr	r3, [pc, #76]	; c222e38 <OSSemPost+0xe0>
 c222de8:	e1520003 	cmp	r2, r3
 c222dec:	0a00000a 	beq	c222e1c <OSSemPost+0xc4>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 c222df0:	e51b3010 	ldr	r3, [fp, #-16]
 c222df4:	e1d330b2 	ldrh	r3, [r3, #2]
 c222df8:	e2833001 	add	r3, r3, #1
 c222dfc:	e1a03803 	lsl	r3, r3, #16
 c222e00:	e1a02823 	lsr	r2, r3, #16
 c222e04:	e51b3010 	ldr	r3, [fp, #-16]
 c222e08:	e1c320b2 	strh	r2, [r3, #2]
        OS_EXIT_CRITICAL();
 c222e0c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222e10:	e121f000 	msr	CPSR_c, r0
        return (OS_NO_ERR);
 c222e14:	e3a03000 	mov	r3, #0
 c222e18:	ea000002 	b	c222e28 <OSSemPost+0xd0>
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
 c222e1c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222e20:	e121f000 	msr	CPSR_c, r0
    return (OS_SEM_OVF);
 c222e24:	e3a03032 	mov	r3, #50	; 0x32
}
 c222e28:	e1a00003 	mov	r0, r3
 c222e2c:	e24bd00c 	sub	sp, fp, #12
 c222e30:	e89d6800 	ldm	sp, {fp, sp, lr}
 c222e34:	e12fff1e 	bx	lr
 c222e38:	0000ffff 	.word	0x0000ffff

0c222e3c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 c222e3c:	e1a0c00d 	mov	ip, sp
 c222e40:	e92dd800 	push	{fp, ip, lr, pc}
 c222e44:	e24cb004 	sub	fp, ip, #4
 c222e48:	e24dd010 	sub	sp, sp, #16
 c222e4c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c222e50:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4


    cpu_sr = 0;                                            /* Prevent compiler warning                 */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 c222e54:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222e58:	e3530000 	cmp	r3, #0
 c222e5c:	1a000001 	bne	c222e68 <OSSemQuery+0x2c>
        return (OS_ERR_PEVENT_NULL);
 c222e60:	e3a03004 	mov	r3, #4
 c222e64:	ea000064 	b	c222ffc <OSSemQuery+0x1c0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 c222e68:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222e6c:	e5d33000 	ldrb	r3, [r3]
 c222e70:	e3530003 	cmp	r3, #3
 c222e74:	0a000001 	beq	c222e80 <OSSemQuery+0x44>
        return (OS_ERR_EVENT_TYPE);
 c222e78:	e3a03001 	mov	r3, #1
 c222e7c:	ea00005e 	b	c222ffc <OSSemQuery+0x1c0>
    }
    OS_ENTER_CRITICAL();
 c222e80:	e10f0000 	mrs	r0, CPSR
 c222e84:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c222e88:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c222e8c:	e121f000 	msr	CPSR_c, r0
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 c222e90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222e94:	e5d32001 	ldrb	r2, [r3, #1]
 c222e98:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c222e9c:	e5c3200a 	strb	r2, [r3, #10]
    psrc              = &pevent->OSEventTbl[0];
 c222ea0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222ea4:	e2833008 	add	r3, r3, #8
 c222ea8:	e50b3010 	str	r3, [fp, #-16]
    pdest             = &p_sem_data->OSEventTbl[0];
 c222eac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c222eb0:	e2833002 	add	r3, r3, #2
 c222eb4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if OS_EVENT_TBL_SIZE > 0
    *pdest++ = *psrc++;
 c222eb8:	e51b3010 	ldr	r3, [fp, #-16]
 c222ebc:	e5d32000 	ldrb	r2, [r3]
 c222ec0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222ec4:	e5c32000 	strb	r2, [r3]
 c222ec8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222ecc:	e2833001 	add	r3, r3, #1
 c222ed0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222ed4:	e51b3010 	ldr	r3, [fp, #-16]
 c222ed8:	e2833001 	add	r3, r3, #1
 c222edc:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 1
    *pdest++ = *psrc++;
 c222ee0:	e51b3010 	ldr	r3, [fp, #-16]
 c222ee4:	e5d32000 	ldrb	r2, [r3]
 c222ee8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222eec:	e5c32000 	strb	r2, [r3]
 c222ef0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222ef4:	e2833001 	add	r3, r3, #1
 c222ef8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222efc:	e51b3010 	ldr	r3, [fp, #-16]
 c222f00:	e2833001 	add	r3, r3, #1
 c222f04:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 2
    *pdest++ = *psrc++;
 c222f08:	e51b3010 	ldr	r3, [fp, #-16]
 c222f0c:	e5d32000 	ldrb	r2, [r3]
 c222f10:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f14:	e5c32000 	strb	r2, [r3]
 c222f18:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f1c:	e2833001 	add	r3, r3, #1
 c222f20:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222f24:	e51b3010 	ldr	r3, [fp, #-16]
 c222f28:	e2833001 	add	r3, r3, #1
 c222f2c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 3
    *pdest++ = *psrc++;
 c222f30:	e51b3010 	ldr	r3, [fp, #-16]
 c222f34:	e5d32000 	ldrb	r2, [r3]
 c222f38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f3c:	e5c32000 	strb	r2, [r3]
 c222f40:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f44:	e2833001 	add	r3, r3, #1
 c222f48:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222f4c:	e51b3010 	ldr	r3, [fp, #-16]
 c222f50:	e2833001 	add	r3, r3, #1
 c222f54:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 4
    *pdest++ = *psrc++;
 c222f58:	e51b3010 	ldr	r3, [fp, #-16]
 c222f5c:	e5d32000 	ldrb	r2, [r3]
 c222f60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f64:	e5c32000 	strb	r2, [r3]
 c222f68:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f6c:	e2833001 	add	r3, r3, #1
 c222f70:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222f74:	e51b3010 	ldr	r3, [fp, #-16]
 c222f78:	e2833001 	add	r3, r3, #1
 c222f7c:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 5
    *pdest++ = *psrc++;
 c222f80:	e51b3010 	ldr	r3, [fp, #-16]
 c222f84:	e5d32000 	ldrb	r2, [r3]
 c222f88:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f8c:	e5c32000 	strb	r2, [r3]
 c222f90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222f94:	e2833001 	add	r3, r3, #1
 c222f98:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222f9c:	e51b3010 	ldr	r3, [fp, #-16]
 c222fa0:	e2833001 	add	r3, r3, #1
 c222fa4:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 6
    *pdest++ = *psrc++;
 c222fa8:	e51b3010 	ldr	r3, [fp, #-16]
 c222fac:	e5d32000 	ldrb	r2, [r3]
 c222fb0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222fb4:	e5c32000 	strb	r2, [r3]
 c222fb8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222fbc:	e2833001 	add	r3, r3, #1
 c222fc0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c222fc4:	e51b3010 	ldr	r3, [fp, #-16]
 c222fc8:	e2833001 	add	r3, r3, #1
 c222fcc:	e50b3010 	str	r3, [fp, #-16]
#endif

#if OS_EVENT_TBL_SIZE > 7
    *pdest   = *psrc;
 c222fd0:	e51b3010 	ldr	r3, [fp, #-16]
 c222fd4:	e5d32000 	ldrb	r2, [r3]
 c222fd8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c222fdc:	e5c32000 	strb	r2, [r3]
#endif
    p_sem_data->OSCnt      = pevent->OSEventCnt;           /* Get semaphore count                      */
 c222fe0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c222fe4:	e1d320b2 	ldrh	r2, [r3, #2]
 c222fe8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c222fec:	e1c320b0 	strh	r2, [r3]
    OS_EXIT_CRITICAL();
 c222ff0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c222ff4:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c222ff8:	e3a03000 	mov	r3, #0
}
 c222ffc:	e1a00003 	mov	r0, r3
 c223000:	e24bd00c 	sub	sp, fp, #12
 c223004:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223008:	e12fff1e 	bx	lr

0c22300c <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *err)
{
 c22300c:	e1a0c00d 	mov	ip, sp
 c223010:	e92dd800 	push	{fp, ip, lr, pc}
 c223014:	e24cb004 	sub	fp, ip, #4
 c223018:	e24dd010 	sub	sp, sp, #16
 c22301c:	e50b0010 	str	r0, [fp, #-16]
 c223020:	e1a03001 	mov	r3, r1
 c223024:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
 c223028:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
#endif    
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 c22302c:	e51b3010 	ldr	r3, [fp, #-16]
 c223030:	e3530000 	cmp	r3, #0
 c223034:	1a000003 	bne	c223048 <OSSemSet+0x3c>
        *err = OS_ERR_PEVENT_NULL;
 c223038:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22303c:	e3a02004 	mov	r2, #4
 c223040:	e5c32000 	strb	r2, [r3]
        return;
 c223044:	ea00001f 	b	c2230c8 <OSSemSet+0xbc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 c223048:	e51b3010 	ldr	r3, [fp, #-16]
 c22304c:	e5d33000 	ldrb	r3, [r3]
 c223050:	e3530003 	cmp	r3, #3
 c223054:	0a000003 	beq	c223068 <OSSemSet+0x5c>
        *err = OS_ERR_EVENT_TYPE;
 c223058:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22305c:	e3a02001 	mov	r2, #1
 c223060:	e5c32000 	strb	r2, [r3]
        return;
 c223064:	ea000017 	b	c2230c8 <OSSemSet+0xbc>
    }
    OS_ENTER_CRITICAL();
 c223068:	e10f0000 	mrs	r0, CPSR
 c22306c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223070:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223074:	e121f000 	msr	CPSR_c, r0
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 c223078:	e51b3010 	ldr	r3, [fp, #-16]
 c22307c:	e1d330b2 	ldrh	r3, [r3, #2]
 c223080:	e3530000 	cmp	r3, #0
 c223084:	0a000003 	beq	c223098 <OSSemSet+0x8c>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 c223088:	e51b3010 	ldr	r3, [fp, #-16]
 c22308c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c223090:	e1c320b2 	strh	r2, [r3, #2]
 c223094:	ea000006 	b	c2230b4 <OSSemSet+0xa8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0x00) {             /*      See if task(s) waiting?                  */
 c223098:	e51b3010 	ldr	r3, [fp, #-16]
 c22309c:	e5d33001 	ldrb	r3, [r3, #1]
 c2230a0:	e3530000 	cmp	r3, #0
 c2230a4:	1a000002 	bne	c2230b4 <OSSemSet+0xa8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 c2230a8:	e51b3010 	ldr	r3, [fp, #-16]
 c2230ac:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c2230b0:	e1c320b2 	strh	r2, [r3, #2]
        }
    }
    OS_EXIT_CRITICAL();
 c2230b4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2230b8:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c2230bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2230c0:	e3a02000 	mov	r2, #0
 c2230c4:	e5c32000 	strb	r2, [r3]
}
 c2230c8:	e24bd00c 	sub	sp, fp, #12
 c2230cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2230d0:	e12fff1e 	bx	lr

0c2230d4 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 c2230d4:	e1a0c00d 	mov	ip, sp
 c2230d8:	e92dd800 	push	{fp, ip, lr, pc}
 c2230dc:	e24cb004 	sub	fp, ip, #4
 c2230e0:	e24dd018 	sub	sp, sp, #24
 c2230e4:	e1a02000 	mov	r2, r0
 c2230e8:	e1a03001 	mov	r3, r1
 c2230ec:	e54b201d 	strb	r2, [fp, #-29]	; 0xffffffe3
 c2230f0:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2


    cpu_sr = 0;                                                 /* Prevent compiler warning            */
#endif    
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 c2230f4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2230f8:	e353003e 	cmp	r3, #62	; 0x3e
 c2230fc:	9a000004 	bls	c223114 <OSTaskChangePrio+0x40>
	    if (oldprio != OS_PRIO_SELF) {
 c223100:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c223104:	e35300ff 	cmp	r3, #255	; 0xff
 c223108:	0a000001 	beq	c223114 <OSTaskChangePrio+0x40>
            return (OS_PRIO_INVALID);
 c22310c:	e3a0302a 	mov	r3, #42	; 0x2a
 c223110:	ea0000d7 	b	c223474 <OSTaskChangePrio+0x3a0>
		}
	}
    if (newprio >= OS_LOWEST_PRIO) {
 c223114:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
 c223118:	e353003e 	cmp	r3, #62	; 0x3e
 c22311c:	9a000001 	bls	c223128 <OSTaskChangePrio+0x54>
        return (OS_PRIO_INVALID);
 c223120:	e3a0302a 	mov	r3, #42	; 0x2a
 c223124:	ea0000d2 	b	c223474 <OSTaskChangePrio+0x3a0>
    }
#endif
    OS_ENTER_CRITICAL();
 c223128:	e10f0000 	mrs	r0, CPSR
 c22312c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223130:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223134:	e121f000 	msr	CPSR_c, r0
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
 c223138:	e55b201e 	ldrb	r2, [fp, #-30]	; 0xffffffe2
 c22313c:	e59f3340 	ldr	r3, [pc, #832]	; c223484 <OSTaskChangePrio+0x3b0>
 c223140:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223144:	e3530000 	cmp	r3, #0
 c223148:	0a000003 	beq	c22315c <OSTaskChangePrio+0x88>
        OS_EXIT_CRITICAL();
 c22314c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223150:	e121f000 	msr	CPSR_c, r0
        return (OS_PRIO_EXIST);
 c223154:	e3a03028 	mov	r3, #40	; 0x28
 c223158:	ea0000c5 	b	c223474 <OSTaskChangePrio+0x3a0>
    } 
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
 c22315c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c223160:	e35300ff 	cmp	r3, #255	; 0xff
 c223164:	1a000003 	bne	c223178 <OSTaskChangePrio+0xa4>
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
 c223168:	e59f3318 	ldr	r3, [pc, #792]	; c223488 <OSTaskChangePrio+0x3b4>
 c22316c:	e5933000 	ldr	r3, [r3]
 c223170:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c223174:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
    }
    ptcb = OSTCBPrioTbl[oldprio];
 c223178:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c22317c:	e59f3300 	ldr	r3, [pc, #768]	; c223484 <OSTaskChangePrio+0x3b0>
 c223180:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223184:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
 c223188:	e51b3010 	ldr	r3, [fp, #-16]
 c22318c:	e3530000 	cmp	r3, #0
 c223190:	1a000003 	bne	c2231a4 <OSTaskChangePrio+0xd0>
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
 c223194:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223198:	e121f000 	msr	CPSR_c, r0
        return (OS_PRIO_ERR);
 c22319c:	e3a03029 	mov	r3, #41	; 0x29
 c2231a0:	ea0000b3 	b	c223474 <OSTaskChangePrio+0x3a0>
    }                                       
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
 c2231a4:	e51b3010 	ldr	r3, [fp, #-16]
 c2231a8:	e3530001 	cmp	r3, #1
 c2231ac:	1a000003 	bne	c2231c0 <OSTaskChangePrio+0xec>
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
 c2231b0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2231b4:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c2231b8:	e3a0300b 	mov	r3, #11
 c2231bc:	ea0000ac 	b	c223474 <OSTaskChangePrio+0x3a0>
    }                                       
    y                     = newprio >> 3;                       /* Yes, compute new TCB fields         */
 c2231c0:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
 c2231c4:	e1a031a3 	lsr	r3, r3, #3
 c2231c8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    bity                  = OSMapTbl[y];
 c2231cc:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c2231d0:	e59f22b4 	ldr	r2, [pc, #692]	; c22348c <OSTaskChangePrio+0x3b8>
 c2231d4:	e7d23003 	ldrb	r3, [r2, r3]
 c2231d8:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
    x                     = newprio & 0x07;
 c2231dc:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
 c2231e0:	e2033007 	and	r3, r3, #7
 c2231e4:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
    bitx                  = OSMapTbl[x];
 c2231e8:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
 c2231ec:	e59f2298 	ldr	r2, [pc, #664]	; c22348c <OSTaskChangePrio+0x3b8>
 c2231f0:	e7d23003 	ldrb	r3, [r2, r3]
 c2231f4:	e54b3014 	strb	r3, [fp, #-20]	; 0xffffffec
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
 c2231f8:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c2231fc:	e59f3280 	ldr	r3, [pc, #640]	; c223484 <OSTaskChangePrio+0x3b0>
 c223200:	e3a01000 	mov	r1, #0
 c223204:	e7831102 	str	r1, [r3, r2, lsl #2]
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
 c223208:	e55b201e 	ldrb	r2, [fp, #-30]	; 0xffffffe2
 c22320c:	e59f3270 	ldr	r3, [pc, #624]	; c223484 <OSTaskChangePrio+0x3b0>
 c223210:	e51b1010 	ldr	r1, [fp, #-16]
 c223214:	e7831102 	str	r1, [r3, r2, lsl #2]
    y_old                 = ptcb->OSTCBY;
 c223218:	e51b3010 	ldr	r3, [fp, #-16]
 c22321c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c223220:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not        */
 c223224:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223228:	e59f2260 	ldr	r2, [pc, #608]	; c223490 <OSTaskChangePrio+0x3bc>
 c22322c:	e7d22003 	ldrb	r2, [r2, r3]
 c223230:	e51b3010 	ldr	r3, [fp, #-16]
 c223234:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c223238:	e0023003 	and	r3, r2, r3
 c22323c:	e20330ff 	and	r3, r3, #255	; 0xff
 c223240:	e3530000 	cmp	r3, #0
 c223244:	0a000031 	beq	c223310 <OSTaskChangePrio+0x23c>
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
 c223248:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22324c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223250:	e59f1238 	ldr	r1, [pc, #568]	; c223490 <OSTaskChangePrio+0x3bc>
 c223254:	e7d12002 	ldrb	r2, [r1, r2]
 c223258:	e20210ff 	and	r1, r2, #255	; 0xff
 c22325c:	e51b2010 	ldr	r2, [fp, #-16]
 c223260:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c223264:	e20220ff 	and	r2, r2, #255	; 0xff
 c223268:	e1e02002 	mvn	r2, r2
 c22326c:	e20220ff 	and	r2, r2, #255	; 0xff
 c223270:	e0012002 	and	r2, r1, r2
 c223274:	e20220ff 	and	r2, r2, #255	; 0xff
 c223278:	e20210ff 	and	r1, r2, #255	; 0xff
 c22327c:	e59f220c 	ldr	r2, [pc, #524]	; c223490 <OSTaskChangePrio+0x3bc>
 c223280:	e7c21003 	strb	r1, [r2, r3]
        if (OSRdyTbl[y_old] == 0x00) {
 c223284:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223288:	e59f2200 	ldr	r2, [pc, #512]	; c223490 <OSTaskChangePrio+0x3bc>
 c22328c:	e7d23003 	ldrb	r3, [r2, r3]
 c223290:	e3530000 	cmp	r3, #0
 c223294:	1a00000c 	bne	c2232cc <OSTaskChangePrio+0x1f8>
            OSRdyGrp &= ~ptcb->OSTCBBitY;
 c223298:	e51b3010 	ldr	r3, [fp, #-16]
 c22329c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c2232a0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2232a4:	e1e03003 	mvn	r3, r3
 c2232a8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2232ac:	e59f31e0 	ldr	r3, [pc, #480]	; c223494 <OSTaskChangePrio+0x3c0>
 c2232b0:	e5d33000 	ldrb	r3, [r3]
 c2232b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2232b8:	e0023003 	and	r3, r2, r3
 c2232bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2232c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2232c4:	e59f31c8 	ldr	r3, [pc, #456]	; c223494 <OSTaskChangePrio+0x3c0>
 c2232c8:	e5c32000 	strb	r2, [r3]
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
 c2232cc:	e59f31c0 	ldr	r3, [pc, #448]	; c223494 <OSTaskChangePrio+0x3c0>
 c2232d0:	e5d32000 	ldrb	r2, [r3]
 c2232d4:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c2232d8:	e1823003 	orr	r3, r2, r3
 c2232dc:	e20320ff 	and	r2, r3, #255	; 0xff
 c2232e0:	e59f31ac 	ldr	r3, [pc, #428]	; c223494 <OSTaskChangePrio+0x3c0>
 c2232e4:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[y] |= bitx;
 c2232e8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c2232ec:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c2232f0:	e59f1198 	ldr	r1, [pc, #408]	; c223490 <OSTaskChangePrio+0x3bc>
 c2232f4:	e7d11002 	ldrb	r1, [r1, r2]
 c2232f8:	e55b2014 	ldrb	r2, [fp, #-20]	; 0xffffffec
 c2232fc:	e1812002 	orr	r2, r1, r2
 c223300:	e20210ff 	and	r1, r2, #255	; 0xff
 c223304:	e59f2184 	ldr	r2, [pc, #388]	; c223490 <OSTaskChangePrio+0x3bc>
 c223308:	e7c21003 	strb	r1, [r2, r3]
 c22330c:	ea000045 	b	c223428 <OSTaskChangePrio+0x354>
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
 c223310:	e51b3010 	ldr	r3, [fp, #-16]
 c223314:	e593301c 	ldr	r3, [r3, #28]
 c223318:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
 c22331c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c223320:	e3530000 	cmp	r3, #0
 c223324:	0a00003f 	beq	c223428 <OSTaskChangePrio+0x354>
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
 c223328:	e55b1015 	ldrb	r1, [fp, #-21]	; 0xffffffeb
 c22332c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223330:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c223334:	e3a03008 	mov	r3, #8
 c223338:	e0802002 	add	r2, r0, r2
 c22333c:	e0823003 	add	r3, r2, r3
 c223340:	e5d33000 	ldrb	r3, [r3]
 c223344:	e20320ff 	and	r2, r3, #255	; 0xff
 c223348:	e51b3010 	ldr	r3, [fp, #-16]
 c22334c:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c223350:	e20330ff 	and	r3, r3, #255	; 0xff
 c223354:	e1e03003 	mvn	r3, r3
 c223358:	e20330ff 	and	r3, r3, #255	; 0xff
 c22335c:	e0023003 	and	r3, r2, r3
 c223360:	e20330ff 	and	r3, r3, #255	; 0xff
 c223364:	e20320ff 	and	r2, r3, #255	; 0xff
 c223368:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c22336c:	e3a03008 	mov	r3, #8
 c223370:	e0801001 	add	r1, r0, r1
 c223374:	e0813003 	add	r3, r1, r3
 c223378:	e5c32000 	strb	r2, [r3]
            if (pevent->OSEventTbl[y_old] == 0) {
 c22337c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223380:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c223384:	e3a03008 	mov	r3, #8
 c223388:	e0812002 	add	r2, r1, r2
 c22338c:	e0823003 	add	r3, r2, r3
 c223390:	e5d33000 	ldrb	r3, [r3]
 c223394:	e3530000 	cmp	r3, #0
 c223398:	1a00000c 	bne	c2233d0 <OSTaskChangePrio+0x2fc>
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 c22339c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2233a0:	e5d33001 	ldrb	r3, [r3, #1]
 c2233a4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2233a8:	e51b3010 	ldr	r3, [fp, #-16]
 c2233ac:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c2233b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2233b4:	e1e03003 	mvn	r3, r3
 c2233b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2233bc:	e0023003 	and	r3, r2, r3
 c2233c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2233c4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2233c8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2233cc:	e5c32001 	strb	r2, [r3, #1]
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
 c2233d0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2233d4:	e5d32001 	ldrb	r2, [r3, #1]
 c2233d8:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c2233dc:	e1823003 	orr	r3, r2, r3
 c2233e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2233e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2233e8:	e5c32001 	strb	r2, [r3, #1]
            pevent->OSEventTbl[y] |= bitx;
 c2233ec:	e55b1011 	ldrb	r1, [fp, #-17]	; 0xffffffef
 c2233f0:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c2233f4:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c2233f8:	e3a03008 	mov	r3, #8
 c2233fc:	e0802002 	add	r2, r0, r2
 c223400:	e0823003 	add	r3, r2, r3
 c223404:	e5d32000 	ldrb	r2, [r3]
 c223408:	e55b3014 	ldrb	r3, [fp, #-20]	; 0xffffffec
 c22340c:	e1823003 	orr	r3, r2, r3
 c223410:	e20320ff 	and	r2, r3, #255	; 0xff
 c223414:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c223418:	e3a03008 	mov	r3, #8
 c22341c:	e0801001 	add	r1, r0, r1
 c223420:	e0813003 	add	r3, r1, r3
 c223424:	e5c32000 	strb	r2, [r3]
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
 c223428:	e51b3010 	ldr	r3, [fp, #-16]
 c22342c:	e55b201e 	ldrb	r2, [fp, #-30]	; 0xffffffe2
 c223430:	e5c3202e 	strb	r2, [r3, #46]	; 0x2e
    ptcb->OSTCBY    = y;
 c223434:	e51b3010 	ldr	r3, [fp, #-16]
 c223438:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c22343c:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    ptcb->OSTCBX    = x;
 c223440:	e51b3010 	ldr	r3, [fp, #-16]
 c223444:	e55b2013 	ldrb	r2, [fp, #-19]	; 0xffffffed
 c223448:	e5c3202f 	strb	r2, [r3, #47]	; 0x2f
    ptcb->OSTCBBitY = bity;
 c22344c:	e51b3010 	ldr	r3, [fp, #-16]
 c223450:	e55b2012 	ldrb	r2, [fp, #-18]	; 0xffffffee
 c223454:	e5c32032 	strb	r2, [r3, #50]	; 0x32
    ptcb->OSTCBBitX = bitx;
 c223458:	e51b3010 	ldr	r3, [fp, #-16]
 c22345c:	e55b2014 	ldrb	r2, [fp, #-20]	; 0xffffffec
 c223460:	e5c32031 	strb	r2, [r3, #49]	; 0x31
    OS_EXIT_CRITICAL();
 c223464:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223468:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                                 /* Run highest priority task ready     */
 c22346c:	ebffe8ed 	bl	c21d828 <OS_Sched>
    return (OS_NO_ERR);
 c223470:	e3a03000 	mov	r3, #0
}
 c223474:	e1a00003 	mov	r0, r3
 c223478:	e24bd00c 	sub	sp, fp, #12
 c22347c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223480:	e12fff1e 	bx	lr
 c223484:	0c1c97a4 	.word	0x0c1c97a4
 c223488:	0c1c84c4 	.word	0x0c1c84c4
 c22348c:	0c100f88 	.word	0x0c100f88
 c223490:	0c1c84b4 	.word	0x0c1c84b4
 c223494:	0c1c84b0 	.word	0x0c1c84b0

0c223498 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
{
 c223498:	e1a0c00d 	mov	ip, sp
 c22349c:	e92dd800 	push	{fp, ip, lr, pc}
 c2234a0:	e24cb004 	sub	fp, ip, #4
 c2234a4:	e24dd028 	sub	sp, sp, #40	; 0x28
 c2234a8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c2234ac:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c2234b0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c2234b4:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf


    cpu_sr = 0;                              /* Prevent compiler warning                               */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 c2234b8:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c2234bc:	e353003f 	cmp	r3, #63	; 0x3f
 c2234c0:	9a000001 	bls	c2234cc <OSTaskCreate+0x34>
        return (OS_PRIO_INVALID);
 c2234c4:	e3a0302a 	mov	r3, #42	; 0x2a
 c2234c8:	ea000042 	b	c2235d8 <OSTaskCreate+0x140>
    }
#endif
    OS_ENTER_CRITICAL();
 c2234cc:	e10f0000 	mrs	r0, CPSR
 c2234d0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2234d4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2234d8:	e121f000 	msr	CPSR_c, r0
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 c2234dc:	e59f3104 	ldr	r3, [pc, #260]	; c2235e8 <OSTaskCreate+0x150>
 c2234e0:	e5d33000 	ldrb	r3, [r3]
 c2234e4:	e3530000 	cmp	r3, #0
 c2234e8:	0a000003 	beq	c2234fc <OSTaskCreate+0x64>
        OS_EXIT_CRITICAL();
 c2234ec:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2234f0:	e121f000 	msr	CPSR_c, r0
        return (OS_ERR_TASK_CREATE_ISR);
 c2234f4:	e3a03010 	mov	r3, #16
 c2234f8:	ea000036 	b	c2235d8 <OSTaskCreate+0x140>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 c2234fc:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c223500:	e59f30e4 	ldr	r3, [pc, #228]	; c2235ec <OSTaskCreate+0x154>
 c223504:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223508:	e3530000 	cmp	r3, #0
 c22350c:	1a00002e 	bne	c2235cc <OSTaskCreate+0x134>
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
 c223510:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c223514:	e59f30d0 	ldr	r3, [pc, #208]	; c2235ec <OSTaskCreate+0x154>
 c223518:	e3a01001 	mov	r1, #1
 c22351c:	e7831102 	str	r1, [r3, r2, lsl #2]
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
 c223520:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223524:	e121f000 	msr	CPSR_c, r0
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
 c223528:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c22352c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c223530:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c223534:	e3a03000 	mov	r3, #0
 c223538:	ebffe36e 	bl	c21c2f8 <OSTaskStkInit>
 c22353c:	e50b0010 	str	r0, [fp, #-16]
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 c223540:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c223544:	e3a02000 	mov	r2, #0
 c223548:	e58d2000 	str	r2, [sp]
 c22354c:	e3a02000 	mov	r2, #0
 c223550:	e58d2004 	str	r2, [sp, #4]
 c223554:	e3a02000 	mov	r2, #0
 c223558:	e58d2008 	str	r2, [sp, #8]
 c22355c:	e1a00003 	mov	r0, r3
 c223560:	e51b1010 	ldr	r1, [fp, #-16]
 c223564:	e3a02000 	mov	r2, #0
 c223568:	e3a03000 	mov	r3, #0
 c22356c:	ebffe9bd 	bl	c21dc68 <OS_TCBInit>
 c223570:	e1a03000 	mov	r3, r0
 c223574:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        if (err == OS_NO_ERR) {
 c223578:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22357c:	e3530000 	cmp	r3, #0
 c223580:	1a000005 	bne	c22359c <OSTaskCreate+0x104>
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
 c223584:	e59f3064 	ldr	r3, [pc, #100]	; c2235f0 <OSTaskCreate+0x158>
 c223588:	e5d33000 	ldrb	r3, [r3]
 c22358c:	e3530001 	cmp	r3, #1
 c223590:	1a00000b 	bne	c2235c4 <OSTaskCreate+0x12c>
                OS_Sched();
 c223594:	ebffe8a3 	bl	c21d828 <OS_Sched>
 c223598:	ea000009 	b	c2235c4 <OSTaskCreate+0x12c>
            }
        } else {
            OS_ENTER_CRITICAL();
 c22359c:	e10f0000 	mrs	r0, CPSR
 c2235a0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2235a4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2235a8:	e121f000 	msr	CPSR_c, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 c2235ac:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c2235b0:	e59f3034 	ldr	r3, [pc, #52]	; c2235ec <OSTaskCreate+0x154>
 c2235b4:	e3a01000 	mov	r1, #0
 c2235b8:	e7831102 	str	r1, [r3, r2, lsl #2]
            OS_EXIT_CRITICAL();
 c2235bc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2235c0:	e121f000 	msr	CPSR_c, r0
        }
        return (err);
 c2235c4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c2235c8:	ea000002 	b	c2235d8 <OSTaskCreate+0x140>
    }
    OS_EXIT_CRITICAL();
 c2235cc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2235d0:	e121f000 	msr	CPSR_c, r0
    return (OS_PRIO_EXIST);
 c2235d4:	e3a03028 	mov	r3, #40	; 0x28
}
 c2235d8:	e1a00003 	mov	r0, r3
 c2235dc:	e24bd00c 	sub	sp, fp, #12
 c2235e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2235e4:	e12fff1e 	bx	lr
 c2235e8:	0c1c84c0 	.word	0x0c1c84c0
 c2235ec:	0c1c97a4 	.word	0x0c1c97a4
 c2235f0:	0c1c7a3d 	.word	0x0c1c7a3d

0c2235f4 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 c2235f4:	e1a0c00d 	mov	ip, sp
 c2235f8:	e92dd800 	push	{fp, ip, lr, pc}
 c2235fc:	e24cb004 	sub	fp, ip, #4
 c223600:	e24dd028 	sub	sp, sp, #40	; 0x28
 c223604:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c223608:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c22360c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c223610:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf


    cpu_sr = 0;                              /* Prevent compiler warning                               */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 c223614:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c223618:	e353003f 	cmp	r3, #63	; 0x3f
 c22361c:	9a000001 	bls	c223628 <OSTaskCreateExt+0x34>
        return (OS_PRIO_INVALID);
 c223620:	e3a0302a 	mov	r3, #42	; 0x2a
 c223624:	ea000047 	b	c223748 <OSTaskCreateExt+0x154>
    }
#endif
    OS_ENTER_CRITICAL();
 c223628:	e10f0000 	mrs	r0, CPSR
 c22362c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223630:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223634:	e121f000 	msr	CPSR_c, r0
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 c223638:	e59f3118 	ldr	r3, [pc, #280]	; c223758 <OSTaskCreateExt+0x164>
 c22363c:	e5d33000 	ldrb	r3, [r3]
 c223640:	e3530000 	cmp	r3, #0
 c223644:	0a000003 	beq	c223658 <OSTaskCreateExt+0x64>
        OS_EXIT_CRITICAL();
 c223648:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22364c:	e121f000 	msr	CPSR_c, r0
        return (OS_ERR_TASK_CREATE_ISR);
 c223650:	e3a03010 	mov	r3, #16
 c223654:	ea00003b 	b	c223748 <OSTaskCreateExt+0x154>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 c223658:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c22365c:	e59f30f8 	ldr	r3, [pc, #248]	; c22375c <OSTaskCreateExt+0x168>
 c223660:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223664:	e3530000 	cmp	r3, #0
 c223668:	1a000033 	bne	c22373c <OSTaskCreateExt+0x148>
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
 c22366c:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c223670:	e59f30e4 	ldr	r3, [pc, #228]	; c22375c <OSTaskCreateExt+0x168>
 c223674:	e3a01001 	mov	r1, #1
 c223678:	e7831102 	str	r1, [r3, r2, lsl #2]
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
 c22367c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223680:	e121f000 	msr	CPSR_c, r0

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 c223684:	e1db31b4 	ldrh	r3, [fp, #20]
 c223688:	e59b0008 	ldr	r0, [fp, #8]
 c22368c:	e59b100c 	ldr	r1, [fp, #12]
 c223690:	e1a02003 	mov	r2, r3
 c223694:	eb000388 	bl	c2244bc <OS_TaskStkClr>

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
 c223698:	e1db31b4 	ldrh	r3, [fp, #20]
 c22369c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c2236a0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c2236a4:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c2236a8:	ebffe312 	bl	c21c2f8 <OSTaskStkInit>
 c2236ac:	e50b0010 	str	r0, [fp, #-16]
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 c2236b0:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c2236b4:	e1db30b4 	ldrh	r3, [fp, #4]
 c2236b8:	e59b100c 	ldr	r1, [fp, #12]
 c2236bc:	e58d1000 	str	r1, [sp]
 c2236c0:	e59b1010 	ldr	r1, [fp, #16]
 c2236c4:	e58d1004 	str	r1, [sp, #4]
 c2236c8:	e1db11b4 	ldrh	r1, [fp, #20]
 c2236cc:	e58d1008 	str	r1, [sp, #8]
 c2236d0:	e1a00002 	mov	r0, r2
 c2236d4:	e51b1010 	ldr	r1, [fp, #-16]
 c2236d8:	e59b2008 	ldr	r2, [fp, #8]
 c2236dc:	ebffe961 	bl	c21dc68 <OS_TCBInit>
 c2236e0:	e1a03000 	mov	r3, r0
 c2236e4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        if (err == OS_NO_ERR) {
 c2236e8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c2236ec:	e3530000 	cmp	r3, #0
 c2236f0:	1a000005 	bne	c22370c <OSTaskCreateExt+0x118>
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
 c2236f4:	e59f3064 	ldr	r3, [pc, #100]	; c223760 <OSTaskCreateExt+0x16c>
 c2236f8:	e5d33000 	ldrb	r3, [r3]
 c2236fc:	e3530001 	cmp	r3, #1
 c223700:	1a00000b 	bne	c223734 <OSTaskCreateExt+0x140>
                OS_Sched();
 c223704:	ebffe847 	bl	c21d828 <OS_Sched>
 c223708:	ea000009 	b	c223734 <OSTaskCreateExt+0x140>
            }
        } else {
            OS_ENTER_CRITICAL();
 c22370c:	e10f0000 	mrs	r0, CPSR
 c223710:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223714:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223718:	e121f000 	msr	CPSR_c, r0
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 c22371c:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
 c223720:	e59f3034 	ldr	r3, [pc, #52]	; c22375c <OSTaskCreateExt+0x168>
 c223724:	e3a01000 	mov	r1, #0
 c223728:	e7831102 	str	r1, [r3, r2, lsl #2]
            OS_EXIT_CRITICAL();
 c22372c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223730:	e121f000 	msr	CPSR_c, r0
        }
        return (err);
 c223734:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c223738:	ea000002 	b	c223748 <OSTaskCreateExt+0x154>
    }
    OS_EXIT_CRITICAL();
 c22373c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223740:	e121f000 	msr	CPSR_c, r0
    return (OS_PRIO_EXIST);
 c223744:	e3a03028 	mov	r3, #40	; 0x28
}
 c223748:	e1a00003 	mov	r0, r3
 c22374c:	e24bd00c 	sub	sp, fp, #12
 c223750:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223754:	e12fff1e 	bx	lr
 c223758:	0c1c84c0 	.word	0x0c1c84c0
 c22375c:	0c1c97a4 	.word	0x0c1c97a4
 c223760:	0c1c7a3d 	.word	0x0c1c7a3d

0c223764 <OSTaskDel>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 c223764:	e1a0c00d 	mov	ip, sp
 c223768:	e92dd800 	push	{fp, ip, lr, pc}
 c22376c:	e24cb004 	sub	fp, ip, #4
 c223770:	e24dd018 	sub	sp, sp, #24
 c223774:	e1a03000 	mov	r3, r0
 c223778:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3



    cpu_sr = 0;                                                 /* Prevent compiler warning            */
#endif    
    if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR    */
 c22377c:	e59f3398 	ldr	r3, [pc, #920]	; c223b1c <OSTaskDel+0x3b8>
 c223780:	e5d33000 	ldrb	r3, [r3]
 c223784:	e3530000 	cmp	r3, #0
 c223788:	0a000001 	beq	c223794 <OSTaskDel+0x30>
        return (OS_TASK_DEL_ISR);
 c22378c:	e3a0303f 	mov	r3, #63	; 0x3f
 c223790:	ea0000dd 	b	c223b0c <OSTaskDel+0x3a8>
    }
#if OS_ARG_CHK_EN > 0
    if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
 c223794:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c223798:	e353003f 	cmp	r3, #63	; 0x3f
 c22379c:	1a000001 	bne	c2237a8 <OSTaskDel+0x44>
        return (OS_TASK_DEL_IDLE);
 c2237a0:	e3a0303d 	mov	r3, #61	; 0x3d
 c2237a4:	ea0000d8 	b	c223b0c <OSTaskDel+0x3a8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 c2237a8:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2237ac:	e353003e 	cmp	r3, #62	; 0x3e
 c2237b0:	9a000004 	bls	c2237c8 <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {       
 c2237b4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2237b8:	e35300ff 	cmp	r3, #255	; 0xff
 c2237bc:	0a000001 	beq	c2237c8 <OSTaskDel+0x64>
            return (OS_PRIO_INVALID);
 c2237c0:	e3a0302a 	mov	r3, #42	; 0x2a
 c2237c4:	ea0000d0 	b	c223b0c <OSTaskDel+0x3a8>
        }
    }
#endif
    OS_ENTER_CRITICAL();
 c2237c8:	e10f0000 	mrs	r0, CPSR
 c2237cc:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2237d0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2237d4:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self    */
 c2237d8:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2237dc:	e35300ff 	cmp	r3, #255	; 0xff
 c2237e0:	1a000003 	bne	c2237f4 <OSTaskDel+0x90>
        prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to current   */
 c2237e4:	e59f3334 	ldr	r3, [pc, #820]	; c223b20 <OSTaskDel+0x3bc>
 c2237e8:	e5933000 	ldr	r3, [r3]
 c2237ec:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c2237f0:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
    }
    ptcb = OSTCBPrioTbl[prio];
 c2237f4:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c2237f8:	e59f3324 	ldr	r3, [pc, #804]	; c223b24 <OSTaskDel+0x3c0>
 c2237fc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223800:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 c223804:	e51b3010 	ldr	r3, [fp, #-16]
 c223808:	e3530000 	cmp	r3, #0
 c22380c:	1a000003 	bne	c223820 <OSTaskDel+0xbc>
        OS_EXIT_CRITICAL();
 c223810:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223814:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_DEL_ERR);
 c223818:	e3a0303c 	mov	r3, #60	; 0x3c
 c22381c:	ea0000ba 	b	c223b0c <OSTaskDel+0x3a8>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must not be assigned to Mutex       */
 c223820:	e51b3010 	ldr	r3, [fp, #-16]
 c223824:	e3530001 	cmp	r3, #1
 c223828:	1a000003 	bne	c22383c <OSTaskDel+0xd8>
        OS_EXIT_CRITICAL();
 c22382c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223830:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c223834:	e3a0300b 	mov	r3, #11
 c223838:	ea0000b3 	b	c223b0c <OSTaskDel+0x3a8>
    }
	y            =  ptcb->OSTCBY;
 c22383c:	e51b3010 	ldr	r3, [fp, #-16]
 c223840:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c223844:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
 c223848:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22384c:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c223850:	e59f12d0 	ldr	r1, [pc, #720]	; c223b28 <OSTaskDel+0x3c4>
 c223854:	e7d12002 	ldrb	r2, [r1, r2]
 c223858:	e20210ff 	and	r1, r2, #255	; 0xff
 c22385c:	e51b2010 	ldr	r2, [fp, #-16]
 c223860:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c223864:	e20220ff 	and	r2, r2, #255	; 0xff
 c223868:	e1e02002 	mvn	r2, r2
 c22386c:	e20220ff 	and	r2, r2, #255	; 0xff
 c223870:	e0012002 	and	r2, r1, r2
 c223874:	e20220ff 	and	r2, r2, #255	; 0xff
 c223878:	e20210ff 	and	r1, r2, #255	; 0xff
 c22387c:	e59f22a4 	ldr	r2, [pc, #676]	; c223b28 <OSTaskDel+0x3c4>
 c223880:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0x00) {                                  /* Make task not ready                 */
 c223884:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c223888:	e59f2298 	ldr	r2, [pc, #664]	; c223b28 <OSTaskDel+0x3c4>
 c22388c:	e7d23003 	ldrb	r3, [r2, r3]
 c223890:	e3530000 	cmp	r3, #0
 c223894:	1a00000c 	bne	c2238cc <OSTaskDel+0x168>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 c223898:	e51b3010 	ldr	r3, [fp, #-16]
 c22389c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c2238a0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2238a4:	e1e03003 	mvn	r3, r3
 c2238a8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2238ac:	e59f3278 	ldr	r3, [pc, #632]	; c223b2c <OSTaskDel+0x3c8>
 c2238b0:	e5d33000 	ldrb	r3, [r3]
 c2238b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2238b8:	e0023003 	and	r3, r2, r3
 c2238bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2238c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2238c4:	e59f3260 	ldr	r3, [pc, #608]	; c223b2c <OSTaskDel+0x3c8>
 c2238c8:	e5c32000 	strb	r2, [r3]
    }
#if OS_EVENT_EN
    pevent = ptcb->OSTCBEventPtr;
 c2238cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2238d0:	e593301c 	ldr	r3, [r3, #28]
 c2238d4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (pevent != (OS_EVENT *)0) {                              /* If task is waiting on event         */
 c2238d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2238dc:	e3530000 	cmp	r3, #0
 c2238e0:	0a000029 	beq	c22398c <OSTaskDel+0x228>
	    pevent->OSEventTbl[y] &= ~ptcb->OSTCBBitX;
 c2238e4:	e55b1011 	ldrb	r1, [fp, #-17]	; 0xffffffef
 c2238e8:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c2238ec:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c2238f0:	e3a03008 	mov	r3, #8
 c2238f4:	e0802002 	add	r2, r0, r2
 c2238f8:	e0823003 	add	r3, r2, r3
 c2238fc:	e5d33000 	ldrb	r3, [r3]
 c223900:	e20320ff 	and	r2, r3, #255	; 0xff
 c223904:	e51b3010 	ldr	r3, [fp, #-16]
 c223908:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
 c22390c:	e20330ff 	and	r3, r3, #255	; 0xff
 c223910:	e1e03003 	mvn	r3, r3
 c223914:	e20330ff 	and	r3, r3, #255	; 0xff
 c223918:	e0023003 	and	r3, r2, r3
 c22391c:	e20330ff 	and	r3, r3, #255	; 0xff
 c223920:	e20320ff 	and	r2, r3, #255	; 0xff
 c223924:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c223928:	e3a03008 	mov	r3, #8
 c22392c:	e0801001 	add	r1, r0, r1
 c223930:	e0813003 	add	r3, r1, r3
 c223934:	e5c32000 	strb	r2, [r3]
        if (pevent->OSEventTbl[y] == 0) {                       /* ... remove task from ...            */
 c223938:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c22393c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c223940:	e3a03008 	mov	r3, #8
 c223944:	e0812002 	add	r2, r1, r2
 c223948:	e0823003 	add	r3, r2, r3
 c22394c:	e5d33000 	ldrb	r3, [r3]
 c223950:	e3530000 	cmp	r3, #0
 c223954:	1a00000c 	bne	c22398c <OSTaskDel+0x228>
            pevent->OSEventGrp &= ~ptcb->OSTCBBitY;             /* ... event ctrl block                */
 c223958:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22395c:	e5d33001 	ldrb	r3, [r3, #1]
 c223960:	e20320ff 	and	r2, r3, #255	; 0xff
 c223964:	e51b3010 	ldr	r3, [fp, #-16]
 c223968:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c22396c:	e20330ff 	and	r3, r3, #255	; 0xff
 c223970:	e1e03003 	mvn	r3, r3
 c223974:	e20330ff 	and	r3, r3, #255	; 0xff
 c223978:	e0023003 	and	r3, r2, r3
 c22397c:	e20330ff 	and	r3, r3, #255	; 0xff
 c223980:	e20320ff 	and	r2, r3, #255	; 0xff
 c223984:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c223988:	e5c32001 	strb	r2, [r3, #1]
        }
    }
#endif
#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 c22398c:	e51b3010 	ldr	r3, [fp, #-16]
 c223990:	e5933024 	ldr	r3, [r3, #36]	; 0x24
 c223994:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    if (pnode != (OS_FLAG_NODE *)0) {                           /* If task is waiting on event flag    */
 c223998:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22399c:	e3530000 	cmp	r3, #0
 c2239a0:	0a000001 	beq	c2239ac <OSTaskDel+0x248>
        OS_FlagUnlink(pnode);                                   /* Remove from wait list               */
 c2239a4:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c2239a8:	ebffef7a 	bl	c21f798 <OS_FlagUnlink>
    }
#endif
    ptcb->OSTCBDly    = 0;                                      /* Prevent OSTimeTick() from updating  */
 c2239ac:	e51b3010 	ldr	r3, [fp, #-16]
 c2239b0:	e3a02000 	mov	r2, #0
 c2239b4:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    ptcb->OSTCBStat   = OS_STAT_RDY;                            /* Prevent task from being resumed     */
 c2239b8:	e51b3010 	ldr	r3, [fp, #-16]
 c2239bc:	e3a02000 	mov	r2, #0
 c2239c0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    ptcb->OSTCBPendTO = FALSE;
 c2239c4:	e51b3010 	ldr	r3, [fp, #-16]
 c2239c8:	e3a02000 	mov	r2, #0
 c2239cc:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
	if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch   */
 c2239d0:	e59f3158 	ldr	r3, [pc, #344]	; c223b30 <OSTaskDel+0x3cc>
 c2239d4:	e5d33000 	ldrb	r3, [r3]
 c2239d8:	e35300ff 	cmp	r3, #255	; 0xff
 c2239dc:	0a000005 	beq	c2239f8 <OSTaskDel+0x294>
        OSLockNesting++;
 c2239e0:	e59f3148 	ldr	r3, [pc, #328]	; c223b30 <OSTaskDel+0x3cc>
 c2239e4:	e5d33000 	ldrb	r3, [r3]
 c2239e8:	e2833001 	add	r3, r3, #1
 c2239ec:	e20320ff 	and	r2, r3, #255	; 0xff
 c2239f0:	e59f3138 	ldr	r3, [pc, #312]	; c223b30 <OSTaskDel+0x3cc>
 c2239f4:	e5c32000 	strb	r2, [r3]
	}
    OS_EXIT_CRITICAL();                                         /* Enabling INT. ignores next instruc. */
 c2239f8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2239fc:	e121f000 	msr	CPSR_c, r0
    OS_Dummy();                                                 /* ... Dummy ensures that INTs will be */
 c223a00:	ebffe4ec 	bl	c21cdb8 <OS_Dummy>
    OS_ENTER_CRITICAL();                                        /* ... disabled HERE!                  */
 c223a04:	e10f0000 	mrs	r0, CPSR
 c223a08:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223a0c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223a10:	e121f000 	msr	CPSR_c, r0
	if (OSLockNesting > 0) {                                    /* Remove context switch lock          */
 c223a14:	e59f3114 	ldr	r3, [pc, #276]	; c223b30 <OSTaskDel+0x3cc>
 c223a18:	e5d33000 	ldrb	r3, [r3]
 c223a1c:	e3530000 	cmp	r3, #0
 c223a20:	0a000005 	beq	c223a3c <OSTaskDel+0x2d8>
        OSLockNesting--;
 c223a24:	e59f3104 	ldr	r3, [pc, #260]	; c223b30 <OSTaskDel+0x3cc>
 c223a28:	e5d33000 	ldrb	r3, [r3]
 c223a2c:	e2433001 	sub	r3, r3, #1
 c223a30:	e20320ff 	and	r2, r3, #255	; 0xff
 c223a34:	e59f30f4 	ldr	r3, [pc, #244]	; c223b30 <OSTaskDel+0x3cc>
 c223a38:	e5c32000 	strb	r2, [r3]
	}
    OSTaskDelHook(ptcb);                                        /* Call user defined hook              */
 c223a3c:	e51b0010 	ldr	r0, [fp, #-16]
 c223a40:	ebffe217 	bl	c21c2a4 <OSTaskDelHook>
    OSTaskCtr--;                                                /* One less task being managed         */
 c223a44:	e59f30e8 	ldr	r3, [pc, #232]	; c223b34 <OSTaskDel+0x3d0>
 c223a48:	e5d33000 	ldrb	r3, [r3]
 c223a4c:	e2433001 	sub	r3, r3, #1
 c223a50:	e20320ff 	and	r2, r3, #255	; 0xff
 c223a54:	e59f30d8 	ldr	r3, [pc, #216]	; c223b34 <OSTaskDel+0x3d0>
 c223a58:	e5c32000 	strb	r2, [r3]
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry            */
 c223a5c:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c223a60:	e59f30bc 	ldr	r3, [pc, #188]	; c223b24 <OSTaskDel+0x3c0>
 c223a64:	e3a01000 	mov	r1, #0
 c223a68:	e7831102 	str	r1, [r3, r2, lsl #2]
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain               */
 c223a6c:	e51b3010 	ldr	r3, [fp, #-16]
 c223a70:	e5933018 	ldr	r3, [r3, #24]
 c223a74:	e3530000 	cmp	r3, #0
 c223a78:	1a000008 	bne	c223aa0 <OSTaskDel+0x33c>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 c223a7c:	e51b3010 	ldr	r3, [fp, #-16]
 c223a80:	e5933014 	ldr	r3, [r3, #20]
 c223a84:	e3a02000 	mov	r2, #0
 c223a88:	e5832018 	str	r2, [r3, #24]
        OSTCBList                  = ptcb->OSTCBNext;
 c223a8c:	e51b3010 	ldr	r3, [fp, #-16]
 c223a90:	e5932014 	ldr	r2, [r3, #20]
 c223a94:	e59f309c 	ldr	r3, [pc, #156]	; c223b38 <OSTaskDel+0x3d4>
 c223a98:	e5832000 	str	r2, [r3]
 c223a9c:	ea000009 	b	c223ac8 <OSTaskDel+0x364>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 c223aa0:	e51b3010 	ldr	r3, [fp, #-16]
 c223aa4:	e5933018 	ldr	r3, [r3, #24]
 c223aa8:	e51b2010 	ldr	r2, [fp, #-16]
 c223aac:	e5922014 	ldr	r2, [r2, #20]
 c223ab0:	e5832014 	str	r2, [r3, #20]
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 c223ab4:	e51b3010 	ldr	r3, [fp, #-16]
 c223ab8:	e5933014 	ldr	r3, [r3, #20]
 c223abc:	e51b2010 	ldr	r2, [fp, #-16]
 c223ac0:	e5922018 	ldr	r2, [r2, #24]
 c223ac4:	e5832018 	str	r2, [r3, #24]
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                          /* Return TCB to free TCB list         */
 c223ac8:	e59f306c 	ldr	r3, [pc, #108]	; c223b3c <OSTaskDel+0x3d8>
 c223acc:	e5932000 	ldr	r2, [r3]
 c223ad0:	e51b3010 	ldr	r3, [fp, #-16]
 c223ad4:	e5832014 	str	r2, [r3, #20]
    OSTCBFreeList     = ptcb;
 c223ad8:	e59f305c 	ldr	r3, [pc, #92]	; c223b3c <OSTaskDel+0x3d8>
 c223adc:	e51b2010 	ldr	r2, [fp, #-16]
 c223ae0:	e5832000 	str	r2, [r3]
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                               /* Unknown name                        */
 c223ae4:	e51b3010 	ldr	r3, [fp, #-16]
 c223ae8:	e3a0203f 	mov	r2, #63	; 0x3f
 c223aec:	e5c32048 	strb	r2, [r3, #72]	; 0x48
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 c223af0:	e51b3010 	ldr	r3, [fp, #-16]
 c223af4:	e3a02000 	mov	r2, #0
 c223af8:	e5c32049 	strb	r2, [r3, #73]	; 0x49
#endif
    OS_EXIT_CRITICAL();
 c223afc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223b00:	e121f000 	msr	CPSR_c, r0
    OS_Sched();                                                 /* Find new highest priority task      */
 c223b04:	ebffe747 	bl	c21d828 <OS_Sched>
    return (OS_NO_ERR);
 c223b08:	e3a03000 	mov	r3, #0
}
 c223b0c:	e1a00003 	mov	r0, r3
 c223b10:	e24bd00c 	sub	sp, fp, #12
 c223b14:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223b18:	e12fff1e 	bx	lr
 c223b1c:	0c1c84c0 	.word	0x0c1c84c0
 c223b20:	0c1c84c4 	.word	0x0c1c84c4
 c223b24:	0c1c97a4 	.word	0x0c1c97a4
 c223b28:	0c1c84b4 	.word	0x0c1c84b4
 c223b2c:	0c1c84b0 	.word	0x0c1c84b0
 c223b30:	0c1c7a3c 	.word	0x0c1c7a3c
 c223b34:	0c1c8441 	.word	0x0c1c8441
 c223b38:	0c1c7b28 	.word	0x0c1c7b28
 c223b3c:	0c1c843c 	.word	0x0c1c843c

0c223b40 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 c223b40:	e1a0c00d 	mov	ip, sp
 c223b44:	e92dd800 	push	{fp, ip, lr, pc}
 c223b48:	e24cb004 	sub	fp, ip, #4
 c223b4c:	e24dd010 	sub	sp, sp, #16
 c223b50:	e1a03000 	mov	r3, r0
 c223b54:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb


    cpu_sr = 0;                                                 /* Prevent compiler warning            */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
 c223b58:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223b5c:	e353003f 	cmp	r3, #63	; 0x3f
 c223b60:	1a000001 	bne	c223b6c <OSTaskDelReq+0x2c>
        return (OS_TASK_DEL_IDLE);
 c223b64:	e3a0303d 	mov	r3, #61	; 0x3d
 c223b68:	ea000032 	b	c223c38 <OSTaskDelReq+0xf8>
    }
    if (prio >= OS_LOWEST_PRIO) {						        /* Task priority valid ?               */
 c223b6c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223b70:	e353003e 	cmp	r3, #62	; 0x3e
 c223b74:	9a000004 	bls	c223b8c <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {                       
 c223b78:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223b7c:	e35300ff 	cmp	r3, #255	; 0xff
 c223b80:	0a000001 	beq	c223b8c <OSTaskDelReq+0x4c>
            return (OS_PRIO_INVALID);
 c223b84:	e3a0302a 	mov	r3, #42	; 0x2a
 c223b88:	ea00002a 	b	c223c38 <OSTaskDelReq+0xf8>
		}
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 c223b8c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223b90:	e35300ff 	cmp	r3, #255	; 0xff
 c223b94:	1a00000b 	bne	c223bc8 <OSTaskDelReq+0x88>
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 c223b98:	e10f0000 	mrs	r0, CPSR
 c223b9c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223ba0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223ba4:	e121f000 	msr	CPSR_c, r0
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 c223ba8:	e59f3098 	ldr	r3, [pc, #152]	; c223c48 <OSTaskDelReq+0x108>
 c223bac:	e5933000 	ldr	r3, [r3]
 c223bb0:	e5d33033 	ldrb	r3, [r3, #51]	; 0x33
 c223bb4:	e54b300d 	strb	r3, [fp, #-13]
        OS_EXIT_CRITICAL();
 c223bb8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223bbc:	e121f000 	msr	CPSR_c, r0
        return (stat);
 c223bc0:	e55b300d 	ldrb	r3, [fp, #-13]
 c223bc4:	ea00001b 	b	c223c38 <OSTaskDelReq+0xf8>
    }
    OS_ENTER_CRITICAL();
 c223bc8:	e10f0000 	mrs	r0, CPSR
 c223bcc:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223bd0:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223bd4:	e121f000 	msr	CPSR_c, r0
    ptcb = OSTCBPrioTbl[prio];
 c223bd8:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223bdc:	e59f3068 	ldr	r3, [pc, #104]	; c223c4c <OSTaskDelReq+0x10c>
 c223be0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223be4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 c223be8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c223bec:	e3530000 	cmp	r3, #0
 c223bf0:	1a000003 	bne	c223c04 <OSTaskDelReq+0xc4>
        OS_EXIT_CRITICAL();
 c223bf4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223bf8:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);                             /* Task must already be deleted        */
 c223bfc:	e3a0300b 	mov	r3, #11
 c223c00:	ea00000c 	b	c223c38 <OSTaskDelReq+0xf8>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* Must NOT be assigned to a Mutex     */
 c223c04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c223c08:	e3530001 	cmp	r3, #1
 c223c0c:	1a000003 	bne	c223c20 <OSTaskDelReq+0xe0>
        OS_EXIT_CRITICAL();
 c223c10:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223c14:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_DEL_ERR);
 c223c18:	e3a0303c 	mov	r3, #60	; 0x3c
 c223c1c:	ea000005 	b	c223c38 <OSTaskDelReq+0xf8>
    }
    ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                        /* Set flag indicating task to be DEL. */
 c223c20:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c223c24:	e3a0203e 	mov	r2, #62	; 0x3e
 c223c28:	e5c32033 	strb	r2, [r3, #51]	; 0x33
    OS_EXIT_CRITICAL();
 c223c2c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223c30:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c223c34:	e3a03000 	mov	r3, #0
}
 c223c38:	e1a00003 	mov	r0, r3
 c223c3c:	e24bd00c 	sub	sp, fp, #12
 c223c40:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223c44:	e12fff1e 	bx	lr
 c223c48:	0c1c84c4 	.word	0x0c1c84c4
 c223c4c:	0c1c97a4 	.word	0x0c1c97a4

0c223c50 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, char *pname, INT8U *err)
{
 c223c50:	e1a0c00d 	mov	ip, sp
 c223c54:	e92dd800 	push	{fp, ip, lr, pc}
 c223c58:	e24cb004 	sub	fp, ip, #4
 c223c5c:	e24dd018 	sub	sp, sp, #24
 c223c60:	e1a03000 	mov	r3, r0
 c223c64:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c223c68:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c223c6c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb


    cpu_sr = 0;                                          /* Prevent compiler warning                   */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 c223c70:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223c74:	e353003f 	cmp	r3, #63	; 0x3f
 c223c78:	9a000007 	bls	c223c9c <OSTaskNameGet+0x4c>
        if (prio != OS_PRIO_SELF) { 
 c223c7c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223c80:	e35300ff 	cmp	r3, #255	; 0xff
 c223c84:	0a000004 	beq	c223c9c <OSTaskNameGet+0x4c>
            *err = OS_PRIO_INVALID;                      /* No                                         */
 c223c88:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223c8c:	e3a0202a 	mov	r2, #42	; 0x2a
 c223c90:	e5c32000 	strb	r2, [r3]
            return (0);
 c223c94:	e3a03000 	mov	r3, #0
 c223c98:	ea000037 	b	c223d7c <OSTaskNameGet+0x12c>
        }
    }
    if (pname == (char *)0) {                             /* Is 'pname' a NULL pointer?                */
 c223c9c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c223ca0:	e3530000 	cmp	r3, #0
 c223ca4:	1a000004 	bne	c223cbc <OSTaskNameGet+0x6c>
        *err = OS_ERR_PNAME_NULL;						  /* Yes                                       */
 c223ca8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223cac:	e3a0200f 	mov	r2, #15
 c223cb0:	e5c32000 	strb	r2, [r3]
        return (0);
 c223cb4:	e3a03000 	mov	r3, #0
 c223cb8:	ea00002f 	b	c223d7c <OSTaskNameGet+0x12c>
    }
#endif
    OS_ENTER_CRITICAL();
 c223cbc:	e10f0000 	mrs	r0, CPSR
 c223cc0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223cc4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223cc8:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                           /* See if caller desires it's own name       */
 c223ccc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223cd0:	e35300ff 	cmp	r3, #255	; 0xff
 c223cd4:	1a000003 	bne	c223ce8 <OSTaskNameGet+0x98>
        prio = OSTCBCur->OSTCBPrio;
 c223cd8:	e59f30ac 	ldr	r3, [pc, #172]	; c223d8c <OSTaskNameGet+0x13c>
 c223cdc:	e5933000 	ldr	r3, [r3]
 c223ce0:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c223ce4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    }
    ptcb = OSTCBPrioTbl[prio];
 c223ce8:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223cec:	e59f309c 	ldr	r3, [pc, #156]	; c223d90 <OSTaskNameGet+0x140>
 c223cf0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223cf4:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                            /* Does task exist?                          */
 c223cf8:	e51b3010 	ldr	r3, [fp, #-16]
 c223cfc:	e3530000 	cmp	r3, #0
 c223d00:	1a000006 	bne	c223d20 <OSTaskNameGet+0xd0>
        OS_EXIT_CRITICAL();                               /* No                                        */
 c223d04:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223d08:	e121f000 	msr	CPSR_c, r0
        *err = OS_TASK_NOT_EXIST;
 c223d0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223d10:	e3a0200b 	mov	r2, #11
 c223d14:	e5c32000 	strb	r2, [r3]
        return (0);
 c223d18:	e3a03000 	mov	r3, #0
 c223d1c:	ea000016 	b	c223d7c <OSTaskNameGet+0x12c>
    }
    if (ptcb == (OS_TCB *)1) {                            /* Task assigned to a Mutex?                 */
 c223d20:	e51b3010 	ldr	r3, [fp, #-16]
 c223d24:	e3530001 	cmp	r3, #1
 c223d28:	1a000006 	bne	c223d48 <OSTaskNameGet+0xf8>
        OS_EXIT_CRITICAL();                               /* Yes                                       */
 c223d2c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223d30:	e121f000 	msr	CPSR_c, r0
        *err = OS_TASK_NOT_EXIST;
 c223d34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223d38:	e3a0200b 	mov	r2, #11
 c223d3c:	e5c32000 	strb	r2, [r3]
        return (0);
 c223d40:	e3a03000 	mov	r3, #0
 c223d44:	ea00000c 	b	c223d7c <OSTaskNameGet+0x12c>
    }
    len  = OS_StrCopy(pname, ptcb->OSTCBTaskName);        /* Yes, copy name from TCB                   */
 c223d48:	e51b3010 	ldr	r3, [fp, #-16]
 c223d4c:	e2833048 	add	r3, r3, #72	; 0x48
 c223d50:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c223d54:	e1a01003 	mov	r1, r3
 c223d58:	ebffe6fa 	bl	c21d948 <OS_StrCopy>
 c223d5c:	e1a03000 	mov	r3, r0
 c223d60:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    OS_EXIT_CRITICAL();
 c223d64:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223d68:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c223d6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223d70:	e3a02000 	mov	r2, #0
 c223d74:	e5c32000 	strb	r2, [r3]
    return (len);
 c223d78:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
}
 c223d7c:	e1a00003 	mov	r0, r3
 c223d80:	e24bd00c 	sub	sp, fp, #12
 c223d84:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223d88:	e12fff1e 	bx	lr
 c223d8c:	0c1c84c4 	.word	0x0c1c84c4
 c223d90:	0c1c97a4 	.word	0x0c1c97a4

0c223d94 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, char *pname, INT8U *err)
{
 c223d94:	e1a0c00d 	mov	ip, sp
 c223d98:	e92dd800 	push	{fp, ip, lr, pc}
 c223d9c:	e24cb004 	sub	fp, ip, #4
 c223da0:	e24dd018 	sub	sp, sp, #24
 c223da4:	e1a03000 	mov	r3, r0
 c223da8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c223dac:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c223db0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb


    cpu_sr = 0;                                      /* Prevent compiler warning                       */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 c223db4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223db8:	e353003f 	cmp	r3, #63	; 0x3f
 c223dbc:	9a000006 	bls	c223ddc <OSTaskNameSet+0x48>
        if (prio != OS_PRIO_SELF) {              
 c223dc0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223dc4:	e35300ff 	cmp	r3, #255	; 0xff
 c223dc8:	0a000003 	beq	c223ddc <OSTaskNameSet+0x48>
            *err = OS_PRIO_INVALID;                  /* No                                             */
 c223dcc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223dd0:	e3a0202a 	mov	r2, #42	; 0x2a
 c223dd4:	e5c32000 	strb	r2, [r3]
            return;
 c223dd8:	ea00003e 	b	c223ed8 <OSTaskNameSet+0x144>
        }
    }
    if (pname == (char *)0) {                        /* Is 'pname' a NULL pointer?                     */
 c223ddc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c223de0:	e3530000 	cmp	r3, #0
 c223de4:	1a000003 	bne	c223df8 <OSTaskNameSet+0x64>
        *err = OS_ERR_PNAME_NULL;					 /* Yes                                            */
 c223de8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223dec:	e3a0200f 	mov	r2, #15
 c223df0:	e5c32000 	strb	r2, [r3]
        return;
 c223df4:	ea000037 	b	c223ed8 <OSTaskNameSet+0x144>
    }
#endif
    OS_ENTER_CRITICAL();
 c223df8:	e10f0000 	mrs	r0, CPSR
 c223dfc:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223e00:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223e04:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 c223e08:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223e0c:	e35300ff 	cmp	r3, #255	; 0xff
 c223e10:	1a000003 	bne	c223e24 <OSTaskNameSet+0x90>
        prio = OSTCBCur->OSTCBPrio;
 c223e14:	e59f30c8 	ldr	r3, [pc, #200]	; c223ee4 <OSTaskNameSet+0x150>
 c223e18:	e5933000 	ldr	r3, [r3]
 c223e1c:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c223e20:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    }
    ptcb = OSTCBPrioTbl[prio];
 c223e24:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223e28:	e59f30b8 	ldr	r3, [pc, #184]	; c223ee8 <OSTaskNameSet+0x154>
 c223e2c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223e30:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 c223e34:	e51b3010 	ldr	r3, [fp, #-16]
 c223e38:	e3530000 	cmp	r3, #0
 c223e3c:	1a000005 	bne	c223e58 <OSTaskNameSet+0xc4>
        OS_EXIT_CRITICAL();                          /* No                                             */
 c223e40:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223e44:	e121f000 	msr	CPSR_c, r0
        *err = OS_TASK_NOT_EXIST;
 c223e48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223e4c:	e3a0200b 	mov	r2, #11
 c223e50:	e5c32000 	strb	r2, [r3]
        return;
 c223e54:	ea00001f 	b	c223ed8 <OSTaskNameSet+0x144>
    }
    if (ptcb == (OS_TCB *)1) {                       /* Task assigned to a Mutex?                      */
 c223e58:	e51b3010 	ldr	r3, [fp, #-16]
 c223e5c:	e3530001 	cmp	r3, #1
 c223e60:	1a000005 	bne	c223e7c <OSTaskNameSet+0xe8>
        OS_EXIT_CRITICAL();                          /* Yes                                            */
 c223e64:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223e68:	e121f000 	msr	CPSR_c, r0
        *err = OS_TASK_NOT_EXIST;
 c223e6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223e70:	e3a0200b 	mov	r2, #11
 c223e74:	e5c32000 	strb	r2, [r3]
        return;
 c223e78:	ea000016 	b	c223ed8 <OSTaskNameSet+0x144>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 c223e7c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
 c223e80:	ebffe6d2 	bl	c21d9d0 <OS_StrLen>
 c223e84:	e1a03000 	mov	r3, r0
 c223e88:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 c223e8c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c223e90:	e353001f 	cmp	r3, #31
 c223e94:	9a000005 	bls	c223eb0 <OSTaskNameSet+0x11c>
        OS_EXIT_CRITICAL();
 c223e98:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223e9c:	e121f000 	msr	CPSR_c, r0
        *err = OS_ERR_TASK_NAME_TOO_LONG;
 c223ea0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223ea4:	e3a0200e 	mov	r2, #14
 c223ea8:	e5c32000 	strb	r2, [r3]
        return;
 c223eac:	ea000009 	b	c223ed8 <OSTaskNameSet+0x144>
    } 
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 c223eb0:	e51b3010 	ldr	r3, [fp, #-16]
 c223eb4:	e2833048 	add	r3, r3, #72	; 0x48
 c223eb8:	e1a00003 	mov	r0, r3
 c223ebc:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
 c223ec0:	ebffe6a0 	bl	c21d948 <OS_StrCopy>
    OS_EXIT_CRITICAL();
 c223ec4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223ec8:	e121f000 	msr	CPSR_c, r0
    *err = OS_NO_ERR;
 c223ecc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c223ed0:	e3a02000 	mov	r2, #0
 c223ed4:	e5c32000 	strb	r2, [r3]
}
 c223ed8:	e24bd00c 	sub	sp, fp, #12
 c223edc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c223ee0:	e12fff1e 	bx	lr
 c223ee4:	0c1c84c4 	.word	0x0c1c84c4
 c223ee8:	0c1c97a4 	.word	0x0c1c97a4

0c223eec <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 c223eec:	e1a0c00d 	mov	ip, sp
 c223ef0:	e92dd800 	push	{fp, ip, lr, pc}
 c223ef4:	e24cb004 	sub	fp, ip, #4
 c223ef8:	e24dd010 	sub	sp, sp, #16
 c223efc:	e1a03000 	mov	r3, r0
 c223f00:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb


    cpu_sr = 0;                                               /* Prevent compiler warning              */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 c223f04:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c223f08:	e353003e 	cmp	r3, #62	; 0x3e
 c223f0c:	9a000001 	bls	c223f18 <OSTaskResume+0x2c>
        return (OS_PRIO_INVALID);
 c223f10:	e3a0302a 	mov	r3, #42	; 0x2a
 c223f14:	ea00004a 	b	c224044 <OSTaskResume+0x158>
    }
#endif
    OS_ENTER_CRITICAL();
 c223f18:	e10f0000 	mrs	r0, CPSR
 c223f1c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c223f20:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c223f24:	e121f000 	msr	CPSR_c, r0
    ptcb = OSTCBPrioTbl[prio];
 c223f28:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c223f2c:	e59f3120 	ldr	r3, [pc, #288]	; c224054 <OSTaskResume+0x168>
 c223f30:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c223f34:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 c223f38:	e51b3010 	ldr	r3, [fp, #-16]
 c223f3c:	e3530000 	cmp	r3, #0
 c223f40:	1a000003 	bne	c223f54 <OSTaskResume+0x68>
        OS_EXIT_CRITICAL();
 c223f44:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223f48:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_RESUME_PRIO);
 c223f4c:	e3a03064 	mov	r3, #100	; 0x64
 c223f50:	ea00003b 	b	c224044 <OSTaskResume+0x158>
    }
    if (ptcb == (OS_TCB *)1) {                                /* See if assigned to Mutex              */
 c223f54:	e51b3010 	ldr	r3, [fp, #-16]
 c223f58:	e3530001 	cmp	r3, #1
 c223f5c:	1a000003 	bne	c223f70 <OSTaskResume+0x84>
        OS_EXIT_CRITICAL();
 c223f60:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c223f64:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c223f68:	e3a0300b 	mov	r3, #11
 c223f6c:	ea000034 	b	c224044 <OSTaskResume+0x158>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 c223f70:	e51b3010 	ldr	r3, [fp, #-16]
 c223f74:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c223f78:	e2033008 	and	r3, r3, #8
 c223f7c:	e3530000 	cmp	r3, #0
 c223f80:	0a00002c 	beq	c224038 <OSTaskResume+0x14c>
        ptcb->OSTCBStat &= ~OS_STAT_SUSPEND;				  /* Remove suspension                     */
 c223f84:	e51b3010 	ldr	r3, [fp, #-16]
 c223f88:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c223f8c:	e3c33008 	bic	r3, r3, #8
 c223f90:	e20320ff 	and	r2, r3, #255	; 0xff
 c223f94:	e51b3010 	ldr	r3, [fp, #-16]
 c223f98:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 c223f9c:	e51b3010 	ldr	r3, [fp, #-16]
 c223fa0:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c223fa4:	e3530000 	cmp	r3, #0
 c223fa8:	1a00001e 	bne	c224028 <OSTaskResume+0x13c>
            if (ptcb->OSTCBDly == 0) {
 c223fac:	e51b3010 	ldr	r3, [fp, #-16]
 c223fb0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
 c223fb4:	e3530000 	cmp	r3, #0
 c223fb8:	1a000017 	bne	c22401c <OSTaskResume+0x130>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 c223fbc:	e51b3010 	ldr	r3, [fp, #-16]
 c223fc0:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c223fc4:	e59f308c 	ldr	r3, [pc, #140]	; c224058 <OSTaskResume+0x16c>
 c223fc8:	e5d33000 	ldrb	r3, [r3]
 c223fcc:	e1823003 	orr	r3, r2, r3
 c223fd0:	e20320ff 	and	r2, r3, #255	; 0xff
 c223fd4:	e59f307c 	ldr	r3, [pc, #124]	; c224058 <OSTaskResume+0x16c>
 c223fd8:	e5c32000 	strb	r2, [r3]
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c223fdc:	e51b3010 	ldr	r3, [fp, #-16]
 c223fe0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c223fe4:	e51b2010 	ldr	r2, [fp, #-16]
 c223fe8:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c223fec:	e59f1068 	ldr	r1, [pc, #104]	; c22405c <OSTaskResume+0x170>
 c223ff0:	e7d11002 	ldrb	r1, [r1, r2]
 c223ff4:	e51b2010 	ldr	r2, [fp, #-16]
 c223ff8:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c223ffc:	e1812002 	orr	r2, r1, r2
 c224000:	e20210ff 	and	r1, r2, #255	; 0xff
 c224004:	e59f2050 	ldr	r2, [pc, #80]	; c22405c <OSTaskResume+0x170>
 c224008:	e7c21003 	strb	r1, [r2, r3]
                OS_EXIT_CRITICAL();
 c22400c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224010:	e121f000 	msr	CPSR_c, r0
                OS_Sched();
 c224014:	ebffe603 	bl	c21d828 <OS_Sched>
 c224018:	ea000004 	b	c224030 <OSTaskResume+0x144>
            } else {
                OS_EXIT_CRITICAL();
 c22401c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224020:	e121f000 	msr	CPSR_c, r0
 c224024:	ea000001 	b	c224030 <OSTaskResume+0x144>
            }
        } else {                                              /* Must be pending on event              */
		    OS_EXIT_CRITICAL();
 c224028:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22402c:	e121f000 	msr	CPSR_c, r0
        }
        return (OS_NO_ERR);
 c224030:	e3a03000 	mov	r3, #0
 c224034:	ea000002 	b	c224044 <OSTaskResume+0x158>
    }
    OS_EXIT_CRITICAL();
 c224038:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22403c:	e121f000 	msr	CPSR_c, r0
    return (OS_TASK_NOT_SUSPENDED);
 c224040:	e3a03065 	mov	r3, #101	; 0x65
}
 c224044:	e1a00003 	mov	r0, r3
 c224048:	e24bd00c 	sub	sp, fp, #12
 c22404c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c224050:	e12fff1e 	bx	lr
 c224054:	0c1c97a4 	.word	0x0c1c97a4
 c224058:	0c1c84b0 	.word	0x0c1c84b0
 c22405c:	0c1c84b4 	.word	0x0c1c84b4

0c224060 <OSTaskStkChk>:
*              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 c224060:	e1a0c00d 	mov	ip, sp
 c224064:	e92dd800 	push	{fp, ip, lr, pc}
 c224068:	e24cb004 	sub	fp, ip, #4
 c22406c:	e24dd018 	sub	sp, sp, #24
 c224070:	e1a03000 	mov	r3, r0
 c224074:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
 c224078:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3


    cpu_sr = 0;                                        /* Prevent compiler warning                     */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {					   /* Make sure task priority is valid             */
 c22407c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c224080:	e353003f 	cmp	r3, #63	; 0x3f
 c224084:	9a000004 	bls	c22409c <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {        
 c224088:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c22408c:	e35300ff 	cmp	r3, #255	; 0xff
 c224090:	0a000001 	beq	c22409c <OSTaskStkChk+0x3c>
            return (OS_PRIO_INVALID);
 c224094:	e3a0302a 	mov	r3, #42	; 0x2a
 c224098:	ea00004f 	b	c2241dc <OSTaskStkChk+0x17c>
        }
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 c22409c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2240a0:	e3a02000 	mov	r2, #0
 c2240a4:	e5832000 	str	r2, [r3]
    p_stk_data->OSUsed = 0;
 c2240a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2240ac:	e3a02000 	mov	r2, #0
 c2240b0:	e5832004 	str	r2, [r3, #4]
    OS_ENTER_CRITICAL();
 c2240b4:	e10f0000 	mrs	r0, CPSR
 c2240b8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2240bc:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2240c0:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 c2240c4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2240c8:	e35300ff 	cmp	r3, #255	; 0xff
 c2240cc:	1a000003 	bne	c2240e0 <OSTaskStkChk+0x80>
        prio = OSTCBCur->OSTCBPrio;
 c2240d0:	e59f3114 	ldr	r3, [pc, #276]	; c2241ec <OSTaskStkChk+0x18c>
 c2240d4:	e5933000 	ldr	r3, [r3]
 c2240d8:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c2240dc:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
    }
    ptcb = OSTCBPrioTbl[prio];
 c2240e0:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c2240e4:	e59f3104 	ldr	r3, [pc, #260]	; c2241f0 <OSTaskStkChk+0x190>
 c2240e8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c2240ec:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 c2240f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2240f4:	e3530000 	cmp	r3, #0
 c2240f8:	1a000003 	bne	c22410c <OSTaskStkChk+0xac>
        OS_EXIT_CRITICAL();
 c2240fc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224100:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c224104:	e3a0300b 	mov	r3, #11
 c224108:	ea000033 	b	c2241dc <OSTaskStkChk+0x17c>
    }
    if (ptcb == (OS_TCB *)1) {
 c22410c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224110:	e3530001 	cmp	r3, #1
 c224114:	1a000003 	bne	c224128 <OSTaskStkChk+0xc8>
        OS_EXIT_CRITICAL();
 c224118:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22411c:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c224120:	e3a0300b 	mov	r3, #11
 c224124:	ea00002c 	b	c2241dc <OSTaskStkChk+0x17c>
    }  
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 c224128:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22412c:	e1d331b0 	ldrh	r3, [r3, #16]
 c224130:	e2033001 	and	r3, r3, #1
 c224134:	e3530000 	cmp	r3, #0
 c224138:	1a000003 	bne	c22414c <OSTaskStkChk+0xec>
        OS_EXIT_CRITICAL();
 c22413c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224140:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_OPT_ERR);
 c224144:	e3a03082 	mov	r3, #130	; 0x82
 c224148:	ea000023 	b	c2241dc <OSTaskStkChk+0x17c>
    }
    free = 0;
 c22414c:	e3a03000 	mov	r3, #0
 c224150:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    size = ptcb->OSTCBStkSize;
 c224154:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224158:	e593300c 	ldr	r3, [r3, #12]
 c22415c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    pchk = ptcb->OSTCBStkBottom;
 c224160:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224164:	e5933008 	ldr	r3, [r3, #8]
 c224168:	e50b3010 	str	r3, [fp, #-16]
    OS_EXIT_CRITICAL();
 c22416c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224170:	e121f000 	msr	CPSR_c, r0
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 c224174:	ea000002 	b	c224184 <OSTaskStkChk+0x124>
        free++;
 c224178:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22417c:	e2833001 	add	r3, r3, #1
 c224180:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 c224184:	e51b3010 	ldr	r3, [fp, #-16]
 c224188:	e5933000 	ldr	r3, [r3]
 c22418c:	e3530000 	cmp	r3, #0
 c224190:	13a03000 	movne	r3, #0
 c224194:	03a03001 	moveq	r3, #1
 c224198:	e20330ff 	and	r3, r3, #255	; 0xff
 c22419c:	e51b2010 	ldr	r2, [fp, #-16]
 c2241a0:	e2822004 	add	r2, r2, #4
 c2241a4:	e50b2010 	str	r2, [fp, #-16]
 c2241a8:	e3530000 	cmp	r3, #0
 c2241ac:	1afffff1 	bne	c224178 <OSTaskStkChk+0x118>
#else
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
 c2241b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2241b4:	e1a02103 	lsl	r2, r3, #2
 c2241b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2241bc:	e5832000 	str	r2, [r3]
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
 c2241c0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2241c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2241c8:	e0633002 	rsb	r3, r3, r2
 c2241cc:	e1a02103 	lsl	r2, r3, #2
 c2241d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c2241d4:	e5832004 	str	r2, [r3, #4]
    return (OS_NO_ERR);
 c2241d8:	e3a03000 	mov	r3, #0
}
 c2241dc:	e1a00003 	mov	r0, r3
 c2241e0:	e24bd00c 	sub	sp, fp, #12
 c2241e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2241e8:	e12fff1e 	bx	lr
 c2241ec:	0c1c84c4 	.word	0x0c1c84c4
 c2241f0:	0c1c97a4 	.word	0x0c1c97a4

0c2241f4 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 c2241f4:	e1a0c00d 	mov	ip, sp
 c2241f8:	e92dd800 	push	{fp, ip, lr, pc}
 c2241fc:	e24cb004 	sub	fp, ip, #4
 c224200:	e24dd018 	sub	sp, sp, #24
 c224204:	e1a03000 	mov	r3, r0
 c224208:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3


    cpu_sr = 0;                                                 /* Prevent compiler warning            */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to suspend idle task    */
 c22420c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c224210:	e353003f 	cmp	r3, #63	; 0x3f
 c224214:	1a000001 	bne	c224220 <OSTaskSuspend+0x2c>
        return (OS_TASK_SUSPEND_IDLE);
 c224218:	e3a0305b 	mov	r3, #91	; 0x5b
 c22421c:	ea000063 	b	c2243b0 <OSTaskSuspend+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {								/* Task priority valid ?               */
 c224220:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c224224:	e353003e 	cmp	r3, #62	; 0x3e
 c224228:	9a000004 	bls	c224240 <OSTaskSuspend+0x4c>
        if (prio != OS_PRIO_SELF) {
 c22422c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c224230:	e35300ff 	cmp	r3, #255	; 0xff
 c224234:	0a000001 	beq	c224240 <OSTaskSuspend+0x4c>
            return (OS_PRIO_INVALID);
 c224238:	e3a0302a 	mov	r3, #42	; 0x2a
 c22423c:	ea00005b 	b	c2243b0 <OSTaskSuspend+0x1bc>
        }
    }
#endif
    OS_ENTER_CRITICAL();
 c224240:	e10f0000 	mrs	r0, CPSR
 c224244:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c224248:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c22424c:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 c224250:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c224254:	e35300ff 	cmp	r3, #255	; 0xff
 c224258:	1a000006 	bne	c224278 <OSTaskSuspend+0x84>
        prio = OSTCBCur->OSTCBPrio;
 c22425c:	e59f315c 	ldr	r3, [pc, #348]	; c2243c0 <OSTaskSuspend+0x1cc>
 c224260:	e5933000 	ldr	r3, [r3]
 c224264:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c224268:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
        self = TRUE;
 c22426c:	e3a03001 	mov	r3, #1
 c224270:	e54b300d 	strb	r3, [fp, #-13]
 c224274:	ea00000a 	b	c2242a4 <OSTaskSuspend+0xb0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 c224278:	e59f3140 	ldr	r3, [pc, #320]	; c2243c0 <OSTaskSuspend+0x1cc>
 c22427c:	e5933000 	ldr	r3, [r3]
 c224280:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c224284:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c224288:	e1520003 	cmp	r2, r3
 c22428c:	1a000002 	bne	c22429c <OSTaskSuspend+0xa8>
        self = TRUE;
 c224290:	e3a03001 	mov	r3, #1
 c224294:	e54b300d 	strb	r3, [fp, #-13]
 c224298:	ea000001 	b	c2242a4 <OSTaskSuspend+0xb0>
    } else {
        self = FALSE;                                           /* No suspending another task          */
 c22429c:	e3a03000 	mov	r3, #0
 c2242a0:	e54b300d 	strb	r3, [fp, #-13]
    }
    ptcb = OSTCBPrioTbl[prio];
 c2242a4:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
 c2242a8:	e59f3114 	ldr	r3, [pc, #276]	; c2243c4 <OSTaskSuspend+0x1d0>
 c2242ac:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c2242b0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 c2242b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2242b8:	e3530000 	cmp	r3, #0
 c2242bc:	1a000003 	bne	c2242d0 <OSTaskSuspend+0xdc>
        OS_EXIT_CRITICAL();
 c2242c0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2242c4:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_SUSPEND_PRIO);
 c2242c8:	e3a0305a 	mov	r3, #90	; 0x5a
 c2242cc:	ea000037 	b	c2243b0 <OSTaskSuspend+0x1bc>
    }
    if (ptcb == (OS_TCB *)1) {                                  /* See if assigned to Mutex            */
 c2242d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2242d4:	e3530001 	cmp	r3, #1
 c2242d8:	1a000003 	bne	c2242ec <OSTaskSuspend+0xf8>
        OS_EXIT_CRITICAL();
 c2242dc:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2242e0:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c2242e4:	e3a0300b 	mov	r3, #11
 c2242e8:	ea000030 	b	c2243b0 <OSTaskSuspend+0x1bc>
    }
	y            = ptcb->OSTCBY;
 c2242ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2242f0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c2242f4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	OSRdyTbl[y] &= ~ptcb->OSTCBBitX;							/* Make task not ready                 */
 c2242f8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2242fc:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c224300:	e59f10c0 	ldr	r1, [pc, #192]	; c2243c8 <OSTaskSuspend+0x1d4>
 c224304:	e7d12002 	ldrb	r2, [r1, r2]
 c224308:	e20210ff 	and	r1, r2, #255	; 0xff
 c22430c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c224310:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c224314:	e20220ff 	and	r2, r2, #255	; 0xff
 c224318:	e1e02002 	mvn	r2, r2
 c22431c:	e20220ff 	and	r2, r2, #255	; 0xff
 c224320:	e0012002 	and	r2, r1, r2
 c224324:	e20220ff 	and	r2, r2, #255	; 0xff
 c224328:	e20210ff 	and	r1, r2, #255	; 0xff
 c22432c:	e59f2094 	ldr	r2, [pc, #148]	; c2243c8 <OSTaskSuspend+0x1d4>
 c224330:	e7c21003 	strb	r1, [r2, r3]
    if (OSRdyTbl[y] == 0x00) { 
 c224334:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c224338:	e59f2088 	ldr	r2, [pc, #136]	; c2243c8 <OSTaskSuspend+0x1d4>
 c22433c:	e7d23003 	ldrb	r3, [r2, r3]
 c224340:	e3530000 	cmp	r3, #0
 c224344:	1a00000c 	bne	c22437c <OSTaskSuspend+0x188>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 c224348:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22434c:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c224350:	e20330ff 	and	r3, r3, #255	; 0xff
 c224354:	e1e03003 	mvn	r3, r3
 c224358:	e20320ff 	and	r2, r3, #255	; 0xff
 c22435c:	e59f3068 	ldr	r3, [pc, #104]	; c2243cc <OSTaskSuspend+0x1d8>
 c224360:	e5d33000 	ldrb	r3, [r3]
 c224364:	e20330ff 	and	r3, r3, #255	; 0xff
 c224368:	e0023003 	and	r3, r2, r3
 c22436c:	e20330ff 	and	r3, r3, #255	; 0xff
 c224370:	e20320ff 	and	r2, r3, #255	; 0xff
 c224374:	e59f3050 	ldr	r3, [pc, #80]	; c2243cc <OSTaskSuspend+0x1d8>
 c224378:	e5c32000 	strb	r2, [r3]
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 c22437c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224380:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c224384:	e3833008 	orr	r3, r3, #8
 c224388:	e20320ff 	and	r2, r3, #255	; 0xff
 c22438c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224390:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
    OS_EXIT_CRITICAL();
 c224394:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224398:	e121f000 	msr	CPSR_c, r0
    if (self == TRUE) {                                         /* Context switch only if SELF         */
 c22439c:	e55b300d 	ldrb	r3, [fp, #-13]
 c2243a0:	e3530001 	cmp	r3, #1
 c2243a4:	1a000000 	bne	c2243ac <OSTaskSuspend+0x1b8>
        OS_Sched();
 c2243a8:	ebffe51e 	bl	c21d828 <OS_Sched>
    }
    return (OS_NO_ERR);
 c2243ac:	e3a03000 	mov	r3, #0
}
 c2243b0:	e1a00003 	mov	r0, r3
 c2243b4:	e24bd00c 	sub	sp, fp, #12
 c2243b8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2243bc:	e12fff1e 	bx	lr
 c2243c0:	0c1c84c4 	.word	0x0c1c84c4
 c2243c4:	0c1c97a4 	.word	0x0c1c97a4
 c2243c8:	0c1c84b4 	.word	0x0c1c84b4
 c2243cc:	0c1c84b0 	.word	0x0c1c84b0

0c2243d0 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 c2243d0:	e1a0c00d 	mov	ip, sp
 c2243d4:	e92dd800 	push	{fp, ip, lr, pc}
 c2243d8:	e24cb004 	sub	fp, ip, #4
 c2243dc:	e24dd010 	sub	sp, sp, #16
 c2243e0:	e1a03000 	mov	r3, r0
 c2243e4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c2243e8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb


    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {				 /* Task priority valid ?    	                       */
 c2243ec:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2243f0:	e353003f 	cmp	r3, #63	; 0x3f
 c2243f4:	9a000004 	bls	c22440c <OSTaskQuery+0x3c>
        if (prio != OS_PRIO_SELF) {   
 c2243f8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2243fc:	e35300ff 	cmp	r3, #255	; 0xff
 c224400:	0a000001 	beq	c22440c <OSTaskQuery+0x3c>
            return (OS_PRIO_INVALID);
 c224404:	e3a0302a 	mov	r3, #42	; 0x2a
 c224408:	ea000025 	b	c2244a4 <OSTaskQuery+0xd4>
        }
    }
#endif
    OS_ENTER_CRITICAL();
 c22440c:	e10f0000 	mrs	r0, CPSR
 c224410:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c224414:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c224418:	e121f000 	msr	CPSR_c, r0
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 c22441c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c224420:	e35300ff 	cmp	r3, #255	; 0xff
 c224424:	1a000003 	bne	c224438 <OSTaskQuery+0x68>
        prio = OSTCBCur->OSTCBPrio;
 c224428:	e59f3084 	ldr	r3, [pc, #132]	; c2244b4 <OSTaskQuery+0xe4>
 c22442c:	e5933000 	ldr	r3, [r3]
 c224430:	e5d3302e 	ldrb	r3, [r3, #46]	; 0x2e
 c224434:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    }
    ptcb = OSTCBPrioTbl[prio];
 c224438:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c22443c:	e59f3074 	ldr	r3, [pc, #116]	; c2244b8 <OSTaskQuery+0xe8>
 c224440:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c224444:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 c224448:	e51b3010 	ldr	r3, [fp, #-16]
 c22444c:	e3530000 	cmp	r3, #0
 c224450:	1a000003 	bne	c224464 <OSTaskQuery+0x94>
        OS_EXIT_CRITICAL();
 c224454:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224458:	e121f000 	msr	CPSR_c, r0
        return (OS_PRIO_ERR);
 c22445c:	e3a03029 	mov	r3, #41	; 0x29
 c224460:	ea00000f 	b	c2244a4 <OSTaskQuery+0xd4>
    }
    if (ptcb == (OS_TCB *)1) {                   /* Task to query must not be assigned to a Mutex      */
 c224464:	e51b3010 	ldr	r3, [fp, #-16]
 c224468:	e3530001 	cmp	r3, #1
 c22446c:	1a000003 	bne	c224480 <OSTaskQuery+0xb0>
        OS_EXIT_CRITICAL();
 c224470:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224474:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);
 c224478:	e3a0300b 	mov	r3, #11
 c22447c:	ea000008 	b	c2244a4 <OSTaskQuery+0xd4>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));  
 c224480:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c224484:	e51b3010 	ldr	r3, [fp, #-16]
 c224488:	e1a00002 	mov	r0, r2
 c22448c:	e1a01003 	mov	r1, r3
 c224490:	e3a02068 	mov	r2, #104	; 0x68
 c224494:	ebffe4c7 	bl	c21d7b8 <OS_MemCopy>
    OS_EXIT_CRITICAL();
 c224498:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c22449c:	e121f000 	msr	CPSR_c, r0
    return (OS_NO_ERR);
 c2244a0:	e3a03000 	mov	r3, #0
}
 c2244a4:	e1a00003 	mov	r0, r3
 c2244a8:	e24bd00c 	sub	sp, fp, #12
 c2244ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2244b0:	e12fff1e 	bx	lr
 c2244b4:	0c1c84c4 	.word	0x0c1c84c4
 c2244b8:	0c1c97a4 	.word	0x0c1c97a4

0c2244bc <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 c2244bc:	e1a0c00d 	mov	ip, sp
 c2244c0:	e92dd800 	push	{fp, ip, lr, pc}
 c2244c4:	e24cb004 	sub	fp, ip, #4
 c2244c8:	e24dd010 	sub	sp, sp, #16
 c2244cc:	e50b0010 	str	r0, [fp, #-16]
 c2244d0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c2244d4:	e1a03002 	mov	r3, r2
 c2244d8:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 c2244dc:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c2244e0:	e2033001 	and	r3, r3, #1
 c2244e4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2244e8:	e3530000 	cmp	r3, #0
 c2244ec:	0a000010 	beq	c224534 <OS_TaskStkClr+0x78>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 c2244f0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c2244f4:	e2033002 	and	r3, r3, #2
 c2244f8:	e3530000 	cmp	r3, #0
 c2244fc:	0a00000c 	beq	c224534 <OS_TaskStkClr+0x78>
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 c224500:	ea000008 	b	c224528 <OS_TaskStkClr+0x6c>
                size--;
 c224504:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224508:	e2433001 	sub	r3, r3, #1
 c22450c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 c224510:	e51b3010 	ldr	r3, [fp, #-16]
 c224514:	e3a02000 	mov	r2, #0
 c224518:	e5832000 	str	r2, [r3]
 c22451c:	e51b3010 	ldr	r3, [fp, #-16]
 c224520:	e2833004 	add	r3, r3, #4
 c224524:	e50b3010 	str	r3, [fp, #-16]
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 c224528:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22452c:	e3530000 	cmp	r3, #0
 c224530:	1afffff3 	bne	c224504 <OS_TaskStkClr+0x48>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 c224534:	e24bd00c 	sub	sp, fp, #12
 c224538:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22453c:	e12fff1e 	bx	lr

0c224540 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 c224540:	e1a0c00d 	mov	ip, sp
 c224544:	e92dd800 	push	{fp, ip, lr, pc}
 c224548:	e24cb004 	sub	fp, ip, #4
 c22454c:	e24dd010 	sub	sp, sp, #16
 c224550:	e1a03000 	mov	r3, r0
 c224554:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 c224558:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c22455c:	e3530000 	cmp	r3, #0
 c224560:	0a000031 	beq	c22462c <OSTimeDly+0xec>
        OS_ENTER_CRITICAL();
 c224564:	e10f0000 	mrs	r0, CPSR
 c224568:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c22456c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c224570:	e121f000 	msr	CPSR_c, r0
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 c224574:	e59f30bc 	ldr	r3, [pc, #188]	; c224638 <OSTimeDly+0xf8>
 c224578:	e5933000 	ldr	r3, [r3]
 c22457c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c224580:	e54b300d 	strb	r3, [fp, #-13]
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 c224584:	e55b300d 	ldrb	r3, [fp, #-13]
 c224588:	e55b200d 	ldrb	r2, [fp, #-13]
 c22458c:	e59f10a8 	ldr	r1, [pc, #168]	; c22463c <OSTimeDly+0xfc>
 c224590:	e7d12002 	ldrb	r2, [r1, r2]
 c224594:	e20210ff 	and	r1, r2, #255	; 0xff
 c224598:	e59f2098 	ldr	r2, [pc, #152]	; c224638 <OSTimeDly+0xf8>
 c22459c:	e5922000 	ldr	r2, [r2]
 c2245a0:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c2245a4:	e20220ff 	and	r2, r2, #255	; 0xff
 c2245a8:	e1e02002 	mvn	r2, r2
 c2245ac:	e20220ff 	and	r2, r2, #255	; 0xff
 c2245b0:	e0012002 	and	r2, r1, r2
 c2245b4:	e20220ff 	and	r2, r2, #255	; 0xff
 c2245b8:	e20210ff 	and	r1, r2, #255	; 0xff
 c2245bc:	e59f2078 	ldr	r2, [pc, #120]	; c22463c <OSTimeDly+0xfc>
 c2245c0:	e7c21003 	strb	r1, [r2, r3]
        if (OSRdyTbl[y] == 0) {  
 c2245c4:	e55b300d 	ldrb	r3, [fp, #-13]
 c2245c8:	e59f206c 	ldr	r2, [pc, #108]	; c22463c <OSTimeDly+0xfc>
 c2245cc:	e7d23003 	ldrb	r3, [r2, r3]
 c2245d0:	e3530000 	cmp	r3, #0
 c2245d4:	1a00000d 	bne	c224610 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 c2245d8:	e59f3058 	ldr	r3, [pc, #88]	; c224638 <OSTimeDly+0xf8>
 c2245dc:	e5933000 	ldr	r3, [r3]
 c2245e0:	e5d33032 	ldrb	r3, [r3, #50]	; 0x32
 c2245e4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2245e8:	e1e03003 	mvn	r3, r3
 c2245ec:	e20320ff 	and	r2, r3, #255	; 0xff
 c2245f0:	e59f3048 	ldr	r3, [pc, #72]	; c224640 <OSTimeDly+0x100>
 c2245f4:	e5d33000 	ldrb	r3, [r3]
 c2245f8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2245fc:	e0023003 	and	r3, r2, r3
 c224600:	e20330ff 	and	r3, r3, #255	; 0xff
 c224604:	e20320ff 	and	r2, r3, #255	; 0xff
 c224608:	e59f3030 	ldr	r3, [pc, #48]	; c224640 <OSTimeDly+0x100>
 c22460c:	e5c32000 	strb	r2, [r3]
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 c224610:	e59f3020 	ldr	r3, [pc, #32]	; c224638 <OSTimeDly+0xf8>
 c224614:	e5933000 	ldr	r3, [r3]
 c224618:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c22461c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
        OS_EXIT_CRITICAL();
 c224620:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224624:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                              /* Find next task to run!                             */
 c224628:	ebffe47e 	bl	c21d828 <OS_Sched>
    }
}
 c22462c:	e24bd00c 	sub	sp, fp, #12
 c224630:	e89d6800 	ldm	sp, {fp, sp, lr}
 c224634:	e12fff1e 	bx	lr
 c224638:	0c1c84c4 	.word	0x0c1c84c4
 c22463c:	0c1c84b4 	.word	0x0c1c84b4
 c224640:	0c1c84b0 	.word	0x0c1c84b0

0c224644 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
 c224644:	e1a0c00d 	mov	ip, sp
 c224648:	e92dd800 	push	{fp, ip, lr, pc}
 c22464c:	e24cb004 	sub	fp, ip, #4
 c224650:	e24dd010 	sub	sp, sp, #16
 c224654:	e54b0015 	strb	r0, [fp, #-21]	; 0xffffffeb
 c224658:	e54b1016 	strb	r1, [fp, #-22]	; 0xffffffea
 c22465c:	e54b2017 	strb	r2, [fp, #-23]	; 0xffffffe9
 c224660:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
    INT32U ticks;
    INT16U loops;


#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 c224664:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c224668:	e3530000 	cmp	r3, #0
 c22466c:	1a00000a 	bne	c22469c <OSTimeDlyHMSM+0x58>
        if (minutes == 0) {
 c224670:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c224674:	e3530000 	cmp	r3, #0
 c224678:	1a000007 	bne	c22469c <OSTimeDlyHMSM+0x58>
            if (seconds == 0) {
 c22467c:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c224680:	e3530000 	cmp	r3, #0
 c224684:	1a000004 	bne	c22469c <OSTimeDlyHMSM+0x58>
                if (milli == 0) {
 c224688:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c22468c:	e3530000 	cmp	r3, #0
 c224690:	1a000001 	bne	c22469c <OSTimeDlyHMSM+0x58>
                    return (OS_TIME_ZERO_DLY);
 c224694:	e3a03054 	mov	r3, #84	; 0x54
 c224698:	ea00004c 	b	c2247d0 <OSTimeDlyHMSM+0x18c>
                }
            }
        }
    }
    if (minutes > 59) {
 c22469c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c2246a0:	e353003b 	cmp	r3, #59	; 0x3b
 c2246a4:	9a000001 	bls	c2246b0 <OSTimeDlyHMSM+0x6c>
        return (OS_TIME_INVALID_MINUTES);        /* Validate arguments to be within range              */
 c2246a8:	e3a03051 	mov	r3, #81	; 0x51
 c2246ac:	ea000047 	b	c2247d0 <OSTimeDlyHMSM+0x18c>
    }
    if (seconds > 59) {
 c2246b0:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c2246b4:	e353003b 	cmp	r3, #59	; 0x3b
 c2246b8:	9a000001 	bls	c2246c4 <OSTimeDlyHMSM+0x80>
        return (OS_TIME_INVALID_SECONDS);
 c2246bc:	e3a03052 	mov	r3, #82	; 0x52
 c2246c0:	ea000042 	b	c2247d0 <OSTimeDlyHMSM+0x18c>
    }
    if (milli > 999) {
 c2246c4:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c2246c8:	e59f3110 	ldr	r3, [pc, #272]	; c2247e0 <OSTimeDlyHMSM+0x19c>
 c2246cc:	e1520003 	cmp	r2, r3
 c2246d0:	9a000001 	bls	c2246dc <OSTimeDlyHMSM+0x98>
        return (OS_TIME_INVALID_MILLI);
 c2246d4:	e3a03053 	mov	r3, #83	; 0x53
 c2246d8:	ea00003c 	b	c2247d0 <OSTimeDlyHMSM+0x18c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 c2246dc:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c2246e0:	e1a03002 	mov	r3, r2
 c2246e4:	e1a03203 	lsl	r3, r3, #4
 c2246e8:	e0623003 	rsb	r3, r2, r3
 c2246ec:	e1a02203 	lsl	r2, r3, #4
 c2246f0:	e0632002 	rsb	r2, r3, r2
 c2246f4:	e1a03202 	lsl	r3, r2, #4
 c2246f8:	e1a02003 	mov	r2, r3
 c2246fc:	e1a01002 	mov	r1, r2
 c224700:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c224704:	e1a03002 	mov	r3, r2
 c224708:	e1a03203 	lsl	r3, r3, #4
 c22470c:	e0623003 	rsb	r3, r2, r3
 c224710:	e1a03103 	lsl	r3, r3, #2
 c224714:	e0812003 	add	r2, r1, r3
 c224718:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c22471c:	e0822003 	add	r2, r2, r3
 c224720:	e1a03002 	mov	r3, r2
 c224724:	e1a03103 	lsl	r3, r3, #2
 c224728:	e0833002 	add	r3, r3, r2
 c22472c:	e1a02103 	lsl	r2, r3, #2
 c224730:	e0833002 	add	r3, r3, r2
 c224734:	e1a03103 	lsl	r3, r3, #2
 c224738:	e1a01003 	mov	r1, r3
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
 c22473c:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c224740:	e1a03002 	mov	r3, r2
 c224744:	e1a03103 	lsl	r3, r3, #2
 c224748:	e0833002 	add	r3, r3, r2
 c22474c:	e1a02103 	lsl	r2, r3, #2
 c224750:	e0833002 	add	r3, r3, r2
 c224754:	e1a03103 	lsl	r3, r3, #2
 c224758:	e2832f7d 	add	r2, r3, #500	; 0x1f4
 c22475c:	e59f3080 	ldr	r3, [pc, #128]	; c2247e4 <OSTimeDlyHMSM+0x1a0>
 c224760:	e0830392 	umull	r0, r3, r2, r3
 c224764:	e1a03323 	lsr	r3, r3, #6
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 c224768:	e0813003 	add	r3, r1, r3
 c22476c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
 c224770:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224774:	e1a03823 	lsr	r3, r3, #16
 c224778:	e14b30be 	strh	r3, [fp, #-14]
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
 c22477c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224780:	e1a03803 	lsl	r3, r3, #16
 c224784:	e1a03823 	lsr	r3, r3, #16
 c224788:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    OSTimeDly((INT16U)ticks);
 c22478c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c224790:	e1a03803 	lsl	r3, r3, #16
 c224794:	e1a03823 	lsr	r3, r3, #16
 c224798:	e1a00003 	mov	r0, r3
 c22479c:	ebffff67 	bl	c224540 <OSTimeDly>
    while (loops > 0) {
 c2247a0:	ea000006 	b	c2247c0 <OSTimeDlyHMSM+0x17c>
        OSTimeDly((INT16U)32768u);
 c2247a4:	e3a00902 	mov	r0, #32768	; 0x8000
 c2247a8:	ebffff64 	bl	c224540 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 c2247ac:	e3a00902 	mov	r0, #32768	; 0x8000
 c2247b0:	ebffff62 	bl	c224540 <OSTimeDly>
        loops--;
 c2247b4:	e15b30be 	ldrh	r3, [fp, #-14]
 c2247b8:	e2433001 	sub	r3, r3, #1
 c2247bc:	e14b30be 	strh	r3, [fp, #-14]
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 c2247c0:	e15b30be 	ldrh	r3, [fp, #-14]
 c2247c4:	e3530000 	cmp	r3, #0
 c2247c8:	1afffff5 	bne	c2247a4 <OSTimeDlyHMSM+0x160>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
 c2247cc:	e3a03000 	mov	r3, #0
}
 c2247d0:	e1a00003 	mov	r0, r3
 c2247d4:	e24bd00c 	sub	sp, fp, #12
 c2247d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2247dc:	e12fff1e 	bx	lr
 c2247e0:	000003e7 	.word	0x000003e7
 c2247e4:	10624dd3 	.word	0x10624dd3

0c2247e8 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 c2247e8:	e1a0c00d 	mov	ip, sp
 c2247ec:	e92dd800 	push	{fp, ip, lr, pc}
 c2247f0:	e24cb004 	sub	fp, ip, #4
 c2247f4:	e24dd010 	sub	sp, sp, #16
 c2247f8:	e1a03000 	mov	r3, r0
 c2247fc:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb



    cpu_sr = 0;                                                /* Prevent compiler warning             */
#endif    
    if (prio >= OS_LOWEST_PRIO) {
 c224800:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c224804:	e353003e 	cmp	r3, #62	; 0x3e
 c224808:	9a000001 	bls	c224814 <OSTimeDlyResume+0x2c>
        return (OS_PRIO_INVALID);
 c22480c:	e3a0302a 	mov	r3, #42	; 0x2a
 c224810:	ea000052 	b	c224960 <OSTimeDlyResume+0x178>
    }
    OS_ENTER_CRITICAL();
 c224814:	e10f0000 	mrs	r0, CPSR
 c224818:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c22481c:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c224820:	e121f000 	msr	CPSR_c, r0
    ptcb = (OS_TCB *)OSTCBPrioTbl[prio];                       /* Make sure that task exist            */
 c224824:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c224828:	e59f3140 	ldr	r3, [pc, #320]	; c224970 <OSTimeDlyResume+0x188>
 c22482c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c224830:	e50b3010 	str	r3, [fp, #-16]
    if (ptcb == (OS_TCB *)0) {
 c224834:	e51b3010 	ldr	r3, [fp, #-16]
 c224838:	e3530000 	cmp	r3, #0
 c22483c:	1a000003 	bne	c224850 <OSTimeDlyResume+0x68>
        OS_EXIT_CRITICAL();
 c224840:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224844:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
 c224848:	e3a0300b 	mov	r3, #11
 c22484c:	ea000043 	b	c224960 <OSTimeDlyResume+0x178>
    }
    if (ptcb == (OS_TCB *)1) {
 c224850:	e51b3010 	ldr	r3, [fp, #-16]
 c224854:	e3530001 	cmp	r3, #1
 c224858:	1a000003 	bne	c22486c <OSTimeDlyResume+0x84>
        OS_EXIT_CRITICAL();
 c22485c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224860:	e121f000 	msr	CPSR_c, r0
        return (OS_TASK_NOT_EXIST);                            /* The task does not exist              */
 c224864:	e3a0300b 	mov	r3, #11
 c224868:	ea00003c 	b	c224960 <OSTimeDlyResume+0x178>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 c22486c:	e51b3010 	ldr	r3, [fp, #-16]
 c224870:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
 c224874:	e3530000 	cmp	r3, #0
 c224878:	1a000003 	bne	c22488c <OSTimeDlyResume+0xa4>
        OS_EXIT_CRITICAL();
 c22487c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224880:	e121f000 	msr	CPSR_c, r0
        return (OS_TIME_NOT_DLY);                              /* Indicate that task was not delayed   */
 c224884:	e3a03050 	mov	r3, #80	; 0x50
 c224888:	ea000034 	b	c224960 <OSTimeDlyResume+0x178>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 c22488c:	e51b3010 	ldr	r3, [fp, #-16]
 c224890:	e3a02000 	mov	r2, #0
 c224894:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 c224898:	e51b3010 	ldr	r3, [fp, #-16]
 c22489c:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c2248a0:	e2033037 	and	r3, r3, #55	; 0x37
 c2248a4:	e3530000 	cmp	r3, #0
 c2248a8:	0a000009 	beq	c2248d4 <OSTimeDlyResume+0xec>
        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag               */
 c2248ac:	e51b3010 	ldr	r3, [fp, #-16]
 c2248b0:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c2248b4:	e3c33037 	bic	r3, r3, #55	; 0x37
 c2248b8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2248bc:	e51b3010 	ldr	r3, [fp, #-16]
 c2248c0:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout                */
 c2248c4:	e51b3010 	ldr	r3, [fp, #-16]
 c2248c8:	e3a02001 	mov	r2, #1
 c2248cc:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
 c2248d0:	ea000002 	b	c2248e0 <OSTimeDlyResume+0xf8>
    } else {
        ptcb->OSTCBPendTO  = FALSE;
 c2248d4:	e51b3010 	ldr	r3, [fp, #-16]
 c2248d8:	e3a02000 	mov	r2, #0
 c2248dc:	e5c3202d 	strb	r2, [r3, #45]	; 0x2d
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 c2248e0:	e51b3010 	ldr	r3, [fp, #-16]
 c2248e4:	e5d3302c 	ldrb	r3, [r3, #44]	; 0x2c
 c2248e8:	e2033008 	and	r3, r3, #8
 c2248ec:	e3530000 	cmp	r3, #0
 c2248f0:	1a000017 	bne	c224954 <OSTimeDlyResume+0x16c>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 c2248f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2248f8:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
 c2248fc:	e59f3070 	ldr	r3, [pc, #112]	; c224974 <OSTimeDlyResume+0x18c>
 c224900:	e5d33000 	ldrb	r3, [r3]
 c224904:	e1823003 	orr	r3, r2, r3
 c224908:	e20320ff 	and	r2, r3, #255	; 0xff
 c22490c:	e59f3060 	ldr	r3, [pc, #96]	; c224974 <OSTimeDlyResume+0x18c>
 c224910:	e5c32000 	strb	r2, [r3]
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 c224914:	e51b3010 	ldr	r3, [fp, #-16]
 c224918:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
 c22491c:	e51b2010 	ldr	r2, [fp, #-16]
 c224920:	e5d22030 	ldrb	r2, [r2, #48]	; 0x30
 c224924:	e59f104c 	ldr	r1, [pc, #76]	; c224978 <OSTimeDlyResume+0x190>
 c224928:	e7d11002 	ldrb	r1, [r1, r2]
 c22492c:	e51b2010 	ldr	r2, [fp, #-16]
 c224930:	e5d22031 	ldrb	r2, [r2, #49]	; 0x31
 c224934:	e1812002 	orr	r2, r1, r2
 c224938:	e20210ff 	and	r1, r2, #255	; 0xff
 c22493c:	e59f2034 	ldr	r2, [pc, #52]	; c224978 <OSTimeDlyResume+0x190>
 c224940:	e7c21003 	strb	r1, [r2, r3]
        OS_EXIT_CRITICAL();
 c224944:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224948:	e121f000 	msr	CPSR_c, r0
        OS_Sched();                                           /* See if this is new highest priority   */
 c22494c:	ebffe3b5 	bl	c21d828 <OS_Sched>
 c224950:	ea000001 	b	c22495c <OSTimeDlyResume+0x174>
    } else {
        OS_EXIT_CRITICAL();                                   /* Task may be suspended                 */
 c224954:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224958:	e121f000 	msr	CPSR_c, r0
    }
    return (OS_NO_ERR);
 c22495c:	e3a03000 	mov	r3, #0
}
 c224960:	e1a00003 	mov	r0, r3
 c224964:	e24bd00c 	sub	sp, fp, #12
 c224968:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22496c:	e12fff1e 	bx	lr
 c224970:	0c1c97a4 	.word	0x0c1c97a4
 c224974:	0c1c84b0 	.word	0x0c1c84b0
 c224978:	0c1c84b4 	.word	0x0c1c84b4

0c22497c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 c22497c:	e1a0c00d 	mov	ip, sp
 c224980:	e92dd800 	push	{fp, ip, lr, pc}
 c224984:	e24cb004 	sub	fp, ip, #4
 c224988:	e24dd008 	sub	sp, sp, #8



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c22498c:	e10f0000 	mrs	r0, CPSR
 c224990:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c224994:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c224998:	e121f000 	msr	CPSR_c, r0
    ticks = OSTime;
 c22499c:	e59f3020 	ldr	r3, [pc, #32]	; c2249c4 <OSTimeGet+0x48>
 c2249a0:	e5933000 	ldr	r3, [r3]
 c2249a4:	e50b3010 	str	r3, [fp, #-16]
    OS_EXIT_CRITICAL();
 c2249a8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2249ac:	e121f000 	msr	CPSR_c, r0
    return (ticks);
 c2249b0:	e51b3010 	ldr	r3, [fp, #-16]
}
 c2249b4:	e1a00003 	mov	r0, r3
 c2249b8:	e24bd00c 	sub	sp, fp, #12
 c2249bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2249c0:	e12fff1e 	bx	lr
 c2249c4:	0c1c84c8 	.word	0x0c1c84c8

0c2249c8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 c2249c8:	e1a0c00d 	mov	ip, sp
 c2249cc:	e92dd800 	push	{fp, ip, lr, pc}
 c2249d0:	e24cb004 	sub	fp, ip, #4
 c2249d4:	e24dd008 	sub	sp, sp, #8
 c2249d8:	e50b0010 	str	r0, [fp, #-16]



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
#endif    
    OS_ENTER_CRITICAL();
 c2249dc:	e10f0000 	mrs	r0, CPSR
 c2249e0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c2249e4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c2249e8:	e121f000 	msr	CPSR_c, r0
    OSTime = ticks;
 c2249ec:	e59f3018 	ldr	r3, [pc, #24]	; c224a0c <OSTimeSet+0x44>
 c2249f0:	e51b2010 	ldr	r2, [fp, #-16]
 c2249f4:	e5832000 	str	r2, [r3]
    OS_EXIT_CRITICAL();
 c2249f8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c2249fc:	e121f000 	msr	CPSR_c, r0
}
 c224a00:	e24bd00c 	sub	sp, fp, #12
 c224a04:	e89d6800 	ldm	sp, {fp, sp, lr}
 c224a08:	e12fff1e 	bx	lr
 c224a0c:	0c1c84c8 	.word	0x0c1c84c8

0c224a10 <OS_CPU_isr_pb>:
** Wrapper + isr_pb
**
*/

OS_CPU_isr_pb:
  OS_CPU_ISR_WRAPPER isr_pb
 c224a10:	e92d000e 	push	{r1, r2, r3}
 c224a14:	e1a0100d 	mov	r1, sp
 c224a18:	e28dd00c 	add	sp, sp, #12
 c224a1c:	e24e2004 	sub	r2, lr, #4
 c224a20:	e14f3000 	mrs	r3, SPSR
 c224a24:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
 c224a28:	e52d2004 	push	{r2}		; (str r2, [sp, #-4]!)
 c224a2c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 c224a30:	e92d1ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip}
 c224a34:	e8b10070 	ldm	r1!, {r4, r5, r6}
 c224a38:	e92d0070 	push	{r4, r5, r6}
 c224a3c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c224a40:	e52d3004 	push	{r3}		; (str r3, [sp, #-4]!)
 c224a44:	ebffdf3a 	bl	c21c734 <OSIntEnter>
 c224a48:	e59f0030 	ldr	r0, [pc, #48]	; c224a80 <labelisr_pb+0x1c>
 c224a4c:	e5d00000 	ldrb	r0, [r0]
 c224a50:	e3500001 	cmp	r0, #1
 c224a54:	1a000002 	bne	c224a64 <labelisr_pb>
 c224a58:	e59f0024 	ldr	r0, [pc, #36]	; c224a84 <labelisr_pb+0x20>
 c224a5c:	e5901000 	ldr	r1, [r0]
 c224a60:	e581d000 	str	sp, [r1]

0c224a64 <labelisr_pb>:
 c224a64:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
 c224a68:	eb000233 	bl	c22533c <isr_pb>
 c224a6c:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
 c224a70:	ebffdf45 	bl	c21c78c <OSIntExit>
 c224a74:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
 c224a78:	e169f004 	msr	SPSR_fc, r4
 c224a7c:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^
 c224a80:	0c1c84c0 	.word	0x0c1c84c0
 c224a84:	0c1c84c4 	.word	0x0c1c84c4

0c224a88 <kernel_entry>:
void isr_pb( void );                 /* Función invocada por el anterior wrapper que atiende al dispositivo, no debe tener el atributo interrupt */

/*******************************************************************/

void kernel_entry( void )
{
 c224a88:	e1a0c00d 	mov	ip, sp
 c224a8c:	e92dd800 	push	{fp, ip, lr, pc}
 c224a90:	e24cb004 	sub	fp, ip, #4
    leds_init();
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init(); */
	rWTCON = 0;
 c224a94:	e59f3090 	ldr	r3, [pc, #144]	; c224b2c <kernel_entry+0xa4>
 c224a98:	e3a02000 	mov	r2, #0
 c224a9c:	e5832000 	str	r2, [r3]

    uart0_puts( "\n\n Ejecutando uCOS-II (version " );
 c224aa0:	e59f0088 	ldr	r0, [pc, #136]	; c224b30 <kernel_entry+0xa8>
 c224aa4:	eb0016d3 	bl	c22a5f8 <uart0_puts>
    uart0_putint( OSVersion() );
 c224aa8:	ebffe0ba 	bl	c21cd98 <OSVersion>
 c224aac:	e1a03000 	mov	r3, r0
 c224ab0:	e1a00003 	mov	r0, r3
 c224ab4:	eb0016e3 	bl	c22a648 <uart0_putint>
    uart0_puts( ")\n" ) ;
 c224ab8:	e59f0074 	ldr	r0, [pc, #116]	; c224b34 <kernel_entry+0xac>
 c224abc:	eb0016cd 	bl	c22a5f8 <uart0_puts>
    uart0_puts( "----------------------------------\n\n" ) ;
 c224ac0:	e59f0070 	ldr	r0, [pc, #112]	; c224b38 <kernel_entry+0xb0>
 c224ac4:	eb0016cb 	bl	c22a5f8 <uart0_puts>

    OSInit();                                                              /* Inicializa el kernel              */
 c224ac8:	ebffdf07 	bl	c21c6ec <OSInit>
    uart0Sem   = OSSemCreate( 1 );                                         /* Crea recursos                     */
 c224acc:	e3a00001 	mov	r0, #1
 c224ad0:	ebfff771 	bl	c22289c <OSSemCreate>
 c224ad4:	e1a02000 	mov	r2, r0
 c224ad8:	e59f305c 	ldr	r3, [pc, #92]	; c224b3c <kernel_entry+0xb4>
 c224adc:	e5832000 	str	r2, [r3]
    keypadMbox = OSMboxCreate( NULL );
 c224ae0:	e3a00000 	mov	r0, #0
 c224ae4:	ebffeb79 	bl	c21f8d0 <OSMboxCreate>
 c224ae8:	e1a02000 	mov	r2, r0
 c224aec:	e59f304c 	ldr	r3, [pc, #76]	; c224b40 <kernel_entry+0xb8>
 c224af0:	e5832000 	str	r2, [r3]
    flagPb     = OSSemCreate( 0 ); 
 c224af4:	e3a00000 	mov	r0, #0
 c224af8:	ebfff767 	bl	c22289c <OSSemCreate>
 c224afc:	e1a02000 	mov	r2, r0
 c224b00:	e59f303c 	ldr	r3, [pc, #60]	; c224b44 <kernel_entry+0xbc>
 c224b04:	e5832000 	str	r2, [r3]
    
    OSTaskCreate( TaskStart, NULL, &TaskStartStk[TASK_STK_SIZE - 1], 0 );  /* Crea la tarea inicial de arranque */
 c224b08:	e59f0038 	ldr	r0, [pc, #56]	; c224b48 <kernel_entry+0xc0>
 c224b0c:	e3a01000 	mov	r1, #0
 c224b10:	e59f2034 	ldr	r2, [pc, #52]	; c224b4c <kernel_entry+0xc4>
 c224b14:	e3a03000 	mov	r3, #0
 c224b18:	ebfffa5e 	bl	c223498 <OSTaskCreate>
    OSStart();                                                             /* Inicia multitarea                 */
 c224b1c:	ebffdfbc 	bl	c21ca14 <OSStart>
}                              
 c224b20:	e24bd00c 	sub	sp, fp, #12
 c224b24:	e89d6800 	ldm	sp, {fp, sp, lr}
 c224b28:	e12fff1e 	bx	lr
 c224b2c:	01d30000 	.word	0x01d30000
 c224b30:	0c1010f0 	.word	0x0c1010f0
 c224b34:	0c101110 	.word	0x0c101110
 c224b38:	0c101114 	.word	0x0c101114
 c224b3c:	0c1f18b0 	.word	0x0c1f18b0
 c224b40:	0c1e78a8 	.word	0x0c1e78a8
 c224b44:	0c1e78ac 	.word	0x0c1e78ac
 c224b48:	0c224b50 	.word	0x0c224b50
 c224b4c:	0c20f8b0 	.word	0x0c20f8b0

0c224b50 <TaskStart>:

/*******************************************************************/

void TaskStart( void *pdata )
{
 c224b50:	e1a0c00d 	mov	ip, sp
 c224b54:	e92dd800 	push	{fp, ip, lr, pc}
 c224b58:	e24cb004 	sub	fp, ip, #4
 c224b5c:	e24dd010 	sub	sp, sp, #16
 c224b60:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    const char id1 = '1'; /* Identificadores de tareas */
 c224b64:	e3a03031 	mov	r3, #49	; 0x31
 c224b68:	e54b300d 	strb	r3, [fp, #-13]
    const char id2 = '2';
 c224b6c:	e3a03032 	mov	r3, #50	; 0x32
 c224b70:	e54b300e 	strb	r3, [fp, #-14]
    const char id3 = '3';
 c224b74:	e3a03033 	mov	r3, #51	; 0x33
 c224b78:	e54b300f 	strb	r3, [fp, #-15]
    const char id4 = '4';
 c224b7c:	e3a03034 	mov	r3, #52	; 0x34
 c224b80:	e54b3010 	strb	r3, [fp, #-16]
    const char id5 = '5';
 c224b84:	e3a03035 	mov	r3, #53	; 0x35
 c224b88:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    const char id6 = '6';
 c224b8c:	e3a03036 	mov	r3, #54	; 0x36
 c224b90:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
    const char id7 = '7';
 c224b94:	e3a03037 	mov	r3, #55	; 0x37
 c224b98:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
  
    OS_ENTER_CRITICAL();
 c224b9c:	e10f0000 	mrs	r0, CPSR
 c224ba0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c224ba4:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c224ba8:	e121f000 	msr	CPSR_c, r0

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c224bac:	e3a00000 	mov	r0, #0
 c224bb0:	e3a01001 	mov	r1, #1
 c224bb4:	eb0013d9 	bl	c229b20 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c224bb8:	e3a00000 	mov	r0, #0
 c224bbc:	e3a01001 	mov	r1, #1
 c224bc0:	eb0012d5 	bl	c22971c <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c224bc4:	e3a00000 	mov	r0, #0
 c224bc8:	e3a01002 	mov	r1, #2
 c224bcc:	eb001309 	bl	c2297f8 <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c224bd0:	e3a00000 	mov	r0, #0
 c224bd4:	e59f1118 	ldr	r1, [pc, #280]	; c224cf4 <TaskStart+0x1a4>
 c224bd8:	e3a02001 	mov	r2, #1
 c224bdc:	eb001354 	bl	c229934 <tmr_set_count>

	tmr_update(TIMER0);
 c224be0:	e3a00000 	mov	r0, #0
 c224be4:	eb00139f 	bl	c229a68 <tmr_update>

	pISR_TIMER0 =(unsigned)OSTickISR;
 c224be8:	e59f3108 	ldr	r3, [pc, #264]	; c224cf8 <TaskStart+0x1a8>
 c224bec:	e59f2108 	ldr	r2, [pc, #264]	; c224cfc <TaskStart+0x1ac>
 c224bf0:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c224bf4:	e3a00000 	mov	r0, #0
 c224bf8:	eb00140b 	bl	c229c2c <tmr_start>

	ic_cleanflag(INT_TIMER0);
 c224bfc:	e3a0000d 	mov	r0, #13
 c224c00:	eb000a1b 	bl	c227474 <ic_cleanflag>
	ic_enable(INT_TIMER0);
 c224c04:	e3a0000d 	mov	r0, #13
 c224c08:	eb0009e6 	bl	c2273a8 <ic_enable>

    pISR_EINT4567 = (unsigned) OS_CPU_isr_pb;
 c224c0c:	e59f30ec 	ldr	r3, [pc, #236]	; c224d00 <TaskStart+0x1b0>
 c224c10:	e59f20ec 	ldr	r2, [pc, #236]	; c224d04 <TaskStart+0x1b4>
 c224c14:	e5832000 	str	r2, [r3]
    ic_cleanflag(INT_EINT4567);
 c224c18:	e3a00015 	mov	r0, #21
 c224c1c:	eb000a14 	bl	c227474 <ic_cleanflag>
    ic_enable(INT_EINT4567);
 c224c20:	e3a00015 	mov	r0, #21
 c224c24:	eb0009df 	bl	c2273a8 <ic_enable>

    OS_EXIT_CRITICAL();
 c224c28:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c224c2c:	e121f000 	msr	CPSR_c, r0

    //OSStatInit();                     /* Opcionalmente, arranca la tarea del kernel de recopilación de estadísticas de uso de CPU  */

    OSTaskCreate( Task1, (void *)&id1, &Task1Stk[TASK_STK_SIZE - 1], 6 );      /* Crea las tareas de la aplicación */
 c224c30:	e24b300d 	sub	r3, fp, #13
 c224c34:	e59f00cc 	ldr	r0, [pc, #204]	; c224d08 <TaskStart+0x1b8>
 c224c38:	e1a01003 	mov	r1, r3
 c224c3c:	e59f20c8 	ldr	r2, [pc, #200]	; c224d0c <TaskStart+0x1bc>
 c224c40:	e3a03006 	mov	r3, #6
 c224c44:	ebfffa13 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task2, (void *)&id2, &Task2Stk[TASK_STK_SIZE - 1], 1 );      /* Las tareas más frecuentes tienen mayor prioridad (criterio Rate-Monotonic-Scheduling) */
 c224c48:	e24b300e 	sub	r3, fp, #14
 c224c4c:	e59f00bc 	ldr	r0, [pc, #188]	; c224d10 <TaskStart+0x1c0>
 c224c50:	e1a01003 	mov	r1, r3
 c224c54:	e59f20b8 	ldr	r2, [pc, #184]	; c224d14 <TaskStart+0x1c4>
 c224c58:	e3a03001 	mov	r3, #1
 c224c5c:	ebfffa0d 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task3, (void *)&id3, &Task3Stk[TASK_STK_SIZE - 1], 7 );
 c224c60:	e24b300f 	sub	r3, fp, #15
 c224c64:	e59f00ac 	ldr	r0, [pc, #172]	; c224d18 <TaskStart+0x1c8>
 c224c68:	e1a01003 	mov	r1, r3
 c224c6c:	e59f20a8 	ldr	r2, [pc, #168]	; c224d1c <TaskStart+0x1cc>
 c224c70:	e3a03007 	mov	r3, #7
 c224c74:	ebfffa07 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task4, (void *)&id4, &Task4Stk[TASK_STK_SIZE - 1], 9 );
 c224c78:	e24b3010 	sub	r3, fp, #16
 c224c7c:	e59f009c 	ldr	r0, [pc, #156]	; c224d20 <TaskStart+0x1d0>
 c224c80:	e1a01003 	mov	r1, r3
 c224c84:	e59f2098 	ldr	r2, [pc, #152]	; c224d24 <TaskStart+0x1d4>
 c224c88:	e3a03009 	mov	r3, #9
 c224c8c:	ebfffa01 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task5, (void *)&id5, &Task5Stk[TASK_STK_SIZE - 1], 3 );
 c224c90:	e24b3011 	sub	r3, fp, #17
 c224c94:	e59f008c 	ldr	r0, [pc, #140]	; c224d28 <TaskStart+0x1d8>
 c224c98:	e1a01003 	mov	r1, r3
 c224c9c:	e59f2088 	ldr	r2, [pc, #136]	; c224d2c <TaskStart+0x1dc>
 c224ca0:	e3a03003 	mov	r3, #3
 c224ca4:	ebfff9fb 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task6, (void *)&id6, &Task6Stk[TASK_STK_SIZE - 1], 4 );
 c224ca8:	e24b3012 	sub	r3, fp, #18
 c224cac:	e59f007c 	ldr	r0, [pc, #124]	; c224d30 <TaskStart+0x1e0>
 c224cb0:	e1a01003 	mov	r1, r3
 c224cb4:	e59f2078 	ldr	r2, [pc, #120]	; c224d34 <TaskStart+0x1e4>
 c224cb8:	e3a03004 	mov	r3, #4
 c224cbc:	ebfff9f5 	bl	c223498 <OSTaskCreate>
    OSTaskCreate( Task7, (void *)&id7, &Task7Stk[TASK_STK_SIZE - 1], 2 );
 c224cc0:	e24b3013 	sub	r3, fp, #19
 c224cc4:	e59f006c 	ldr	r0, [pc, #108]	; c224d38 <TaskStart+0x1e8>
 c224cc8:	e1a01003 	mov	r1, r3
 c224ccc:	e59f2068 	ldr	r2, [pc, #104]	; c224d3c <TaskStart+0x1ec>
 c224cd0:	e3a03002 	mov	r3, #2
 c224cd4:	ebfff9ef 	bl	c223498 <OSTaskCreate>

    Delay(1000);
 c224cd8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
 c224cdc:	eb001824 	bl	c22ad74 <Delay>

    OSTaskDel(OS_PRIO_SELF);             /* La tarea inicial de arranque se auto-elimina */
 c224ce0:	e3a000ff 	mov	r0, #255	; 0xff
 c224ce4:	ebfffa9e 	bl	c223764 <OSTaskDel>
}
 c224ce8:	e24bd00c 	sub	sp, fp, #12
 c224cec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c224cf0:	e12fff1e 	bx	lr
 c224cf4:	00009c40 	.word	0x00009c40
 c224cf8:	0c7fff54 	.word	0x0c7fff54
 c224cfc:	0c21c1bc 	.word	0x0c21c1bc
 c224d00:	0c7fff74 	.word	0x0c7fff74
 c224d04:	0c224a10 	.word	0x0c224a10
 c224d08:	0c224d40 	.word	0x0c224d40
 c224d0c:	0c2058b0 	.word	0x0c2058b0
 c224d10:	0c224dc8 	.word	0x0c224dc8
 c224d14:	0c1f18ac 	.word	0x0c1f18ac
 c224d18:	0c224ea4 	.word	0x0c224ea4
 c224d1c:	0c1d38a4 	.word	0x0c1d38a4
 c224d20:	0c224fbc 	.word	0x0c224fbc
 c224d24:	0c1e78a4 	.word	0x0c1e78a4
 c224d28:	0c2250a8 	.word	0x0c2250a8
 c224d2c:	0c2198b0 	.word	0x0c2198b0
 c224d30:	0c2251b0 	.word	0x0c2251b0
 c224d34:	0c1fb8b0 	.word	0x0c1fb8b0
 c224d38:	0c225258 	.word	0x0c225258
 c224d3c:	0c1dd8a4 	.word	0x0c1dd8a4

0c224d40 <Task1>:

void Task1( void *id )
{
 c224d40:	e1a0c00d 	mov	ip, sp
 c224d44:	e92dd800 	push	{fp, ip, lr, pc}
 c224d48:	e24cb004 	sub	fp, ip, #4
 c224d4c:	e24dd010 	sub	sp, sp, #16
 c224d50:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c224d54:	e59f3060 	ldr	r3, [pc, #96]	; c224dbc <Task1+0x7c>
 c224d58:	e5932000 	ldr	r2, [r3]
 c224d5c:	e24b300d 	sub	r3, fp, #13
 c224d60:	e1a00002 	mov	r0, r2
 c224d64:	e3a01000 	mov	r1, #0
 c224d68:	e1a02003 	mov	r2, r3
 c224d6c:	ebfff791 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c224d70:	e59f0048 	ldr	r0, [pc, #72]	; c224dc0 <Task1+0x80>
 c224d74:	eb00161f 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c224d78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224d7c:	e5d33000 	ldrb	r3, [r3]
 c224d80:	e1a00003 	mov	r0, r3
 c224d84:	eb0015f5 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c224d88:	e59f0034 	ldr	r0, [pc, #52]	; c224dc4 <Task1+0x84>
 c224d8c:	eb001619 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c224d90:	e59f3024 	ldr	r3, [pc, #36]	; c224dbc <Task1+0x7c>
 c224d94:	e5933000 	ldr	r3, [r3]
 c224d98:	e1a00003 	mov	r0, r3
 c224d9c:	ebfff7ed 	bl	c222d58 <OSSemPost>
    
    led1_on();
 c224da0:	eb000ce1 	bl	c22812c <led1_on>
    led2_off();
 c224da4:	eb000d10 	bl	c2281ec <led2_off>

    while( 1 )                         /* Cada 0,5 segundos (50 ticks) alterna el led que se enciende */
    {
        OSTimeDly( 50 );
 c224da8:	e3a00032 	mov	r0, #50	; 0x32
 c224dac:	ebfffde3 	bl	c224540 <OSTimeDly>
        led1_switch();
 c224db0:	eb000d1d 	bl	c22822c <led1_switch>
        led2_switch();
 c224db4:	eb000d2c 	bl	c22826c <led2_switch>
    }
 c224db8:	eafffffa 	b	c224da8 <Task1+0x68>
 c224dbc:	0c1f18b0 	.word	0x0c1f18b0
 c224dc0:	0c10113c 	.word	0x0c10113c
 c224dc4:	0c101144 	.word	0x0c101144

0c224dc8 <Task2>:
}

void Task2( void *id)
{
 c224dc8:	e1a0c00d 	mov	ip, sp
 c224dcc:	e92dd800 	push	{fp, ip, lr, pc}
 c224dd0:	e24cb004 	sub	fp, ip, #4
 c224dd4:	e24dd010 	sub	sp, sp, #16
 c224dd8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;
    uint8 scancode;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c224ddc:	e59f30b0 	ldr	r3, [pc, #176]	; c224e94 <Task2+0xcc>
 c224de0:	e5932000 	ldr	r2, [r3]
 c224de4:	e24b300d 	sub	r3, fp, #13
 c224de8:	e1a00002 	mov	r0, r2
 c224dec:	e3a01000 	mov	r1, #0
 c224df0:	e1a02003 	mov	r2, r3
 c224df4:	ebfff76f 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c224df8:	e59f0098 	ldr	r0, [pc, #152]	; c224e98 <Task2+0xd0>
 c224dfc:	eb0015fd 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c224e00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224e04:	e5d33000 	ldrb	r3, [r3]
 c224e08:	e1a00003 	mov	r0, r3
 c224e0c:	eb0015d3 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c224e10:	e59f0084 	ldr	r0, [pc, #132]	; c224e9c <Task2+0xd4>
 c224e14:	eb0015f7 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c224e18:	e59f3074 	ldr	r3, [pc, #116]	; c224e94 <Task2+0xcc>
 c224e1c:	e5933000 	ldr	r3, [r3]
 c224e20:	e1a00003 	mov	r0, r3
 c224e24:	ebfff7cb 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada 50 ms (5 ticks) muestrea el keypad y envía el scancode a otras tareas */
    {      
        while( kb_scan() < 0 )
 c224e28:	ea000001 	b	c224e34 <Task2+0x6c>
            OSTimeDly( 5 );
 c224e2c:	e3a00005 	mov	r0, #5
 c224e30:	ebfffdc2 	bl	c224540 <OSTimeDly>
        uart0_puts( " iniciada.\n" );
    OSSemPost( uart0Sem );

    while( 1 )                         /* Cada 50 ms (5 ticks) muestrea el keypad y envía el scancode a otras tareas */
    {      
        while( kb_scan() < 0 )
 c224e34:	eb0009b8 	bl	c22751c <kb_scan>
 c224e38:	e1a03000 	mov	r3, r0
 c224e3c:	e3530000 	cmp	r3, #0
 c224e40:	bafffff9 	blt	c224e2c <Task2+0x64>
            OSTimeDly( 5 );
        scancode = kb_scan();
 c224e44:	eb0009b4 	bl	c22751c <kb_scan>
 c224e48:	e1a03000 	mov	r3, r0
 c224e4c:	e20330ff 	and	r3, r3, #255	; 0xff
 c224e50:	e54b300e 	strb	r3, [fp, #-14]
        if( scancode >= 0 )
            OSMboxPostOpt( keypadMbox, (void *) &scancode, OS_POST_OPT_BROADCAST );
 c224e54:	e59f3044 	ldr	r3, [pc, #68]	; c224ea0 <Task2+0xd8>
 c224e58:	e5932000 	ldr	r2, [r3]
 c224e5c:	e24b300e 	sub	r3, fp, #14
 c224e60:	e1a00002 	mov	r0, r2
 c224e64:	e1a01003 	mov	r1, r3
 c224e68:	e3a02001 	mov	r2, #1
 c224e6c:	ebffec0f 	bl	c21feb0 <OSMboxPostOpt>
        while( kb_scan() >= 0 )
 c224e70:	ea000001 	b	c224e7c <Task2+0xb4>
            OSTimeDly( 5 );
 c224e74:	e3a00005 	mov	r0, #5
 c224e78:	ebfffdb0 	bl	c224540 <OSTimeDly>
        while( kb_scan() < 0 )
            OSTimeDly( 5 );
        scancode = kb_scan();
        if( scancode >= 0 )
            OSMboxPostOpt( keypadMbox, (void *) &scancode, OS_POST_OPT_BROADCAST );
        while( kb_scan() >= 0 )
 c224e7c:	eb0009a6 	bl	c22751c <kb_scan>
 c224e80:	e1a03000 	mov	r3, r0
 c224e84:	e3530000 	cmp	r3, #0
 c224e88:	aafffff9 	bge	c224e74 <Task2+0xac>
            OSTimeDly( 5 );
    }
 c224e8c:	e1a00000 	nop			; (mov r0, r0)
        uart0_puts( " iniciada.\n" );
    OSSemPost( uart0Sem );

    while( 1 )                         /* Cada 50 ms (5 ticks) muestrea el keypad y envía el scancode a otras tareas */
    {      
        while( kb_scan() < 0 )
 c224e90:	eaffffe7 	b	c224e34 <Task2+0x6c>
 c224e94:	0c1f18b0 	.word	0x0c1f18b0
 c224e98:	0c10113c 	.word	0x0c10113c
 c224e9c:	0c101144 	.word	0x0c101144
 c224ea0:	0c1e78a8 	.word	0x0c1e78a8

0c224ea4 <Task3>:
            OSTimeDly( 5 );
    }
}

void Task3( void *id )
{
 c224ea4:	e1a0c00d 	mov	ip, sp
 c224ea8:	e92dd800 	push	{fp, ip, lr, pc}
 c224eac:	e24cb004 	sub	fp, ip, #4
 c224eb0:	e24dd010 	sub	sp, sp, #16
 c224eb4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;
    rtc_time_t rtc_time;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c224eb8:	e59f30e4 	ldr	r3, [pc, #228]	; c224fa4 <Task3+0x100>
 c224ebc:	e5932000 	ldr	r2, [r3]
 c224ec0:	e24b300d 	sub	r3, fp, #13
 c224ec4:	e1a00002 	mov	r0, r2
 c224ec8:	e3a01000 	mov	r1, #0
 c224ecc:	e1a02003 	mov	r2, r3
 c224ed0:	ebfff738 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c224ed4:	e59f00cc 	ldr	r0, [pc, #204]	; c224fa8 <Task3+0x104>
 c224ed8:	eb0015c6 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c224edc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224ee0:	e5d33000 	ldrb	r3, [r3]
 c224ee4:	e1a00003 	mov	r0, r3
 c224ee8:	eb00159c 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c224eec:	e59f00b8 	ldr	r0, [pc, #184]	; c224fac <Task3+0x108>
 c224ef0:	eb0015c0 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c224ef4:	e59f30a8 	ldr	r3, [pc, #168]	; c224fa4 <Task3+0x100>
 c224ef8:	e5933000 	ldr	r3, [r3]
 c224efc:	e1a00003 	mov	r0, r3
 c224f00:	ebfff794 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada segundo (100 ticks) muestra por la UART0 la hora del RTC */
    {
        OSTimeDly( 100 );
 c224f04:	e3a00064 	mov	r0, #100	; 0x64
 c224f08:	ebfffd8c 	bl	c224540 <OSTimeDly>
        rtc_gettime( &rtc_time );
 c224f0c:	e24b3014 	sub	r3, fp, #20
 c224f10:	e1a00003 	mov	r0, r3
 c224f14:	eb000fc1 	bl	c228e20 <rtc_gettime>
        OSSemPend( uart0Sem, 0, &err );
 c224f18:	e59f3084 	ldr	r3, [pc, #132]	; c224fa4 <Task3+0x100>
 c224f1c:	e5932000 	ldr	r2, [r3]
 c224f20:	e24b300d 	sub	r3, fp, #13
 c224f24:	e1a00002 	mov	r0, r2
 c224f28:	e3a01000 	mov	r1, #0
 c224f2c:	e1a02003 	mov	r2, r3
 c224f30:	ebfff720 	bl	c222bb8 <OSSemPend>
            uart0_puts( "  (Task" );
 c224f34:	e59f0074 	ldr	r0, [pc, #116]	; c224fb0 <Task3+0x10c>
 c224f38:	eb0015ae 	bl	c22a5f8 <uart0_puts>
            uart0_putchar( *(char *)id );
 c224f3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224f40:	e5d33000 	ldrb	r3, [r3]
 c224f44:	e1a00003 	mov	r0, r3
 c224f48:	eb001584 	bl	c22a560 <uart0_putchar>
            uart0_puts( ") Hora: " );
 c224f4c:	e59f0060 	ldr	r0, [pc, #96]	; c224fb4 <Task3+0x110>
 c224f50:	eb0015a8 	bl	c22a5f8 <uart0_puts>
            uart0_putint( rtc_time.hour );
 c224f54:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c224f58:	e1a00003 	mov	r0, r3
 c224f5c:	eb0015b9 	bl	c22a648 <uart0_putint>
            uart0_putchar( ':' );
 c224f60:	e3a0003a 	mov	r0, #58	; 0x3a
 c224f64:	eb00157d 	bl	c22a560 <uart0_putchar>
            uart0_putint( rtc_time.min );
 c224f68:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
 c224f6c:	e1a00003 	mov	r0, r3
 c224f70:	eb0015b4 	bl	c22a648 <uart0_putint>
            uart0_putchar( ':' );
 c224f74:	e3a0003a 	mov	r0, #58	; 0x3a
 c224f78:	eb001578 	bl	c22a560 <uart0_putchar>
            uart0_putint( rtc_time.sec );
 c224f7c:	e55b3014 	ldrb	r3, [fp, #-20]	; 0xffffffec
 c224f80:	e1a00003 	mov	r0, r3
 c224f84:	eb0015af 	bl	c22a648 <uart0_putint>
            uart0_puts( "\n" );
 c224f88:	e59f0028 	ldr	r0, [pc, #40]	; c224fb8 <Task3+0x114>
 c224f8c:	eb001599 	bl	c22a5f8 <uart0_puts>
        OSSemPost( uart0Sem );
 c224f90:	e59f300c 	ldr	r3, [pc, #12]	; c224fa4 <Task3+0x100>
 c224f94:	e5933000 	ldr	r3, [r3]
 c224f98:	e1a00003 	mov	r0, r3
 c224f9c:	ebfff76d 	bl	c222d58 <OSSemPost>
    }
 c224fa0:	eaffffd7 	b	c224f04 <Task3+0x60>
 c224fa4:	0c1f18b0 	.word	0x0c1f18b0
 c224fa8:	0c10113c 	.word	0x0c10113c
 c224fac:	0c101144 	.word	0x0c101144
 c224fb0:	0c101150 	.word	0x0c101150
 c224fb4:	0c101158 	.word	0x0c101158
 c224fb8:	0c101164 	.word	0x0c101164

0c224fbc <Task4>:
}

void Task4( void *id )
{
 c224fbc:	e1a0c00d 	mov	ip, sp
 c224fc0:	e92dd800 	push	{fp, ip, lr, pc}
 c224fc4:	e24cb004 	sub	fp, ip, #4
 c224fc8:	e24dd010 	sub	sp, sp, #16
 c224fcc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;
    INT32U ticks;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c224fd0:	e59f30b8 	ldr	r3, [pc, #184]	; c225090 <Task4+0xd4>
 c224fd4:	e5932000 	ldr	r2, [r3]
 c224fd8:	e24b3011 	sub	r3, fp, #17
 c224fdc:	e1a00002 	mov	r0, r2
 c224fe0:	e3a01000 	mov	r1, #0
 c224fe4:	e1a02003 	mov	r2, r3
 c224fe8:	ebfff6f2 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c224fec:	e59f00a0 	ldr	r0, [pc, #160]	; c225094 <Task4+0xd8>
 c224ff0:	eb001580 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c224ff4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c224ff8:	e5d33000 	ldrb	r3, [r3]
 c224ffc:	e1a00003 	mov	r0, r3
 c225000:	eb001556 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c225004:	e59f008c 	ldr	r0, [pc, #140]	; c225098 <Task4+0xdc>
 c225008:	eb00157a 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c22500c:	e59f307c 	ldr	r3, [pc, #124]	; c225090 <Task4+0xd4>
 c225010:	e5933000 	ldr	r3, [r3]
 c225014:	e1a00003 	mov	r0, r3
 c225018:	ebfff74e 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada 10 segundos (1000 ticks) muestra por la UART0 los ticks transcurridos */
    {
        OSTimeDly( 1000 );
 c22501c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
 c225020:	ebfffd46 	bl	c224540 <OSTimeDly>
        ticks = OSTimeGet();
 c225024:	ebfffe54 	bl	c22497c <OSTimeGet>
 c225028:	e50b0010 	str	r0, [fp, #-16]
        OSSemPend( uart0Sem, 0, &err );
 c22502c:	e59f305c 	ldr	r3, [pc, #92]	; c225090 <Task4+0xd4>
 c225030:	e5932000 	ldr	r2, [r3]
 c225034:	e24b3011 	sub	r3, fp, #17
 c225038:	e1a00002 	mov	r0, r2
 c22503c:	e3a01000 	mov	r1, #0
 c225040:	e1a02003 	mov	r2, r3
 c225044:	ebfff6db 	bl	c222bb8 <OSSemPend>
            uart0_puts( "  (Task" );
 c225048:	e59f004c 	ldr	r0, [pc, #76]	; c22509c <Task4+0xe0>
 c22504c:	eb001569 	bl	c22a5f8 <uart0_puts>
            uart0_putchar( *(char *)id );
 c225050:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225054:	e5d33000 	ldrb	r3, [r3]
 c225058:	e1a00003 	mov	r0, r3
 c22505c:	eb00153f 	bl	c22a560 <uart0_putchar>
            uart0_puts( ") Ticks: " );
 c225060:	e59f0038 	ldr	r0, [pc, #56]	; c2250a0 <Task4+0xe4>
 c225064:	eb001563 	bl	c22a5f8 <uart0_puts>
            uart0_putint( ticks );
 c225068:	e51b3010 	ldr	r3, [fp, #-16]
 c22506c:	e1a00003 	mov	r0, r3
 c225070:	eb001574 	bl	c22a648 <uart0_putint>
            uart0_puts( "\n" );
 c225074:	e59f0028 	ldr	r0, [pc, #40]	; c2250a4 <Task4+0xe8>
 c225078:	eb00155e 	bl	c22a5f8 <uart0_puts>
        OSSemPost( uart0Sem );
 c22507c:	e59f300c 	ldr	r3, [pc, #12]	; c225090 <Task4+0xd4>
 c225080:	e5933000 	ldr	r3, [r3]
 c225084:	e1a00003 	mov	r0, r3
 c225088:	ebfff732 	bl	c222d58 <OSSemPost>
    }
 c22508c:	eaffffe2 	b	c22501c <Task4+0x60>
 c225090:	0c1f18b0 	.word	0x0c1f18b0
 c225094:	0c10113c 	.word	0x0c10113c
 c225098:	0c101144 	.word	0x0c101144
 c22509c:	0c101150 	.word	0x0c101150
 c2250a0:	0c101168 	.word	0x0c101168
 c2250a4:	0c101164 	.word	0x0c101164

0c2250a8 <Task5>:
}

void Task5( void *id )
{
 c2250a8:	e1a0c00d 	mov	ip, sp
 c2250ac:	e92dd800 	push	{fp, ip, lr, pc}
 c2250b0:	e24cb004 	sub	fp, ip, #4
 c2250b4:	e24dd010 	sub	sp, sp, #16
 c2250b8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;
    uint8 scancode;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c2250bc:	e59f30d0 	ldr	r3, [pc, #208]	; c225194 <Task5+0xec>
 c2250c0:	e5932000 	ldr	r2, [r3]
 c2250c4:	e24b300e 	sub	r3, fp, #14
 c2250c8:	e1a00002 	mov	r0, r2
 c2250cc:	e3a01000 	mov	r1, #0
 c2250d0:	e1a02003 	mov	r2, r3
 c2250d4:	ebfff6b7 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c2250d8:	e59f00b8 	ldr	r0, [pc, #184]	; c225198 <Task5+0xf0>
 c2250dc:	eb001545 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c2250e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2250e4:	e5d33000 	ldrb	r3, [r3]
 c2250e8:	e1a00003 	mov	r0, r3
 c2250ec:	eb00151b 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c2250f0:	e59f00a4 	ldr	r0, [pc, #164]	; c22519c <Task5+0xf4>
 c2250f4:	eb00153f 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c2250f8:	e59f3094 	ldr	r3, [pc, #148]	; c225194 <Task5+0xec>
 c2250fc:	e5933000 	ldr	r3, [r3]
 c225100:	e1a00003 	mov	r0, r3
 c225104:	ebfff713 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada vez que reciba un scancode lo muestra por la UART0 */
    {
        scancode = *((uint8 *) OSMboxPend( keypadMbox, 0, &err ));
 c225108:	e59f3090 	ldr	r3, [pc, #144]	; c2251a0 <Task5+0xf8>
 c22510c:	e5932000 	ldr	r2, [r3]
 c225110:	e24b300e 	sub	r3, fp, #14
 c225114:	e1a00002 	mov	r0, r2
 c225118:	e3a01000 	mov	r1, #0
 c22511c:	e1a02003 	mov	r2, r3
 c225120:	ebffeab0 	bl	c21fbe8 <OSMboxPend>
 c225124:	e1a03000 	mov	r3, r0
 c225128:	e5d33000 	ldrb	r3, [r3]
 c22512c:	e54b300d 	strb	r3, [fp, #-13]
        OSSemPend( uart0Sem, 0, &err );
 c225130:	e59f305c 	ldr	r3, [pc, #92]	; c225194 <Task5+0xec>
 c225134:	e5932000 	ldr	r2, [r3]
 c225138:	e24b300e 	sub	r3, fp, #14
 c22513c:	e1a00002 	mov	r0, r2
 c225140:	e3a01000 	mov	r1, #0
 c225144:	e1a02003 	mov	r2, r3
 c225148:	ebfff69a 	bl	c222bb8 <OSSemPend>
            uart0_puts( "  (Task" );
 c22514c:	e59f0050 	ldr	r0, [pc, #80]	; c2251a4 <Task5+0xfc>
 c225150:	eb001528 	bl	c22a5f8 <uart0_puts>
            uart0_putchar( *(char *)id );
 c225154:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225158:	e5d33000 	ldrb	r3, [r3]
 c22515c:	e1a00003 	mov	r0, r3
 c225160:	eb0014fe 	bl	c22a560 <uart0_putchar>
            uart0_puts( ") Tecla pulsada: " );
 c225164:	e59f003c 	ldr	r0, [pc, #60]	; c2251a8 <Task5+0x100>
 c225168:	eb001522 	bl	c22a5f8 <uart0_puts>
            uart0_puthex( scancode );
 c22516c:	e55b300d 	ldrb	r3, [fp, #-13]
 c225170:	e1a00003 	mov	r0, r3
 c225174:	eb001573 	bl	c22a748 <uart0_puthex>
            uart0_puts( "\n" );
 c225178:	e59f002c 	ldr	r0, [pc, #44]	; c2251ac <Task5+0x104>
 c22517c:	eb00151d 	bl	c22a5f8 <uart0_puts>
        OSSemPost( uart0Sem );
 c225180:	e59f300c 	ldr	r3, [pc, #12]	; c225194 <Task5+0xec>
 c225184:	e5933000 	ldr	r3, [r3]
 c225188:	e1a00003 	mov	r0, r3
 c22518c:	ebfff6f1 	bl	c222d58 <OSSemPost>
    }
 c225190:	eaffffdc 	b	c225108 <Task5+0x60>
 c225194:	0c1f18b0 	.word	0x0c1f18b0
 c225198:	0c10113c 	.word	0x0c10113c
 c22519c:	0c101144 	.word	0x0c101144
 c2251a0:	0c1e78a8 	.word	0x0c1e78a8
 c2251a4:	0c101150 	.word	0x0c101150
 c2251a8:	0c101174 	.word	0x0c101174
 c2251ac:	0c101164 	.word	0x0c101164

0c2251b0 <Task6>:
}

void Task6( void *id )
{
 c2251b0:	e1a0c00d 	mov	ip, sp
 c2251b4:	e92dd800 	push	{fp, ip, lr, pc}
 c2251b8:	e24cb004 	sub	fp, ip, #4
 c2251bc:	e24dd010 	sub	sp, sp, #16
 c2251c0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;
    uint8 scancode;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c2251c4:	e59f307c 	ldr	r3, [pc, #124]	; c225248 <Task6+0x98>
 c2251c8:	e5932000 	ldr	r2, [r3]
 c2251cc:	e24b300e 	sub	r3, fp, #14
 c2251d0:	e1a00002 	mov	r0, r2
 c2251d4:	e3a01000 	mov	r1, #0
 c2251d8:	e1a02003 	mov	r2, r3
 c2251dc:	ebfff675 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c2251e0:	e59f0064 	ldr	r0, [pc, #100]	; c22524c <Task6+0x9c>
 c2251e4:	eb001503 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c2251e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2251ec:	e5d33000 	ldrb	r3, [r3]
 c2251f0:	e1a00003 	mov	r0, r3
 c2251f4:	eb0014d9 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c2251f8:	e59f0050 	ldr	r0, [pc, #80]	; c225250 <Task6+0xa0>
 c2251fc:	eb0014fd 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c225200:	e59f3040 	ldr	r3, [pc, #64]	; c225248 <Task6+0x98>
 c225204:	e5933000 	ldr	r3, [r3]
 c225208:	e1a00003 	mov	r0, r3
 c22520c:	ebfff6d1 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada vez que reciba un scancode lo muestra por los 7 segmentos */
    {
        scancode = *((uint8 *) OSMboxPend( keypadMbox, 0, &err ));
 c225210:	e59f303c 	ldr	r3, [pc, #60]	; c225254 <Task6+0xa4>
 c225214:	e5932000 	ldr	r2, [r3]
 c225218:	e24b300e 	sub	r3, fp, #14
 c22521c:	e1a00002 	mov	r0, r2
 c225220:	e3a01000 	mov	r1, #0
 c225224:	e1a02003 	mov	r2, r3
 c225228:	ebffea6e 	bl	c21fbe8 <OSMboxPend>
 c22522c:	e1a03000 	mov	r3, r0
 c225230:	e5d33000 	ldrb	r3, [r3]
 c225234:	e54b300d 	strb	r3, [fp, #-13]
        D8Led_digit(scancode);
 c225238:	e55b300d 	ldrb	r3, [fp, #-13]
 c22523c:	e1a00003 	mov	r0, r3
 c225240:	eb000077 	bl	c225424 <D8Led_digit>
    }
 c225244:	eafffff1 	b	c225210 <Task6+0x60>
 c225248:	0c1f18b0 	.word	0x0c1f18b0
 c22524c:	0c10113c 	.word	0x0c10113c
 c225250:	0c101144 	.word	0x0c101144
 c225254:	0c1e78a8 	.word	0x0c1e78a8

0c225258 <Task7>:
}

void Task7( void *id )
{
 c225258:	e1a0c00d 	mov	ip, sp
 c22525c:	e92dd800 	push	{fp, ip, lr, pc}
 c225260:	e24cb004 	sub	fp, ip, #4
 c225264:	e24dd010 	sub	sp, sp, #16
 c225268:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    INT8U err;

    OSSemPend( uart0Sem, 0, &err );    /* Muestra un mensaje inicial en la UART0 (protegida por un semáforo) */
 c22526c:	e59f30b0 	ldr	r3, [pc, #176]	; c225324 <Task7+0xcc>
 c225270:	e5932000 	ldr	r2, [r3]
 c225274:	e24b300d 	sub	r3, fp, #13
 c225278:	e1a00002 	mov	r0, r2
 c22527c:	e3a01000 	mov	r1, #0
 c225280:	e1a02003 	mov	r2, r3
 c225284:	ebfff64b 	bl	c222bb8 <OSSemPend>
        uart0_puts( "  Task" );
 c225288:	e59f0098 	ldr	r0, [pc, #152]	; c225328 <Task7+0xd0>
 c22528c:	eb0014d9 	bl	c22a5f8 <uart0_puts>
        uart0_putchar( *(char *)id );
 c225290:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225294:	e5d33000 	ldrb	r3, [r3]
 c225298:	e1a00003 	mov	r0, r3
 c22529c:	eb0014af 	bl	c22a560 <uart0_putchar>
        uart0_puts( " iniciada.\n" );
 c2252a0:	e59f0084 	ldr	r0, [pc, #132]	; c22532c <Task7+0xd4>
 c2252a4:	eb0014d3 	bl	c22a5f8 <uart0_puts>
    OSSemPost( uart0Sem );
 c2252a8:	e59f3074 	ldr	r3, [pc, #116]	; c225324 <Task7+0xcc>
 c2252ac:	e5933000 	ldr	r3, [r3]
 c2252b0:	e1a00003 	mov	r0, r3
 c2252b4:	ebfff6a7 	bl	c222d58 <OSSemPost>

    while( 1 )                         /* Cada vez que se presione un pulsador lo avisa por la UART0 */
    {
        OSSemPend( flagPb, 0, &err );
 c2252b8:	e59f3070 	ldr	r3, [pc, #112]	; c225330 <Task7+0xd8>
 c2252bc:	e5932000 	ldr	r2, [r3]
 c2252c0:	e24b300d 	sub	r3, fp, #13
 c2252c4:	e1a00002 	mov	r0, r2
 c2252c8:	e3a01000 	mov	r1, #0
 c2252cc:	e1a02003 	mov	r2, r3
 c2252d0:	ebfff638 	bl	c222bb8 <OSSemPend>
        OSSemPend( uart0Sem, 0, &err );
 c2252d4:	e59f3048 	ldr	r3, [pc, #72]	; c225324 <Task7+0xcc>
 c2252d8:	e5932000 	ldr	r2, [r3]
 c2252dc:	e24b300d 	sub	r3, fp, #13
 c2252e0:	e1a00002 	mov	r0, r2
 c2252e4:	e3a01000 	mov	r1, #0
 c2252e8:	e1a02003 	mov	r2, r3
 c2252ec:	ebfff631 	bl	c222bb8 <OSSemPend>
            uart0_puts( "  (Task" );
 c2252f0:	e59f003c 	ldr	r0, [pc, #60]	; c225334 <Task7+0xdc>
 c2252f4:	eb0014bf 	bl	c22a5f8 <uart0_puts>
            uart0_putchar( *(char *)id );
 c2252f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2252fc:	e5d33000 	ldrb	r3, [r3]
 c225300:	e1a00003 	mov	r0, r3
 c225304:	eb001495 	bl	c22a560 <uart0_putchar>
            uart0_puts( ") Se ha pulsado algún pushbutton...\n" );
 c225308:	e59f0028 	ldr	r0, [pc, #40]	; c225338 <Task7+0xe0>
 c22530c:	eb0014b9 	bl	c22a5f8 <uart0_puts>
        OSSemPost( uart0Sem );
 c225310:	e59f300c 	ldr	r3, [pc, #12]	; c225324 <Task7+0xcc>
 c225314:	e5933000 	ldr	r3, [r3]
 c225318:	e1a00003 	mov	r0, r3
 c22531c:	ebfff68d 	bl	c222d58 <OSSemPost>
    }
 c225320:	eaffffe4 	b	c2252b8 <Task7+0x60>
 c225324:	0c1f18b0 	.word	0x0c1f18b0
 c225328:	0c10113c 	.word	0x0c10113c
 c22532c:	0c101144 	.word	0x0c101144
 c225330:	0c1e78ac 	.word	0x0c1e78ac
 c225334:	0c101150 	.word	0x0c101150
 c225338:	0c101188 	.word	0x0c101188

0c22533c <isr_pb>:
}

/*******************************************************************/

void isr_pb( void )
{
 c22533c:	e1a0c00d 	mov	ip, sp
 c225340:	e92dd800 	push	{fp, ip, lr, pc}
 c225344:	e24cb004 	sub	fp, ip, #4
    OSSemPost( flagPb );
 c225348:	e59f3028 	ldr	r3, [pc, #40]	; c225378 <isr_pb+0x3c>
 c22534c:	e5933000 	ldr	r3, [r3]
 c225350:	e1a00003 	mov	r0, r3
 c225354:	ebfff67f 	bl	c222d58 <OSSemPost>
    rEXTINTPND = (1 << 2) | (1 << 3);
 c225358:	e59f301c 	ldr	r3, [pc, #28]	; c22537c <isr_pb+0x40>
 c22535c:	e3a0200c 	mov	r2, #12
 c225360:	e5832000 	str	r2, [r3]
	ic_cleanflag(INT_EINT4567);
 c225364:	e3a00015 	mov	r0, #21
 c225368:	eb000841 	bl	c227474 <ic_cleanflag>
}
 c22536c:	e24bd00c 	sub	sp, fp, #12
 c225370:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225374:	e12fff1e 	bx	lr
 c225378:	0c1e78ac 	.word	0x0c1e78ac
 c22537c:	01d20054 	.word	0x01d20054

0c225380 <D8Led_init>:
	 							 DIGIT_4, DIGIT_5, DIGIT_6, DIGIT_7, 
								 DIGIT_8, DIGIT_9, DIGIT_A, DIGIT_B,
								 DIGIT_C, DIGIT_D, DIGIT_E, DIGIT_F };
			  					  
void D8Led_init(void)
{
 c225380:	e1a0c00d 	mov	ip, sp
 c225384:	e92dd800 	push	{fp, ip, lr, pc}
 c225388:	e24cb004 	sub	fp, ip, #4
    LED8ADDR = ~0;
 c22538c:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c225390:	e3e02000 	mvn	r2, #0
 c225394:	e5c32000 	strb	r2, [r3]
}
 c225398:	e24bd00c 	sub	sp, fp, #12
 c22539c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2253a0:	e12fff1e 	bx	lr

0c2253a4 <D8Led_off>:

void D8Led_off(void)
{
 c2253a4:	e1a0c00d 	mov	ip, sp
 c2253a8:	e92dd800 	push	{fp, ip, lr, pc}
 c2253ac:	e24cb004 	sub	fp, ip, #4
    LED8ADDR = ~0;
 c2253b0:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c2253b4:	e3e02000 	mvn	r2, #0
 c2253b8:	e5c32000 	strb	r2, [r3]
}
 c2253bc:	e24bd00c 	sub	sp, fp, #12
 c2253c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2253c4:	e12fff1e 	bx	lr

0c2253c8 <D8Led_segment>:

void D8Led_segment(int value)
{
 c2253c8:	e1a0c00d 	mov	ip, sp
 c2253cc:	e92dd800 	push	{fp, ip, lr, pc}
 c2253d0:	e24cb004 	sub	fp, ip, #4
 c2253d4:	e24dd008 	sub	sp, sp, #8
 c2253d8:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 8) )
 c2253dc:	e51b3010 	ldr	r3, [fp, #-16]
 c2253e0:	e3530000 	cmp	r3, #0
 c2253e4:	ba00000a 	blt	c225414 <D8Led_segment+0x4c>
 c2253e8:	e51b3010 	ldr	r3, [fp, #-16]
 c2253ec:	e3530007 	cmp	r3, #7
 c2253f0:	ca000007 	bgt	c225414 <D8Led_segment+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el segmento que está en la posición
		// value del array Segmentes. Hay que tener en cuente que el display
		// usa lógica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Segments[value];
 c2253f4:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c2253f8:	e59f2020 	ldr	r2, [pc, #32]	; c225420 <D8Led_segment+0x58>
 c2253fc:	e51b1010 	ldr	r1, [fp, #-16]
 c225400:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c225404:	e20220ff 	and	r2, r2, #255	; 0xff
 c225408:	e1e02002 	mvn	r2, r2
 c22540c:	e20220ff 	and	r2, r2, #255	; 0xff
 c225410:	e5c32000 	strb	r2, [r3]
}
 c225414:	e24bd00c 	sub	sp, fp, #12
 c225418:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22541c:	e12fff1e 	bx	lr
 c225420:	0c1000e0 	.word	0x0c1000e0

0c225424 <D8Led_digit>:

void D8Led_digit(int value)
{
 c225424:	e1a0c00d 	mov	ip, sp
 c225428:	e92dd800 	push	{fp, ip, lr, pc}
 c22542c:	e24cb004 	sub	fp, ip, #4
 c225430:	e24dd008 	sub	sp, sp, #8
 c225434:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 16) )
 c225438:	e51b3010 	ldr	r3, [fp, #-16]
 c22543c:	e3530000 	cmp	r3, #0
 c225440:	ba00000a 	blt	c225470 <D8Led_digit+0x4c>
 c225444:	e51b3010 	ldr	r3, [fp, #-16]
 c225448:	e353000f 	cmp	r3, #15
 c22544c:	ca000007 	bgt	c225470 <D8Led_digit+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el dígito que está en la posición
		// value del array Digits. Hay que tener en cuente que el display
		// usa lógica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Digits[value];
 c225450:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c225454:	e59f2020 	ldr	r2, [pc, #32]	; c22547c <D8Led_digit+0x58>
 c225458:	e51b1010 	ldr	r1, [fp, #-16]
 c22545c:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c225460:	e20220ff 	and	r2, r2, #255	; 0xff
 c225464:	e1e02002 	mvn	r2, r2
 c225468:	e20220ff 	and	r2, r2, #255	; 0xff
 c22546c:	e5c32000 	strb	r2, [r3]
}
 c225470:	e24bd00c 	sub	sp, fp, #12
 c225474:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225478:	e12fff1e 	bx	lr
 c22547c:	0c100100 	.word	0x0c100100

0c225480 <L3_init>:
#include "gpio.h"

#define SHORT_DELAY { volatile int8 j; for( j=0; j<4; j++ ); }

void L3_init( void )
{
 c225480:	e1a0c00d 	mov	ip, sp
 c225484:	e92dd800 	push	{fp, ip, lr, pc}
 c225488:	e24cb004 	sub	fp, ip, #4
 c22548c:	e24dd008 	sub	sp, sp, #8
    //L3CLOCK = 1
	//L3MODE = 1
    uint8 rled, lled;

    rled = !led2_status();
 c225490:	eb000bc7 	bl	c2283b4 <led2_status>
 c225494:	e1a03000 	mov	r3, r0
 c225498:	e3530000 	cmp	r3, #0
 c22549c:	13a03000 	movne	r3, #0
 c2254a0:	03a03001 	moveq	r3, #1
 c2254a4:	e54b300d 	strb	r3, [fp, #-13]
    lled = !led1_status();
 c2254a8:	eb000bb4 	bl	c228380 <led1_status>
 c2254ac:	e1a03000 	mov	r3, r0
 c2254b0:	e3530000 	cmp	r3, #0
 c2254b4:	13a03000 	movne	r3, #0
 c2254b8:	03a03001 	moveq	r3, #1
 c2254bc:	e54b300e 	strb	r3, [fp, #-14]

    portB_conf(5, OUTPUT);
 c2254c0:	e3a00005 	mov	r0, #5
 c2254c4:	e3a01001 	mov	r1, #1
 c2254c8:	eb00028e 	bl	c225f08 <portB_conf>
    portB_conf(4, OUTPUT);
 c2254cc:	e3a00004 	mov	r0, #4
 c2254d0:	e3a01001 	mov	r1, #1
 c2254d4:	eb00028b 	bl	c225f08 <portB_conf>
    rPCONA &= ~(1 << 9);
 c2254d8:	e59f3038 	ldr	r3, [pc, #56]	; c225518 <L3_init+0x98>
 c2254dc:	e59f2034 	ldr	r2, [pc, #52]	; c225518 <L3_init+0x98>
 c2254e0:	e5922000 	ldr	r2, [r2]
 c2254e4:	e3c22c02 	bic	r2, r2, #512	; 0x200
 c2254e8:	e5832000 	str	r2, [r3]

    //L3CLOCK = PDATB[5]
    //L3MODE = PDATB[4]

    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (1 << 4);
 c2254ec:	e59f3028 	ldr	r3, [pc, #40]	; c22551c <L3_init+0x9c>
 c2254f0:	e55b200d 	ldrb	r2, [fp, #-13]
 c2254f4:	e1a01502 	lsl	r1, r2, #10
 c2254f8:	e55b200e 	ldrb	r2, [fp, #-14]
 c2254fc:	e1a02482 	lsl	r2, r2, #9
 c225500:	e1812002 	orr	r2, r1, r2
 c225504:	e3822030 	orr	r2, r2, #48	; 0x30
 c225508:	e5832000 	str	r2, [r3]
}
 c22550c:	e24bd00c 	sub	sp, fp, #12
 c225510:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225514:	e12fff1e 	bx	lr
 c225518:	01d20000 	.word	0x01d20000
 c22551c:	01d2000c 	.word	0x01d2000c

0c225520 <L3_putByte>:

void L3_putByte( uint8 byte, enum L3_mode_t mode )
{
 c225520:	e1a0c00d 	mov	ip, sp
 c225524:	e92dd800 	push	{fp, ip, lr, pc}
 c225528:	e24cb004 	sub	fp, ip, #4
 c22552c:	e24dd010 	sub	sp, sp, #16
 c225530:	e1a02000 	mov	r2, r0
 c225534:	e1a03001 	mov	r3, r1
 c225538:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c22553c:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
    uint8 i;
    uint8 rled, lled;

    rled = !led2_status();
 c225540:	eb000b9b 	bl	c2283b4 <led2_status>
 c225544:	e1a03000 	mov	r3, r0
 c225548:	e3530000 	cmp	r3, #0
 c22554c:	13a03000 	movne	r3, #0
 c225550:	03a03001 	moveq	r3, #1
 c225554:	e54b300e 	strb	r3, [fp, #-14]
    lled = !led1_status();
 c225558:	eb000b88 	bl	c228380 <led1_status>
 c22555c:	e1a03000 	mov	r3, r0
 c225560:	e3530000 	cmp	r3, #0
 c225564:	13a03000 	movne	r3, #0
 c225568:	03a03001 	moveq	r3, #1
 c22556c:	e54b300f 	strb	r3, [fp, #-15]

    //L3CLOCK = PDATB[5]
    //L3MODE = PDATB[4]

    //L3CLOCK=1, L3MODE=mode
    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
 c225570:	e59f31b0 	ldr	r3, [pc, #432]	; c225728 <L3_putByte+0x208>
 c225574:	e55b200e 	ldrb	r2, [fp, #-14]
 c225578:	e1a01502 	lsl	r1, r2, #10
 c22557c:	e55b200f 	ldrb	r2, [fp, #-15]
 c225580:	e1a02482 	lsl	r2, r2, #9
 c225584:	e1812002 	orr	r2, r1, r2
 c225588:	e3821020 	orr	r1, r2, #32
 c22558c:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c225590:	e1a02202 	lsl	r2, r2, #4
 c225594:	e1812002 	orr	r2, r1, r2
 c225598:	e5832000 	str	r2, [r3]
    SHORT_DELAY;
 c22559c:	e3a03000 	mov	r3, #0
 c2255a0:	e54b3010 	strb	r3, [fp, #-16]
 c2255a4:	ea000004 	b	c2255bc <L3_putByte+0x9c>
 c2255a8:	e55b3010 	ldrb	r3, [fp, #-16]
 c2255ac:	e20330ff 	and	r3, r3, #255	; 0xff
 c2255b0:	e2833001 	add	r3, r3, #1
 c2255b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2255b8:	e54b3010 	strb	r3, [fp, #-16]
 c2255bc:	e55b3010 	ldrb	r3, [fp, #-16]
 c2255c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2255c4:	e1a03c03 	lsl	r3, r3, #24
 c2255c8:	e1a03c43 	asr	r3, r3, #24
 c2255cc:	e3530003 	cmp	r3, #3
 c2255d0:	dafffff4 	ble	c2255a8 <L3_putByte+0x88>

    for( i=0; i<8; i++ )
 c2255d4:	e3a03000 	mov	r3, #0
 c2255d8:	e54b300d 	strb	r3, [fp, #-13]
 c2255dc:	ea000043 	b	c2256f0 <L3_putByte+0x1d0>
    {
    	//L3CLOCK = 0, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (0 << 5) | (mode << 4);
 c2255e0:	e59f3140 	ldr	r3, [pc, #320]	; c225728 <L3_putByte+0x208>
 c2255e4:	e55b200e 	ldrb	r2, [fp, #-14]
 c2255e8:	e1a01502 	lsl	r1, r2, #10
 c2255ec:	e55b200f 	ldrb	r2, [fp, #-15]
 c2255f0:	e1a02482 	lsl	r2, r2, #9
 c2255f4:	e1811002 	orr	r1, r1, r2
 c2255f8:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c2255fc:	e1a02202 	lsl	r2, r2, #4
 c225600:	e1812002 	orr	r2, r1, r2
 c225604:	e5832000 	str	r2, [r3]

        //L3DATA = byte[i]
        //L3DATA = PDATA[9]
        rPDATA &= ~(1 << 9);
 c225608:	e59f311c 	ldr	r3, [pc, #284]	; c22572c <L3_putByte+0x20c>
 c22560c:	e59f2118 	ldr	r2, [pc, #280]	; c22572c <L3_putByte+0x20c>
 c225610:	e5922000 	ldr	r2, [r2]
 c225614:	e3c22c02 	bic	r2, r2, #512	; 0x200
 c225618:	e5832000 	str	r2, [r3]
        rPDATA |= (byte & 1) << 9;
 c22561c:	e59f3108 	ldr	r3, [pc, #264]	; c22572c <L3_putByte+0x20c>
 c225620:	e59f2104 	ldr	r2, [pc, #260]	; c22572c <L3_putByte+0x20c>
 c225624:	e5921000 	ldr	r1, [r2]
 c225628:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c22562c:	e2022001 	and	r2, r2, #1
 c225630:	e1a02482 	lsl	r2, r2, #9
 c225634:	e1812002 	orr	r2, r1, r2
 c225638:	e5832000 	str	r2, [r3]
        byte >>= 1;
 c22563c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c225640:	e1a030a3 	lsr	r3, r3, #1
 c225644:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb

        SHORT_DELAY;
 c225648:	e3a03000 	mov	r3, #0
 c22564c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c225650:	ea000004 	b	c225668 <L3_putByte+0x148>
 c225654:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c225658:	e20330ff 	and	r3, r3, #255	; 0xff
 c22565c:	e2833001 	add	r3, r3, #1
 c225660:	e20330ff 	and	r3, r3, #255	; 0xff
 c225664:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c225668:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22566c:	e20330ff 	and	r3, r3, #255	; 0xff
 c225670:	e1a03c03 	lsl	r3, r3, #24
 c225674:	e1a03c43 	asr	r3, r3, #24
 c225678:	e3530003 	cmp	r3, #3
 c22567c:	dafffff4 	ble	c225654 <L3_putByte+0x134>

        //L3CLOCK = 1, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
 c225680:	e59f30a0 	ldr	r3, [pc, #160]	; c225728 <L3_putByte+0x208>
 c225684:	e55b200e 	ldrb	r2, [fp, #-14]
 c225688:	e1a01502 	lsl	r1, r2, #10
 c22568c:	e55b200f 	ldrb	r2, [fp, #-15]
 c225690:	e1a02482 	lsl	r2, r2, #9
 c225694:	e1812002 	orr	r2, r1, r2
 c225698:	e3821020 	orr	r1, r2, #32
 c22569c:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c2256a0:	e1a02202 	lsl	r2, r2, #4
 c2256a4:	e1812002 	orr	r2, r1, r2
 c2256a8:	e5832000 	str	r2, [r3]
        SHORT_DELAY;
 c2256ac:	e3a03000 	mov	r3, #0
 c2256b0:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
 c2256b4:	ea000004 	b	c2256cc <L3_putByte+0x1ac>
 c2256b8:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c2256bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2256c0:	e2833001 	add	r3, r3, #1
 c2256c4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2256c8:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
 c2256cc:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c2256d0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2256d4:	e1a03c03 	lsl	r3, r3, #24
 c2256d8:	e1a03c43 	asr	r3, r3, #24
 c2256dc:	e3530003 	cmp	r3, #3
 c2256e0:	dafffff4 	ble	c2256b8 <L3_putByte+0x198>

    //L3CLOCK=1, L3MODE=mode
    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
    SHORT_DELAY;

    for( i=0; i<8; i++ )
 c2256e4:	e55b300d 	ldrb	r3, [fp, #-13]
 c2256e8:	e2833001 	add	r3, r3, #1
 c2256ec:	e54b300d 	strb	r3, [fp, #-13]
 c2256f0:	e55b300d 	ldrb	r3, [fp, #-13]
 c2256f4:	e3530007 	cmp	r3, #7
 c2256f8:	9affffb8 	bls	c2255e0 <L3_putByte+0xc0>
        //L3CLOCK = 1, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
        SHORT_DELAY;
    }

    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (1 << 4);
 c2256fc:	e59f3024 	ldr	r3, [pc, #36]	; c225728 <L3_putByte+0x208>
 c225700:	e55b200e 	ldrb	r2, [fp, #-14]
 c225704:	e1a01502 	lsl	r1, r2, #10
 c225708:	e55b200f 	ldrb	r2, [fp, #-15]
 c22570c:	e1a02482 	lsl	r2, r2, #9
 c225710:	e1812002 	orr	r2, r1, r2
 c225714:	e3822030 	orr	r2, r2, #48	; 0x30
 c225718:	e5832000 	str	r2, [r3]
}
 c22571c:	e24bd00c 	sub	sp, fp, #12
 c225720:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225724:	e12fff1e 	bx	lr
 c225728:	01d2000c 	.word	0x01d2000c
 c22572c:	01d20004 	.word	0x01d20004

0c225730 <isr_ADC_dummy>:
static uint8 state;

void isr_ADC_dummy( void ) __attribute__ ((interrupt ("IRQ")));

void isr_ADC_dummy(void)
{
 c225730:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c225734:	e1a0c00d 	mov	ip, sp
 c225738:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c22573c:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_ADC);
 c225740:	e3a00000 	mov	r0, #0
 c225744:	eb00074a 	bl	c227474 <ic_cleanflag>
}
 c225748:	e24bd01c 	sub	sp, fp, #28
 c22574c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c225750:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c225754:	e25ef004 	subs	pc, lr, #4

0c225758 <adc_init>:

void adc_init( void )
{
 c225758:	e1a0c00d 	mov	ip, sp
 c22575c:	e92dd800 	push	{fp, ip, lr, pc}
 c225760:	e24cb004 	sub	fp, ip, #4
	//Tasa de conversiÃ³n: mÃ¡xima (100 KSPS, tiempo de conversiÃ³n 10 us)
	//100KHz = 64 MHz / 2(n+1)Ã16 => n = 19
	rADCPSR = 19;
 c225764:	e59f3014 	ldr	r3, [pc, #20]	; c225780 <adc_init+0x28>
 c225768:	e3a02013 	mov	r2, #19
 c22576c:	e5832000 	str	r2, [r3]
    adc_off();
 c225770:	eb000014 	bl	c2257c8 <adc_off>
}
 c225774:	e24bd00c 	sub	sp, fp, #12
 c225778:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22577c:	e12fff1e 	bx	lr
 c225780:	01d40004 	.word	0x01d40004

0c225784 <adc_on>:

void adc_on( void )
{
 c225784:	e1a0c00d 	mov	ip, sp
 c225788:	e92dd800 	push	{fp, ip, lr, pc}
 c22578c:	e24cb004 	sub	fp, ip, #4
	//	ADCCON[5] = 0 Normal mode
	rADCCON &= ~(1 << 5);
 c225790:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c225794:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c225798:	e5922000 	ldr	r2, [r2]
 c22579c:	e3c22020 	bic	r2, r2, #32
 c2257a0:	e5832000 	str	r2, [r3]

	//Esperar 10 ms antes de arrancar la conversiÃ³n
	Delay(10);
 c2257a4:	e3a0000a 	mov	r0, #10
 c2257a8:	eb001571 	bl	c22ad74 <Delay>
    state = ON;
 c2257ac:	e59f3010 	ldr	r3, [pc, #16]	; c2257c4 <adc_on+0x40>
 c2257b0:	e3a02001 	mov	r2, #1
 c2257b4:	e5c32000 	strb	r2, [r3]
}
 c2257b8:	e24bd00c 	sub	sp, fp, #12
 c2257bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2257c0:	e12fff1e 	bx	lr
 c2257c4:	0c1023f8 	.word	0x0c1023f8

0c2257c8 <adc_off>:

void adc_off( void )
{
 c2257c8:	e1a0c00d 	mov	ip, sp
 c2257cc:	e92dd800 	push	{fp, ip, lr, pc}
 c2257d0:	e24cb004 	sub	fp, ip, #4
	//ADCCON[5] = 1  Sleep mode
	rADCCON |= 1 << 5;
 c2257d4:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c2257d8:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c2257dc:	e5922000 	ldr	r2, [r2]
 c2257e0:	e3822020 	orr	r2, r2, #32
 c2257e4:	e5832000 	str	r2, [r3]
	state = OFF;
 c2257e8:	e59f3010 	ldr	r3, [pc, #16]	; c225800 <adc_off+0x38>
 c2257ec:	e3a02000 	mov	r2, #0
 c2257f0:	e5c32000 	strb	r2, [r3]
}
 c2257f4:	e24bd00c 	sub	sp, fp, #12
 c2257f8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2257fc:	e12fff1e 	bx	lr
 c225800:	0c1023f8 	.word	0x0c1023f8

0c225804 <adc_status>:

uint8 adc_status( void )
{
 c225804:	e1a0c00d 	mov	ip, sp
 c225808:	e92dd800 	push	{fp, ip, lr, pc}
 c22580c:	e24cb004 	sub	fp, ip, #4
    return state;
 c225810:	e59f3010 	ldr	r3, [pc, #16]	; c225828 <adc_status+0x24>
 c225814:	e5d33000 	ldrb	r3, [r3]
}
 c225818:	e1a00003 	mov	r0, r3
 c22581c:	e24bd00c 	sub	sp, fp, #12
 c225820:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225824:	e12fff1e 	bx	lr
 c225828:	0c1023f8 	.word	0x0c1023f8

0c22582c <adc_getSample>:

uint16 adc_getSample( enum ADC_channel_t ch )
{
 c22582c:	e1a0c00d 	mov	ip, sp
 c225830:	e92dd800 	push	{fp, ip, lr, pc}
 c225834:	e24cb004 	sub	fp, ip, #4
 c225838:	e24dd010 	sub	sp, sp, #16
 c22583c:	e1a03000 	mov	r3, r0
 c225840:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    uint32 sample;
    uint8 i;

    //Seleccionar el canal
    rADCCON &= ~(0b111 << 2);
 c225844:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c225848:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c22584c:	e5922000 	ldr	r2, [r2]
 c225850:	e3c2201c 	bic	r2, r2, #28
 c225854:	e5832000 	str	r2, [r3]
    rADCCON |= ch << 2;
 c225858:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c22585c:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c225860:	e5921000 	ldr	r1, [r2]
 c225864:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c225868:	e1a02102 	lsl	r2, r2, #2
 c22586c:	e1812002 	orr	r2, r1, r2
 c225870:	e5832000 	str	r2, [r3]

    Delay(10);
 c225874:	e3a0000a 	mov	r0, #10
 c225878:	eb00153d 	bl	c22ad74 <Delay>

    // Hacer la media de 5 samples para estabilizar
    for( i=0, sample=0; i<5; i++ )
 c22587c:	e3a03000 	mov	r3, #0
 c225880:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c225884:	e3a03000 	mov	r3, #0
 c225888:	e50b3010 	str	r3, [fp, #-16]
 c22588c:	ea000020 	b	c225914 <adc_getSample+0xe8>
    {
    	//ADCCON[1] = 0 deshabilita arranque por lectura
    	//ADCCON[0] = 1 arranca manualmente la conversiÃ³n

    	rADCCON &= ~2;
 c225890:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c225894:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c225898:	e5922000 	ldr	r2, [r2]
 c22589c:	e3c22002 	bic	r2, r2, #2
 c2258a0:	e5832000 	str	r2, [r3]
        rADCCON |= 1;
 c2258a4:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c2258a8:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c2258ac:	e5922000 	ldr	r2, [r2]
 c2258b0:	e3822001 	orr	r2, r2, #1
 c2258b4:	e5832000 	str	r2, [r3]

    	//Espera hasta que la conversion comience (mientras ADCCON[0] == 1)
        while( rADCCON & 1 );
 c2258b8:	e1a00000 	nop			; (mov r0, r0)
 c2258bc:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c2258c0:	e5933000 	ldr	r3, [r3]
 c2258c4:	e2033001 	and	r3, r3, #1
 c2258c8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2258cc:	e3530000 	cmp	r3, #0
 c2258d0:	1afffff9 	bne	c2258bc <adc_getSample+0x90>

    	//Espera hasta que la conversion finalice (mientras ADCCON[6] == 0)
        while( !(rADCCON & (1 << 6)) );
 c2258d4:	e1a00000 	nop			; (mov r0, r0)
 c2258d8:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c2258dc:	e5933000 	ldr	r3, [r3]
 c2258e0:	e2033040 	and	r3, r3, #64	; 0x40
 c2258e4:	e3530000 	cmp	r3, #0
 c2258e8:	0afffffa 	beq	c2258d8 <adc_getSample+0xac>

        sample += rADCDAT & 0x3ff;
 c2258ec:	e59f3054 	ldr	r3, [pc, #84]	; c225948 <adc_getSample+0x11c>
 c2258f0:	e5933000 	ldr	r3, [r3]
 c2258f4:	e1a03b03 	lsl	r3, r3, #22
 c2258f8:	e1a03b23 	lsr	r3, r3, #22
 c2258fc:	e51b2010 	ldr	r2, [fp, #-16]
 c225900:	e0823003 	add	r3, r2, r3
 c225904:	e50b3010 	str	r3, [fp, #-16]
    rADCCON |= ch << 2;

    Delay(10);

    // Hacer la media de 5 samples para estabilizar
    for( i=0, sample=0; i<5; i++ )
 c225908:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22590c:	e2833001 	add	r3, r3, #1
 c225910:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c225914:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c225918:	e3530004 	cmp	r3, #4
 c22591c:	9affffdb 	bls	c225890 <adc_getSample+0x64>
    	//Espera hasta que la conversion finalice (mientras ADCCON[6] == 0)
        while( !(rADCCON & (1 << 6)) );

        sample += rADCDAT & 0x3ff;
    }
    return sample / 5;
 c225920:	e51b2010 	ldr	r2, [fp, #-16]
 c225924:	e59f3020 	ldr	r3, [pc, #32]	; c22594c <adc_getSample+0x120>
 c225928:	e0831392 	umull	r1, r3, r2, r3
 c22592c:	e1a03123 	lsr	r3, r3, #2
 c225930:	e1a03803 	lsl	r3, r3, #16
 c225934:	e1a03823 	lsr	r3, r3, #16
}
 c225938:	e1a00003 	mov	r0, r3
 c22593c:	e24bd00c 	sub	sp, fp, #12
 c225940:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225944:	e12fff1e 	bx	lr
 c225948:	01d40008 	.word	0x01d40008
 c22594c:	cccccccd 	.word	0xcccccccd

0c225950 <adc_open>:

void adc_open( void (*isr)(void) )
{
 c225950:	e1a0c00d 	mov	ip, sp
 c225954:	e92dd800 	push	{fp, ip, lr, pc}
 c225958:	e24cb004 	sub	fp, ip, #4
 c22595c:	e24dd008 	sub	sp, sp, #8
 c225960:	e50b0010 	str	r0, [fp, #-16]
	pISR_ADC = (unsigned) isr;
 c225964:	e59f3018 	ldr	r3, [pc, #24]	; c225984 <adc_open+0x34>
 c225968:	e51b2010 	ldr	r2, [fp, #-16]
 c22596c:	e5832000 	str	r2, [r3]
    ic_enable(INT_ADC);
 c225970:	e3a00000 	mov	r0, #0
 c225974:	eb00068b 	bl	c2273a8 <ic_enable>
}
 c225978:	e24bd00c 	sub	sp, fp, #12
 c22597c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225980:	e12fff1e 	bx	lr
 c225984:	0c7fff20 	.word	0x0c7fff20

0c225988 <adc_close>:

void adc_close( void )
{
 c225988:	e1a0c00d 	mov	ip, sp
 c22598c:	e92dd800 	push	{fp, ip, lr, pc}
 c225990:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_ADC);
 c225994:	e3a00000 	mov	r0, #0
 c225998:	eb00069c 	bl	c227410 <ic_disable>
    pISR_ADC = (unsigned) isr_ADC_dummy;
 c22599c:	e59f3010 	ldr	r3, [pc, #16]	; c2259b4 <adc_close+0x2c>
 c2259a0:	e59f2010 	ldr	r2, [pc, #16]	; c2259b8 <adc_close+0x30>
 c2259a4:	e5832000 	str	r2, [r3]
}
 c2259a8:	e24bd00c 	sub	sp, fp, #12
 c2259ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2259b0:	e12fff1e 	bx	lr
 c2259b4:	0c7fff20 	.word	0x0c7fff20
 c2259b8:	0c225730 	.word	0x0c225730

0c2259bc <at24c04_clear>:

#define READ  (1)
#define WRITE (0)

void at24c04_clear( void )
{
 c2259bc:	e1a0c00d 	mov	ip, sp
 c2259c0:	e92dd800 	push	{fp, ip, lr, pc}
 c2259c4:	e24cb004 	sub	fp, ip, #4
 c2259c8:	e24dd010 	sub	sp, sp, #16
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
 c2259cc:	e3a03000 	mov	r3, #0
 c2259d0:	e50b3010 	str	r3, [fp, #-16]
 c2259d4:	e3a03000 	mov	r3, #0
 c2259d8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c2259dc:	e3a03000 	mov	r3, #0
 c2259e0:	e50b3010 	str	r3, [fp, #-16]
 c2259e4:	ea000025 	b	c225a80 <at24c04_clear+0xc4>
		//Store page
		int addr = page_count * 16;
 c2259e8:	e51b3010 	ldr	r3, [fp, #-16]
 c2259ec:	e1a03203 	lsl	r3, r3, #4
 c2259f0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		bit = (addr & 0x100) >> 8;
 c2259f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2259f8:	e2033c01 	and	r3, r3, #256	; 0x100
 c2259fc:	e1a03443 	asr	r3, r3, #8
 c225a00:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

		//Se envÃ­a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
		//-el bit 8 de la direcciÃ³n del dato
		//-un 0 para indicar la operaciÃ³n de escritura
		iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c225a04:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c225a08:	e1a03083 	lsl	r3, r3, #1
 c225a0c:	e20330ff 	and	r3, r3, #255	; 0xff
 c225a10:	e1e03003 	mvn	r3, r3
 c225a14:	e203305f 	and	r3, r3, #95	; 0x5f
 c225a18:	e1e03003 	mvn	r3, r3
 c225a1c:	e20330ff 	and	r3, r3, #255	; 0xff
 c225a20:	e20330ff 	and	r3, r3, #255	; 0xff
 c225a24:	e3a00003 	mov	r0, #3
 c225a28:	e1a01003 	mov	r1, r3
 c225a2c:	eb00036d 	bl	c2267e8 <iic_start>

		//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
		iic_putByte(addr & 0xff);
 c225a30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225a34:	e20330ff 	and	r3, r3, #255	; 0xff
 c225a38:	e1a00003 	mov	r0, r3
 c225a3c:	eb00038a 	bl	c22686c <iic_putByte>

		//Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c225a40:	e3a03000 	mov	r3, #0
 c225a44:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c225a48:	ea000004 	b	c225a60 <at24c04_clear+0xa4>
			iic_putByte(0);
 c225a4c:	e3a00000 	mov	r0, #0
 c225a50:	eb000385 	bl	c22686c <iic_putByte>

		//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
		iic_putByte(addr & 0xff);

		//Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c225a54:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c225a58:	e2833001 	add	r3, r3, #1
 c225a5c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c225a60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c225a64:	e353000f 	cmp	r3, #15
 c225a68:	dafffff7 	ble	c225a4c <at24c04_clear+0x90>
			iic_putByte(0);
		}

		//Se envÃ­a la stop condition
		iic_stop(5);
 c225a6c:	e3a00005 	mov	r0, #5
 c225a70:	eb0003be 	bl	c226970 <iic_stop>
{
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c225a74:	e51b3010 	ldr	r3, [fp, #-16]
 c225a78:	e2833001 	add	r3, r3, #1
 c225a7c:	e50b3010 	str	r3, [fp, #-16]
 c225a80:	e51b3010 	ldr	r3, [fp, #-16]
 c225a84:	e353001f 	cmp	r3, #31
 c225a88:	daffffd6 	ble	c2259e8 <at24c04_clear+0x2c>
		}

		//Se envÃ­a la stop condition
		iic_stop(5);
	}
}
 c225a8c:	e24bd00c 	sub	sp, fp, #12
 c225a90:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225a94:	e12fff1e 	bx	lr

0c225a98 <at24c04_bytewrite>:

void at24c04_bytewrite( uint16 addr, uint8 data )
{
 c225a98:	e1a0c00d 	mov	ip, sp
 c225a9c:	e92dd800 	push	{fp, ip, lr, pc}
 c225aa0:	e24cb004 	sub	fp, ip, #4
 c225aa4:	e24dd010 	sub	sp, sp, #16
 c225aa8:	e1a02000 	mov	r2, r0
 c225aac:	e1a03001 	mov	r3, r1
 c225ab0:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c225ab4:	e54b3017 	strb	r3, [fp, #-23]	; 0xffffffe9
    uint8 page;

    page = (addr & 0x100) >> 8;
 c225ab8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c225abc:	e2033c01 	and	r3, r3, #256	; 0x100
 c225ac0:	e1a03443 	asr	r3, r3, #8
 c225ac4:	e54b300d 	strb	r3, [fp, #-13]

    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c225ac8:	e55b300d 	ldrb	r3, [fp, #-13]
 c225acc:	e1a03083 	lsl	r3, r3, #1
 c225ad0:	e20330ff 	and	r3, r3, #255	; 0xff
 c225ad4:	e1e03003 	mvn	r3, r3
 c225ad8:	e203305f 	and	r3, r3, #95	; 0x5f
 c225adc:	e1e03003 	mvn	r3, r3
 c225ae0:	e20330ff 	and	r3, r3, #255	; 0xff
 c225ae4:	e20330ff 	and	r3, r3, #255	; 0xff
 c225ae8:	e3a00003 	mov	r0, #3
 c225aec:	e1a01003 	mov	r1, r3
 c225af0:	eb00033c 	bl	c2267e8 <iic_start>
    iic_putByte( addr & 0xFF );
 c225af4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c225af8:	e20330ff 	and	r3, r3, #255	; 0xff
 c225afc:	e1a00003 	mov	r0, r3
 c225b00:	eb000359 	bl	c22686c <iic_putByte>
    iic_putByte( data );
 c225b04:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c225b08:	e1a00003 	mov	r0, r3
 c225b0c:	eb000356 	bl	c22686c <iic_putByte>
    iic_stop( 5 );
 c225b10:	e3a00005 	mov	r0, #5
 c225b14:	eb000395 	bl	c226970 <iic_stop>
}
 c225b18:	e24bd00c 	sub	sp, fp, #12
 c225b1c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225b20:	e12fff1e 	bx	lr

0c225b24 <at24c04_byteread>:

void at24c04_byteread( uint16 addr, uint8 *data )
{
 c225b24:	e1a0c00d 	mov	ip, sp
 c225b28:	e92dd800 	push	{fp, ip, lr, pc}
 c225b2c:	e24cb004 	sub	fp, ip, #4
 c225b30:	e24dd010 	sub	sp, sp, #16
 c225b34:	e1a03000 	mov	r3, r0
 c225b38:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c225b3c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
	//Read random byte
	uint8 page;
    page = (addr & 0x100) >> 8;
 c225b40:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c225b44:	e2033c01 	and	r3, r3, #256	; 0x100
 c225b48:	e1a03443 	asr	r3, r3, #8
 c225b4c:	e54b300d 	strb	r3, [fp, #-13]
	//Steps:
	//Se envÃ­a la start condition seguida del 1er. byte que incluye:
	//- los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
	//- el bit 8 de la direcciÃ³n del dato
	//- un 0 para indicar la operaciÃ³n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c225b50:	e55b300d 	ldrb	r3, [fp, #-13]
 c225b54:	e1a03083 	lsl	r3, r3, #1
 c225b58:	e20330ff 	and	r3, r3, #255	; 0xff
 c225b5c:	e1e03003 	mvn	r3, r3
 c225b60:	e203305f 	and	r3, r3, #95	; 0x5f
 c225b64:	e1e03003 	mvn	r3, r3
 c225b68:	e20330ff 	and	r3, r3, #255	; 0xff
 c225b6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c225b70:	e3a00003 	mov	r0, #3
 c225b74:	e1a01003 	mov	r1, r3
 c225b78:	eb00031a 	bl	c2267e8 <iic_start>

	//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
    iic_putByte( addr & 0xFF );
 c225b7c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c225b80:	e20330ff 	and	r3, r3, #255	; 0xff
 c225b84:	e1a00003 	mov	r0, r3
 c225b88:	eb000337 	bl	c22686c <iic_putByte>

	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	//- La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (page << 1) | READ);
 c225b8c:	e55b300d 	ldrb	r3, [fp, #-13]
 c225b90:	e1a03083 	lsl	r3, r3, #1
 c225b94:	e20330ff 	and	r3, r3, #255	; 0xff
 c225b98:	e1e03003 	mvn	r3, r3
 c225b9c:	e203305e 	and	r3, r3, #94	; 0x5e
 c225ba0:	e1e03003 	mvn	r3, r3
 c225ba4:	e20330ff 	and	r3, r3, #255	; 0xff
 c225ba8:	e20330ff 	and	r3, r3, #255	; 0xff
 c225bac:	e3a00002 	mov	r0, #2
 c225bb0:	e1a01003 	mov	r1, r3
 c225bb4:	eb00030b 	bl	c2267e8 <iic_start>

	//Se recibe el byte que incluye el dato (sin enviar ACK).
    *data = iic_getByte(NO_RxACK);
 c225bb8:	e3a00000 	mov	r0, #0
 c225bbc:	eb000343 	bl	c2268d0 <iic_getByte>
 c225bc0:	e1a03000 	mov	r3, r0
 c225bc4:	e1a02003 	mov	r2, r3
 c225bc8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c225bcc:	e5c32000 	strb	r2, [r3]

	//Se envÃ­a la stop condition
    iic_stop( 5 );
 c225bd0:	e3a00005 	mov	r0, #5
 c225bd4:	eb000365 	bl	c226970 <iic_stop>
}
 c225bd8:	e24bd00c 	sub	sp, fp, #12
 c225bdc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225be0:	e12fff1e 	bx	lr

0c225be4 <at24c04_load>:

void at24c04_load( uint8 *buffer )
{
 c225be4:	e1a0c00d 	mov	ip, sp
 c225be8:	e92dd800 	push	{fp, ip, lr, pc}
 c225bec:	e24cb004 	sub	fp, ip, #4
 c225bf0:	e24dd010 	sub	sp, sp, #16
 c225bf4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    //Load sequentially all 512 bytes from 0x0
	int i = 0;
 c225bf8:	e3a03000 	mov	r3, #0
 c225bfc:	e50b3010 	str	r3, [fp, #-16]

	//Se envÃ­a la start condition seguida del 1er. byte que incluye:
	// - los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
	// - el bit 8 de la direcciÃ³n del dato
	// -un 0 para indicar la operaciÃ³n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (0 << 1) | WRITE );
 c225c00:	e3a00003 	mov	r0, #3
 c225c04:	e3a010a0 	mov	r1, #160	; 0xa0
 c225c08:	eb0002f6 	bl	c2267e8 <iic_start>

	//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
    iic_putByte(00);
 c225c0c:	e3a00000 	mov	r0, #0
 c225c10:	eb000315 	bl	c22686c <iic_putByte>

	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	// - La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );
 c225c14:	e3a00002 	mov	r0, #2
 c225c18:	e3a010a1 	mov	r1, #161	; 0xa1
 c225c1c:	eb0002f1 	bl	c2267e8 <iic_start>

	//Se reciben nâ1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c225c20:	e3a03000 	mov	r3, #0
 c225c24:	e50b3010 	str	r3, [fp, #-16]
 c225c28:	ea00000b 	b	c225c5c <at24c04_load+0x78>
    	*buffer = iic_getByte(RxACK);
 c225c2c:	e3a00001 	mov	r0, #1
 c225c30:	eb000326 	bl	c2268d0 <iic_getByte>
 c225c34:	e1a03000 	mov	r3, r0
 c225c38:	e1a02003 	mov	r2, r3
 c225c3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225c40:	e5c32000 	strb	r2, [r3]
    	buffer++;
 c225c44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225c48:	e2833001 	add	r3, r3, #1
 c225c4c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	// - La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );

	//Se reciben nâ1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c225c50:	e51b3010 	ldr	r3, [fp, #-16]
 c225c54:	e2833001 	add	r3, r3, #1
 c225c58:	e50b3010 	str	r3, [fp, #-16]
 c225c5c:	e51b2010 	ldr	r2, [fp, #-16]
 c225c60:	e59f3030 	ldr	r3, [pc, #48]	; c225c98 <at24c04_load+0xb4>
 c225c64:	e1520003 	cmp	r2, r3
 c225c68:	daffffef 	ble	c225c2c <at24c04_load+0x48>
    	*buffer = iic_getByte(RxACK);
    	buffer++;
    }

	//Se recibe el Ãºltimo byte que incluye datos (sin enviar ACK).
	*buffer = iic_getByte(NO_RxACK);
 c225c6c:	e3a00000 	mov	r0, #0
 c225c70:	eb000316 	bl	c2268d0 <iic_getByte>
 c225c74:	e1a03000 	mov	r3, r0
 c225c78:	e1a02003 	mov	r2, r3
 c225c7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225c80:	e5c32000 	strb	r2, [r3]

	//Se envÃ­a la stop condition.
    iic_stop( 5 );
 c225c84:	e3a00005 	mov	r0, #5
 c225c88:	eb000338 	bl	c226970 <iic_stop>
}
 c225c8c:	e24bd00c 	sub	sp, fp, #12
 c225c90:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225c94:	e12fff1e 	bx	lr
 c225c98:	000001fe 	.word	0x000001fe

0c225c9c <at24c04_store>:

void at24c04_store( uint8 *buffer )
{
 c225c9c:	e1a0c00d 	mov	ip, sp
 c225ca0:	e92dd800 	push	{fp, ip, lr, pc}
 c225ca4:	e24cb004 	sub	fp, ip, #4
 c225ca8:	e24dd018 	sub	sp, sp, #24
 c225cac:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
 c225cb0:	e3a03000 	mov	r3, #0
 c225cb4:	e50b3010 	str	r3, [fp, #-16]
 c225cb8:	e3a03000 	mov	r3, #0
 c225cbc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c225cc0:	e3a03000 	mov	r3, #0
 c225cc4:	e50b3010 	str	r3, [fp, #-16]
 c225cc8:	ea00002a 	b	c225d78 <at24c04_store+0xdc>
		//Store page
		int addr = page_count * 16;
 c225ccc:	e51b3010 	ldr	r3, [fp, #-16]
 c225cd0:	e1a03203 	lsl	r3, r3, #4
 c225cd4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	    bit = (addr & 0x100) >> 8;
 c225cd8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225cdc:	e2033c01 	and	r3, r3, #256	; 0x100
 c225ce0:	e1a03443 	asr	r3, r3, #8
 c225ce4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

	    //Se envÃ­a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
		//-el bit 8 de la direcciÃ³n del dato
		//-un 0 para indicar la operaciÃ³n de escritura
	    iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c225ce8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c225cec:	e1a03083 	lsl	r3, r3, #1
 c225cf0:	e20330ff 	and	r3, r3, #255	; 0xff
 c225cf4:	e1e03003 	mvn	r3, r3
 c225cf8:	e203305f 	and	r3, r3, #95	; 0x5f
 c225cfc:	e1e03003 	mvn	r3, r3
 c225d00:	e20330ff 	and	r3, r3, #255	; 0xff
 c225d04:	e20330ff 	and	r3, r3, #255	; 0xff
 c225d08:	e3a00003 	mov	r0, #3
 c225d0c:	e1a01003 	mov	r1, r3
 c225d10:	eb0002b4 	bl	c2267e8 <iic_start>

	    //Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
	    iic_putByte(addr & 0xff);
 c225d14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225d18:	e20330ff 	and	r3, r3, #255	; 0xff
 c225d1c:	e1a00003 	mov	r0, r3
 c225d20:	eb0002d1 	bl	c22686c <iic_putByte>

	    //Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c225d24:	e3a03000 	mov	r3, #0
 c225d28:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c225d2c:	ea000009 	b	c225d58 <at24c04_store+0xbc>
	    	iic_putByte(*buffer);
 c225d30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c225d34:	e5d33000 	ldrb	r3, [r3]
 c225d38:	e1a00003 	mov	r0, r3
 c225d3c:	eb0002ca 	bl	c22686c <iic_putByte>
	    	++buffer;
 c225d40:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c225d44:	e2833001 	add	r3, r3, #1
 c225d48:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	    //Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
	    iic_putByte(addr & 0xff);

	    //Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c225d4c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c225d50:	e2833001 	add	r3, r3, #1
 c225d54:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c225d58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c225d5c:	e353000f 	cmp	r3, #15
 c225d60:	dafffff2 	ble	c225d30 <at24c04_store+0x94>
	    	iic_putByte(*buffer);
	    	++buffer;
	    }

	    //Se envÃ­a la stop condition
	    iic_stop(5);
 c225d64:	e3a00005 	mov	r0, #5
 c225d68:	eb000300 	bl	c226970 <iic_stop>
{
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c225d6c:	e51b3010 	ldr	r3, [fp, #-16]
 c225d70:	e2833001 	add	r3, r3, #1
 c225d74:	e50b3010 	str	r3, [fp, #-16]
 c225d78:	e51b3010 	ldr	r3, [fp, #-16]
 c225d7c:	e353001f 	cmp	r3, #31
 c225d80:	daffffd1 	ble	c225ccc <at24c04_store+0x30>
	    }

	    //Se envÃ­a la stop condition
	    iic_stop(5);
	}
}
 c225d84:	e24bd00c 	sub	sp, fp, #12
 c225d88:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225d8c:	e12fff1e 	bx	lr

0c225d90 <read_button>:
#include "button.h"
#include "leds.h"
#include "gpio.h"

unsigned int read_button(void)
{
 c225d90:	e1a0c00d 	mov	ip, sp
 c225d94:	e92dd800 	push	{fp, ip, lr, pc}
 c225d98:	e24cb004 	sub	fp, ip, #4
 c225d9c:	e24dd008 	sub	sp, sp, #8
	unsigned int buttons = 0;
 c225da0:	e3a03000 	mov	r3, #0
 c225da4:	e50b3010 	str	r3, [fp, #-16]
	//pines 6 y 7 del puerto G (portG_read) debemos devolver un valor (buttons)
	//en el que el bit 0 (el menos significativo) representa el estado del botÃ³n
	//del pin 6 y el bit 1 representa el estado del botÃ³n del pin 7 (a 1 si
	//estÃ¡n pulsados a 0 si no lo estÃ¡n).

	portG_read(6, &val);
 c225da8:	e24b3011 	sub	r3, fp, #17
 c225dac:	e3a00006 	mov	r0, #6
 c225db0:	e1a01003 	mov	r1, r3
 c225db4:	eb000216 	bl	c226614 <portG_read>
	if(!val)
 c225db8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c225dbc:	e3530000 	cmp	r3, #0
 c225dc0:	1a000002 	bne	c225dd0 <read_button+0x40>
		buttons |= BUT1;
 c225dc4:	e51b3010 	ldr	r3, [fp, #-16]
 c225dc8:	e3833001 	orr	r3, r3, #1
 c225dcc:	e50b3010 	str	r3, [fp, #-16]

	portG_read(7, &val);
 c225dd0:	e24b3011 	sub	r3, fp, #17
 c225dd4:	e3a00007 	mov	r0, #7
 c225dd8:	e1a01003 	mov	r1, r3
 c225ddc:	eb00020c 	bl	c226614 <portG_read>
	if(!val)
 c225de0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c225de4:	e3530000 	cmp	r3, #0
 c225de8:	1a000002 	bne	c225df8 <read_button+0x68>
		buttons |= BUT2;
 c225dec:	e51b3010 	ldr	r3, [fp, #-16]
 c225df0:	e3833002 	orr	r3, r3, #2
 c225df4:	e50b3010 	str	r3, [fp, #-16]

	return buttons;
 c225df8:	e51b3010 	ldr	r3, [fp, #-16]
}
 c225dfc:	e1a00003 	mov	r0, r3
 c225e00:	e24bd00c 	sub	sp, fp, #12
 c225e04:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225e08:	e12fff1e 	bx	lr

0c225e0c <isr_BDMA0_dummy>:
#include "dma.h"
#include "intcontroller.h"

void isr_BDMA0_dummy( void )  __attribute__ ((interrupt ("IRQ")));

void isr_BDMA0_dummy( void ) {
 c225e0c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c225e10:	e1a0c00d 	mov	ip, sp
 c225e14:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c225e18:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_BDMA0);
 c225e1c:	e3a00011 	mov	r0, #17
 c225e20:	eb000593 	bl	c227474 <ic_cleanflag>
}
 c225e24:	e24bd01c 	sub	sp, fp, #28
 c225e28:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c225e2c:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c225e30:	e25ef004 	subs	pc, lr, #4

0c225e34 <bdma0_init>:

void bdma0_init( void )
{
 c225e34:	e1a0c00d 	mov	ip, sp
 c225e38:	e92dd800 	push	{fp, ip, lr, pc}
 c225e3c:	e24cb004 	sub	fp, ip, #4
    rBDCON0  = 0;
 c225e40:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c225e44:	e3a02000 	mov	r2, #0
 c225e48:	e5832000 	str	r2, [r3]
    rBDISRC0 = 0;
 c225e4c:	e59f3034 	ldr	r3, [pc, #52]	; c225e88 <bdma0_init+0x54>
 c225e50:	e3a02000 	mov	r2, #0
 c225e54:	e5832000 	str	r2, [r3]
    rBDIDES0 = 0;
 c225e58:	e59f302c 	ldr	r3, [pc, #44]	; c225e8c <bdma0_init+0x58>
 c225e5c:	e3a02000 	mov	r2, #0
 c225e60:	e5832000 	str	r2, [r3]
    rBDICNT0 = 0;
 c225e64:	e59f3024 	ldr	r3, [pc, #36]	; c225e90 <bdma0_init+0x5c>
 c225e68:	e3a02000 	mov	r2, #0
 c225e6c:	e5832000 	str	r2, [r3]

    ic_conf_line(INT_BDMA0, IRQ);
 c225e70:	e3a00011 	mov	r0, #17
 c225e74:	e3a01000 	mov	r1, #0
 c225e78:	eb00051a 	bl	c2272e8 <ic_conf_line>
}
 c225e7c:	e24bd00c 	sub	sp, fp, #12
 c225e80:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225e84:	e12fff1e 	bx	lr
 c225e88:	01f80004 	.word	0x01f80004
 c225e8c:	01f80008 	.word	0x01f80008
 c225e90:	01f8000c 	.word	0x01f8000c

0c225e94 <bdma0_open>:

void bdma0_open( void (*isr)(void) )
{
 c225e94:	e1a0c00d 	mov	ip, sp
 c225e98:	e92dd800 	push	{fp, ip, lr, pc}
 c225e9c:	e24cb004 	sub	fp, ip, #4
 c225ea0:	e24dd008 	sub	sp, sp, #8
 c225ea4:	e50b0010 	str	r0, [fp, #-16]
    pISR_BDMA0 = (unsigned) isr;
 c225ea8:	e59f3020 	ldr	r3, [pc, #32]	; c225ed0 <bdma0_open+0x3c>
 c225eac:	e51b2010 	ldr	r2, [fp, #-16]
 c225eb0:	e5832000 	str	r2, [r3]
    ic_cleanflag(INT_BDMA0);
 c225eb4:	e3a00011 	mov	r0, #17
 c225eb8:	eb00056d 	bl	c227474 <ic_cleanflag>
    ic_enable(INT_BDMA0);
 c225ebc:	e3a00011 	mov	r0, #17
 c225ec0:	eb000538 	bl	c2273a8 <ic_enable>
}
 c225ec4:	e24bd00c 	sub	sp, fp, #12
 c225ec8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225ecc:	e12fff1e 	bx	lr
 c225ed0:	0c7fff64 	.word	0x0c7fff64

0c225ed4 <bdma0_close>:

void bdma0_close( void )
{
 c225ed4:	e1a0c00d 	mov	ip, sp
 c225ed8:	e92dd800 	push	{fp, ip, lr, pc}
 c225edc:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_BDMA0);
 c225ee0:	e3a00011 	mov	r0, #17
 c225ee4:	eb000549 	bl	c227410 <ic_disable>
    pISR_BDMA0 = (unsigned) isr_BDMA0_dummy;
 c225ee8:	e59f3010 	ldr	r3, [pc, #16]	; c225f00 <bdma0_close+0x2c>
 c225eec:	e59f2010 	ldr	r2, [pc, #16]	; c225f04 <bdma0_close+0x30>
 c225ef0:	e5832000 	str	r2, [r3]
}
 c225ef4:	e24bd00c 	sub	sp, fp, #12
 c225ef8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225efc:	e12fff1e 	bx	lr
 c225f00:	0c7fff64 	.word	0x0c7fff64
 c225f04:	0c225e0c 	.word	0x0c225e0c

0c225f08 <portB_conf>:
#include "gpio.h"

/* Port B interface implementation */

int portB_conf(int pin, enum port_mode mode)
{
 c225f08:	e1a0c00d 	mov	ip, sp
 c225f0c:	e92dd800 	push	{fp, ip, lr, pc}
 c225f10:	e24cb004 	sub	fp, ip, #4
 c225f14:	e24dd010 	sub	sp, sp, #16
 c225f18:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c225f1c:	e1a03001 	mov	r3, r1
 c225f20:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int ret = 0;
 c225f24:	e3a03000 	mov	r3, #0
 c225f28:	e50b3010 	str	r3, [fp, #-16]
	if (pin < 0 || pin > 10)
 c225f2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225f30:	e3530000 	cmp	r3, #0
 c225f34:	ba000002 	blt	c225f44 <portB_conf+0x3c>
 c225f38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c225f3c:	e353000a 	cmp	r3, #10
 c225f40:	da000001 	ble	c225f4c <portB_conf+0x44>
		return -1; // indica error
 c225f44:	e3e03000 	mvn	r3, #0
 c225f48:	ea00001b 	b	c225fbc <portB_conf+0xb4>

	if (mode == SIGOUT)
 c225f4c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c225f50:	e3530002 	cmp	r3, #2
 c225f54:	1a000008 	bne	c225f7c <portB_conf+0x74>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 1 para que por
		// dicho pin en el puerto B salga la seÃ±al correspondiente del
		// controlador de memoria
		rPCONB |= 1 << pin;
 c225f58:	e59f306c 	ldr	r3, [pc, #108]	; c225fcc <portB_conf+0xc4>
 c225f5c:	e59f2068 	ldr	r2, [pc, #104]	; c225fcc <portB_conf+0xc4>
 c225f60:	e5921000 	ldr	r1, [r2]
 c225f64:	e3a00001 	mov	r0, #1
 c225f68:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c225f6c:	e1a02210 	lsl	r2, r0, r2
 c225f70:	e1812002 	orr	r2, r1, r2
 c225f74:	e5832000 	str	r2, [r3]
 c225f78:	ea00000e 	b	c225fb8 <portB_conf+0xb0>
	else if (mode == OUTPUT)
 c225f7c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c225f80:	e3530001 	cmp	r3, #1
 c225f84:	1a000009 	bne	c225fb0 <portB_conf+0xa8>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 0 para que dicho
		// pin sea un pin de salida
		rPCONB &= ~(1 << pin);
 c225f88:	e59f303c 	ldr	r3, [pc, #60]	; c225fcc <portB_conf+0xc4>
 c225f8c:	e59f2038 	ldr	r2, [pc, #56]	; c225fcc <portB_conf+0xc4>
 c225f90:	e5921000 	ldr	r1, [r2]
 c225f94:	e3a00001 	mov	r0, #1
 c225f98:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c225f9c:	e1a02210 	lsl	r2, r0, r2
 c225fa0:	e1e02002 	mvn	r2, r2
 c225fa4:	e0012002 	and	r2, r1, r2
 c225fa8:	e5832000 	str	r2, [r3]
 c225fac:	ea000001 	b	c225fb8 <portB_conf+0xb0>
	else
		ret = -1; // indica error
 c225fb0:	e3e03000 	mvn	r3, #0
 c225fb4:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c225fb8:	e51b3010 	ldr	r3, [fp, #-16]
}
 c225fbc:	e1a00003 	mov	r0, r3
 c225fc0:	e24bd00c 	sub	sp, fp, #12
 c225fc4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c225fc8:	e12fff1e 	bx	lr
 c225fcc:	01d20008 	.word	0x01d20008

0c225fd0 <portB_write>:

int portB_write(int pin, enum digital val)
{
 c225fd0:	e1a0c00d 	mov	ip, sp
 c225fd4:	e92dd800 	push	{fp, ip, lr, pc}
 c225fd8:	e24cb004 	sub	fp, ip, #4
 c225fdc:	e24dd008 	sub	sp, sp, #8
 c225fe0:	e50b0010 	str	r0, [fp, #-16]
 c225fe4:	e1a03001 	mov	r3, r1
 c225fe8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 10)
 c225fec:	e51b3010 	ldr	r3, [fp, #-16]
 c225ff0:	e3530000 	cmp	r3, #0
 c225ff4:	ba000002 	blt	c226004 <portB_write+0x34>
 c225ff8:	e51b3010 	ldr	r3, [fp, #-16]
 c225ffc:	e353000a 	cmp	r3, #10
 c226000:	da000001 	ble	c22600c <portB_write+0x3c>
		return -1; // indica error
 c226004:	e3e03000 	mvn	r3, #0
 c226008:	ea00001a 	b	c226078 <portB_write+0xa8>

	if (val < 0 || val > 1)
 c22600c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c226010:	e3530001 	cmp	r3, #1
 c226014:	9a000001 	bls	c226020 <portB_write+0x50>
		return -1; // indica error
 c226018:	e3e03000 	mvn	r3, #0
 c22601c:	ea000015 	b	c226078 <portB_write+0xa8>

	if (val)
 c226020:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c226024:	e3530000 	cmp	r3, #0
 c226028:	0a000008 	beq	c226050 <portB_write+0x80>
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 1
		rPDATB |= 1 << pin;
 c22602c:	e59f3054 	ldr	r3, [pc, #84]	; c226088 <portB_write+0xb8>
 c226030:	e59f2050 	ldr	r2, [pc, #80]	; c226088 <portB_write+0xb8>
 c226034:	e5921000 	ldr	r1, [r2]
 c226038:	e3a00001 	mov	r0, #1
 c22603c:	e51b2010 	ldr	r2, [fp, #-16]
 c226040:	e1a02210 	lsl	r2, r0, r2
 c226044:	e1812002 	orr	r2, r1, r2
 c226048:	e5832000 	str	r2, [r3]
 c22604c:	ea000008 	b	c226074 <portB_write+0xa4>
	else
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 0
		rPDATB &= ~(1 << pin);
 c226050:	e59f3030 	ldr	r3, [pc, #48]	; c226088 <portB_write+0xb8>
 c226054:	e59f202c 	ldr	r2, [pc, #44]	; c226088 <portB_write+0xb8>
 c226058:	e5921000 	ldr	r1, [r2]
 c22605c:	e3a00001 	mov	r0, #1
 c226060:	e51b2010 	ldr	r2, [fp, #-16]
 c226064:	e1a02210 	lsl	r2, r0, r2
 c226068:	e1e02002 	mvn	r2, r2
 c22606c:	e0012002 	and	r2, r1, r2
 c226070:	e5832000 	str	r2, [r3]

	return 0;
 c226074:	e3a03000 	mov	r3, #0
}
 c226078:	e1a00003 	mov	r0, r3
 c22607c:	e24bd00c 	sub	sp, fp, #12
 c226080:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226084:	e12fff1e 	bx	lr
 c226088:	01d2000c 	.word	0x01d2000c

0c22608c <portG_conf>:

/* Port G interface implementation */

int portG_conf(int pin, enum port_mode mode)
{
 c22608c:	e1a0c00d 	mov	ip, sp
 c226090:	e92dd800 	push	{fp, ip, lr, pc}
 c226094:	e24cb004 	sub	fp, ip, #4
 c226098:	e24dd010 	sub	sp, sp, #16
 c22609c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c2260a0:	e1a03001 	mov	r3, r1
 c2260a4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos  = pin*2;
 c2260a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2260ac:	e1a03083 	lsl	r3, r3, #1
 c2260b0:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c2260b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2260b8:	e3530000 	cmp	r3, #0
 c2260bc:	ba000002 	blt	c2260cc <portG_conf+0x40>
 c2260c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2260c4:	e3530007 	cmp	r3, #7
 c2260c8:	da000001 	ble	c2260d4 <portG_conf+0x48>
		return -1; // indica error
 c2260cc:	e3e03000 	mvn	r3, #0
 c2260d0:	ea000056 	b	c226230 <portG_conf+0x1a4>

	switch (mode) {
 c2260d4:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c2260d8:	e3530003 	cmp	r3, #3
 c2260dc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c2260e0:	ea00004f 	b	c226224 <portG_conf+0x198>
 c2260e4:	0c2260f4 	.word	0x0c2260f4
 c2260e8:	0c226144 	.word	0x0c226144
 c2260ec:	0c226190 	.word	0x0c226190
 c2260f0:	0c2261dc 	.word	0x0c2261dc
		case INPUT:
			// COMPLETAR: poner en rPCONG 00 a partir de la posiciÃ³n pos para
			// configurar como pin de entrada el pin indicado por el parÃ¡metro pin
			rPCONG &= ~(1 << pos);  	 // 0
 c2260f4:	e59f3144 	ldr	r3, [pc, #324]	; c226240 <portG_conf+0x1b4>
 c2260f8:	e59f2140 	ldr	r2, [pc, #320]	; c226240 <portG_conf+0x1b4>
 c2260fc:	e5921000 	ldr	r1, [r2]
 c226100:	e3a00001 	mov	r0, #1
 c226104:	e51b2010 	ldr	r2, [fp, #-16]
 c226108:	e1a02210 	lsl	r2, r0, r2
 c22610c:	e1e02002 	mvn	r2, r2
 c226110:	e0012002 	and	r2, r1, r2
 c226114:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c226118:	e59f3120 	ldr	r3, [pc, #288]	; c226240 <portG_conf+0x1b4>
 c22611c:	e59f211c 	ldr	r2, [pc, #284]	; c226240 <portG_conf+0x1b4>
 c226120:	e5921000 	ldr	r1, [r2]
 c226124:	e51b2010 	ldr	r2, [fp, #-16]
 c226128:	e2822001 	add	r2, r2, #1
 c22612c:	e3a00001 	mov	r0, #1
 c226130:	e1a02210 	lsl	r2, r0, r2
 c226134:	e1e02002 	mvn	r2, r2
 c226138:	e0012002 	and	r2, r1, r2
 c22613c:	e5832000 	str	r2, [r3]
			break;
 c226140:	ea000039 	b	c22622c <portG_conf+0x1a0>
		case OUTPUT:
			// COMPLETAR: poner en rPCONG 01 a partir de la posiciÃ³n pos para
			// configurar como pin de salida el pin indicado por el parÃ¡metro pin
			rPCONG |= 1 << pos;			 // 1
 c226144:	e59f30f4 	ldr	r3, [pc, #244]	; c226240 <portG_conf+0x1b4>
 c226148:	e59f20f0 	ldr	r2, [pc, #240]	; c226240 <portG_conf+0x1b4>
 c22614c:	e5921000 	ldr	r1, [r2]
 c226150:	e3a00001 	mov	r0, #1
 c226154:	e51b2010 	ldr	r2, [fp, #-16]
 c226158:	e1a02210 	lsl	r2, r0, r2
 c22615c:	e1812002 	orr	r2, r1, r2
 c226160:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c226164:	e59f30d4 	ldr	r3, [pc, #212]	; c226240 <portG_conf+0x1b4>
 c226168:	e59f20d0 	ldr	r2, [pc, #208]	; c226240 <portG_conf+0x1b4>
 c22616c:	e5921000 	ldr	r1, [r2]
 c226170:	e51b2010 	ldr	r2, [fp, #-16]
 c226174:	e2822001 	add	r2, r2, #1
 c226178:	e3a00001 	mov	r0, #1
 c22617c:	e1a02210 	lsl	r2, r0, r2
 c226180:	e1e02002 	mvn	r2, r2
 c226184:	e0012002 	and	r2, r1, r2
 c226188:	e5832000 	str	r2, [r3]
			break;
 c22618c:	ea000026 	b	c22622c <portG_conf+0x1a0>
		case SIGOUT:
			// COMPLETAR: poner en rPCONG 10 a partir de la posiciÃ³n pos para
			// que salga la seÃ±al interna correspondiente por el pin indicado
			// por el parÃ¡metro pin
			rPCONG &= ~(1 << pos); 		// 0
 c226190:	e59f30a8 	ldr	r3, [pc, #168]	; c226240 <portG_conf+0x1b4>
 c226194:	e59f20a4 	ldr	r2, [pc, #164]	; c226240 <portG_conf+0x1b4>
 c226198:	e5921000 	ldr	r1, [r2]
 c22619c:	e3a00001 	mov	r0, #1
 c2261a0:	e51b2010 	ldr	r2, [fp, #-16]
 c2261a4:	e1a02210 	lsl	r2, r0, r2
 c2261a8:	e1e02002 	mvn	r2, r2
 c2261ac:	e0012002 	and	r2, r1, r2
 c2261b0:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c2261b4:	e59f3084 	ldr	r3, [pc, #132]	; c226240 <portG_conf+0x1b4>
 c2261b8:	e59f2080 	ldr	r2, [pc, #128]	; c226240 <portG_conf+0x1b4>
 c2261bc:	e5921000 	ldr	r1, [r2]
 c2261c0:	e51b2010 	ldr	r2, [fp, #-16]
 c2261c4:	e2822001 	add	r2, r2, #1
 c2261c8:	e3a00001 	mov	r0, #1
 c2261cc:	e1a02210 	lsl	r2, r0, r2
 c2261d0:	e1812002 	orr	r2, r1, r2
 c2261d4:	e5832000 	str	r2, [r3]
			break;
 c2261d8:	ea000013 	b	c22622c <portG_conf+0x1a0>
		case EINT:
			// COMPLETAR: poner en rPCONG 11 a partir de la posiciÃ³n pos para
			// habilitar la generaciÃ³n de interrupciones externas por el pin
			// indicado por el parÃ¡metro pin
			rPCONG |= 1 << pos;			// 1
 c2261dc:	e59f305c 	ldr	r3, [pc, #92]	; c226240 <portG_conf+0x1b4>
 c2261e0:	e59f2058 	ldr	r2, [pc, #88]	; c226240 <portG_conf+0x1b4>
 c2261e4:	e5921000 	ldr	r1, [r2]
 c2261e8:	e3a00001 	mov	r0, #1
 c2261ec:	e51b2010 	ldr	r2, [fp, #-16]
 c2261f0:	e1a02210 	lsl	r2, r0, r2
 c2261f4:	e1812002 	orr	r2, r1, r2
 c2261f8:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c2261fc:	e59f303c 	ldr	r3, [pc, #60]	; c226240 <portG_conf+0x1b4>
 c226200:	e59f2038 	ldr	r2, [pc, #56]	; c226240 <portG_conf+0x1b4>
 c226204:	e5921000 	ldr	r1, [r2]
 c226208:	e51b2010 	ldr	r2, [fp, #-16]
 c22620c:	e2822001 	add	r2, r2, #1
 c226210:	e3a00001 	mov	r0, #1
 c226214:	e1a02210 	lsl	r2, r0, r2
 c226218:	e1812002 	orr	r2, r1, r2
 c22621c:	e5832000 	str	r2, [r3]
			break;
 c226220:	ea000001 	b	c22622c <portG_conf+0x1a0>
		default:
			return -1;
 c226224:	e3e03000 	mvn	r3, #0
 c226228:	ea000000 	b	c226230 <portG_conf+0x1a4>
	}

	return 0;
 c22622c:	e3a03000 	mov	r3, #0
}
 c226230:	e1a00003 	mov	r0, r3
 c226234:	e24bd00c 	sub	sp, fp, #12
 c226238:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22623c:	e12fff1e 	bx	lr
 c226240:	01d20040 	.word	0x01d20040

0c226244 <portG_eint_trig>:

int portG_eint_trig(int pin, enum trigger trig)
{
 c226244:	e1a0c00d 	mov	ip, sp
 c226248:	e92dd800 	push	{fp, ip, lr, pc}
 c22624c:	e24cb004 	sub	fp, ip, #4
 c226250:	e24dd010 	sub	sp, sp, #16
 c226254:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c226258:	e1a03001 	mov	r3, r1
 c22625c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*4;
 c226260:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226264:	e1a03103 	lsl	r3, r3, #2
 c226268:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c22626c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226270:	e3530000 	cmp	r3, #0
 c226274:	ba000002 	blt	c226284 <portG_eint_trig+0x40>
 c226278:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22627c:	e3530007 	cmp	r3, #7
 c226280:	da000001 	ble	c22628c <portG_eint_trig+0x48>
		return -1;
 c226284:	e3e03000 	mvn	r3, #0
 c226288:	ea00009c 	b	c226500 <portG_eint_trig+0x2bc>

switch (trig) {
 c22628c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c226290:	e3530004 	cmp	r3, #4
 c226294:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c226298:	ea000095 	b	c2264f4 <portG_eint_trig+0x2b0>
 c22629c:	0c2262b0 	.word	0x0c2262b0
 c2262a0:	0c226328 	.word	0x0c226328
 c2262a4:	0c22639c 	.word	0x0c22639c
 c2262a8:	0c226410 	.word	0x0c226410
 c2262ac:	0c226484 	.word	0x0c226484
		case LLOW:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 000, para configurar interrupciones externas por nivel bajo
			rEXTINT &= ~(1 << pos);	 		// 0
 c2262b0:	e59f3258 	ldr	r3, [pc, #600]	; c226510 <portG_eint_trig+0x2cc>
 c2262b4:	e59f2254 	ldr	r2, [pc, #596]	; c226510 <portG_eint_trig+0x2cc>
 c2262b8:	e5921000 	ldr	r1, [r2]
 c2262bc:	e3a00001 	mov	r0, #1
 c2262c0:	e51b2010 	ldr	r2, [fp, #-16]
 c2262c4:	e1a02210 	lsl	r2, r0, r2
 c2262c8:	e1e02002 	mvn	r2, r2
 c2262cc:	e0012002 	and	r2, r1, r2
 c2262d0:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c2262d4:	e59f3234 	ldr	r3, [pc, #564]	; c226510 <portG_eint_trig+0x2cc>
 c2262d8:	e59f2230 	ldr	r2, [pc, #560]	; c226510 <portG_eint_trig+0x2cc>
 c2262dc:	e5921000 	ldr	r1, [r2]
 c2262e0:	e51b2010 	ldr	r2, [fp, #-16]
 c2262e4:	e2822001 	add	r2, r2, #1
 c2262e8:	e3a00001 	mov	r0, #1
 c2262ec:	e1a02210 	lsl	r2, r0, r2
 c2262f0:	e1e02002 	mvn	r2, r2
 c2262f4:	e0012002 	and	r2, r1, r2
 c2262f8:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c2262fc:	e59f320c 	ldr	r3, [pc, #524]	; c226510 <portG_eint_trig+0x2cc>
 c226300:	e59f2208 	ldr	r2, [pc, #520]	; c226510 <portG_eint_trig+0x2cc>
 c226304:	e5921000 	ldr	r1, [r2]
 c226308:	e51b2010 	ldr	r2, [fp, #-16]
 c22630c:	e2822002 	add	r2, r2, #2
 c226310:	e3a00001 	mov	r0, #1
 c226314:	e1a02210 	lsl	r2, r0, r2
 c226318:	e1e02002 	mvn	r2, r2
 c22631c:	e0012002 	and	r2, r1, r2
 c226320:	e5832000 	str	r2, [r3]
			break;
 c226324:	ea000074 	b	c2264fc <portG_eint_trig+0x2b8>
		case LHIGH:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 001, para configurar interrupciones externas por nivel alto
			rEXTINT |= 1 << pos;	 		// 1
 c226328:	e59f31e0 	ldr	r3, [pc, #480]	; c226510 <portG_eint_trig+0x2cc>
 c22632c:	e59f21dc 	ldr	r2, [pc, #476]	; c226510 <portG_eint_trig+0x2cc>
 c226330:	e5921000 	ldr	r1, [r2]
 c226334:	e3a00001 	mov	r0, #1
 c226338:	e51b2010 	ldr	r2, [fp, #-16]
 c22633c:	e1a02210 	lsl	r2, r0, r2
 c226340:	e1812002 	orr	r2, r1, r2
 c226344:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c226348:	e59f31c0 	ldr	r3, [pc, #448]	; c226510 <portG_eint_trig+0x2cc>
 c22634c:	e59f21bc 	ldr	r2, [pc, #444]	; c226510 <portG_eint_trig+0x2cc>
 c226350:	e5921000 	ldr	r1, [r2]
 c226354:	e51b2010 	ldr	r2, [fp, #-16]
 c226358:	e2822001 	add	r2, r2, #1
 c22635c:	e3a00001 	mov	r0, #1
 c226360:	e1a02210 	lsl	r2, r0, r2
 c226364:	e1e02002 	mvn	r2, r2
 c226368:	e0012002 	and	r2, r1, r2
 c22636c:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c226370:	e59f3198 	ldr	r3, [pc, #408]	; c226510 <portG_eint_trig+0x2cc>
 c226374:	e59f2194 	ldr	r2, [pc, #404]	; c226510 <portG_eint_trig+0x2cc>
 c226378:	e5921000 	ldr	r1, [r2]
 c22637c:	e51b2010 	ldr	r2, [fp, #-16]
 c226380:	e2822002 	add	r2, r2, #2
 c226384:	e3a00001 	mov	r0, #1
 c226388:	e1a02210 	lsl	r2, r0, r2
 c22638c:	e1e02002 	mvn	r2, r2
 c226390:	e0012002 	and	r2, r1, r2
 c226394:	e5832000 	str	r2, [r3]
			break;
 c226398:	ea000057 	b	c2264fc <portG_eint_trig+0x2b8>
		case FALLING:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 010, para configurar interrupciones externas por flanco de
			// bajada
			rEXTINT &= ~(1 << pos);	 		// 0
 c22639c:	e59f316c 	ldr	r3, [pc, #364]	; c226510 <portG_eint_trig+0x2cc>
 c2263a0:	e59f2168 	ldr	r2, [pc, #360]	; c226510 <portG_eint_trig+0x2cc>
 c2263a4:	e5921000 	ldr	r1, [r2]
 c2263a8:	e3a00001 	mov	r0, #1
 c2263ac:	e51b2010 	ldr	r2, [fp, #-16]
 c2263b0:	e1a02210 	lsl	r2, r0, r2
 c2263b4:	e1e02002 	mvn	r2, r2
 c2263b8:	e0012002 	and	r2, r1, r2
 c2263bc:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c2263c0:	e59f3148 	ldr	r3, [pc, #328]	; c226510 <portG_eint_trig+0x2cc>
 c2263c4:	e59f2144 	ldr	r2, [pc, #324]	; c226510 <portG_eint_trig+0x2cc>
 c2263c8:	e5921000 	ldr	r1, [r2]
 c2263cc:	e51b2010 	ldr	r2, [fp, #-16]
 c2263d0:	e2822001 	add	r2, r2, #1
 c2263d4:	e3a00001 	mov	r0, #1
 c2263d8:	e1a02210 	lsl	r2, r0, r2
 c2263dc:	e1812002 	orr	r2, r1, r2
 c2263e0:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c2263e4:	e59f3124 	ldr	r3, [pc, #292]	; c226510 <portG_eint_trig+0x2cc>
 c2263e8:	e59f2120 	ldr	r2, [pc, #288]	; c226510 <portG_eint_trig+0x2cc>
 c2263ec:	e5921000 	ldr	r1, [r2]
 c2263f0:	e51b2010 	ldr	r2, [fp, #-16]
 c2263f4:	e2822002 	add	r2, r2, #2
 c2263f8:	e3a00001 	mov	r0, #1
 c2263fc:	e1a02210 	lsl	r2, r0, r2
 c226400:	e1e02002 	mvn	r2, r2
 c226404:	e0012002 	and	r2, r1, r2
 c226408:	e5832000 	str	r2, [r3]
			break;
 c22640c:	ea00003a 	b	c2264fc <portG_eint_trig+0x2b8>
		case RISING:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 100, para configurar interrupciones externas por flanco de
			// subida
			rEXTINT &= ~(1 << pos);	 		// 0
 c226410:	e59f30f8 	ldr	r3, [pc, #248]	; c226510 <portG_eint_trig+0x2cc>
 c226414:	e59f20f4 	ldr	r2, [pc, #244]	; c226510 <portG_eint_trig+0x2cc>
 c226418:	e5921000 	ldr	r1, [r2]
 c22641c:	e3a00001 	mov	r0, #1
 c226420:	e51b2010 	ldr	r2, [fp, #-16]
 c226424:	e1a02210 	lsl	r2, r0, r2
 c226428:	e1e02002 	mvn	r2, r2
 c22642c:	e0012002 	and	r2, r1, r2
 c226430:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c226434:	e59f30d4 	ldr	r3, [pc, #212]	; c226510 <portG_eint_trig+0x2cc>
 c226438:	e59f20d0 	ldr	r2, [pc, #208]	; c226510 <portG_eint_trig+0x2cc>
 c22643c:	e5921000 	ldr	r1, [r2]
 c226440:	e51b2010 	ldr	r2, [fp, #-16]
 c226444:	e2822001 	add	r2, r2, #1
 c226448:	e3a00001 	mov	r0, #1
 c22644c:	e1a02210 	lsl	r2, r0, r2
 c226450:	e1e02002 	mvn	r2, r2
 c226454:	e0012002 	and	r2, r1, r2
 c226458:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c22645c:	e59f30ac 	ldr	r3, [pc, #172]	; c226510 <portG_eint_trig+0x2cc>
 c226460:	e59f20a8 	ldr	r2, [pc, #168]	; c226510 <portG_eint_trig+0x2cc>
 c226464:	e5921000 	ldr	r1, [r2]
 c226468:	e51b2010 	ldr	r2, [fp, #-16]
 c22646c:	e2822002 	add	r2, r2, #2
 c226470:	e3a00001 	mov	r0, #1
 c226474:	e1a02210 	lsl	r2, r0, r2
 c226478:	e1812002 	orr	r2, r1, r2
 c22647c:	e5832000 	str	r2, [r3]
			break;
 c226480:	ea00001d 	b	c2264fc <portG_eint_trig+0x2b8>
		case EDGE:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 110, para configurar interrupciones externas por cualquier
			// flanco
			rEXTINT &= ~(1 << pos);	 		// 0
 c226484:	e59f3084 	ldr	r3, [pc, #132]	; c226510 <portG_eint_trig+0x2cc>
 c226488:	e59f2080 	ldr	r2, [pc, #128]	; c226510 <portG_eint_trig+0x2cc>
 c22648c:	e5921000 	ldr	r1, [r2]
 c226490:	e3a00001 	mov	r0, #1
 c226494:	e51b2010 	ldr	r2, [fp, #-16]
 c226498:	e1a02210 	lsl	r2, r0, r2
 c22649c:	e1e02002 	mvn	r2, r2
 c2264a0:	e0012002 	and	r2, r1, r2
 c2264a4:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c2264a8:	e59f3060 	ldr	r3, [pc, #96]	; c226510 <portG_eint_trig+0x2cc>
 c2264ac:	e59f205c 	ldr	r2, [pc, #92]	; c226510 <portG_eint_trig+0x2cc>
 c2264b0:	e5921000 	ldr	r1, [r2]
 c2264b4:	e51b2010 	ldr	r2, [fp, #-16]
 c2264b8:	e2822001 	add	r2, r2, #1
 c2264bc:	e3a00001 	mov	r0, #1
 c2264c0:	e1a02210 	lsl	r2, r0, r2
 c2264c4:	e1812002 	orr	r2, r1, r2
 c2264c8:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c2264cc:	e59f303c 	ldr	r3, [pc, #60]	; c226510 <portG_eint_trig+0x2cc>
 c2264d0:	e59f2038 	ldr	r2, [pc, #56]	; c226510 <portG_eint_trig+0x2cc>
 c2264d4:	e5921000 	ldr	r1, [r2]
 c2264d8:	e51b2010 	ldr	r2, [fp, #-16]
 c2264dc:	e2822002 	add	r2, r2, #2
 c2264e0:	e3a00001 	mov	r0, #1
 c2264e4:	e1a02210 	lsl	r2, r0, r2
 c2264e8:	e1812002 	orr	r2, r1, r2
 c2264ec:	e5832000 	str	r2, [r3]
			break;
 c2264f0:	ea000001 	b	c2264fc <portG_eint_trig+0x2b8>
		default:
			return -1;
 c2264f4:	e3e03000 	mvn	r3, #0
 c2264f8:	ea000000 	b	c226500 <portG_eint_trig+0x2bc>
	}
	return 0;
 c2264fc:	e3a03000 	mov	r3, #0
}
 c226500:	e1a00003 	mov	r0, r3
 c226504:	e24bd00c 	sub	sp, fp, #12
 c226508:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22650c:	e12fff1e 	bx	lr
 c226510:	01d20050 	.word	0x01d20050

0c226514 <portG_write>:

int portG_write(int pin, enum digital val)
{
 c226514:	e1a0c00d 	mov	ip, sp
 c226518:	e92dd800 	push	{fp, ip, lr, pc}
 c22651c:	e24cb004 	sub	fp, ip, #4
 c226520:	e24dd010 	sub	sp, sp, #16
 c226524:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c226528:	e1a03001 	mov	r3, r1
 c22652c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*2;
 c226530:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226534:	e1a03083 	lsl	r3, r3, #1
 c226538:	e50b3010 	str	r3, [fp, #-16]

		if (pin < 0 || pin > 7)
 c22653c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226540:	e3530000 	cmp	r3, #0
 c226544:	ba000002 	blt	c226554 <portG_write+0x40>
 c226548:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22654c:	e3530007 	cmp	r3, #7
 c226550:	da000001 	ble	c22655c <portG_write+0x48>
			return -1; // indica error
 c226554:	e3e03000 	mvn	r3, #0
 c226558:	ea000027 	b	c2265fc <portG_write+0xe8>

		if (val < 0 || val > 1)
 c22655c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c226560:	e3530001 	cmp	r3, #1
 c226564:	9a000001 	bls	c226570 <portG_write+0x5c>
			return -1; // indica error
 c226568:	e3e03000 	mvn	r3, #0
 c22656c:	ea000022 	b	c2265fc <portG_write+0xe8>

		if ((rPCONG & (0x3 << pos)) != (0x1 << pos))
 c226570:	e59f3094 	ldr	r3, [pc, #148]	; c22660c <portG_write+0xf8>
 c226574:	e5932000 	ldr	r2, [r3]
 c226578:	e3a01003 	mov	r1, #3
 c22657c:	e51b3010 	ldr	r3, [fp, #-16]
 c226580:	e1a03311 	lsl	r3, r1, r3
 c226584:	e0022003 	and	r2, r2, r3
 c226588:	e3a01001 	mov	r1, #1
 c22658c:	e51b3010 	ldr	r3, [fp, #-16]
 c226590:	e1a03311 	lsl	r3, r1, r3
 c226594:	e1520003 	cmp	r2, r3
 c226598:	0a000001 	beq	c2265a4 <portG_write+0x90>
			return -1; // indica error
 c22659c:	e3e03000 	mvn	r3, #0
 c2265a0:	ea000015 	b	c2265fc <portG_write+0xe8>

		if (val)
 c2265a4:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c2265a8:	e3530000 	cmp	r3, #0
 c2265ac:	0a000008 	beq	c2265d4 <portG_write+0xc0>
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 1
			rPDATG |= 1 << pin;
 c2265b0:	e59f3058 	ldr	r3, [pc, #88]	; c226610 <portG_write+0xfc>
 c2265b4:	e59f2054 	ldr	r2, [pc, #84]	; c226610 <portG_write+0xfc>
 c2265b8:	e5921000 	ldr	r1, [r2]
 c2265bc:	e3a00001 	mov	r0, #1
 c2265c0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c2265c4:	e1a02210 	lsl	r2, r0, r2
 c2265c8:	e1812002 	orr	r2, r1, r2
 c2265cc:	e5832000 	str	r2, [r3]
 c2265d0:	ea000008 	b	c2265f8 <portG_write+0xe4>
		else
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 0
			rPDATG &= ~(1 << pin);
 c2265d4:	e59f3034 	ldr	r3, [pc, #52]	; c226610 <portG_write+0xfc>
 c2265d8:	e59f2030 	ldr	r2, [pc, #48]	; c226610 <portG_write+0xfc>
 c2265dc:	e5921000 	ldr	r1, [r2]
 c2265e0:	e3a00001 	mov	r0, #1
 c2265e4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c2265e8:	e1a02210 	lsl	r2, r0, r2
 c2265ec:	e1e02002 	mvn	r2, r2
 c2265f0:	e0012002 	and	r2, r1, r2
 c2265f4:	e5832000 	str	r2, [r3]

		return 0;
 c2265f8:	e3a03000 	mov	r3, #0
}
 c2265fc:	e1a00003 	mov	r0, r3
 c226600:	e24bd00c 	sub	sp, fp, #12
 c226604:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226608:	e12fff1e 	bx	lr
 c22660c:	01d20040 	.word	0x01d20040
 c226610:	01d20044 	.word	0x01d20044

0c226614 <portG_read>:

int portG_read(int pin, enum digital* val)
{
 c226614:	e1a0c00d 	mov	ip, sp
 c226618:	e92dd800 	push	{fp, ip, lr, pc}
 c22661c:	e24cb004 	sub	fp, ip, #4
 c226620:	e24dd010 	sub	sp, sp, #16
 c226624:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c226628:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
	int pos = pin*2;
 c22662c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226630:	e1a03083 	lsl	r3, r3, #1
 c226634:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c226638:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22663c:	e3530000 	cmp	r3, #0
 c226640:	ba000002 	blt	c226650 <portG_read+0x3c>
 c226644:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226648:	e3530007 	cmp	r3, #7
 c22664c:	da000001 	ble	c226658 <portG_read+0x44>
		return -1; // indica error
 c226650:	e3e03000 	mvn	r3, #0
 c226654:	ea000019 	b	c2266c0 <portG_read+0xac>

	if (rPCONG & (0x3 << pos))
 c226658:	e59f3070 	ldr	r3, [pc, #112]	; c2266d0 <portG_read+0xbc>
 c22665c:	e5932000 	ldr	r2, [r3]
 c226660:	e3a01003 	mov	r1, #3
 c226664:	e51b3010 	ldr	r3, [fp, #-16]
 c226668:	e1a03311 	lsl	r3, r1, r3
 c22666c:	e0023003 	and	r3, r2, r3
 c226670:	e3530000 	cmp	r3, #0
 c226674:	0a000001 	beq	c226680 <portG_read+0x6c>
		return -1; // indica error
 c226678:	e3e03000 	mvn	r3, #0
 c22667c:	ea00000f 	b	c2266c0 <portG_read+0xac>

	/*COMPLETAR: true si estÃ¡ a 1 en rPDATG el pin indicado por el parÃ¡metro pin*/
	if (rPDATG & (1 << pin))
 c226680:	e59f304c 	ldr	r3, [pc, #76]	; c2266d4 <portG_read+0xc0>
 c226684:	e5932000 	ldr	r2, [r3]
 c226688:	e3a01001 	mov	r1, #1
 c22668c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226690:	e1a03311 	lsl	r3, r1, r3
 c226694:	e0023003 	and	r3, r2, r3
 c226698:	e3530000 	cmp	r3, #0
 c22669c:	0a000003 	beq	c2266b0 <portG_read+0x9c>
		*val = HIGH;
 c2266a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2266a4:	e3a02001 	mov	r2, #1
 c2266a8:	e5c32000 	strb	r2, [r3]
 c2266ac:	ea000002 	b	c2266bc <portG_read+0xa8>
	else
		*val = LOW;
 c2266b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c2266b4:	e3a02000 	mov	r2, #0
 c2266b8:	e5c32000 	strb	r2, [r3]

	return 0;
 c2266bc:	e3a03000 	mov	r3, #0
}
 c2266c0:	e1a00003 	mov	r0, r3
 c2266c4:	e24bd00c 	sub	sp, fp, #12
 c2266c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2266cc:	e12fff1e 	bx	lr
 c2266d0:	01d20040 	.word	0x01d20040
 c2266d4:	01d20044 	.word	0x01d20044

0c2266d8 <portG_conf_pup>:

int portG_conf_pup(int pin, enum enable st)
{
 c2266d8:	e1a0c00d 	mov	ip, sp
 c2266dc:	e92dd800 	push	{fp, ip, lr, pc}
 c2266e0:	e24cb004 	sub	fp, ip, #4
 c2266e4:	e24dd008 	sub	sp, sp, #8
 c2266e8:	e50b0010 	str	r0, [fp, #-16]
 c2266ec:	e1a03001 	mov	r3, r1
 c2266f0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 7)
 c2266f4:	e51b3010 	ldr	r3, [fp, #-16]
 c2266f8:	e3530000 	cmp	r3, #0
 c2266fc:	ba000002 	blt	c22670c <portG_conf_pup+0x34>
 c226700:	e51b3010 	ldr	r3, [fp, #-16]
 c226704:	e3530007 	cmp	r3, #7
 c226708:	da000001 	ble	c226714 <portG_conf_pup+0x3c>
		return -1; // indica error
 c22670c:	e3e03000 	mvn	r3, #0
 c226710:	ea00001d 	b	c22678c <portG_conf_pup+0xb4>

	if (st != ENABLE && st != DISABLE)
 c226714:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c226718:	e3530001 	cmp	r3, #1
 c22671c:	0a000004 	beq	c226734 <portG_conf_pup+0x5c>
 c226720:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c226724:	e3530000 	cmp	r3, #0
 c226728:	0a000001 	beq	c226734 <portG_conf_pup+0x5c>
		return -1; // indica error
 c22672c:	e3e03000 	mvn	r3, #0
 c226730:	ea000015 	b	c22678c <portG_conf_pup+0xb4>

	if (st == ENABLE)
 c226734:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c226738:	e3530001 	cmp	r3, #1
 c22673c:	1a000009 	bne	c226768 <portG_conf_pup+0x90>
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para activar la resistencia de pull-up
		rPUPG &= ~(1 << pin);
 c226740:	e59f3054 	ldr	r3, [pc, #84]	; c22679c <portG_conf_pup+0xc4>
 c226744:	e59f2050 	ldr	r2, [pc, #80]	; c22679c <portG_conf_pup+0xc4>
 c226748:	e5921000 	ldr	r1, [r2]
 c22674c:	e3a00001 	mov	r0, #1
 c226750:	e51b2010 	ldr	r2, [fp, #-16]
 c226754:	e1a02210 	lsl	r2, r0, r2
 c226758:	e1e02002 	mvn	r2, r2
 c22675c:	e0012002 	and	r2, r1, r2
 c226760:	e5832000 	str	r2, [r3]
 c226764:	ea000007 	b	c226788 <portG_conf_pup+0xb0>
	else
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para desactivar la resistencia de pull-up
		rPUPG |= 1 << pin;
 c226768:	e59f302c 	ldr	r3, [pc, #44]	; c22679c <portG_conf_pup+0xc4>
 c22676c:	e59f2028 	ldr	r2, [pc, #40]	; c22679c <portG_conf_pup+0xc4>
 c226770:	e5921000 	ldr	r1, [r2]
 c226774:	e3a00001 	mov	r0, #1
 c226778:	e51b2010 	ldr	r2, [fp, #-16]
 c22677c:	e1a02210 	lsl	r2, r0, r2
 c226780:	e1812002 	orr	r2, r1, r2
 c226784:	e5832000 	str	r2, [r3]

	return 0;
 c226788:	e3a03000 	mov	r3, #0
}
 c22678c:	e1a00003 	mov	r0, r3
 c226790:	e24bd00c 	sub	sp, fp, #12
 c226794:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226798:	e12fff1e 	bx	lr
 c22679c:	01d20048 	.word	0x01d20048

0c2267a0 <iic_init>:
#include "44b.h"
#include "iic.h"
#include "utils.h"

void iic_init( void )
{
 c2267a0:	e1a0c00d 	mov	ip, sp
 c2267a4:	e92dd800 	push	{fp, ip, lr, pc}
 c2267a8:	e24cb004 	sub	fp, ip, #4
	//Slave Address: Undefined, always going to be master
	rIICADD = 0;
 c2267ac:	e59f3028 	ldr	r3, [pc, #40]	; c2267dc <iic_init+0x3c>
 c2267b0:	e3a02000 	mov	r2, #0
 c2267b4:	e5832000 	str	r2, [r3]
	//*250kHz
	//IICCON[7]	  = 1   Generate ACK
	//IICCON[6]   = 0   IICCLK = MCLK / 16
	//IICCON[5]   = 1	Enable RX/TX Interrupts
	//IICCON[3:0] = 15  TxCLK = IICCLK / (15+1) = 64 MHz / 256
	rIICCON = 0xAF;
 c2267b8:	e59f3020 	ldr	r3, [pc, #32]	; c2267e0 <iic_init+0x40>
 c2267bc:	e3a020af 	mov	r2, #175	; 0xaf
 c2267c0:	e5832000 	str	r2, [r3]

	//*Transfer mode: set per transfer
	//ICCSTAT[4] = 1 read/write enable
	rIICSTAT = 0x10;
 c2267c4:	e59f3018 	ldr	r3, [pc, #24]	; c2267e4 <iic_init+0x44>
 c2267c8:	e3a02010 	mov	r2, #16
 c2267cc:	e5832000 	str	r2, [r3]
}
 c2267d0:	e24bd00c 	sub	sp, fp, #12
 c2267d4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2267d8:	e12fff1e 	bx	lr
 c2267dc:	01d60008 	.word	0x01d60008
 c2267e0:	01d60000 	.word	0x01d60000
 c2267e4:	01d60004 	.word	0x01d60004

0c2267e8 <iic_start>:

void iic_start(enum IIC_Mode_t mode, uint8 addr)
{
 c2267e8:	e1a0c00d 	mov	ip, sp
 c2267ec:	e92dd800 	push	{fp, ip, lr, pc}
 c2267f0:	e24cb004 	sub	fp, ip, #4
 c2267f4:	e24dd008 	sub	sp, sp, #8
 c2267f8:	e1a02000 	mov	r2, r0
 c2267fc:	e1a03001 	mov	r3, r1
 c226800:	e54b200d 	strb	r2, [fp, #-13]
 c226804:	e54b300e 	strb	r3, [fp, #-14]
	//Address
    rIICDS = addr;
 c226808:	e59f3050 	ldr	r3, [pc, #80]	; c226860 <iic_start+0x78>
 c22680c:	e55b200e 	ldrb	r2, [fp, #-14]
 c226810:	e5832000 	str	r2, [r3]

    //Set mode, send START signal, Serial Output enable
    rIICSTAT = mode << 6 | 0b11 << 4;
 c226814:	e59f3048 	ldr	r3, [pc, #72]	; c226864 <iic_start+0x7c>
 c226818:	e55b200d 	ldrb	r2, [fp, #-13]
 c22681c:	e1a02302 	lsl	r2, r2, #6
 c226820:	e3822030 	orr	r2, r2, #48	; 0x30
 c226824:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c226828:	e59f3038 	ldr	r3, [pc, #56]	; c226868 <iic_start+0x80>
 c22682c:	e59f2034 	ldr	r2, [pc, #52]	; c226868 <iic_start+0x80>
 c226830:	e5922000 	ldr	r2, [r2]
 c226834:	e3c22010 	bic	r2, r2, #16
 c226838:	e5832000 	str	r2, [r3]

    while(!( rIICCON & (1 << 4)));
 c22683c:	e1a00000 	nop			; (mov r0, r0)
 c226840:	e59f3020 	ldr	r3, [pc, #32]	; c226868 <iic_start+0x80>
 c226844:	e5933000 	ldr	r3, [r3]
 c226848:	e2033010 	and	r3, r3, #16
 c22684c:	e3530000 	cmp	r3, #0
 c226850:	0afffffa 	beq	c226840 <iic_start+0x58>
}
 c226854:	e24bd00c 	sub	sp, fp, #12
 c226858:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22685c:	e12fff1e 	bx	lr
 c226860:	01d6000c 	.word	0x01d6000c
 c226864:	01d60004 	.word	0x01d60004
 c226868:	01d60000 	.word	0x01d60000

0c22686c <iic_putByte>:


void iic_putByte( uint8 byte )
{
 c22686c:	e1a0c00d 	mov	ip, sp
 c226870:	e92dd800 	push	{fp, ip, lr, pc}
 c226874:	e24cb004 	sub	fp, ip, #4
 c226878:	e24dd008 	sub	sp, sp, #8
 c22687c:	e1a03000 	mov	r3, r0
 c226880:	e54b300d 	strb	r3, [fp, #-13]
    rIICDS   = byte;
 c226884:	e59f303c 	ldr	r3, [pc, #60]	; c2268c8 <iic_putByte+0x5c>
 c226888:	e55b200d 	ldrb	r2, [fp, #-13]
 c22688c:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c226890:	e59f3034 	ldr	r3, [pc, #52]	; c2268cc <iic_putByte+0x60>
 c226894:	e59f2030 	ldr	r2, [pc, #48]	; c2268cc <iic_putByte+0x60>
 c226898:	e5922000 	ldr	r2, [r2]
 c22689c:	e3c22010 	bic	r2, r2, #16
 c2268a0:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c2268a4:	e1a00000 	nop			; (mov r0, r0)
 c2268a8:	e59f301c 	ldr	r3, [pc, #28]	; c2268cc <iic_putByte+0x60>
 c2268ac:	e5933000 	ldr	r3, [r3]
 c2268b0:	e2033010 	and	r3, r3, #16
 c2268b4:	e3530000 	cmp	r3, #0
 c2268b8:	0afffffa 	beq	c2268a8 <iic_putByte+0x3c>
}
 c2268bc:	e24bd00c 	sub	sp, fp, #12
 c2268c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2268c4:	e12fff1e 	bx	lr
 c2268c8:	01d6000c 	.word	0x01d6000c
 c2268cc:	01d60000 	.word	0x01d60000

0c2268d0 <iic_getByte>:

uint8 iic_getByte(enum IIC_ACK_t ack)
{
 c2268d0:	e1a0c00d 	mov	ip, sp
 c2268d4:	e92dd800 	push	{fp, ip, lr, pc}
 c2268d8:	e24cb004 	sub	fp, ip, #4
 c2268dc:	e24dd008 	sub	sp, sp, #8
 c2268e0:	e1a03000 	mov	r3, r0
 c2268e4:	e54b300d 	strb	r3, [fp, #-13]
	// Setup ACK or not
	if(ack == RxACK) {
 c2268e8:	e55b300d 	ldrb	r3, [fp, #-13]
 c2268ec:	e3530001 	cmp	r3, #1
 c2268f0:	1a000005 	bne	c22690c <iic_getByte+0x3c>
		//IICCON[7] = 1   Generate ACK
	    rIICCON |= 1 << 7;
 c2268f4:	e59f306c 	ldr	r3, [pc, #108]	; c226968 <iic_getByte+0x98>
 c2268f8:	e59f2068 	ldr	r2, [pc, #104]	; c226968 <iic_getByte+0x98>
 c2268fc:	e5922000 	ldr	r2, [r2]
 c226900:	e3822080 	orr	r2, r2, #128	; 0x80
 c226904:	e5832000 	str	r2, [r3]
 c226908:	ea000004 	b	c226920 <iic_getByte+0x50>
	} else {
		//IICCON[7] = 0   Don't generate ACK
	    rIICCON &= ~(1 << 7);
 c22690c:	e59f3054 	ldr	r3, [pc, #84]	; c226968 <iic_getByte+0x98>
 c226910:	e59f2050 	ldr	r2, [pc, #80]	; c226968 <iic_getByte+0x98>
 c226914:	e5922000 	ldr	r2, [r2]
 c226918:	e3c22080 	bic	r2, r2, #128	; 0x80
 c22691c:	e5832000 	str	r2, [r3]
	}

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c226920:	e59f3040 	ldr	r3, [pc, #64]	; c226968 <iic_getByte+0x98>
 c226924:	e59f203c 	ldr	r2, [pc, #60]	; c226968 <iic_getByte+0x98>
 c226928:	e5922000 	ldr	r2, [r2]
 c22692c:	e3c22010 	bic	r2, r2, #16
 c226930:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c226934:	e1a00000 	nop			; (mov r0, r0)
 c226938:	e59f3028 	ldr	r3, [pc, #40]	; c226968 <iic_getByte+0x98>
 c22693c:	e5933000 	ldr	r3, [r3]
 c226940:	e2033010 	and	r3, r3, #16
 c226944:	e3530000 	cmp	r3, #0
 c226948:	0afffffa 	beq	c226938 <iic_getByte+0x68>

    return rIICDS;
 c22694c:	e59f3018 	ldr	r3, [pc, #24]	; c22696c <iic_getByte+0x9c>
 c226950:	e5933000 	ldr	r3, [r3]
 c226954:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c226958:	e1a00003 	mov	r0, r3
 c22695c:	e24bd00c 	sub	sp, fp, #12
 c226960:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226964:	e12fff1e 	bx	lr
 c226968:	01d60000 	.word	0x01d60000
 c22696c:	01d6000c 	.word	0x01d6000c

0c226970 <iic_stop>:

void iic_stop( uint16 ms )
{
 c226970:	e1a0c00d 	mov	ip, sp
 c226974:	e92dd800 	push	{fp, ip, lr, pc}
 c226978:	e24cb004 	sub	fp, ip, #4
 c22697c:	e24dd008 	sub	sp, sp, #8
 c226980:	e1a03000 	mov	r3, r0
 c226984:	e14b30be 	strh	r3, [fp, #-14]
	//Generate STOP signal (ICCSTAT[5]=0)
    rIICSTAT &= ~(1 << 5);
 c226988:	e59f3038 	ldr	r3, [pc, #56]	; c2269c8 <iic_stop+0x58>
 c22698c:	e59f2034 	ldr	r2, [pc, #52]	; c2269c8 <iic_stop+0x58>
 c226990:	e5922000 	ldr	r2, [r2]
 c226994:	e3c22020 	bic	r2, r2, #32
 c226998:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission of STOP signal
    rIICCON &= ~(1 << 4);
 c22699c:	e59f3028 	ldr	r3, [pc, #40]	; c2269cc <iic_stop+0x5c>
 c2269a0:	e59f2024 	ldr	r2, [pc, #36]	; c2269cc <iic_stop+0x5c>
 c2269a4:	e5922000 	ldr	r2, [r2]
 c2269a8:	e3c22010 	bic	r2, r2, #16
 c2269ac:	e5832000 	str	r2, [r3]

    Delay(ms);
 c2269b0:	e15b30be 	ldrh	r3, [fp, #-14]
 c2269b4:	e1a00003 	mov	r0, r3
 c2269b8:	eb0010ed 	bl	c22ad74 <Delay>
}
 c2269bc:	e24bd00c 	sub	sp, fp, #12
 c2269c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2269c4:	e12fff1e 	bx	lr
 c2269c8:	01d60004 	.word	0x01d60004
 c2269cc:	01d60000 	.word	0x01d60000

0c2269d0 <iis_init>:
static void isr_bdma0( void ) __attribute__ ((interrupt ("IRQ")));

static enum IIS_mode_t iomode;

void iis_init(enum IIS_mode_t mode )
{
 c2269d0:	e1a0c00d 	mov	ip, sp
 c2269d4:	e92dd800 	push	{fp, ip, lr, pc}
 c2269d8:	e24cb004 	sub	fp, ip, #4
 c2269dc:	e24dd008 	sub	sp, sp, #8
 c2269e0:	e1a03000 	mov	r3, r0
 c2269e4:	e54b300d 	strb	r3, [fp, #-13]
    iomode = mode;
 c2269e8:	e59f30a0 	ldr	r3, [pc, #160]	; c226a90 <iis_init+0xc0>
 c2269ec:	e55b200d 	ldrb	r2, [fp, #-13]
 c2269f0:	e5c32000 	strb	r2, [r3]
    //IISPSR[3:0] = 7 division factor = 16

    //IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
    //IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n

    if( iomode == IIS_POLLING ) {
 c2269f4:	e59f3094 	ldr	r3, [pc, #148]	; c226a90 <iis_init+0xc0>
 c2269f8:	e5d33000 	ldrb	r3, [r3]
 c2269fc:	e3530002 	cmp	r3, #2
 c226a00:	1a00000c 	bne	c226a38 <iis_init+0x68>

    	//IISPSR[7:4] = 7 Frecuencia de muestreo: fs = 16 KHz (calidad Voz IP)
    	//IISPSR[3:0] = 7 division factor = 16

    	rIISPSR  = 0x7 | (0x7 << 4);
 c226a04:	e59f3088 	ldr	r3, [pc, #136]	; c226a94 <iis_init+0xc4>
 c226a08:	e3a02077 	mov	r2, #119	; 0x77
 c226a0c:	e5832000 	str	r2, [r3]
		//IISMOD[4] = 0  IIS compatible
		//IISMOD[3] = 1  16b Transfer
		//IISMOD[2] = 0 Frecuencia de CODECLK: 256fs
		//IISMOD[1:0] = 1 Frecuencia de SCLK: 32fs

    	rIISMOD  = 0b011001001;
 c226a10:	e59f3080 	ldr	r3, [pc, #128]	; c226a98 <iis_init+0xc8>
 c226a14:	e3a020c9 	mov	r2, #201	; 0xc9
 c226a18:	e5832000 	str	r2, [r3]
    	//IISFCON[11] = 0 normal access mode (no DMA)
		//IISFCON[10] = 0 normal access mode (no DMA)
		//IISFCON[9] = 1 Tx FIFO enable
		//IISFCON[8] = 1 Rx FIFO enable

        rIISFCON = 0b0011 << 8;
 c226a1c:	e59f3078 	ldr	r3, [pc, #120]	; c226a9c <iis_init+0xcc>
 c226a20:	e3a02c03 	mov	r2, #768	; 0x300
 c226a24:	e5832000 	str	r2, [r3]
		//IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
		//IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n
		//IISCON[1] = 1 prescaler habilitado
		//IISCON[0] = 1 interfaz IIS habilitado

        rIISCON  = 0b000011;
 c226a28:	e59f3070 	ldr	r3, [pc, #112]	; c226aa0 <iis_init+0xd0>
 c226a2c:	e3a02003 	mov	r2, #3
 c226a30:	e5832000 	str	r2, [r3]
 c226a34:	ea000012 	b	c226a84 <iis_init+0xb4>

    } else if( iomode == IIS_DMA ) {
 c226a38:	e59f3050 	ldr	r3, [pc, #80]	; c226a90 <iis_init+0xc0>
 c226a3c:	e5d33000 	ldrb	r3, [r3]
 c226a40:	e3530001 	cmp	r3, #1
 c226a44:	1a00000e 	bne	c226a84 <iis_init+0xb4>

        //IISPSR[7:4] = 7 Frecuencia de muestreo: fs = 16 KHz (calidad Voz IP)
        //IISPSR[3:0] = 7 division factor = 16

        rIISPSR  = 0x7 | (0x7 << 4);
 c226a48:	e59f3044 	ldr	r3, [pc, #68]	; c226a94 <iis_init+0xc4>
 c226a4c:	e3a02077 	mov	r2, #119	; 0x77
 c226a50:	e5832000 	str	r2, [r3]
        //IISMOD[4] = 0  IIS compatible
        //IISMOD[3] = 1  16b Transfer
        //IISMOD[2] = 0 Frecuencia de CODECLK: 256fs
        //IISMOD[1:0] = 1 Frecuencia de SCLK: 32fs

        rIISMOD  = 0b000001001;
 c226a54:	e59f303c 	ldr	r3, [pc, #60]	; c226a98 <iis_init+0xc8>
 c226a58:	e3a02009 	mov	r2, #9
 c226a5c:	e5832000 	str	r2, [r3]
    	//IISFCON[11] = 1 DMA access mode
    	//IISFCON[10] = 1 DMA access mode
    	//IISFCON[9] = 1 Tx FIFO habilitada
    	//IISFCON[8] = 1 Rx FIFO habilitada

        rIISFCON = 0b1111 << 8;
 c226a60:	e59f3034 	ldr	r3, [pc, #52]	; c226a9c <iis_init+0xcc>
 c226a64:	e3a02c0f 	mov	r2, #3840	; 0xf00
 c226a68:	e5832000 	str	r2, [r3]
        //IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
        //IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n
    	//IISCON[1] = 1  prescaler habilitado
    	//IISCON[0] = 0 interfaz IIS deshabilitado

        rIISCON  = 0b110010;
 c226a6c:	e59f302c 	ldr	r3, [pc, #44]	; c226aa0 <iis_init+0xd0>
 c226a70:	e3a02032 	mov	r2, #50	; 0x32
 c226a74:	e5832000 	str	r2, [r3]

        bdma0_init();
 c226a78:	ebfffced 	bl	c225e34 <bdma0_init>
        bdma0_open( isr_bdma0 );
 c226a7c:	e59f0020 	ldr	r0, [pc, #32]	; c226aa4 <iis_init+0xd4>
 c226a80:	ebfffd03 	bl	c225e94 <bdma0_open>
    }
}
 c226a84:	e24bd00c 	sub	sp, fp, #12
 c226a88:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226a8c:	e12fff1e 	bx	lr
 c226a90:	0c1023f9 	.word	0x0c1023f9
 c226a94:	01d18008 	.word	0x01d18008
 c226a98:	01d18004 	.word	0x01d18004
 c226a9c:	01d1800c 	.word	0x01d1800c
 c226aa0:	01d18000 	.word	0x01d18000
 c226aa4:	0c226aa8 	.word	0x0c226aa8

0c226aa8 <isr_bdma0>:

static void isr_bdma0( void )
{
 c226aa8:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c226aac:	e1a0c00d 	mov	ip, sp
 c226ab0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c226ab4:	e24cb004 	sub	fp, ip, #4
	//Disable IIS Controller
    rIISCON &= ~1;
 c226ab8:	e59f3024 	ldr	r3, [pc, #36]	; c226ae4 <isr_bdma0+0x3c>
 c226abc:	e59f2020 	ldr	r2, [pc, #32]	; c226ae4 <isr_bdma0+0x3c>
 c226ac0:	e5922000 	ldr	r2, [r2]
 c226ac4:	e3c22001 	bic	r2, r2, #1
 c226ac8:	e5832000 	str	r2, [r3]

    //Clean flag
    ic_cleanflag(INT_BDMA0);
 c226acc:	e3a00011 	mov	r0, #17
 c226ad0:	eb000267 	bl	c227474 <ic_cleanflag>
}
 c226ad4:	e24bd01c 	sub	sp, fp, #28
 c226ad8:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c226adc:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c226ae0:	e25ef004 	subs	pc, lr, #4
 c226ae4:	01d18000 	.word	0x01d18000

0c226ae8 <iis_putSample>:

inline void iis_putSample( int16 ch0, int16 ch1 )
{
 c226ae8:	e1a0c00d 	mov	ip, sp
 c226aec:	e92dd800 	push	{fp, ip, lr, pc}
 c226af0:	e24cb004 	sub	fp, ip, #4
 c226af4:	e24dd008 	sub	sp, sp, #8
 c226af8:	e1a02000 	mov	r2, r0
 c226afc:	e1a03001 	mov	r3, r1
 c226b00:	e14b20be 	strh	r2, [fp, #-14]
 c226b04:	e14b31b0 	strh	r3, [fp, #-16]
	//Polling only

	//Wait until there are two empty spots in FIFO
    while(((rIISFCON >> 4) & 0b1111) > 6);
 c226b08:	e1a00000 	nop			; (mov r0, r0)
 c226b0c:	e59f3034 	ldr	r3, [pc, #52]	; c226b48 <iis_putSample+0x60>
 c226b10:	e5933000 	ldr	r3, [r3]
 c226b14:	e1a03223 	lsr	r3, r3, #4
 c226b18:	e203300f 	and	r3, r3, #15
 c226b1c:	e3530006 	cmp	r3, #6
 c226b20:	8afffff9 	bhi	c226b0c <iis_putSample+0x24>

    //Send data
    IISFIF = ch0;
 c226b24:	e59f3020 	ldr	r3, [pc, #32]	; c226b4c <iis_putSample+0x64>
 c226b28:	e15b20be 	ldrh	r2, [fp, #-14]
 c226b2c:	e1c320b0 	strh	r2, [r3]
    IISFIF = ch1;
 c226b30:	e59f3014 	ldr	r3, [pc, #20]	; c226b4c <iis_putSample+0x64>
 c226b34:	e15b21b0 	ldrh	r2, [fp, #-16]
 c226b38:	e1c320b0 	strh	r2, [r3]
}
 c226b3c:	e24bd00c 	sub	sp, fp, #12
 c226b40:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226b44:	e12fff1e 	bx	lr
 c226b48:	01d1800c 	.word	0x01d1800c
 c226b4c:	01d18010 	.word	0x01d18010

0c226b50 <iis_getSample>:

inline void iis_getSample( int16 *ch0, int16 *ch1 )
{
 c226b50:	e1a0c00d 	mov	ip, sp
 c226b54:	e92dd800 	push	{fp, ip, lr, pc}
 c226b58:	e24cb004 	sub	fp, ip, #4
 c226b5c:	e24dd008 	sub	sp, sp, #8
 c226b60:	e50b0010 	str	r0, [fp, #-16]
 c226b64:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	//Polling only

	//Wait until there are two samples in FIFO
    while((rIISFCON & 0b1111) < 2);
 c226b68:	e1a00000 	nop			; (mov r0, r0)
 c226b6c:	e59f3058 	ldr	r3, [pc, #88]	; c226bcc <iis_getSample+0x7c>
 c226b70:	e5933000 	ldr	r3, [r3]
 c226b74:	e203300f 	and	r3, r3, #15
 c226b78:	e3530001 	cmp	r3, #1
 c226b7c:	9afffffa 	bls	c226b6c <iis_getSample+0x1c>

    *ch0 = IISFIF;
 c226b80:	e59f3048 	ldr	r3, [pc, #72]	; c226bd0 <iis_getSample+0x80>
 c226b84:	e1d330b0 	ldrh	r3, [r3]
 c226b88:	e1a03803 	lsl	r3, r3, #16
 c226b8c:	e1a03823 	lsr	r3, r3, #16
 c226b90:	e1a03803 	lsl	r3, r3, #16
 c226b94:	e1a02823 	lsr	r2, r3, #16
 c226b98:	e51b3010 	ldr	r3, [fp, #-16]
 c226b9c:	e1c320b0 	strh	r2, [r3]
    *ch1 = IISFIF;
 c226ba0:	e59f3028 	ldr	r3, [pc, #40]	; c226bd0 <iis_getSample+0x80>
 c226ba4:	e1d330b0 	ldrh	r3, [r3]
 c226ba8:	e1a03803 	lsl	r3, r3, #16
 c226bac:	e1a03823 	lsr	r3, r3, #16
 c226bb0:	e1a03803 	lsl	r3, r3, #16
 c226bb4:	e1a02823 	lsr	r2, r3, #16
 c226bb8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c226bbc:	e1c320b0 	strh	r2, [r3]
}
 c226bc0:	e24bd00c 	sub	sp, fp, #12
 c226bc4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226bc8:	e12fff1e 	bx	lr
 c226bcc:	01d1800c 	.word	0x01d1800c
 c226bd0:	01d18010 	.word	0x01d18010

0c226bd4 <iis_play>:

void iis_play( int16 *buffer, uint32 length, uint8 loop )
{
 c226bd4:	e1a0c00d 	mov	ip, sp
 c226bd8:	e92dd800 	push	{fp, ip, lr, pc}
 c226bdc:	e24cb004 	sub	fp, ip, #4
 c226be0:	e24dd020 	sub	sp, sp, #32
 c226be4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c226be8:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
 c226bec:	e1a03002 	mov	r3, r2
 c226bf0:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    uint32 i;
    int16 ch1, ch2;
    uint8 loop_23_22, loop_21;

    if( iomode == IIS_POLLING )
 c226bf4:	e59f316c 	ldr	r3, [pc, #364]	; c226d68 <iis_play+0x194>
 c226bf8:	e5d33000 	ldrb	r3, [r3]
 c226bfc:	e3530002 	cmp	r3, #2
 c226c00:	1a00001e 	bne	c226c80 <iis_play+0xac>
        for( i=0; i<length/2; )
 c226c04:	e3a03000 	mov	r3, #0
 c226c08:	e50b3010 	str	r3, [fp, #-16]
 c226c0c:	ea000016 	b	c226c6c <iis_play+0x98>
        {
            ch1 = buffer[i++];
 c226c10:	e51b3010 	ldr	r3, [fp, #-16]
 c226c14:	e1a03083 	lsl	r3, r3, #1
 c226c18:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c226c1c:	e0823003 	add	r3, r2, r3
 c226c20:	e1d330b0 	ldrh	r3, [r3]
 c226c24:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c226c28:	e51b3010 	ldr	r3, [fp, #-16]
 c226c2c:	e2833001 	add	r3, r3, #1
 c226c30:	e50b3010 	str	r3, [fp, #-16]
            ch2 = buffer[i++];
 c226c34:	e51b3010 	ldr	r3, [fp, #-16]
 c226c38:	e1a03083 	lsl	r3, r3, #1
 c226c3c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c226c40:	e0823003 	add	r3, r2, r3
 c226c44:	e1d330b0 	ldrh	r3, [r3]
 c226c48:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
 c226c4c:	e51b3010 	ldr	r3, [fp, #-16]
 c226c50:	e2833001 	add	r3, r3, #1
 c226c54:	e50b3010 	str	r3, [fp, #-16]
            iis_putSample( ch1, ch2 );
 c226c58:	e15b21f2 	ldrsh	r2, [fp, #-18]	; 0xffffffee
 c226c5c:	e15b31f4 	ldrsh	r3, [fp, #-20]	; 0xffffffec
 c226c60:	e1a00002 	mov	r0, r2
 c226c64:	e1a01003 	mov	r1, r3
 c226c68:	ebffff9e 	bl	c226ae8 <iis_putSample>
    uint32 i;
    int16 ch1, ch2;
    uint8 loop_23_22, loop_21;

    if( iomode == IIS_POLLING )
        for( i=0; i<length/2; )
 c226c6c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c226c70:	e1a020a3 	lsr	r2, r3, #1
 c226c74:	e51b3010 	ldr	r3, [fp, #-16]
 c226c78:	e1520003 	cmp	r2, r3
 c226c7c:	8affffe3 	bhi	c226c10 <iis_play+0x3c>
        {
            ch1 = buffer[i++];
            ch2 = buffer[i++];
            iis_putSample( ch1, ch2 );
        }
    if( iomode == IIS_DMA ){
 c226c80:	e59f30e0 	ldr	r3, [pc, #224]	; c226d68 <iis_play+0x194>
 c226c84:	e5d33000 	ldrb	r3, [r3]
 c226c88:	e3530001 	cmp	r3, #1
 c226c8c:	1a000032 	bne	c226d5c <iis_play+0x188>

    	//BDISRC0[31:30] = 1 half word (16b)
    	//BDISRC0[29:28] = 1 postâincrementada source address
    	//BDISRC0[27:0] = ... direcciÃ³n del buffer source address

    	rBDISRC0  = (1 << 30) | (1 << 28) | (uint32) buffer;
 c226c90:	e59f30d4 	ldr	r3, [pc, #212]	; c226d6c <iis_play+0x198>
 c226c94:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c226c98:	e3822205 	orr	r2, r2, #1342177280	; 0x50000000
 c226c9c:	e5832000 	str	r2, [r3]

    	//BDIDES0[31:30] = 1 from external memory to internal peripheral transfer direction
    	//BDIDES0[29:28] = 3 fija (dest address)
    	//BDIDES0[27:0] = ... direcciÃ³n de IISFIF (dest address)

		rBDIDES0  = (1 << 30) | (3 << 28) | (uint32) &IISFIF;
 c226ca0:	e59f30c8 	ldr	r3, [pc, #200]	; c226d70 <iis_play+0x19c>
 c226ca4:	e59f20c8 	ldr	r2, [pc, #200]	; c226d74 <iis_play+0x1a0>
 c226ca8:	e5832000 	str	r2, [r3]

    	//BDCON0[3:2] = 0 DMA request enable
    	//BDCON0[1:0] = 0 no command
		rBDCON0  = 0;
 c226cac:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c226cb0:	e3a02000 	mov	r2, #0
 c226cb4:	e5832000 	str	r2, [r3]
    	//BDICNT0[23:22] = 0 (no) si loop = TRUE; 3 (sÃ­, al terminar la transferencia DMA) en otro caso
    	//BDICNT0[21] = 1 (activado) si loop = TRUE; 0 (desactivado) en otro caso
    	//BDICNT0[20] = 1 DMA enable
    	//BDICNT0[19:0] = ... tamaÃ±o del buffer a transferur

		loop_23_22 = loop ? 0 : 3;
 c226cb8:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
 c226cbc:	e3530000 	cmp	r3, #0
 c226cc0:	0a000001 	beq	c226ccc <iis_play+0xf8>
 c226cc4:	e3a03000 	mov	r3, #0
 c226cc8:	ea000000 	b	c226cd0 <iis_play+0xfc>
 c226ccc:	e3a03003 	mov	r3, #3
 c226cd0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
		loop_21 = loop ? 1 : 0;
 c226cd4:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
 c226cd8:	e3530000 	cmp	r3, #0
 c226cdc:	03a03000 	moveq	r3, #0
 c226ce0:	13a03001 	movne	r3, #1
 c226ce4:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea

		rBDICNT0  = (1 << 30) | (1 << 26) | (loop_23_22 << 22) | (loop_21 << 21) | (0xfffff & length);
 c226ce8:	e59f2088 	ldr	r2, [pc, #136]	; c226d78 <iis_play+0x1a4>
 c226cec:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c226cf0:	e1a03b03 	lsl	r3, r3, #22
 c226cf4:	e3831311 	orr	r1, r3, #1140850688	; 0x44000000
 c226cf8:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c226cfc:	e1a03a83 	lsl	r3, r3, #21
 c226d00:	e1813003 	orr	r3, r1, r3
 c226d04:	e1a01003 	mov	r1, r3
 c226d08:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c226d0c:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c226d10:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
 c226d14:	e1813003 	orr	r3, r1, r3
 c226d18:	e5823000 	str	r3, [r2]
		rBDICNT0 |= (1 << 20);
 c226d1c:	e59f3054 	ldr	r3, [pc, #84]	; c226d78 <iis_play+0x1a4>
 c226d20:	e59f2050 	ldr	r2, [pc, #80]	; c226d78 <iis_play+0x1a4>
 c226d24:	e5922000 	ldr	r2, [r2]
 c226d28:	e3822601 	orr	r2, r2, #1048576	; 0x100000
 c226d2c:	e5832000 	str	r2, [r3]

    	//*IIS Controller

    	//IISMOD[7:6] = 2 modo transmisiÃ³n
    	//IISCON[0] = 1 interfaz IIS habilitado
        rIISMOD   = (rIISMOD & ~(3 << 6)) | (2 << 6);
 c226d30:	e59f3044 	ldr	r3, [pc, #68]	; c226d7c <iis_play+0x1a8>
 c226d34:	e59f2040 	ldr	r2, [pc, #64]	; c226d7c <iis_play+0x1a8>
 c226d38:	e5922000 	ldr	r2, [r2]
 c226d3c:	e3c220c0 	bic	r2, r2, #192	; 0xc0
 c226d40:	e3822080 	orr	r2, r2, #128	; 0x80
 c226d44:	e5832000 	str	r2, [r3]
        rIISCON  |= 1;
 c226d48:	e59f3030 	ldr	r3, [pc, #48]	; c226d80 <iis_play+0x1ac>
 c226d4c:	e59f202c 	ldr	r2, [pc, #44]	; c226d80 <iis_play+0x1ac>
 c226d50:	e5922000 	ldr	r2, [r2]
 c226d54:	e3822001 	orr	r2, r2, #1
 c226d58:	e5832000 	str	r2, [r3]
    }
}
 c226d5c:	e24bd00c 	sub	sp, fp, #12
 c226d60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226d64:	e12fff1e 	bx	lr
 c226d68:	0c1023f9 	.word	0x0c1023f9
 c226d6c:	01f80004 	.word	0x01f80004
 c226d70:	01f80008 	.word	0x01f80008
 c226d74:	71d18010 	.word	0x71d18010
 c226d78:	01f8000c 	.word	0x01f8000c
 c226d7c:	01d18004 	.word	0x01d18004
 c226d80:	01d18000 	.word	0x01d18000

0c226d84 <iis_rec>:

void iis_rec( int16 *buffer, uint32 length )
{
 c226d84:	e1a0c00d 	mov	ip, sp
 c226d88:	e92dd800 	push	{fp, ip, lr, pc}
 c226d8c:	e24cb004 	sub	fp, ip, #4
 c226d90:	e24dd010 	sub	sp, sp, #16
 c226d94:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c226d98:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    uint32 i;
    int16 ch1, ch2;

    if( iomode == IIS_POLLING ) {
 c226d9c:	e59f3108 	ldr	r3, [pc, #264]	; c226eac <iis_rec+0x128>
 c226da0:	e5d33000 	ldrb	r3, [r3]
 c226da4:	e3530002 	cmp	r3, #2
 c226da8:	1a000010 	bne	c226df0 <iis_rec+0x6c>
    	//Repeated polling
    	for( i=0; i<length/2; ) {
 c226dac:	e3a03000 	mov	r3, #0
 c226db0:	e50b3010 	str	r3, [fp, #-16]
 c226db4:	ea000007 	b	c226dd8 <iis_rec+0x54>
			iis_getSample( buffer, buffer + 1);
 c226db8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226dbc:	e2833002 	add	r3, r3, #2
 c226dc0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c226dc4:	e1a01003 	mov	r1, r3
 c226dc8:	ebffff60 	bl	c226b50 <iis_getSample>
			buffer += 2;
 c226dcc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226dd0:	e2833004 	add	r3, r3, #4
 c226dd4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    uint32 i;
    int16 ch1, ch2;

    if( iomode == IIS_POLLING ) {
    	//Repeated polling
    	for( i=0; i<length/2; ) {
 c226dd8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c226ddc:	e1a020a3 	lsr	r2, r3, #1
 c226de0:	e51b3010 	ldr	r3, [fp, #-16]
 c226de4:	e1520003 	cmp	r2, r3
 c226de8:	8afffff2 	bhi	c226db8 <iis_rec+0x34>
 c226dec:	ea00002b 	b	c226ea0 <iis_rec+0x11c>
			iis_getSample( buffer, buffer + 1);
			buffer += 2;
		}
    } else if( iomode == IIS_DMA ) {
 c226df0:	e59f30b4 	ldr	r3, [pc, #180]	; c226eac <iis_rec+0x128>
 c226df4:	e5d33000 	ldrb	r3, [r3]
 c226df8:	e3530001 	cmp	r3, #1
 c226dfc:	1a000027 	bne	c226ea0 <iis_rec+0x11c>

    	//Wait while DMA transfer is ongoing
        while( rIISCON & 1  );
 c226e00:	e1a00000 	nop			; (mov r0, r0)
 c226e04:	e59f30a4 	ldr	r3, [pc, #164]	; c226eb0 <iis_rec+0x12c>
 c226e08:	e5933000 	ldr	r3, [r3]
 c226e0c:	e2033001 	and	r3, r3, #1
 c226e10:	e20330ff 	and	r3, r3, #255	; 0xff
 c226e14:	e3530000 	cmp	r3, #0
 c226e18:	1afffff9 	bne	c226e04 <iis_rec+0x80>

        //Set up DMA Receive
        rBDISRC0  = (1 << 30) | (3 << 28) | (uint32)&IISFIF;
 c226e1c:	e59f3090 	ldr	r3, [pc, #144]	; c226eb4 <iis_rec+0x130>
 c226e20:	e59f2090 	ldr	r2, [pc, #144]	; c226eb8 <iis_rec+0x134>
 c226e24:	e5832000 	str	r2, [r3]
        rBDIDES0  = (2 << 30) | (1 << 28) | (uint32) buffer;
 c226e28:	e59f308c 	ldr	r3, [pc, #140]	; c226ebc <iis_rec+0x138>
 c226e2c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c226e30:	e3822209 	orr	r2, r2, #-1879048192	; 0x90000000
 c226e34:	e5832000 	str	r2, [r3]
        rBDCON0   = 0;
 c226e38:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c226e3c:	e3a02000 	mov	r2, #0
 c226e40:	e5832000 	str	r2, [r3]
        rBDICNT0  = (1 << 30) | (1 << 26) | (3 << 22) | (0xfffff & length);
 c226e44:	e59f2074 	ldr	r2, [pc, #116]	; c226ec0 <iis_rec+0x13c>
 c226e48:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c226e4c:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c226e50:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
 c226e54:	e3833311 	orr	r3, r3, #1140850688	; 0x44000000
 c226e58:	e3833503 	orr	r3, r3, #12582912	; 0xc00000
 c226e5c:	e5823000 	str	r3, [r2]
        rBDICNT0 |= (1 << 20);
 c226e60:	e59f3058 	ldr	r3, [pc, #88]	; c226ec0 <iis_rec+0x13c>
 c226e64:	e59f2054 	ldr	r2, [pc, #84]	; c226ec0 <iis_rec+0x13c>
 c226e68:	e5922000 	ldr	r2, [r2]
 c226e6c:	e3822601 	orr	r2, r2, #1048576	; 0x100000
 c226e70:	e5832000 	str	r2, [r3]
        //*Set up IIS

        //IISMOD[7:6] = 1 modo recepciÃ³n
        //IISCON[0] = 1 interfaz IIS habilitado

        rIISMOD   = (rIISMOD & ~(3 << 6)) | (1 << 6);
 c226e74:	e59f3048 	ldr	r3, [pc, #72]	; c226ec4 <iis_rec+0x140>
 c226e78:	e59f2044 	ldr	r2, [pc, #68]	; c226ec4 <iis_rec+0x140>
 c226e7c:	e5922000 	ldr	r2, [r2]
 c226e80:	e3c220c0 	bic	r2, r2, #192	; 0xc0
 c226e84:	e3822040 	orr	r2, r2, #64	; 0x40
 c226e88:	e5832000 	str	r2, [r3]
        rIISCON  |= 1;
 c226e8c:	e59f301c 	ldr	r3, [pc, #28]	; c226eb0 <iis_rec+0x12c>
 c226e90:	e59f2018 	ldr	r2, [pc, #24]	; c226eb0 <iis_rec+0x12c>
 c226e94:	e5922000 	ldr	r2, [r2]
 c226e98:	e3822001 	orr	r2, r2, #1
 c226e9c:	e5832000 	str	r2, [r3]
    }
}
 c226ea0:	e24bd00c 	sub	sp, fp, #12
 c226ea4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226ea8:	e12fff1e 	bx	lr
 c226eac:	0c1023f9 	.word	0x0c1023f9
 c226eb0:	01d18000 	.word	0x01d18000
 c226eb4:	01f80004 	.word	0x01f80004
 c226eb8:	71d18010 	.word	0x71d18010
 c226ebc:	01f80008 	.word	0x01f80008
 c226ec0:	01f8000c 	.word	0x01f8000c
 c226ec4:	01d18004 	.word	0x01d18004

0c226ec8 <iis_pause>:

void iis_pause( void )
{
 c226ec8:	e1a0c00d 	mov	ip, sp
 c226ecc:	e92dd800 	push	{fp, ip, lr, pc}
 c226ed0:	e24cb004 	sub	fp, ip, #4
	//Pause DMA transfer

	//Desabilita IIS
	rIISCON &= ~1;
 c226ed4:	e59f3018 	ldr	r3, [pc, #24]	; c226ef4 <iis_pause+0x2c>
 c226ed8:	e59f2014 	ldr	r2, [pc, #20]	; c226ef4 <iis_pause+0x2c>
 c226edc:	e5922000 	ldr	r2, [r2]
 c226ee0:	e3c22001 	bic	r2, r2, #1
 c226ee4:	e5832000 	str	r2, [r3]
}
 c226ee8:	e24bd00c 	sub	sp, fp, #12
 c226eec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226ef0:	e12fff1e 	bx	lr
 c226ef4:	01d18000 	.word	0x01d18000

0c226ef8 <iis_continue>:

void iis_continue( void )
{
 c226ef8:	e1a0c00d 	mov	ip, sp
 c226efc:	e92dd800 	push	{fp, ip, lr, pc}
 c226f00:	e24cb004 	sub	fp, ip, #4
	//Continue DMA transfer

	//Habilita IIS
	rIISCON |= 1;
 c226f04:	e59f3018 	ldr	r3, [pc, #24]	; c226f24 <iis_continue+0x2c>
 c226f08:	e59f2014 	ldr	r2, [pc, #20]	; c226f24 <iis_continue+0x2c>
 c226f0c:	e5922000 	ldr	r2, [r2]
 c226f10:	e3822001 	orr	r2, r2, #1
 c226f14:	e5832000 	str	r2, [r3]
}
 c226f18:	e24bd00c 	sub	sp, fp, #12
 c226f1c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226f20:	e12fff1e 	bx	lr
 c226f24:	01d18000 	.word	0x01d18000

0c226f28 <iis_status>:

uint8 iis_status( void )
{
 c226f28:	e1a0c00d 	mov	ip, sp
 c226f2c:	e92dd800 	push	{fp, ip, lr, pc}
 c226f30:	e24cb004 	sub	fp, ip, #4
	//Return if DMA is currently playing / recording
    return rIISCON & 1;
 c226f34:	e59f301c 	ldr	r3, [pc, #28]	; c226f58 <iis_status+0x30>
 c226f38:	e5933000 	ldr	r3, [r3]
 c226f3c:	e20330ff 	and	r3, r3, #255	; 0xff
 c226f40:	e2033001 	and	r3, r3, #1
 c226f44:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c226f48:	e1a00003 	mov	r0, r3
 c226f4c:	e24bd00c 	sub	sp, fp, #12
 c226f50:	e89d6800 	ldm	sp, {fp, sp, lr}
 c226f54:	e12fff1e 	bx	lr
 c226f58:	01d18000 	.word	0x01d18000

0c226f5c <iis_playWawFile>:

void iis_playWawFile( int16 *wav, uint8 loop )
{
 c226f5c:	e1a0c00d 	mov	ip, sp
 c226f60:	e92dd800 	push	{fp, ip, lr, pc}
 c226f64:	e24cb004 	sub	fp, ip, #4
 c226f68:	e24dd010 	sub	sp, sp, #16
 c226f6c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c226f70:	e1a03001 	mov	r3, r1
 c226f74:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    uint32 size;
    char *p;

    p = (char *) wav;
 c226f78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c226f7c:	e50b3010 	str	r3, [fp, #-16]
    while ( !(p[0] == 'd' && p[1] == 'a' && p[2] == 't' && p[3] == 'a') ) // busca el chunck data
 c226f80:	ea000002 	b	c226f90 <iis_playWawFile+0x34>
        p++;
 c226f84:	e51b3010 	ldr	r3, [fp, #-16]
 c226f88:	e2833001 	add	r3, r3, #1
 c226f8c:	e50b3010 	str	r3, [fp, #-16]
{
    uint32 size;
    char *p;

    p = (char *) wav;
    while ( !(p[0] == 'd' && p[1] == 'a' && p[2] == 't' && p[3] == 'a') ) // busca el chunck data
 c226f90:	e51b3010 	ldr	r3, [fp, #-16]
 c226f94:	e5d33000 	ldrb	r3, [r3]
 c226f98:	e3530064 	cmp	r3, #100	; 0x64
 c226f9c:	1afffff8 	bne	c226f84 <iis_playWawFile+0x28>
 c226fa0:	e51b3010 	ldr	r3, [fp, #-16]
 c226fa4:	e2833001 	add	r3, r3, #1
 c226fa8:	e5d33000 	ldrb	r3, [r3]
 c226fac:	e3530061 	cmp	r3, #97	; 0x61
 c226fb0:	1afffff3 	bne	c226f84 <iis_playWawFile+0x28>
 c226fb4:	e51b3010 	ldr	r3, [fp, #-16]
 c226fb8:	e2833002 	add	r3, r3, #2
 c226fbc:	e5d33000 	ldrb	r3, [r3]
 c226fc0:	e3530074 	cmp	r3, #116	; 0x74
 c226fc4:	1affffee 	bne	c226f84 <iis_playWawFile+0x28>
 c226fc8:	e51b3010 	ldr	r3, [fp, #-16]
 c226fcc:	e2833003 	add	r3, r3, #3
 c226fd0:	e5d33000 	ldrb	r3, [r3]
 c226fd4:	e3530061 	cmp	r3, #97	; 0x61
 c226fd8:	1affffe9 	bne	c226f84 <iis_playWawFile+0x28>
        p++;
    p += 4;
 c226fdc:	e51b3010 	ldr	r3, [fp, #-16]
 c226fe0:	e2833004 	add	r3, r3, #4
 c226fe4:	e50b3010 	str	r3, [fp, #-16]

    size = p[0] + (p[1] << 8) + (p[2] << 16) + (p[3] << 24); // los datos de cabecera estÃ¡n en little-endian
 c226fe8:	e51b3010 	ldr	r3, [fp, #-16]
 c226fec:	e5d33000 	ldrb	r3, [r3]
 c226ff0:	e1a02003 	mov	r2, r3
 c226ff4:	e51b3010 	ldr	r3, [fp, #-16]
 c226ff8:	e2833001 	add	r3, r3, #1
 c226ffc:	e5d33000 	ldrb	r3, [r3]
 c227000:	e1a03403 	lsl	r3, r3, #8
 c227004:	e0822003 	add	r2, r2, r3
 c227008:	e51b3010 	ldr	r3, [fp, #-16]
 c22700c:	e2833002 	add	r3, r3, #2
 c227010:	e5d33000 	ldrb	r3, [r3]
 c227014:	e1a03803 	lsl	r3, r3, #16
 c227018:	e0822003 	add	r2, r2, r3
 c22701c:	e51b3010 	ldr	r3, [fp, #-16]
 c227020:	e2833003 	add	r3, r3, #3
 c227024:	e5d33000 	ldrb	r3, [r3]
 c227028:	e1a03c03 	lsl	r3, r3, #24
 c22702c:	e0823003 	add	r3, r2, r3
 c227030:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    p += 4;
 c227034:	e51b3010 	ldr	r3, [fp, #-16]
 c227038:	e2833004 	add	r3, r3, #4
 c22703c:	e50b3010 	str	r3, [fp, #-16]

    iis_play( (int16 *)p, size, loop );
 c227040:	e51b2010 	ldr	r2, [fp, #-16]
 c227044:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c227048:	e1a00002 	mov	r0, r2
 c22704c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c227050:	e1a02003 	mov	r2, r3
 c227054:	ebfffede 	bl	c226bd4 <iis_play>
}
 c227058:	e24bd00c 	sub	sp, fp, #12
 c22705c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227060:	e12fff1e 	bx	lr

0c227064 <start>:
	.equ rEXTINTPND, 0x1d20054

start:

	/* Pasa a modo supervisor */
    mrs	r0, cpsr
 c227064:	e10f0000 	mrs	r0, CPSR
    bic	r0, r0, #MODEMASK
 c227068:	e3c0001f 	bic	r0, r0, #31
    orr	r1, r0, #SVCMODE
 c22706c:	e3801013 	orr	r1, r0, #19
    msr	cpsr_c, r1 
 c227070:	e121f001 	msr	CPSR_c, r1

	/* InicializaciÃ³n de la secciÃ³n bss a 0, estÃ¡ndar C */
    ldr	    r3, =Image_ZI_Base
 c227074:	e59f30b8 	ldr	r3, [pc, #184]	; c227134 <InitStacks+0x48>
	ldr	    r1, =Image_ZI_Limit	/* Top of zero init segment */
 c227078:	e59f10b8 	ldr	r1, [pc, #184]	; c227138 <InitStacks+0x4c>
    mov	    r2, #0
 c22707c:	e3a02000 	mov	r2, #0

0c227080 <L0>:
L0:
    cmp	    r3, r1	    		/* Zero init */
 c227080:	e1530001 	cmp	r3, r1
    strcc   r2, [r3], #4
 c227084:	34832004 	strcc	r2, [r3], #4
    bcc	    L0
 c227088:	3afffffc 	bcc	c227080 <L0>
	/****************************************************/

	/* Desde modo SVC inicializa los SP de todos los modos de ejecuciï¿½n privilegiados */
    bl InitStacks
 c22708c:	eb000016 	bl	c2270ec <InitStacks>

	ldr r0, =rEXTINTPND
 c227090:	e59f00a4 	ldr	r0, [pc, #164]	; c22713c <InitStacks+0x50>
	ldr r1, =0xff
 c227094:	e3a010ff 	mov	r1, #255	; 0xff
	str r1, [r0]
 c227098:	e5801000 	str	r1, [r0]
	ldr r0, =rI_ISPC
 c22709c:	e59f009c 	ldr	r0, [pc, #156]	; c227140 <InitStacks+0x54>
	ldr r1, =0x1fffffff
 c2270a0:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c2270a4:	e5801000 	str	r1, [r0]
	ldr r0, =rF_ISPC
 c2270a8:	e59f0094 	ldr	r0, [pc, #148]	; c227144 <InitStacks+0x58>
	ldr r1, =0x1fffffff
 c2270ac:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c2270b0:	e5801000 	str	r1, [r0]

	/* Enmascara interrupciones */
	ldr r0, =rINTMSK
 c2270b4:	e59f008c 	ldr	r0, [pc, #140]	; c227148 <InitStacks+0x5c>
	ldr r1, =0x1fffffff
 c2270b8:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
    str r1, [r0]
 c2270bc:	e5801000 	str	r1, [r0]

	/* Habilita linea IRQ y FIQ del CPSR */
	mrs r0, cpsr
 c2270c0:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #0xC0
 c2270c4:	e3c000c0 	bic	r0, r0, #192	; 0xc0
	msr cpsr_c, r0
 c2270c8:	e121f000 	msr	CPSR_c, r0
	
	/* Desde modo SVC cambia a modo USR e inicializa el SP_usr */
	mrs r0, cpsr
 c2270cc:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c2270d0:	e3c0001f 	bic	r0, r0, #31
	orr r1, r0, #USRMODE  
 c2270d4:	e3801010 	orr	r1, r0, #16
	msr cpsr_c, r1
 c2270d8:	e121f001 	msr	CPSR_c, r1
	ldr sp, =USRSTACK
 c2270dc:	e59fd068 	ldr	sp, [pc, #104]	; c22714c <InitStacks+0x60>

    mov fp, #0
 c2270e0:	e3a0b000 	mov	fp, #0

    bl main
 c2270e4:	eb000608 	bl	c22890c <main>

0c2270e8 <End>:
End:
    B End
 c2270e8:	eafffffe 	b	c2270e8 <End>

0c2270ec <InitStacks>:

InitStacks:
	mrs r0, cpsr
 c2270ec:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c2270f0:	e3c0001f 	bic	r0, r0, #31

	orr r1, r0, #UNDMODE  /* desde modo SVC cambia a modo UND e inicializa el SP_und */
 c2270f4:	e380101b 	orr	r1, r0, #27
	msr cpsr_c, r1    
 c2270f8:	e121f001 	msr	CPSR_c, r1
	ldr sp, =UNDSTACK
 c2270fc:	e59fd04c 	ldr	sp, [pc, #76]	; c227150 <InitStacks+0x64>

	orr r1, r0, #ABTMODE  /* desde modo UND cambia a modo ABT e inicializa el SP_abt */
 c227100:	e3801017 	orr	r1, r0, #23
	msr cpsr_c, r1 
 c227104:	e121f001 	msr	CPSR_c, r1
	ldr sp, =ABTSTACK
 c227108:	e59fd044 	ldr	sp, [pc, #68]	; c227154 <InitStacks+0x68>

	orr r1, r0, #IRQMODE  /* desde modo ABT cambia a modo IRQ e inicializa el SP_abt */
 c22710c:	e3801012 	orr	r1, r0, #18
	msr cpsr_c, r1
 c227110:	e121f001 	msr	CPSR_c, r1
	ldr sp, =IRQSTACK
 c227114:	e59fd03c 	ldr	sp, [pc, #60]	; c227158 <InitStacks+0x6c>

	orr r1, r0, #FIQMODE  /* desde modo IRQ cambia a modo FIQ e inicializa el SP_fiq */
 c227118:	e3801011 	orr	r1, r0, #17
	msr cpsr_c, r1
 c22711c:	e121f001 	msr	CPSR_c, r1
	ldr sp, =FIQSTACK
 c227120:	e59fd034 	ldr	sp, [pc, #52]	; c22715c <InitStacks+0x70>

	orr r1, r0, #SVCMODE  /* desde modo FIQ cambia a modo SVC e inicializa el SP_svc */
 c227124:	e3801013 	orr	r1, r0, #19
	msr cpsr_c, r1
 c227128:	e121f001 	msr	CPSR_c, r1
	ldr sp, =SVCSTACK
 c22712c:	e59fd02c 	ldr	sp, [pc, #44]	; c227160 <InitStacks+0x74>
	
    mov pc, lr
 c227130:	e1a0f00e 	mov	pc, lr
 c227134:	0c102358 	.word	0x0c102358
 c227138:	0c2198b4 	.word	0x0c2198b4
 c22713c:	01d20054 	.word	0x01d20054
 c227140:	01e00024 	.word	0x01e00024
 c227144:	01e0003c 	.word	0x01e0003c
 c227148:	01e0000c 	.word	0x01e0000c
 c22714c:	0c7ff000 	.word	0x0c7ff000
 c227150:	0c7ff200 	.word	0x0c7ff200
 c227154:	0c7ff300 	.word	0x0c7ff300
 c227158:	0c7ff400 	.word	0x0c7ff400
 c22715c:	0c7ff500 	.word	0x0c7ff500
 c227160:	0c7ff100 	.word	0x0c7ff100

0c227164 <ic_init>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "intcontroller.h"

void ic_init(void)
{
 c227164:	e1a0c00d 	mov	ip, sp
 c227168:	e92dd800 	push	{fp, ip, lr, pc}
 c22716c:	e24cb004 	sub	fp, ip, #4
	 *    Lineas IRQ y FIQ no habilitadas
	 *    Linea IRQ en modo no vectorizado
	 *    Todo por la lÃ­nea IRQ
	 *    Todas las interrupciones enmascaradas
	 **/
	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 c227170:	e59f3028 	ldr	r3, [pc, #40]	; c2271a0 <ic_init+0x3c>
 c227174:	e3a02000 	mov	r2, #0
 c227178:	e5832000 	str	r2, [r3]
	rINTCON = 0x7; // IRQ y FIQ enmascaradas, IRQ en modo no vectorizado
 c22717c:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c227180:	e3a02007 	mov	r2, #7
 c227184:	e5832000 	str	r2, [r3]
	rINTMSK = ~(0x0); // Enmascara todas las lineas
 c227188:	e59f3014 	ldr	r3, [pc, #20]	; c2271a4 <ic_init+0x40>
 c22718c:	e3e02000 	mvn	r2, #0
 c227190:	e5832000 	str	r2, [r3]
}
 c227194:	e24bd00c 	sub	sp, fp, #12
 c227198:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22719c:	e12fff1e 	bx	lr
 c2271a0:	01e00008 	.word	0x01e00008
 c2271a4:	01e0000c 	.word	0x01e0000c

0c2271a8 <ic_conf_irq>:

int ic_conf_irq(enum enable st, enum int_vec vec)
{
 c2271a8:	e1a0c00d 	mov	ip, sp
 c2271ac:	e92dd800 	push	{fp, ip, lr, pc}
 c2271b0:	e24cb004 	sub	fp, ip, #4
 c2271b4:	e24dd010 	sub	sp, sp, #16
 c2271b8:	e1a02000 	mov	r2, r0
 c2271bc:	e1a03001 	mov	r3, r1
 c2271c0:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c2271c4:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int conf = rINTCON;
 c2271c8:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c2271cc:	e5933000 	ldr	r3, [r3]
 c2271d0:	e50b3010 	str	r3, [fp, #-16]

	if (st != ENABLE && st != DISABLE)
 c2271d4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2271d8:	e3530001 	cmp	r3, #1
 c2271dc:	0a000004 	beq	c2271f4 <ic_conf_irq+0x4c>
 c2271e0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2271e4:	e3530000 	cmp	r3, #0
 c2271e8:	0a000001 	beq	c2271f4 <ic_conf_irq+0x4c>
		return -1;
 c2271ec:	e3e03000 	mvn	r3, #0
 c2271f0:	ea000017 	b	c227254 <ic_conf_irq+0xac>

	if (vec == VEC)
 c2271f4:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c2271f8:	e3530000 	cmp	r3, #0
 c2271fc:	1a000003 	bne	c227210 <ic_conf_irq+0x68>
		//COMPLETAR: poner la linea IRQ en modo vectorizado
		conf &= ~(1 << 2);
 c227200:	e51b3010 	ldr	r3, [fp, #-16]
 c227204:	e3c33004 	bic	r3, r3, #4
 c227208:	e50b3010 	str	r3, [fp, #-16]
 c22720c:	ea000002 	b	c22721c <ic_conf_irq+0x74>
	else
		//COMPLETAR: poner la linea IRQ en modo no vectorizado
		conf |= 1 << 2;
 c227210:	e51b3010 	ldr	r3, [fp, #-16]
 c227214:	e3833004 	orr	r3, r3, #4
 c227218:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c22721c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c227220:	e3530001 	cmp	r3, #1
 c227224:	1a000003 	bne	c227238 <ic_conf_irq+0x90>
		//COMPLETAR: habilitar la linea IRQ
		conf &= ~(1 << 1);
 c227228:	e51b3010 	ldr	r3, [fp, #-16]
 c22722c:	e3c33002 	bic	r3, r3, #2
 c227230:	e50b3010 	str	r3, [fp, #-16]
 c227234:	ea000002 	b	c227244 <ic_conf_irq+0x9c>
	else
		//COMPLETAR: deshabilitar la linea IRQ
		conf |= 1 << 1;
 c227238:	e51b3010 	ldr	r3, [fp, #-16]
 c22723c:	e3833002 	orr	r3, r3, #2
 c227240:	e50b3010 	str	r3, [fp, #-16]

	rINTCON = conf;
 c227244:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c227248:	e51b2010 	ldr	r2, [fp, #-16]
 c22724c:	e5832000 	str	r2, [r3]
	return 0;
 c227250:	e3a03000 	mov	r3, #0
}
 c227254:	e1a00003 	mov	r0, r3
 c227258:	e24bd00c 	sub	sp, fp, #12
 c22725c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227260:	e12fff1e 	bx	lr

0c227264 <ic_conf_fiq>:

int ic_conf_fiq(enum enable st)
{
 c227264:	e1a0c00d 	mov	ip, sp
 c227268:	e92dd800 	push	{fp, ip, lr, pc}
 c22726c:	e24cb004 	sub	fp, ip, #4
 c227270:	e24dd010 	sub	sp, sp, #16
 c227274:	e1a03000 	mov	r3, r0
 c227278:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c22727c:	e3a03000 	mov	r3, #0
 c227280:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c227284:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c227288:	e3530001 	cmp	r3, #1
 c22728c:	1a000005 	bne	c2272a8 <ic_conf_fiq+0x44>
		//COMPLETAR: habilitar la linea FIQ
		rINTCON &= ~(1 << 0);
 c227290:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c227294:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c227298:	e5922000 	ldr	r2, [r2]
 c22729c:	e3c22001 	bic	r2, r2, #1
 c2272a0:	e5832000 	str	r2, [r3]
 c2272a4:	ea00000a 	b	c2272d4 <ic_conf_fiq+0x70>
	else if (st == DISABLE)
 c2272a8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2272ac:	e3530000 	cmp	r3, #0
 c2272b0:	1a000005 	bne	c2272cc <ic_conf_fiq+0x68>
		//COMPLETAR: deshabilitar la linea FIQ
		rINTCON |= 1 << 0;
 c2272b4:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c2272b8:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c2272bc:	e5922000 	ldr	r2, [r2]
 c2272c0:	e3822001 	orr	r2, r2, #1
 c2272c4:	e5832000 	str	r2, [r3]
 c2272c8:	ea000001 	b	c2272d4 <ic_conf_fiq+0x70>
	else
		ret = -1;
 c2272cc:	e3e03000 	mvn	r3, #0
 c2272d0:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c2272d4:	e51b3010 	ldr	r3, [fp, #-16]
}
 c2272d8:	e1a00003 	mov	r0, r3
 c2272dc:	e24bd00c 	sub	sp, fp, #12
 c2272e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2272e4:	e12fff1e 	bx	lr

0c2272e8 <ic_conf_line>:

int ic_conf_line(enum int_line line, enum int_mode mode)
{
 c2272e8:	e1a0c00d 	mov	ip, sp
 c2272ec:	e92dd800 	push	{fp, ip, lr, pc}
 c2272f0:	e24cb004 	sub	fp, ip, #4
 c2272f4:	e24dd010 	sub	sp, sp, #16
 c2272f8:	e1a02000 	mov	r2, r0
 c2272fc:	e1a03001 	mov	r3, r1
 c227300:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c227304:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	unsigned int bit = INT_BIT(line);
 c227308:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22730c:	e3a02001 	mov	r2, #1
 c227310:	e1a03312 	lsl	r3, r2, r3
 c227314:	e50b3010 	str	r3, [fp, #-16]

	if (line < 0 || line > 26)
 c227318:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22731c:	e353001a 	cmp	r3, #26
 c227320:	9a000001 	bls	c22732c <ic_conf_line+0x44>
		return -1;
 c227324:	e3e03000 	mvn	r3, #0
 c227328:	ea000019 	b	c227394 <ic_conf_line+0xac>

	if (mode != IRQ && mode != FIQ)
 c22732c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c227330:	e3530000 	cmp	r3, #0
 c227334:	0a000004 	beq	c22734c <ic_conf_line+0x64>
 c227338:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c22733c:	e3530001 	cmp	r3, #1
 c227340:	0a000001 	beq	c22734c <ic_conf_line+0x64>
		return -1;
 c227344:	e3e03000 	mvn	r3, #0
 c227348:	ea000011 	b	c227394 <ic_conf_line+0xac>

	if (mode == IRQ)
 c22734c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c227350:	e3530000 	cmp	r3, #0
 c227354:	1a000007 	bne	c227378 <ic_conf_line+0x90>
		//COMPLETAR: poner la linea line en modo IRQ
		rINTMOD &= ~bit;
 c227358:	e59f3044 	ldr	r3, [pc, #68]	; c2273a4 <ic_conf_line+0xbc>
 c22735c:	e59f2040 	ldr	r2, [pc, #64]	; c2273a4 <ic_conf_line+0xbc>
 c227360:	e5921000 	ldr	r1, [r2]
 c227364:	e51b2010 	ldr	r2, [fp, #-16]
 c227368:	e1e02002 	mvn	r2, r2
 c22736c:	e0012002 	and	r2, r1, r2
 c227370:	e5832000 	str	r2, [r3]
 c227374:	ea000005 	b	c227390 <ic_conf_line+0xa8>
	else
		//COMPLETAR: poner la linea line en modo FIQ
		rINTMOD |= bit;
 c227378:	e59f3024 	ldr	r3, [pc, #36]	; c2273a4 <ic_conf_line+0xbc>
 c22737c:	e59f2020 	ldr	r2, [pc, #32]	; c2273a4 <ic_conf_line+0xbc>
 c227380:	e5921000 	ldr	r1, [r2]
 c227384:	e51b2010 	ldr	r2, [fp, #-16]
 c227388:	e1812002 	orr	r2, r1, r2
 c22738c:	e5832000 	str	r2, [r3]
	return 0;
 c227390:	e3a03000 	mov	r3, #0
}
 c227394:	e1a00003 	mov	r0, r3
 c227398:	e24bd00c 	sub	sp, fp, #12
 c22739c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2273a0:	e12fff1e 	bx	lr
 c2273a4:	01e00008 	.word	0x01e00008

0c2273a8 <ic_enable>:

int ic_enable(enum int_line line)
{
 c2273a8:	e1a0c00d 	mov	ip, sp
 c2273ac:	e92dd800 	push	{fp, ip, lr, pc}
 c2273b0:	e24cb004 	sub	fp, ip, #4
 c2273b4:	e24dd008 	sub	sp, sp, #8
 c2273b8:	e1a03000 	mov	r3, r0
 c2273bc:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c2273c0:	e55b300d 	ldrb	r3, [fp, #-13]
 c2273c4:	e353001a 	cmp	r3, #26
 c2273c8:	9a000001 	bls	c2273d4 <ic_enable+0x2c>
		return -1;
 c2273cc:	e3e03000 	mvn	r3, #0
 c2273d0:	ea000009 	b	c2273fc <ic_enable+0x54>

	//COMPLETAR: habilitar las interrupciones por la linea line
	rINTMSK &= ~(1 << line);
 c2273d4:	e59f3030 	ldr	r3, [pc, #48]	; c22740c <ic_enable+0x64>
 c2273d8:	e59f202c 	ldr	r2, [pc, #44]	; c22740c <ic_enable+0x64>
 c2273dc:	e5921000 	ldr	r1, [r2]
 c2273e0:	e55b200d 	ldrb	r2, [fp, #-13]
 c2273e4:	e3a00001 	mov	r0, #1
 c2273e8:	e1a02210 	lsl	r2, r0, r2
 c2273ec:	e1e02002 	mvn	r2, r2
 c2273f0:	e0012002 	and	r2, r1, r2
 c2273f4:	e5832000 	str	r2, [r3]
	return 0;
 c2273f8:	e3a03000 	mov	r3, #0
}
 c2273fc:	e1a00003 	mov	r0, r3
 c227400:	e24bd00c 	sub	sp, fp, #12
 c227404:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227408:	e12fff1e 	bx	lr
 c22740c:	01e0000c 	.word	0x01e0000c

0c227410 <ic_disable>:

int ic_disable(enum int_line line)
{
 c227410:	e1a0c00d 	mov	ip, sp
 c227414:	e92dd800 	push	{fp, ip, lr, pc}
 c227418:	e24cb004 	sub	fp, ip, #4
 c22741c:	e24dd008 	sub	sp, sp, #8
 c227420:	e1a03000 	mov	r3, r0
 c227424:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c227428:	e55b300d 	ldrb	r3, [fp, #-13]
 c22742c:	e353001a 	cmp	r3, #26
 c227430:	9a000001 	bls	c22743c <ic_disable+0x2c>
		return -1;
 c227434:	e3e03000 	mvn	r3, #0
 c227438:	ea000008 	b	c227460 <ic_disable+0x50>

	//COMPLETAR: enmascarar las interrupciones por la linea line
	rINTMSK |= 1 << line;
 c22743c:	e59f302c 	ldr	r3, [pc, #44]	; c227470 <ic_disable+0x60>
 c227440:	e59f2028 	ldr	r2, [pc, #40]	; c227470 <ic_disable+0x60>
 c227444:	e5921000 	ldr	r1, [r2]
 c227448:	e55b200d 	ldrb	r2, [fp, #-13]
 c22744c:	e3a00001 	mov	r0, #1
 c227450:	e1a02210 	lsl	r2, r0, r2
 c227454:	e1812002 	orr	r2, r1, r2
 c227458:	e5832000 	str	r2, [r3]
	return 0;
 c22745c:	e3a03000 	mov	r3, #0
}
 c227460:	e1a00003 	mov	r0, r3
 c227464:	e24bd00c 	sub	sp, fp, #12
 c227468:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22746c:	e12fff1e 	bx	lr
 c227470:	01e0000c 	.word	0x01e0000c

0c227474 <ic_cleanflag>:

int ic_cleanflag(enum int_line line)
{
 c227474:	e1a0c00d 	mov	ip, sp
 c227478:	e92dd800 	push	{fp, ip, lr, pc}
 c22747c:	e24cb004 	sub	fp, ip, #4
 c227480:	e24dd010 	sub	sp, sp, #16
 c227484:	e1a03000 	mov	r3, r0
 c227488:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int bit;

	if (line < 0 || line > 26)
 c22748c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c227490:	e353001a 	cmp	r3, #26
 c227494:	9a000001 	bls	c2274a0 <ic_cleanflag+0x2c>
		return -1;
 c227498:	e3e03000 	mvn	r3, #0
 c22749c:	ea000017 	b	c227500 <ic_cleanflag+0x8c>

	bit = INT_BIT(line);
 c2274a0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c2274a4:	e3a02001 	mov	r2, #1
 c2274a8:	e1a03312 	lsl	r3, r2, r3
 c2274ac:	e50b3010 	str	r3, [fp, #-16]

	if (rINTMOD & bit)
 c2274b0:	e59f3058 	ldr	r3, [pc, #88]	; c227510 <ic_cleanflag+0x9c>
 c2274b4:	e5932000 	ldr	r2, [r3]
 c2274b8:	e51b3010 	ldr	r3, [fp, #-16]
 c2274bc:	e0023003 	and	r3, r2, r3
 c2274c0:	e3530000 	cmp	r3, #0
 c2274c4:	0a000006 	beq	c2274e4 <ic_cleanflag+0x70>
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por FIQ
		rF_ISPC |= bit;
 c2274c8:	e59f3044 	ldr	r3, [pc, #68]	; c227514 <ic_cleanflag+0xa0>
 c2274cc:	e59f2040 	ldr	r2, [pc, #64]	; c227514 <ic_cleanflag+0xa0>
 c2274d0:	e5921000 	ldr	r1, [r2]
 c2274d4:	e51b2010 	ldr	r2, [fp, #-16]
 c2274d8:	e1812002 	orr	r2, r1, r2
 c2274dc:	e5832000 	str	r2, [r3]
 c2274e0:	ea000005 	b	c2274fc <ic_cleanflag+0x88>
	else
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por IRQ
		rI_ISPC |= bit;
 c2274e4:	e59f302c 	ldr	r3, [pc, #44]	; c227518 <ic_cleanflag+0xa4>
 c2274e8:	e59f2028 	ldr	r2, [pc, #40]	; c227518 <ic_cleanflag+0xa4>
 c2274ec:	e5921000 	ldr	r1, [r2]
 c2274f0:	e51b2010 	ldr	r2, [fp, #-16]
 c2274f4:	e1812002 	orr	r2, r1, r2
 c2274f8:	e5832000 	str	r2, [r3]
	return 0;
 c2274fc:	e3a03000 	mov	r3, #0
}
 c227500:	e1a00003 	mov	r0, r3
 c227504:	e24bd00c 	sub	sp, fp, #12
 c227508:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22750c:	e12fff1e 	bx	lr
 c227510:	01e00008 	.word	0x01e00008
 c227514:	01e0003c 	.word	0x01e0003c
 c227518:	01e00024 	.word	0x01e00024

0c22751c <kb_scan>:
/*--- Variables globales ---*/
volatile static unsigned char *keyboard_base = (unsigned char *)0x06000000;


int kb_scan(void)
{
 c22751c:	e1a0c00d 	mov	ip, sp
 c227520:	e92dd810 	push	{r4, fp, ip, lr, pc}
 c227524:	e24cb004 	sub	fp, ip, #4
 c227528:	e24dd064 	sub	sp, sp, #100	; 0x64
	int value = -1;
 c22752c:	e3e03000 	mvn	r3, #0
 c227530:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	int i;
	char temp;
	int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};
 c227534:	e59f3178 	ldr	r3, [pc, #376]	; c2276b4 <kb_scan+0x198>
 c227538:	e24bc030 	sub	ip, fp, #48	; 0x30
 c22753c:	e893000f 	ldm	r3, {r0, r1, r2, r3}
 c227540:	e88c000f 	stm	ip, {r0, r1, r2, r3}
	int map[4][4] = {{0, 1, 2, 3},
 c227544:	e59f316c 	ldr	r3, [pc, #364]	; c2276b8 <kb_scan+0x19c>
 c227548:	e24bc070 	sub	ip, fp, #112	; 0x70
 c22754c:	e1a04003 	mov	r4, r3
 c227550:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c227554:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c227558:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c22755c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c227560:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c227564:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c227568:	e894000f 	ldm	r4, {r0, r1, r2, r3}
 c22756c:	e88c000f 	stm	ip, {r0, r1, r2, r3}
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c227570:	e3a03000 	mov	r3, #0
 c227574:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c227578:	ea000042 	b	c227688 <kb_scan+0x16c>
		temp = *(keyboard_base+lines[i]);
 c22757c:	e59f3138 	ldr	r3, [pc, #312]	; c2276bc <kb_scan+0x1a0>
 c227580:	e5932000 	ldr	r2, [r3]
 c227584:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c227588:	e3e0301b 	mvn	r3, #27
 c22758c:	e1a01101 	lsl	r1, r1, #2
 c227590:	e24b0014 	sub	r0, fp, #20
 c227594:	e0801001 	add	r1, r0, r1
 c227598:	e0813003 	add	r3, r1, r3
 c22759c:	e5933000 	ldr	r3, [r3]
 c2275a0:	e0823003 	add	r3, r2, r3
 c2275a4:	e5d33000 	ldrb	r3, [r3]
 c2275a8:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3

		if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {
 c2275ac:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2275b0:	e203300f 	and	r3, r3, #15
 c2275b4:	e353000f 	cmp	r3, #15
 c2275b8:	0a00002f 	beq	c22767c <kb_scan+0x160>
			//COMPLETAR: 
			//      si estÃ¡ el bit 1 a 0 la tecla es la map[i][3]
			//      si estÃ¡ el bit 2 a 0 la tecla es la map[i][2]
			//      si estÃ¡ el bit 3 a 0 la tecla es la map[i][1]
			//      si estÃ¡ el bit 4 a 0 la tecla es la map[i][0]
			if(!(temp & 1 << 0)) {
 c2275bc:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2275c0:	e2033001 	and	r3, r3, #1
 c2275c4:	e3530000 	cmp	r3, #0
 c2275c8:	1a000007 	bne	c2275ec <kb_scan+0xd0>
				return map[i][3];
 c2275cc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c2275d0:	e3e0304f 	mvn	r3, #79	; 0x4f
 c2275d4:	e1a02202 	lsl	r2, r2, #4
 c2275d8:	e24b1014 	sub	r1, fp, #20
 c2275dc:	e0812002 	add	r2, r1, r2
 c2275e0:	e0823003 	add	r3, r2, r3
 c2275e4:	e5933000 	ldr	r3, [r3]
 c2275e8:	ea00002d 	b	c2276a4 <kb_scan+0x188>
			}

			if(!(temp & 1 << 1)) {
 c2275ec:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c2275f0:	e2033002 	and	r3, r3, #2
 c2275f4:	e3530000 	cmp	r3, #0
 c2275f8:	1a000007 	bne	c22761c <kb_scan+0x100>
				return map[i][2];
 c2275fc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c227600:	e3e03053 	mvn	r3, #83	; 0x53
 c227604:	e1a02202 	lsl	r2, r2, #4
 c227608:	e24b0014 	sub	r0, fp, #20
 c22760c:	e0802002 	add	r2, r0, r2
 c227610:	e0823003 	add	r3, r2, r3
 c227614:	e5933000 	ldr	r3, [r3]
 c227618:	ea000021 	b	c2276a4 <kb_scan+0x188>
			}

			if(!(temp & 1 << 2)) {
 c22761c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c227620:	e2033004 	and	r3, r3, #4
 c227624:	e3530000 	cmp	r3, #0
 c227628:	1a000007 	bne	c22764c <kb_scan+0x130>
				return map[i][1];
 c22762c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c227630:	e3e03057 	mvn	r3, #87	; 0x57
 c227634:	e1a02202 	lsl	r2, r2, #4
 c227638:	e24b1014 	sub	r1, fp, #20
 c22763c:	e0812002 	add	r2, r1, r2
 c227640:	e0823003 	add	r3, r2, r3
 c227644:	e5933000 	ldr	r3, [r3]
 c227648:	ea000015 	b	c2276a4 <kb_scan+0x188>
			}

			if(!(temp & 1 << 3)) {
 c22764c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c227650:	e2033008 	and	r3, r3, #8
 c227654:	e3530000 	cmp	r3, #0
 c227658:	1a000007 	bne	c22767c <kb_scan+0x160>
				return map[i][0];
 c22765c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c227660:	e3e0305b 	mvn	r3, #91	; 0x5b
 c227664:	e1a02202 	lsl	r2, r2, #4
 c227668:	e24b0014 	sub	r0, fp, #20
 c22766c:	e0802002 	add	r2, r0, r2
 c227670:	e0823003 	add	r3, r2, r3
 c227674:	e5933000 	ldr	r3, [r3]
 c227678:	ea000009 	b	c2276a4 <kb_scan+0x188>
	int map[4][4] = {{0, 1, 2, 3},
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c22767c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c227680:	e2833001 	add	r3, r3, #1
 c227684:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c227688:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22768c:	e3530003 	cmp	r3, #3
 c227690:	ca000002 	bgt	c2276a0 <kb_scan+0x184>
 c227694:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c227698:	e3730001 	cmn	r3, #1
 c22769c:	0affffb6 	beq	c22757c <kb_scan+0x60>
			}

	}
	}

	return value;
 c2276a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
 c2276a4:	e1a00003 	mov	r0, r3
 c2276a8:	e24bd010 	sub	sp, fp, #16
 c2276ac:	e89d6810 	ldm	sp, {r4, fp, sp, lr}
 c2276b0:	e12fff1e 	bx	lr
 c2276b4:	0c1021b0 	.word	0x0c1021b0
 c2276b8:	0c1021c0 	.word	0x0c1021c0
 c2276bc:	0c100140 	.word	0x0c100140

0c2276c0 <lcd_init>:
static uint8 lcd_buffer[LCD_BUFFER_SIZE];

static uint8 state;

void lcd_init( void )
{
 c2276c0:	e1a0c00d 	mov	ip, sp
 c2276c4:	e92dd800 	push	{fp, ip, lr, pc}
 c2276c8:	e24cb004 	sub	fp, ip, #4
	//Initialize dithering patterns to recommended patterns
	rDITHMODE = 0x12210;
 c2276cc:	e59f30fc 	ldr	r3, [pc, #252]	; c2277d0 <lcd_init+0x110>
 c2276d0:	e59f20fc 	ldr	r2, [pc, #252]	; c2277d4 <lcd_init+0x114>
 c2276d4:	e5832000 	str	r2, [r3]
	rDP1_2 = 0xA5A5;
 c2276d8:	e59f30f8 	ldr	r3, [pc, #248]	; c2277d8 <lcd_init+0x118>
 c2276dc:	e59f20f8 	ldr	r2, [pc, #248]	; c2277dc <lcd_init+0x11c>
 c2276e0:	e5832000 	str	r2, [r3]
	rDP4_7 = 0xBA5DA65;
 c2276e4:	e59f30f4 	ldr	r3, [pc, #244]	; c2277e0 <lcd_init+0x120>
 c2276e8:	e59f20f4 	ldr	r2, [pc, #244]	; c2277e4 <lcd_init+0x124>
 c2276ec:	e5832000 	str	r2, [r3]
	rDP3_5 = 0xA5A5F;
 c2276f0:	e59f30f0 	ldr	r3, [pc, #240]	; c2277e8 <lcd_init+0x128>
 c2276f4:	e59f20f0 	ldr	r2, [pc, #240]	; c2277ec <lcd_init+0x12c>
 c2276f8:	e5832000 	str	r2, [r3]
	rDP2_3 = 0xD6B;
 c2276fc:	e59f30ec 	ldr	r3, [pc, #236]	; c2277f0 <lcd_init+0x130>
 c227700:	e59f20ec 	ldr	r2, [pc, #236]	; c2277f4 <lcd_init+0x134>
 c227704:	e5832000 	str	r2, [r3]
	rDP5_7 = 0xEB7B5ED;
 c227708:	e59f30e8 	ldr	r3, [pc, #232]	; c2277f8 <lcd_init+0x138>
 c22770c:	e59f20e8 	ldr	r2, [pc, #232]	; c2277fc <lcd_init+0x13c>
 c227710:	e5832000 	str	r2, [r3]
	rDP3_4 = 0x7DBE;
 c227714:	e59f30e4 	ldr	r3, [pc, #228]	; c227800 <lcd_init+0x140>
 c227718:	e59f20e4 	ldr	r2, [pc, #228]	; c227804 <lcd_init+0x144>
 c22771c:	e5832000 	str	r2, [r3]
	rDP4_5 = 0x7EBDF;
 c227720:	e59f30e0 	ldr	r3, [pc, #224]	; c227808 <lcd_init+0x148>
 c227724:	e59f20e0 	ldr	r2, [pc, #224]	; c22780c <lcd_init+0x14c>
 c227728:	e5832000 	str	r2, [r3]
	rDP6_7 = 0x7FDFBFE;
 c22772c:	e59f30dc 	ldr	r3, [pc, #220]	; c227810 <lcd_init+0x150>
 c227730:	e59f20dc 	ldr	r2, [pc, #220]	; c227814 <lcd_init+0x154>
 c227734:	e5832000 	str	r2, [r3]

	//Zero, black and white LCD
    rREDLUT   = 0;
 c227738:	e59f30d8 	ldr	r3, [pc, #216]	; c227818 <lcd_init+0x158>
 c22773c:	e3a02000 	mov	r2, #0
 c227740:	e5832000 	str	r2, [r3]
    rGREENLUT = 0;
 c227744:	e59f30d0 	ldr	r3, [pc, #208]	; c22781c <lcd_init+0x15c>
 c227748:	e3a02000 	mov	r2, #0
 c22774c:	e5832000 	str	r2, [r3]
    rBLUELUT  = 0;
 c227750:	e59f30c8 	ldr	r3, [pc, #200]	; c227820 <lcd_init+0x160>
 c227754:	e3a02000 	mov	r2, #0
 c227758:	e5832000 	str	r2, [r3]
    //LCDCON1[3]     = 0   no invierte la señal VLINE
    //LCDCON1[4]     = 0   las señales de vídeo se muestrean a flanco de bajada
    //LCDCON1[9:8]   = 0   WDLY = 4 ciclos (minimum blanking)
    //LCDCON1[11:10] = 0   WLH = 4 ciclos  (minimum blanking)
    //LCDCON1[21:12] = 28  CLKVAL = 28 => tFRAME = 59,4 Hz
    rLCDCON1  = 0x1C020;
 c22775c:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c227760:	e59f20bc 	ldr	r2, [pc, #188]	; c227824 <lcd_init+0x164>
 c227764:	e5832000 	str	r2, [r3]

    //LCDCON2[31:21] =  0 LINEBLANK = 0 ciclos (minimum horizontal blanking
    //LCDCON2[20:10] = 79   HOZVAL = (320 / 4)  1 (Horizontal resolution)
    //LCDCON2[9:0]   = 239  LINEVAL = 240  1 (Vertical resolution)
    rLCDCON2  = 0x13CEF;
 c227768:	e59f30b8 	ldr	r3, [pc, #184]	; c227828 <lcd_init+0x168>
 c22776c:	e59f20b8 	ldr	r2, [pc, #184]	; c22782c <lcd_init+0x16c>
 c227770:	e5832000 	str	r2, [r3]

    //LCDCON3[0] = 0  Disable self refresh
    rLCDCON3  = 0;
 c227774:	e59f30b4 	ldr	r3, [pc, #180]	; c227830 <lcd_init+0x170>
 c227778:	e3a02000 	mov	r2, #0
 c22777c:	e5832000 	str	r2, [r3]

    //Start of lcd_buffer
    rLCDSADDR1 = (2 << 27) | ((uint32)lcd_buffer >> 1);
 c227780:	e59f30ac 	ldr	r3, [pc, #172]	; c227834 <lcd_init+0x174>
 c227784:	e59f20ac 	ldr	r2, [pc, #172]	; c227838 <lcd_init+0x178>
 c227788:	e1a020a2 	lsr	r2, r2, #1
 c22778c:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
 c227790:	e5832000 	str	r2, [r3]

    //End of lcd_buffer
    rLCDSADDR2 = (1 << 29) | (((uint32)lcd_buffer + LCD_BUFFER_SIZE) & 0x3FFFFF) >> 1;
 c227794:	e59f20a0 	ldr	r2, [pc, #160]	; c22783c <lcd_init+0x17c>
 c227798:	e59f3098 	ldr	r3, [pc, #152]	; c227838 <lcd_init+0x178>
 c22779c:	e2833c96 	add	r3, r3, #38400	; 0x9600
 c2277a0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c2277a4:	e3c33503 	bic	r3, r3, #12582912	; 0xc00000
 c2277a8:	e1a030a3 	lsr	r3, r3, #1
 c2277ac:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
 c2277b0:	e5823000 	str	r3, [r2]

    //No virtual screen
    //LCDSADDR3[19:9] = 0 OFFSIZE = 0
    //LCDSADDR3[8:0] = 80 PAGEWIDTH = HOZVAL + 1 = 320 / 4
    rLCDSADDR3 = 0x50;
 c2277b4:	e59f3084 	ldr	r3, [pc, #132]	; c227840 <lcd_init+0x180>
 c2277b8:	e3a02050 	mov	r2, #80	; 0x50
 c2277bc:	e5832000 	str	r2, [r3]

    lcd_off();
 c2277c0:	eb00002e 	bl	c227880 <lcd_off>
}
 c2277c4:	e24bd00c 	sub	sp, fp, #12
 c2277c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2277cc:	e12fff1e 	bx	lr
 c2277d0:	01f00044 	.word	0x01f00044
 c2277d4:	00012210 	.word	0x00012210
 c2277d8:	01f00020 	.word	0x01f00020
 c2277dc:	0000a5a5 	.word	0x0000a5a5
 c2277e0:	01f00024 	.word	0x01f00024
 c2277e4:	0ba5da65 	.word	0x0ba5da65
 c2277e8:	01f00028 	.word	0x01f00028
 c2277ec:	000a5a5f 	.word	0x000a5a5f
 c2277f0:	01f0002c 	.word	0x01f0002c
 c2277f4:	00000d6b 	.word	0x00000d6b
 c2277f8:	01f00030 	.word	0x01f00030
 c2277fc:	0eb7b5ed 	.word	0x0eb7b5ed
 c227800:	01f00034 	.word	0x01f00034
 c227804:	00007dbe 	.word	0x00007dbe
 c227808:	01f00038 	.word	0x01f00038
 c22780c:	0007ebdf 	.word	0x0007ebdf
 c227810:	01f0003c 	.word	0x01f0003c
 c227814:	07fdfbfe 	.word	0x07fdfbfe
 c227818:	01f00014 	.word	0x01f00014
 c22781c:	01f00018 	.word	0x01f00018
 c227820:	01f0001c 	.word	0x01f0001c
 c227824:	0001c020 	.word	0x0001c020
 c227828:	01f00004 	.word	0x01f00004
 c22782c:	00013cef 	.word	0x00013cef
 c227830:	01f00040 	.word	0x01f00040
 c227834:	01f00008 	.word	0x01f00008
 c227838:	0c1023fc 	.word	0x0c1023fc
 c22783c:	01f0000c 	.word	0x01f0000c
 c227840:	01f00010 	.word	0x01f00010

0c227844 <lcd_on>:

void lcd_on( void )
{
 c227844:	e1a0c00d 	mov	ip, sp
 c227848:	e92dd800 	push	{fp, ip, lr, pc}
 c22784c:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 |= 1;
 c227850:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c227854:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c227858:	e5922000 	ldr	r2, [r2]
 c22785c:	e3822001 	orr	r2, r2, #1
 c227860:	e5832000 	str	r2, [r3]
	state = 1;
 c227864:	e59f3010 	ldr	r3, [pc, #16]	; c22787c <lcd_on+0x38>
 c227868:	e3a02001 	mov	r2, #1
 c22786c:	e5c32000 	strb	r2, [r3]
}
 c227870:	e24bd00c 	sub	sp, fp, #12
 c227874:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227878:	e12fff1e 	bx	lr
 c22787c:	0c10b9fc 	.word	0x0c10b9fc

0c227880 <lcd_off>:

void lcd_off( void )
{
 c227880:	e1a0c00d 	mov	ip, sp
 c227884:	e92dd800 	push	{fp, ip, lr, pc}
 c227888:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 &= ~1;
 c22788c:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c227890:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c227894:	e5922000 	ldr	r2, [r2]
 c227898:	e3c22001 	bic	r2, r2, #1
 c22789c:	e5832000 	str	r2, [r3]
	state = 0;
 c2278a0:	e59f3010 	ldr	r3, [pc, #16]	; c2278b8 <lcd_off+0x38>
 c2278a4:	e3a02000 	mov	r2, #0
 c2278a8:	e5c32000 	strb	r2, [r3]
}
 c2278ac:	e24bd00c 	sub	sp, fp, #12
 c2278b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2278b4:	e12fff1e 	bx	lr
 c2278b8:	0c10b9fc 	.word	0x0c10b9fc

0c2278bc <lcd_status>:

uint8 lcd_status( void )
{
 c2278bc:	e1a0c00d 	mov	ip, sp
 c2278c0:	e92dd800 	push	{fp, ip, lr, pc}
 c2278c4:	e24cb004 	sub	fp, ip, #4
	return state;
 c2278c8:	e59f3010 	ldr	r3, [pc, #16]	; c2278e0 <lcd_status+0x24>
 c2278cc:	e5d33000 	ldrb	r3, [r3]
}
 c2278d0:	e1a00003 	mov	r0, r3
 c2278d4:	e24bd00c 	sub	sp, fp, #12
 c2278d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2278dc:	e12fff1e 	bx	lr
 c2278e0:	0c10b9fc 	.word	0x0c10b9fc

0c2278e4 <lcd_clear>:

void lcd_clear( void )
{
 c2278e4:	e1a0c00d 	mov	ip, sp
 c2278e8:	e92dd800 	push	{fp, ip, lr, pc}
 c2278ec:	e24cb004 	sub	fp, ip, #4
 c2278f0:	e24dd008 	sub	sp, sp, #8
	uint16 i = 0;
 c2278f4:	e3a03000 	mov	r3, #0
 c2278f8:	e14b30be 	strh	r3, [fp, #-14]
    while(i < LCD_BUFFER_SIZE) {
 c2278fc:	ea000006 	b	c22791c <lcd_clear+0x38>
    	lcd_buffer[i] = 0x0;
 c227900:	e15b30be 	ldrh	r3, [fp, #-14]
 c227904:	e59f202c 	ldr	r2, [pc, #44]	; c227938 <lcd_clear+0x54>
 c227908:	e3a01000 	mov	r1, #0
 c22790c:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c227910:	e15b30be 	ldrh	r3, [fp, #-14]
 c227914:	e2833001 	add	r3, r3, #1
 c227918:	e14b30be 	strh	r3, [fp, #-14]
}

void lcd_clear( void )
{
	uint16 i = 0;
    while(i < LCD_BUFFER_SIZE) {
 c22791c:	e15b20be 	ldrh	r2, [fp, #-14]
 c227920:	e59f3014 	ldr	r3, [pc, #20]	; c22793c <lcd_clear+0x58>
 c227924:	e1520003 	cmp	r2, r3
 c227928:	9afffff4 	bls	c227900 <lcd_clear+0x1c>
    	lcd_buffer[i] = 0x0;
    	i++;
    }
}
 c22792c:	e24bd00c 	sub	sp, fp, #12
 c227930:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227934:	e12fff1e 	bx	lr
 c227938:	0c1023fc 	.word	0x0c1023fc
 c22793c:	000095ff 	.word	0x000095ff

0c227940 <lcd_clear_color>:

void lcd_clear_color( uint8 color )
{
 c227940:	e1a0c00d 	mov	ip, sp
 c227944:	e92dd800 	push	{fp, ip, lr, pc}
 c227948:	e24cb004 	sub	fp, ip, #4
 c22794c:	e24dd010 	sub	sp, sp, #16
 c227950:	e1a03000 	mov	r3, r0
 c227954:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	uint16 i = 0;
 c227958:	e3a03000 	mov	r3, #0
 c22795c:	e14b30be 	strh	r3, [fp, #-14]
	uint8 c = color & 0xf;
 c227960:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c227964:	e203300f 	and	r3, r3, #15
 c227968:	e54b300f 	strb	r3, [fp, #-15]

    while(i < LCD_BUFFER_SIZE) {
 c22796c:	ea00000c 	b	c2279a4 <lcd_clear_color+0x64>
    	lcd_buffer[i] = (c << 4) | c;
 c227970:	e15b30be 	ldrh	r3, [fp, #-14]
 c227974:	e55b200f 	ldrb	r2, [fp, #-15]
 c227978:	e1a02202 	lsl	r2, r2, #4
 c22797c:	e20210ff 	and	r1, r2, #255	; 0xff
 c227980:	e55b200f 	ldrb	r2, [fp, #-15]
 c227984:	e1812002 	orr	r2, r1, r2
 c227988:	e20220ff 	and	r2, r2, #255	; 0xff
 c22798c:	e20210ff 	and	r1, r2, #255	; 0xff
 c227990:	e59f2028 	ldr	r2, [pc, #40]	; c2279c0 <lcd_clear_color+0x80>
 c227994:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c227998:	e15b30be 	ldrh	r3, [fp, #-14]
 c22799c:	e2833001 	add	r3, r3, #1
 c2279a0:	e14b30be 	strh	r3, [fp, #-14]
void lcd_clear_color( uint8 color )
{
	uint16 i = 0;
	uint8 c = color & 0xf;

    while(i < LCD_BUFFER_SIZE) {
 c2279a4:	e15b20be 	ldrh	r2, [fp, #-14]
 c2279a8:	e59f3014 	ldr	r3, [pc, #20]	; c2279c4 <lcd_clear_color+0x84>
 c2279ac:	e1520003 	cmp	r2, r3
 c2279b0:	9affffee 	bls	c227970 <lcd_clear_color+0x30>
    	lcd_buffer[i] = (c << 4) | c;
    	i++;
    }
}
 c2279b4:	e24bd00c 	sub	sp, fp, #12
 c2279b8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2279bc:	e12fff1e 	bx	lr
 c2279c0:	0c1023fc 	.word	0x0c1023fc
 c2279c4:	000095ff 	.word	0x000095ff

0c2279c8 <lcd_putpixel>:


void lcd_putpixel( uint16 x, uint16 y, uint8 c)
{
 c2279c8:	e1a0c00d 	mov	ip, sp
 c2279cc:	e92dd800 	push	{fp, ip, lr, pc}
 c2279d0:	e24cb004 	sub	fp, ip, #4
 c2279d4:	e24dd010 	sub	sp, sp, #16
 c2279d8:	e1a03002 	mov	r3, r2
 c2279dc:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c2279e0:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c2279e4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    uint8 byte, bit;
    uint16 i;

    i = x/2 + y*(LCD_WIDTH/2);
 c2279e8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c2279ec:	e1a030a3 	lsr	r3, r3, #1
 c2279f0:	e1a03803 	lsl	r3, r3, #16
 c2279f4:	e1a02823 	lsr	r2, r3, #16
 c2279f8:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c2279fc:	e1a01003 	mov	r1, r3
 c227a00:	e1a01101 	lsl	r1, r1, #2
 c227a04:	e0813003 	add	r3, r1, r3
 c227a08:	e1a03283 	lsl	r3, r3, #5
 c227a0c:	e1a03803 	lsl	r3, r3, #16
 c227a10:	e1a03823 	lsr	r3, r3, #16
 c227a14:	e0823003 	add	r3, r2, r3
 c227a18:	e14b30be 	strh	r3, [fp, #-14]
    bit = (1-x%2)*4;
 c227a1c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227a20:	e2033001 	and	r3, r3, #1
 c227a24:	e3530000 	cmp	r3, #0
 c227a28:	1a000001 	bne	c227a34 <lcd_putpixel+0x6c>
 c227a2c:	e3a03004 	mov	r3, #4
 c227a30:	ea000000 	b	c227a38 <lcd_putpixel+0x70>
 c227a34:	e3a03000 	mov	r3, #0
 c227a38:	e54b300f 	strb	r3, [fp, #-15]

    byte = lcd_buffer[i];
 c227a3c:	e15b30be 	ldrh	r3, [fp, #-14]
 c227a40:	e59f2068 	ldr	r2, [pc, #104]	; c227ab0 <lcd_putpixel+0xe8>
 c227a44:	e7d23003 	ldrb	r3, [r2, r3]
 c227a48:	e54b3010 	strb	r3, [fp, #-16]
    byte &= ~(0xF << bit);
 c227a4c:	e55b300f 	ldrb	r3, [fp, #-15]
 c227a50:	e3a0200f 	mov	r2, #15
 c227a54:	e1a03312 	lsl	r3, r2, r3
 c227a58:	e20330ff 	and	r3, r3, #255	; 0xff
 c227a5c:	e1e03003 	mvn	r3, r3
 c227a60:	e20320ff 	and	r2, r3, #255	; 0xff
 c227a64:	e55b3010 	ldrb	r3, [fp, #-16]
 c227a68:	e0023003 	and	r3, r2, r3
 c227a6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c227a70:	e54b3010 	strb	r3, [fp, #-16]
    byte |= c << bit;
 c227a74:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
 c227a78:	e55b300f 	ldrb	r3, [fp, #-15]
 c227a7c:	e1a03312 	lsl	r3, r2, r3
 c227a80:	e20320ff 	and	r2, r3, #255	; 0xff
 c227a84:	e55b3010 	ldrb	r3, [fp, #-16]
 c227a88:	e1823003 	orr	r3, r2, r3
 c227a8c:	e20330ff 	and	r3, r3, #255	; 0xff
 c227a90:	e54b3010 	strb	r3, [fp, #-16]
    lcd_buffer[i] = byte;
 c227a94:	e15b30be 	ldrh	r3, [fp, #-14]
 c227a98:	e59f2010 	ldr	r2, [pc, #16]	; c227ab0 <lcd_putpixel+0xe8>
 c227a9c:	e55b1010 	ldrb	r1, [fp, #-16]
 c227aa0:	e7c21003 	strb	r1, [r2, r3]
}
 c227aa4:	e24bd00c 	sub	sp, fp, #12
 c227aa8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227aac:	e12fff1e 	bx	lr
 c227ab0:	0c1023fc 	.word	0x0c1023fc

0c227ab4 <lcd_getpixel>:

uint8 lcd_getpixel( uint16 x, uint16 y )
{
 c227ab4:	e1a0c00d 	mov	ip, sp
 c227ab8:	e92dd800 	push	{fp, ip, lr, pc}
 c227abc:	e24cb004 	sub	fp, ip, #4
 c227ac0:	e24dd010 	sub	sp, sp, #16
 c227ac4:	e1a02000 	mov	r2, r0
 c227ac8:	e1a03001 	mov	r3, r1
 c227acc:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c227ad0:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
	uint8 byte, bit;
	uint16 i = x/2 + y*(LCD_WIDTH/2);
 c227ad4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227ad8:	e1a030a3 	lsr	r3, r3, #1
 c227adc:	e1a03803 	lsl	r3, r3, #16
 c227ae0:	e1a02823 	lsr	r2, r3, #16
 c227ae4:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c227ae8:	e1a01003 	mov	r1, r3
 c227aec:	e1a01101 	lsl	r1, r1, #2
 c227af0:	e0813003 	add	r3, r1, r3
 c227af4:	e1a03283 	lsl	r3, r3, #5
 c227af8:	e1a03803 	lsl	r3, r3, #16
 c227afc:	e1a03823 	lsr	r3, r3, #16
 c227b00:	e0823003 	add	r3, r2, r3
 c227b04:	e14b30be 	strh	r3, [fp, #-14]

	bit = (1-x%2)*4;
 c227b08:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227b0c:	e2033001 	and	r3, r3, #1
 c227b10:	e3530000 	cmp	r3, #0
 c227b14:	1a000001 	bne	c227b20 <lcd_getpixel+0x6c>
 c227b18:	e3a03004 	mov	r3, #4
 c227b1c:	ea000000 	b	c227b24 <lcd_getpixel+0x70>
 c227b20:	e3a03000 	mov	r3, #0
 c227b24:	e54b300f 	strb	r3, [fp, #-15]
	byte = lcd_buffer[i];
 c227b28:	e15b30be 	ldrh	r3, [fp, #-14]
 c227b2c:	e59f202c 	ldr	r2, [pc, #44]	; c227b60 <lcd_getpixel+0xac>
 c227b30:	e7d23003 	ldrb	r3, [r2, r3]
 c227b34:	e54b3010 	strb	r3, [fp, #-16]

	return (byte >> bit ) & 0xf;
 c227b38:	e55b2010 	ldrb	r2, [fp, #-16]
 c227b3c:	e55b300f 	ldrb	r3, [fp, #-15]
 c227b40:	e1a03352 	asr	r3, r2, r3
 c227b44:	e20330ff 	and	r3, r3, #255	; 0xff
 c227b48:	e203300f 	and	r3, r3, #15
 c227b4c:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c227b50:	e1a00003 	mov	r0, r3
 c227b54:	e24bd00c 	sub	sp, fp, #12
 c227b58:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227b5c:	e12fff1e 	bx	lr
 c227b60:	0c1023fc 	.word	0x0c1023fc

0c227b64 <lcd_draw_hline>:

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
 c227b64:	e1a0c00d 	mov	ip, sp
 c227b68:	e92dd800 	push	{fp, ip, lr, pc}
 c227b6c:	e24cb004 	sub	fp, ip, #4
 c227b70:	e24dd010 	sub	sp, sp, #16
 c227b74:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c227b78:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c227b7c:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c227b80:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c227b84:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227b88:	e50b3010 	str	r3, [fp, #-16]
 c227b8c:	ea000019 	b	c227bf8 <lcd_draw_hline+0x94>
		for(y_i = y; y_i < y + width; ++y_i)
 c227b90:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c227b94:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c227b98:	ea00000d 	b	c227bd4 <lcd_draw_hline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c227b9c:	e51b3010 	ldr	r3, [fp, #-16]
 c227ba0:	e1a03803 	lsl	r3, r3, #16
 c227ba4:	e1a01823 	lsr	r1, r3, #16
 c227ba8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227bac:	e1a03803 	lsl	r3, r3, #16
 c227bb0:	e1a02823 	lsr	r2, r3, #16
 c227bb4:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c227bb8:	e1a00001 	mov	r0, r1
 c227bbc:	e1a01002 	mov	r1, r2
 c227bc0:	e1a02003 	mov	r2, r3
 c227bc4:	ebffff7f 	bl	c2279c8 <lcd_putpixel>

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
		for(y_i = y; y_i < y + width; ++y_i)
 c227bc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227bcc:	e2833001 	add	r3, r3, #1
 c227bd0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c227bd4:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c227bd8:	e1db30b4 	ldrh	r3, [fp, #4]
 c227bdc:	e0822003 	add	r2, r2, r3
 c227be0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227be4:	e1520003 	cmp	r2, r3
 c227be8:	caffffeb 	bgt	c227b9c <lcd_draw_hline+0x38>
}

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c227bec:	e51b3010 	ldr	r3, [fp, #-16]
 c227bf0:	e2833001 	add	r3, r3, #1
 c227bf4:	e50b3010 	str	r3, [fp, #-16]
 c227bf8:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c227bfc:	e51b3010 	ldr	r3, [fp, #-16]
 c227c00:	e1520003 	cmp	r2, r3
 c227c04:	aaffffe1 	bge	c227b90 <lcd_draw_hline+0x2c>
		for(y_i = y; y_i < y + width; ++y_i)
			lcd_putpixel(x_i, y_i, color);
}
 c227c08:	e24bd00c 	sub	sp, fp, #12
 c227c0c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227c10:	e12fff1e 	bx	lr

0c227c14 <lcd_draw_vline>:

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
 c227c14:	e1a0c00d 	mov	ip, sp
 c227c18:	e92dd800 	push	{fp, ip, lr, pc}
 c227c1c:	e24cb004 	sub	fp, ip, #4
 c227c20:	e24dd010 	sub	sp, sp, #16
 c227c24:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c227c28:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c227c2c:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c227c30:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c227c34:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227c38:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c227c3c:	ea000019 	b	c227ca8 <lcd_draw_vline+0x94>
		for(x_i = x; x_i < x + width; ++x_i)
 c227c40:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c227c44:	e50b3010 	str	r3, [fp, #-16]
 c227c48:	ea00000d 	b	c227c84 <lcd_draw_vline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c227c4c:	e51b3010 	ldr	r3, [fp, #-16]
 c227c50:	e1a03803 	lsl	r3, r3, #16
 c227c54:	e1a01823 	lsr	r1, r3, #16
 c227c58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227c5c:	e1a03803 	lsl	r3, r3, #16
 c227c60:	e1a02823 	lsr	r2, r3, #16
 c227c64:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c227c68:	e1a00001 	mov	r0, r1
 c227c6c:	e1a01002 	mov	r1, r2
 c227c70:	e1a02003 	mov	r2, r3
 c227c74:	ebffff53 	bl	c2279c8 <lcd_putpixel>

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
		for(x_i = x; x_i < x + width; ++x_i)
 c227c78:	e51b3010 	ldr	r3, [fp, #-16]
 c227c7c:	e2833001 	add	r3, r3, #1
 c227c80:	e50b3010 	str	r3, [fp, #-16]
 c227c84:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c227c88:	e1db30b4 	ldrh	r3, [fp, #4]
 c227c8c:	e0822003 	add	r2, r2, r3
 c227c90:	e51b3010 	ldr	r3, [fp, #-16]
 c227c94:	e1520003 	cmp	r2, r3
 c227c98:	caffffeb 	bgt	c227c4c <lcd_draw_vline+0x38>
}

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c227c9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227ca0:	e2833001 	add	r3, r3, #1
 c227ca4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c227ca8:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c227cac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c227cb0:	e1520003 	cmp	r2, r3
 c227cb4:	aaffffe1 	bge	c227c40 <lcd_draw_vline+0x2c>
		for(x_i = x; x_i < x + width; ++x_i)
			lcd_putpixel(x_i, y_i, color);
}
 c227cb8:	e24bd00c 	sub	sp, fp, #12
 c227cbc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227cc0:	e12fff1e 	bx	lr

0c227cc4 <lcd_draw_box>:

void lcd_draw_box( uint16 xleft, uint16 yup, uint16 xright, uint16 ydown, uint8 color, uint16 width )
{
 c227cc4:	e1a0c00d 	mov	ip, sp
 c227cc8:	e92dd800 	push	{fp, ip, lr, pc}
 c227ccc:	e24cb004 	sub	fp, ip, #4
 c227cd0:	e24dd010 	sub	sp, sp, #16
 c227cd4:	e14b00be 	strh	r0, [fp, #-14]
 c227cd8:	e14b11b0 	strh	r1, [fp, #-16]
 c227cdc:	e14b21b2 	strh	r2, [fp, #-18]	; 0xffffffee
 c227ce0:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
	lcd_draw_hline(xleft, xright, yup, color, width);
 c227ce4:	e15b00be 	ldrh	r0, [fp, #-14]
 c227ce8:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c227cec:	e15b21b0 	ldrh	r2, [fp, #-16]
 c227cf0:	e5db3004 	ldrb	r3, [fp, #4]
 c227cf4:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c227cf8:	e58dc000 	str	ip, [sp]
 c227cfc:	ebffff98 	bl	c227b64 <lcd_draw_hline>
	lcd_draw_vline(yup, ydown, xleft, color, width);
 c227d00:	e15b01b0 	ldrh	r0, [fp, #-16]
 c227d04:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c227d08:	e15b20be 	ldrh	r2, [fp, #-14]
 c227d0c:	e5db3004 	ldrb	r3, [fp, #4]
 c227d10:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c227d14:	e58dc000 	str	ip, [sp]
 c227d18:	ebffffbd 	bl	c227c14 <lcd_draw_vline>
	lcd_draw_vline(yup, ydown, xright - width + 1, color, width);
 c227d1c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c227d20:	e1db30b8 	ldrh	r3, [fp, #8]
 c227d24:	e0633002 	rsb	r3, r3, r2
 c227d28:	e1a03803 	lsl	r3, r3, #16
 c227d2c:	e1a03823 	lsr	r3, r3, #16
 c227d30:	e2833001 	add	r3, r3, #1
 c227d34:	e1a03803 	lsl	r3, r3, #16
 c227d38:	e1a02823 	lsr	r2, r3, #16
 c227d3c:	e15b01b0 	ldrh	r0, [fp, #-16]
 c227d40:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c227d44:	e5db3004 	ldrb	r3, [fp, #4]
 c227d48:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c227d4c:	e58dc000 	str	ip, [sp]
 c227d50:	ebffffaf 	bl	c227c14 <lcd_draw_vline>
	lcd_draw_hline(xleft, xright, ydown - width + 1, color, width);
 c227d54:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c227d58:	e1db30b8 	ldrh	r3, [fp, #8]
 c227d5c:	e0633002 	rsb	r3, r3, r2
 c227d60:	e1a03803 	lsl	r3, r3, #16
 c227d64:	e1a03823 	lsr	r3, r3, #16
 c227d68:	e2833001 	add	r3, r3, #1
 c227d6c:	e1a03803 	lsl	r3, r3, #16
 c227d70:	e1a02823 	lsr	r2, r3, #16
 c227d74:	e15b00be 	ldrh	r0, [fp, #-14]
 c227d78:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c227d7c:	e5db3004 	ldrb	r3, [fp, #4]
 c227d80:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c227d84:	e58dc000 	str	ip, [sp]
 c227d88:	ebffff75 	bl	c227b64 <lcd_draw_hline>
}
 c227d8c:	e24bd00c 	sub	sp, fp, #12
 c227d90:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227d94:	e12fff1e 	bx	lr

0c227d98 <lcd_putchar>:

void lcd_putchar( uint16 x, uint16 y, uint8 color, char ch )
{
 c227d98:	e1a0c00d 	mov	ip, sp
 c227d9c:	e92dd800 	push	{fp, ip, lr, pc}
 c227da0:	e24cb004 	sub	fp, ip, #4
 c227da4:	e24dd010 	sub	sp, sp, #16
 c227da8:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c227dac:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c227db0:	e54b2019 	strb	r2, [fp, #-25]	; 0xffffffe7
 c227db4:	e54b301a 	strb	r3, [fp, #-26]	; 0xffffffe6
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
 c227db8:	e55b301a 	ldrb	r3, [fp, #-26]	; 0xffffffe6
 c227dbc:	e1a03203 	lsl	r3, r3, #4
 c227dc0:	e1a02003 	mov	r2, r3
 c227dc4:	e59f311c 	ldr	r3, [pc, #284]	; c227ee8 <lcd_putchar+0x150>
 c227dc8:	e0823003 	add	r3, r2, r3
 c227dcc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for( line=0; line<16; line++ )
 c227dd0:	e3a03000 	mov	r3, #0
 c227dd4:	e54b300d 	strb	r3, [fp, #-13]
 c227dd8:	ea00003c 	b	c227ed0 <lcd_putchar+0x138>
        for( row=0; row<8; row++ )
 c227ddc:	e3a03000 	mov	r3, #0
 c227de0:	e54b300e 	strb	r3, [fp, #-14]
 c227de4:	ea000033 	b	c227eb8 <lcd_putchar+0x120>
            if( bitmap[line] & (0x80 >> row) )
 c227de8:	e55b300d 	ldrb	r3, [fp, #-13]
 c227dec:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c227df0:	e0823003 	add	r3, r2, r3
 c227df4:	e5d33000 	ldrb	r3, [r3]
 c227df8:	e1a02003 	mov	r2, r3
 c227dfc:	e55b300e 	ldrb	r3, [fp, #-14]
 c227e00:	e3a01080 	mov	r1, #128	; 0x80
 c227e04:	e1a03351 	asr	r3, r1, r3
 c227e08:	e0023003 	and	r3, r2, r3
 c227e0c:	e3530000 	cmp	r3, #0
 c227e10:	0a000013 	beq	c227e64 <lcd_putchar+0xcc>
                lcd_putpixel( x+row, y+line, color );
 c227e14:	e55b300e 	ldrb	r3, [fp, #-14]
 c227e18:	e1a03803 	lsl	r3, r3, #16
 c227e1c:	e1a02823 	lsr	r2, r3, #16
 c227e20:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227e24:	e0823003 	add	r3, r2, r3
 c227e28:	e1a03803 	lsl	r3, r3, #16
 c227e2c:	e1a01823 	lsr	r1, r3, #16
 c227e30:	e55b300d 	ldrb	r3, [fp, #-13]
 c227e34:	e1a03803 	lsl	r3, r3, #16
 c227e38:	e1a02823 	lsr	r2, r3, #16
 c227e3c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c227e40:	e0823003 	add	r3, r2, r3
 c227e44:	e1a03803 	lsl	r3, r3, #16
 c227e48:	e1a02823 	lsr	r2, r3, #16
 c227e4c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c227e50:	e1a00001 	mov	r0, r1
 c227e54:	e1a01002 	mov	r1, r2
 c227e58:	e1a02003 	mov	r2, r3
 c227e5c:	ebfffed9 	bl	c2279c8 <lcd_putpixel>
 c227e60:	ea000011 	b	c227eac <lcd_putchar+0x114>
            else
                lcd_putpixel( x+row, y+line, WHITE );
 c227e64:	e55b300e 	ldrb	r3, [fp, #-14]
 c227e68:	e1a03803 	lsl	r3, r3, #16
 c227e6c:	e1a02823 	lsr	r2, r3, #16
 c227e70:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c227e74:	e0823003 	add	r3, r2, r3
 c227e78:	e1a03803 	lsl	r3, r3, #16
 c227e7c:	e1a02823 	lsr	r2, r3, #16
 c227e80:	e55b300d 	ldrb	r3, [fp, #-13]
 c227e84:	e1a03803 	lsl	r3, r3, #16
 c227e88:	e1a01823 	lsr	r1, r3, #16
 c227e8c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c227e90:	e0813003 	add	r3, r1, r3
 c227e94:	e1a03803 	lsl	r3, r3, #16
 c227e98:	e1a03823 	lsr	r3, r3, #16
 c227e9c:	e1a00002 	mov	r0, r2
 c227ea0:	e1a01003 	mov	r1, r3
 c227ea4:	e3a02000 	mov	r2, #0
 c227ea8:	ebfffec6 	bl	c2279c8 <lcd_putpixel>
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
        for( row=0; row<8; row++ )
 c227eac:	e55b300e 	ldrb	r3, [fp, #-14]
 c227eb0:	e2833001 	add	r3, r3, #1
 c227eb4:	e54b300e 	strb	r3, [fp, #-14]
 c227eb8:	e55b300e 	ldrb	r3, [fp, #-14]
 c227ebc:	e3530007 	cmp	r3, #7
 c227ec0:	9affffc8 	bls	c227de8 <lcd_putchar+0x50>
{
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
 c227ec4:	e55b300d 	ldrb	r3, [fp, #-13]
 c227ec8:	e2833001 	add	r3, r3, #1
 c227ecc:	e54b300d 	strb	r3, [fp, #-13]
 c227ed0:	e55b300d 	ldrb	r3, [fp, #-13]
 c227ed4:	e353000f 	cmp	r3, #15
 c227ed8:	9affffbf 	bls	c227ddc <lcd_putchar+0x44>
        for( row=0; row<8; row++ )
            if( bitmap[line] & (0x80 >> row) )
                lcd_putpixel( x+row, y+line, color );
            else
                lcd_putpixel( x+row, y+line, WHITE );
}
 c227edc:	e24bd00c 	sub	sp, fp, #12
 c227ee0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227ee4:	e12fff1e 	bx	lr
 c227ee8:	0c1011b0 	.word	0x0c1011b0

0c227eec <lcd_puts>:

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
 c227eec:	e1a0c00d 	mov	ip, sp
 c227ef0:	e92dd800 	push	{fp, ip, lr, pc}
 c227ef4:	e24cb004 	sub	fp, ip, #4
 c227ef8:	e24dd010 	sub	sp, sp, #16
 c227efc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c227f00:	e14b00be 	strh	r0, [fp, #-14]
 c227f04:	e14b11b0 	strh	r1, [fp, #-16]
 c227f08:	e1a03002 	mov	r3, r2
 c227f0c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	while(*s) {
 c227f10:	ea000015 	b	c227f6c <lcd_puts+0x80>
		lcd_putchar(x, y, color, *s);
 c227f14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c227f18:	e5d33000 	ldrb	r3, [r3]
 c227f1c:	e15b00be 	ldrh	r0, [fp, #-14]
 c227f20:	e15b11b0 	ldrh	r1, [fp, #-16]
 c227f24:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c227f28:	ebffff9a 	bl	c227d98 <lcd_putchar>

		x += 8;
 c227f2c:	e15b30be 	ldrh	r3, [fp, #-14]
 c227f30:	e2833008 	add	r3, r3, #8
 c227f34:	e14b30be 	strh	r3, [fp, #-14]
		if(x + 8 >= LCD_WIDTH) {
 c227f38:	e15b30be 	ldrh	r3, [fp, #-14]
 c227f3c:	e2832008 	add	r2, r3, #8
 c227f40:	e59f3040 	ldr	r3, [pc, #64]	; c227f88 <lcd_puts+0x9c>
 c227f44:	e1520003 	cmp	r2, r3
 c227f48:	da000004 	ble	c227f60 <lcd_puts+0x74>
			x = 0;
 c227f4c:	e3a03000 	mov	r3, #0
 c227f50:	e14b30be 	strh	r3, [fp, #-14]
			y += 16;
 c227f54:	e15b31b0 	ldrh	r3, [fp, #-16]
 c227f58:	e2833010 	add	r3, r3, #16
 c227f5c:	e14b31b0 	strh	r3, [fp, #-16]
		}
		s++;
 c227f60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c227f64:	e2833001 	add	r3, r3, #1
 c227f68:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
                lcd_putpixel( x+row, y+line, WHITE );
}

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
	while(*s) {
 c227f6c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c227f70:	e5d33000 	ldrb	r3, [r3]
 c227f74:	e3530000 	cmp	r3, #0
 c227f78:	1affffe5 	bne	c227f14 <lcd_puts+0x28>
			x = 0;
			y += 16;
		}
		s++;
	}
}
 c227f7c:	e24bd00c 	sub	sp, fp, #12
 c227f80:	e89d6800 	ldm	sp, {fp, sp, lr}
 c227f84:	e12fff1e 	bx	lr
 c227f88:	0000013f 	.word	0x0000013f

0c227f8c <lcd_putWallpaper>:

void lcd_putWallpaper( uint8 *bmp )
{
 c227f8c:	e1a0c00d 	mov	ip, sp
 c227f90:	e92dd800 	push	{fp, ip, lr, pc}
 c227f94:	e24cb004 	sub	fp, ip, #4
 c227f98:	e24dd018 	sub	sp, sp, #24
 c227f9c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    uint32 headerSize;

    uint16 x, ySrc, yDst;
    uint16 offsetSrc, offsetDst;

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);
 c227fa0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c227fa4:	e283300a 	add	r3, r3, #10
 c227fa8:	e5d33000 	ldrb	r3, [r3]
 c227fac:	e1a02003 	mov	r2, r3
 c227fb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c227fb4:	e283300b 	add	r3, r3, #11
 c227fb8:	e5d33000 	ldrb	r3, [r3]
 c227fbc:	e1a03403 	lsl	r3, r3, #8
 c227fc0:	e0822003 	add	r2, r2, r3
 c227fc4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c227fc8:	e283300c 	add	r3, r3, #12
 c227fcc:	e5d33000 	ldrb	r3, [r3]
 c227fd0:	e1a03803 	lsl	r3, r3, #16
 c227fd4:	e0822003 	add	r2, r2, r3
 c227fd8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c227fdc:	e283300d 	add	r3, r3, #13
 c227fe0:	e5d33000 	ldrb	r3, [r3]
 c227fe4:	e1a03c03 	lsl	r3, r3, #24
 c227fe8:	e0823003 	add	r3, r2, r3
 c227fec:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    bmp = bmp + headerSize;
 c227ff0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c227ff4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c227ff8:	e0823003 	add	r3, r2, r3
 c227ffc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c228000:	e3a03000 	mov	r3, #0
 c228004:	e14b31b0 	strh	r3, [fp, #-16]
 c228008:	e3a030ef 	mov	r3, #239	; 0xef
 c22800c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c228010:	ea00002d 	b	c2280cc <lcd_putWallpaper+0x140>
    {
        offsetDst = yDst*LCD_WIDTH/2;
 c228014:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c228018:	e1a03002 	mov	r3, r2
 c22801c:	e1a03103 	lsl	r3, r3, #2
 c228020:	e0833002 	add	r3, r3, r2
 c228024:	e1a03303 	lsl	r3, r3, #6
 c228028:	e1a02fa3 	lsr	r2, r3, #31
 c22802c:	e0823003 	add	r3, r2, r3
 c228030:	e1a030c3 	asr	r3, r3, #1
 c228034:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
        offsetSrc = ySrc*LCD_WIDTH/2;
 c228038:	e15b21b0 	ldrh	r2, [fp, #-16]
 c22803c:	e1a03002 	mov	r3, r2
 c228040:	e1a03103 	lsl	r3, r3, #2
 c228044:	e0833002 	add	r3, r3, r2
 c228048:	e1a03303 	lsl	r3, r3, #6
 c22804c:	e1a02fa3 	lsr	r2, r3, #31
 c228050:	e0823003 	add	r3, r2, r3
 c228054:	e1a030c3 	asr	r3, r3, #1
 c228058:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
        for( x=0; x<LCD_WIDTH/2; x++ )
 c22805c:	e3a03000 	mov	r3, #0
 c228060:	e14b30be 	strh	r3, [fp, #-14]
 c228064:	ea00000f 	b	c2280a8 <lcd_putWallpaper+0x11c>
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
 c228068:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c22806c:	e15b30be 	ldrh	r3, [fp, #-14]
 c228070:	e0823003 	add	r3, r2, r3
 c228074:	e15b11bc 	ldrh	r1, [fp, #-28]	; 0xffffffe4
 c228078:	e15b20be 	ldrh	r2, [fp, #-14]
 c22807c:	e0812002 	add	r2, r1, r2
 c228080:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c228084:	e0812002 	add	r2, r1, r2
 c228088:	e5d22000 	ldrb	r2, [r2]
 c22808c:	e1e02002 	mvn	r2, r2
 c228090:	e20210ff 	and	r1, r2, #255	; 0xff
 c228094:	e59f2048 	ldr	r2, [pc, #72]	; c2280e4 <lcd_putWallpaper+0x158>
 c228098:	e7c21003 	strb	r1, [r2, r3]

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
    {
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
 c22809c:	e15b30be 	ldrh	r3, [fp, #-14]
 c2280a0:	e2833001 	add	r3, r3, #1
 c2280a4:	e14b30be 	strh	r3, [fp, #-14]
 c2280a8:	e15b30be 	ldrh	r3, [fp, #-14]
 c2280ac:	e353009f 	cmp	r3, #159	; 0x9f
 c2280b0:	9affffec 	bls	c228068 <lcd_putWallpaper+0xdc>

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);

    bmp = bmp + headerSize;

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c2280b4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c2280b8:	e2833001 	add	r3, r3, #1
 c2280bc:	e14b31b0 	strh	r3, [fp, #-16]
 c2280c0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c2280c4:	e2433001 	sub	r3, r3, #1
 c2280c8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c2280cc:	e15b31b0 	ldrh	r3, [fp, #-16]
 c2280d0:	e35300ef 	cmp	r3, #239	; 0xef
 c2280d4:	9affffce 	bls	c228014 <lcd_putWallpaper+0x88>
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
    }
}
 c2280d8:	e24bd00c 	sub	sp, fp, #12
 c2280dc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2280e0:	e12fff1e 	bx	lr
 c2280e4:	0c1023fc 	.word	0x0c1023fc

0c2280e8 <leds_init>:
// significativos, cada uno para un led
// 1 encendido y 0 apagado
static unsigned int status = 0;

void leds_init( void )
{
 c2280e8:	e1a0c00d 	mov	ip, sp
 c2280ec:	e92dd800 	push	{fp, ip, lr, pc}
 c2280f0:	e24cb004 	sub	fp, ip, #4
	//COMPLETAR usando el interfaz del puerto B definido en gpio.h
	// hay que configurar los pines 9 y 10 como pines de salida
	portB_conf(BIT_LED1, OUTPUT);
 c2280f4:	e3a00009 	mov	r0, #9
 c2280f8:	e3a01001 	mov	r1, #1
 c2280fc:	ebfff781 	bl	c225f08 <portB_conf>
	portB_conf(BIT_LED2, OUTPUT);
 c228100:	e3a0000a 	mov	r0, #10
 c228104:	e3a01001 	mov	r1, #1
 c228108:	ebfff77e 	bl	c225f08 <portB_conf>
	leds_display( status );
 c22810c:	e59f3014 	ldr	r3, [pc, #20]	; c228128 <leds_init+0x40>
 c228110:	e5933000 	ldr	r3, [r3]
 c228114:	e1a00003 	mov	r0, r3
 c228118:	eb000073 	bl	c2282ec <leds_display>
}
 c22811c:	e24bd00c 	sub	sp, fp, #12
 c228120:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228124:	e12fff1e 	bx	lr
 c228128:	0c10ba00 	.word	0x0c10ba00

0c22812c <led1_on>:

void led1_on( void )
{
 c22812c:	e1a0c00d 	mov	ip, sp
 c228130:	e92dd800 	push	{fp, ip, lr, pc}
 c228134:	e24cb004 	sub	fp, ip, #4
	status |=  LED1;
 c228138:	e59f3028 	ldr	r3, [pc, #40]	; c228168 <led1_on+0x3c>
 c22813c:	e5933000 	ldr	r3, [r3]
 c228140:	e3832001 	orr	r2, r3, #1
 c228144:	e59f301c 	ldr	r3, [pc, #28]	; c228168 <led1_on+0x3c>
 c228148:	e5832000 	str	r2, [r3]
	leds_display( status );
 c22814c:	e59f3014 	ldr	r3, [pc, #20]	; c228168 <led1_on+0x3c>
 c228150:	e5933000 	ldr	r3, [r3]
 c228154:	e1a00003 	mov	r0, r3
 c228158:	eb000063 	bl	c2282ec <leds_display>
}
 c22815c:	e24bd00c 	sub	sp, fp, #12
 c228160:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228164:	e12fff1e 	bx	lr
 c228168:	0c10ba00 	.word	0x0c10ba00

0c22816c <led1_off>:

void led1_off( void )
{
 c22816c:	e1a0c00d 	mov	ip, sp
 c228170:	e92dd800 	push	{fp, ip, lr, pc}
 c228174:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED1;
 c228178:	e59f3028 	ldr	r3, [pc, #40]	; c2281a8 <led1_off+0x3c>
 c22817c:	e5933000 	ldr	r3, [r3]
 c228180:	e3c32001 	bic	r2, r3, #1
 c228184:	e59f301c 	ldr	r3, [pc, #28]	; c2281a8 <led1_off+0x3c>
 c228188:	e5832000 	str	r2, [r3]
	leds_display( status );
 c22818c:	e59f3014 	ldr	r3, [pc, #20]	; c2281a8 <led1_off+0x3c>
 c228190:	e5933000 	ldr	r3, [r3]
 c228194:	e1a00003 	mov	r0, r3
 c228198:	eb000053 	bl	c2282ec <leds_display>
}
 c22819c:	e24bd00c 	sub	sp, fp, #12
 c2281a0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2281a4:	e12fff1e 	bx	lr
 c2281a8:	0c10ba00 	.word	0x0c10ba00

0c2281ac <led2_on>:

void led2_on( void )
{
 c2281ac:	e1a0c00d 	mov	ip, sp
 c2281b0:	e92dd800 	push	{fp, ip, lr, pc}
 c2281b4:	e24cb004 	sub	fp, ip, #4
	status |=  LED2;
 c2281b8:	e59f3028 	ldr	r3, [pc, #40]	; c2281e8 <led2_on+0x3c>
 c2281bc:	e5933000 	ldr	r3, [r3]
 c2281c0:	e3832002 	orr	r2, r3, #2
 c2281c4:	e59f301c 	ldr	r3, [pc, #28]	; c2281e8 <led2_on+0x3c>
 c2281c8:	e5832000 	str	r2, [r3]
	leds_display( status );
 c2281cc:	e59f3014 	ldr	r3, [pc, #20]	; c2281e8 <led2_on+0x3c>
 c2281d0:	e5933000 	ldr	r3, [r3]
 c2281d4:	e1a00003 	mov	r0, r3
 c2281d8:	eb000043 	bl	c2282ec <leds_display>
}
 c2281dc:	e24bd00c 	sub	sp, fp, #12
 c2281e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2281e4:	e12fff1e 	bx	lr
 c2281e8:	0c10ba00 	.word	0x0c10ba00

0c2281ec <led2_off>:

void led2_off( void )
{
 c2281ec:	e1a0c00d 	mov	ip, sp
 c2281f0:	e92dd800 	push	{fp, ip, lr, pc}
 c2281f4:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED2;
 c2281f8:	e59f3028 	ldr	r3, [pc, #40]	; c228228 <led2_off+0x3c>
 c2281fc:	e5933000 	ldr	r3, [r3]
 c228200:	e3c32002 	bic	r2, r3, #2
 c228204:	e59f301c 	ldr	r3, [pc, #28]	; c228228 <led2_off+0x3c>
 c228208:	e5832000 	str	r2, [r3]
	leds_display( status );
 c22820c:	e59f3014 	ldr	r3, [pc, #20]	; c228228 <led2_off+0x3c>
 c228210:	e5933000 	ldr	r3, [r3]
 c228214:	e1a00003 	mov	r0, r3
 c228218:	eb000033 	bl	c2282ec <leds_display>
}
 c22821c:	e24bd00c 	sub	sp, fp, #12
 c228220:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228224:	e12fff1e 	bx	lr
 c228228:	0c10ba00 	.word	0x0c10ba00

0c22822c <led1_switch>:

void led1_switch( void )
{
 c22822c:	e1a0c00d 	mov	ip, sp
 c228230:	e92dd800 	push	{fp, ip, lr, pc}
 c228234:	e24cb004 	sub	fp, ip, #4
	status ^= LED1;
 c228238:	e59f3028 	ldr	r3, [pc, #40]	; c228268 <led1_switch+0x3c>
 c22823c:	e5933000 	ldr	r3, [r3]
 c228240:	e2232001 	eor	r2, r3, #1
 c228244:	e59f301c 	ldr	r3, [pc, #28]	; c228268 <led1_switch+0x3c>
 c228248:	e5832000 	str	r2, [r3]
	leds_display( status );
 c22824c:	e59f3014 	ldr	r3, [pc, #20]	; c228268 <led1_switch+0x3c>
 c228250:	e5933000 	ldr	r3, [r3]
 c228254:	e1a00003 	mov	r0, r3
 c228258:	eb000023 	bl	c2282ec <leds_display>
}
 c22825c:	e24bd00c 	sub	sp, fp, #12
 c228260:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228264:	e12fff1e 	bx	lr
 c228268:	0c10ba00 	.word	0x0c10ba00

0c22826c <led2_switch>:

void led2_switch( void )
{
 c22826c:	e1a0c00d 	mov	ip, sp
 c228270:	e92dd800 	push	{fp, ip, lr, pc}
 c228274:	e24cb004 	sub	fp, ip, #4
	status ^= LED2;
 c228278:	e59f3028 	ldr	r3, [pc, #40]	; c2282a8 <led2_switch+0x3c>
 c22827c:	e5933000 	ldr	r3, [r3]
 c228280:	e2232002 	eor	r2, r3, #2
 c228284:	e59f301c 	ldr	r3, [pc, #28]	; c2282a8 <led2_switch+0x3c>
 c228288:	e5832000 	str	r2, [r3]
	leds_display( status );
 c22828c:	e59f3014 	ldr	r3, [pc, #20]	; c2282a8 <led2_switch+0x3c>
 c228290:	e5933000 	ldr	r3, [r3]
 c228294:	e1a00003 	mov	r0, r3
 c228298:	eb000013 	bl	c2282ec <leds_display>
}
 c22829c:	e24bd00c 	sub	sp, fp, #12
 c2282a0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2282a4:	e12fff1e 	bx	lr
 c2282a8:	0c10ba00 	.word	0x0c10ba00

0c2282ac <leds_switch>:

void leds_switch( void ){
 c2282ac:	e1a0c00d 	mov	ip, sp
 c2282b0:	e92dd800 	push	{fp, ip, lr, pc}
 c2282b4:	e24cb004 	sub	fp, ip, #4
	status ^= (LED1 | LED2);
 c2282b8:	e59f3028 	ldr	r3, [pc, #40]	; c2282e8 <leds_switch+0x3c>
 c2282bc:	e5933000 	ldr	r3, [r3]
 c2282c0:	e2232003 	eor	r2, r3, #3
 c2282c4:	e59f301c 	ldr	r3, [pc, #28]	; c2282e8 <leds_switch+0x3c>
 c2282c8:	e5832000 	str	r2, [r3]
	leds_display( status );
 c2282cc:	e59f3014 	ldr	r3, [pc, #20]	; c2282e8 <leds_switch+0x3c>
 c2282d0:	e5933000 	ldr	r3, [r3]
 c2282d4:	e1a00003 	mov	r0, r3
 c2282d8:	eb000003 	bl	c2282ec <leds_display>
}
 c2282dc:	e24bd00c 	sub	sp, fp, #12
 c2282e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2282e4:	e12fff1e 	bx	lr
 c2282e8:	0c10ba00 	.word	0x0c10ba00

0c2282ec <leds_display>:

void leds_display( unsigned int leds_status )
{
 c2282ec:	e1a0c00d 	mov	ip, sp
 c2282f0:	e92dd800 	push	{fp, ip, lr, pc}
 c2282f4:	e24cb004 	sub	fp, ip, #4
 c2282f8:	e24dd008 	sub	sp, sp, #8
 c2282fc:	e50b0010 	str	r0, [fp, #-16]
	status = leds_status;
 c228300:	e59f3074 	ldr	r3, [pc, #116]	; c22837c <leds_display+0x90>
 c228304:	e51b2010 	ldr	r2, [fp, #-16]
 c228308:	e5832000 	str	r2, [r3]
	
	// LED 1
	if( status & LED1 )
 c22830c:	e59f3068 	ldr	r3, [pc, #104]	; c22837c <leds_display+0x90>
 c228310:	e5933000 	ldr	r3, [r3]
 c228314:	e2033001 	and	r3, r3, #1
 c228318:	e20330ff 	and	r3, r3, #255	; 0xff
 c22831c:	e3530000 	cmp	r3, #0
 c228320:	0a000003 	beq	c228334 <leds_display+0x48>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 1
		portB_write(BIT_LED1, DISABLE);
 c228324:	e3a00009 	mov	r0, #9
 c228328:	e3a01000 	mov	r1, #0
 c22832c:	ebfff727 	bl	c225fd0 <portB_write>
 c228330:	ea000002 	b	c228340 <leds_display+0x54>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 1
		portB_write(BIT_LED1, ENABLE);
 c228334:	e3a00009 	mov	r0, #9
 c228338:	e3a01001 	mov	r1, #1
 c22833c:	ebfff723 	bl	c225fd0 <portB_write>

	// LED 2
	if( status & LED2 )
 c228340:	e59f3034 	ldr	r3, [pc, #52]	; c22837c <leds_display+0x90>
 c228344:	e5933000 	ldr	r3, [r3]
 c228348:	e2033002 	and	r3, r3, #2
 c22834c:	e3530000 	cmp	r3, #0
 c228350:	0a000003 	beq	c228364 <leds_display+0x78>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 2
		portB_write(BIT_LED2, DISABLE);
 c228354:	e3a0000a 	mov	r0, #10
 c228358:	e3a01000 	mov	r1, #0
 c22835c:	ebfff71b 	bl	c225fd0 <portB_write>
 c228360:	ea000002 	b	c228370 <leds_display+0x84>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 2
		portB_write(BIT_LED2, ENABLE);
 c228364:	e3a0000a 	mov	r0, #10
 c228368:	e3a01001 	mov	r1, #1
 c22836c:	ebfff717 	bl	c225fd0 <portB_write>
}
 c228370:	e24bd00c 	sub	sp, fp, #12
 c228374:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228378:	e12fff1e 	bx	lr
 c22837c:	0c10ba00 	.word	0x0c10ba00

0c228380 <led1_status>:

inline uint8 led1_status(void)
{
 c228380:	e1a0c00d 	mov	ip, sp
 c228384:	e92dd800 	push	{fp, ip, lr, pc}
 c228388:	e24cb004 	sub	fp, ip, #4
	return status & LED1;
 c22838c:	e59f301c 	ldr	r3, [pc, #28]	; c2283b0 <led1_status+0x30>
 c228390:	e5933000 	ldr	r3, [r3]
 c228394:	e20330ff 	and	r3, r3, #255	; 0xff
 c228398:	e2033001 	and	r3, r3, #1
 c22839c:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c2283a0:	e1a00003 	mov	r0, r3
 c2283a4:	e24bd00c 	sub	sp, fp, #12
 c2283a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2283ac:	e12fff1e 	bx	lr
 c2283b0:	0c10ba00 	.word	0x0c10ba00

0c2283b4 <led2_status>:

inline uint8 led2_status(void) {
 c2283b4:	e1a0c00d 	mov	ip, sp
 c2283b8:	e92dd800 	push	{fp, ip, lr, pc}
 c2283bc:	e24cb004 	sub	fp, ip, #4
	return status & LED2;
 c2283c0:	e59f301c 	ldr	r3, [pc, #28]	; c2283e4 <led2_status+0x30>
 c2283c4:	e5933000 	ldr	r3, [r3]
 c2283c8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2283cc:	e2033002 	and	r3, r3, #2
 c2283d0:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c2283d4:	e1a00003 	mov	r0, r3
 c2283d8:	e24bd00c 	sub	sp, fp, #12
 c2283dc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2283e0:	e12fff1e 	bx	lr
 c2283e4:	0c10ba00 	.word	0x0c10ba00

0c2283e8 <timer_ISR>:
void keyboard_ISR(void) __attribute__ ((interrupt ("IRQ")));
void rtc_ISR(void)  __attribute__ ((interrupt ("IRQ")));
void rtc_alarm_ISR(void)  __attribute__ ((interrupt ("IRQ")));

void timer_ISR(void)
{
 c2283e8:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c2283ec:	e1a0c00d 	mov	ip, sp
 c2283f0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c2283f4:	e24cb004 	sub	fp, ip, #4
	//Timer ISR Implementation
	led1_switch();
 c2283f8:	ebffff8b 	bl	c22822c <led1_switch>
	led2_switch();
 c2283fc:	ebffff9a 	bl	c22826c <led2_switch>

	ic_cleanflag(INT_TIMER0);
 c228400:	e3a0000d 	mov	r0, #13
 c228404:	ebfffc1a 	bl	c227474 <ic_cleanflag>
}
 c228408:	e24bd01c 	sub	sp, fp, #28
 c22840c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228410:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c228414:	e25ef004 	subs	pc, lr, #4

0c228418 <button_ISR>:

void button_ISR(void)
{
 c228418:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c22841c:	e1a0c00d 	mov	ip, sp
 c228420:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c228424:	e24cb004 	sub	fp, ip, #4
 c228428:	e24dd008 	sub	sp, sp, #8
	unsigned int whicheint = rEXTINTPND;
 c22842c:	e59f3080 	ldr	r3, [pc, #128]	; c2284b4 <button_ISR+0x9c>
 c228430:	e5933000 	ldr	r3, [r3]
 c228434:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
	unsigned int buttons = (whicheint >> 2) & 0x3;
 c228438:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22843c:	e1a03123 	lsr	r3, r3, #2
 c228440:	e2033003 	and	r3, r3, #3
 c228444:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
	if (buttons & BUT2) {
		//BUT2 pressed
	}

	// eliminamos rebotes
	Delay(2000);
 c228448:	e3a00e7d 	mov	r0, #2000	; 0x7d0
 c22844c:	eb000a48 	bl	c22ad74 <Delay>
	// borramos el flag en extintpnd
	//COMPLETAR: debemos borrar las peticiones de interrupciÃ³n en
	//EXTINTPND escribiendo un 1 en los flags que queremos borrar (los
	//correspondientes a los pulsadores pulsados)

	if(buttons & BUT1)
 c228450:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c228454:	e2033001 	and	r3, r3, #1
 c228458:	e20330ff 	and	r3, r3, #255	; 0xff
 c22845c:	e3530000 	cmp	r3, #0
 c228460:	0a000004 	beq	c228478 <button_ISR+0x60>
		//Borrar bit 2
		rEXTINTPND |= 1 << 2;
 c228464:	e59f3048 	ldr	r3, [pc, #72]	; c2284b4 <button_ISR+0x9c>
 c228468:	e59f2044 	ldr	r2, [pc, #68]	; c2284b4 <button_ISR+0x9c>
 c22846c:	e5922000 	ldr	r2, [r2]
 c228470:	e3822004 	orr	r2, r2, #4
 c228474:	e5832000 	str	r2, [r3]

	if(buttons & BUT2)
 c228478:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c22847c:	e2033002 	and	r3, r3, #2
 c228480:	e3530000 	cmp	r3, #0
 c228484:	0a000004 	beq	c22849c <button_ISR+0x84>
		//Borrar bit 3
		rEXTINTPND |= 1 << 3;
 c228488:	e59f3024 	ldr	r3, [pc, #36]	; c2284b4 <button_ISR+0x9c>
 c22848c:	e59f2020 	ldr	r2, [pc, #32]	; c2284b4 <button_ISR+0x9c>
 c228490:	e5922000 	ldr	r2, [r2]
 c228494:	e3822008 	orr	r2, r2, #8
 c228498:	e5832000 	str	r2, [r3]

	ic_cleanflag(INT_EINT4567);
 c22849c:	e3a00015 	mov	r0, #21
 c2284a0:	ebfffbf3 	bl	c227474 <ic_cleanflag>
}
 c2284a4:	e24bd01c 	sub	sp, fp, #28
 c2284a8:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c2284ac:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c2284b0:	e25ef004 	subs	pc, lr, #4
 c2284b4:	01d20054 	.word	0x01d20054

0c2284b8 <keyboard_ISR>:

void keyboard_ISR(void)
{
 c2284b8:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c2284bc:	e1a0c00d 	mov	ip, sp
 c2284c0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c2284c4:	e24cb004 	sub	fp, ip, #4
 c2284c8:	e24dd008 	sub	sp, sp, #8
	static unsigned n = 0;
	int key = -1;
 c2284cc:	e3e03000 	mvn	r3, #0
 c2284d0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	/* Eliminar rebotes de presiÃ³n */
	Delay(200);
 c2284d4:	e3a000c8 	mov	r0, #200	; 0xc8
 c2284d8:	eb000a25 	bl	c22ad74 <Delay>
	
	/* Escaneo de tecla */
	key = kb_scan();
 c2284dc:	ebfffc0e 	bl	c22751c <kb_scan>
 c2284e0:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0

	n = (n+1) & 0xf;
 c2284e4:	e59f3044 	ldr	r3, [pc, #68]	; c228530 <keyboard_ISR+0x78>
 c2284e8:	e5933000 	ldr	r3, [r3]
 c2284ec:	e2833001 	add	r3, r3, #1
 c2284f0:	e203200f 	and	r2, r3, #15
 c2284f4:	e59f3034 	ldr	r3, [pc, #52]	; c228530 <keyboard_ISR+0x78>
 c2284f8:	e5832000 	str	r2, [r3]

	if (key != -1) {
 c2284fc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c228500:	e3730001 	cmn	r3, #1
 c228504:	0a000001 	beq	c228510 <keyboard_ISR+0x58>
		/* Visualizacion en el display */
		//COMPLETAR: mostrar la tecla en el display utilizando el interfaz
		//definido en D8Led.h

		D8Led_digit(key);
 c228508:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c22850c:	ebfff3c4 	bl	c225424 <D8Led_digit>
		/* Esperar a que la tecla se suelte, consultando el registro de datos */		
		//while (/*COMPLETAR: true si estÃ¡ pulsada la tecla (leer del registro rPDATG)*/);
	}

    /* Eliminar rebotes de depresiÃ³n */
    Delay(200);
 c228510:	e3a000c8 	mov	r0, #200	; 0xc8
 c228514:	eb000a16 	bl	c22ad74 <Delay>
     
    /* Borrar interrupciones pendientes */
	//COMPLETAR
	//borrar la interrupciÃ³n por la lÃ­nea EINT1 en el registro rI_ISPC
    ic_cleanflag(INT_EINT1);
 c228518:	e3a00018 	mov	r0, #24
 c22851c:	ebfffbd4 	bl	c227474 <ic_cleanflag>
}
 c228520:	e24bd01c 	sub	sp, fp, #28
 c228524:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228528:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c22852c:	e25ef004 	subs	pc, lr, #4
 c228530:	0c10ba14 	.word	0x0c10ba14

0c228534 <setup>:

int setup(void)
{
 c228534:	e1a0c00d 	mov	ip, sp
 c228538:	e92dd800 	push	{fp, ip, lr, pc}
 c22853c:	e24cb004 	sub	fp, ip, #4
	leds_init();
 c228540:	ebfffee8 	bl	c2280e8 <leds_init>
	D8Led_init();
 c228544:	ebfff38d 	bl	c225380 <D8Led_init>
	D8Led_segment(0x02); // "-" Symbol
 c228548:	e3a00002 	mov	r0, #2
 c22854c:	ebfff39d 	bl	c2253c8 <D8Led_segment>
	led1_on();
 c228550:	ebfffef5 	bl	c22812c <led1_on>
	//COMPLETAR: utilizando el interfaz para el puerto G definido en gpio.h
	//configurar los pines 1, 6 y 7 del puerto G para poder generar interrupciones
	//externas por flanco de bajada por ellos y activar las correspondientes
	//resistencias de pull-up.

	portG_conf(6, EINT);
 c228554:	e3a00006 	mov	r0, #6
 c228558:	e3a01003 	mov	r1, #3
 c22855c:	ebfff6ca 	bl	c22608c <portG_conf>
	portG_eint_trig(6, FALLING);
 c228560:	e3a00006 	mov	r0, #6
 c228564:	e3a01002 	mov	r1, #2
 c228568:	ebfff735 	bl	c226244 <portG_eint_trig>
	portG_conf_pup(6, ENABLE);
 c22856c:	e3a00006 	mov	r0, #6
 c228570:	e3a01001 	mov	r1, #1
 c228574:	ebfff857 	bl	c2266d8 <portG_conf_pup>

	portG_conf(7, EINT);
 c228578:	e3a00007 	mov	r0, #7
 c22857c:	e3a01003 	mov	r1, #3
 c228580:	ebfff6c1 	bl	c22608c <portG_conf>
	portG_eint_trig(7, FALLING);
 c228584:	e3a00007 	mov	r0, #7
 c228588:	e3a01002 	mov	r1, #2
 c22858c:	ebfff72c 	bl	c226244 <portG_eint_trig>
	portG_conf_pup(7, ENABLE);
 c228590:	e3a00007 	mov	r0, #7
 c228594:	e3a01001 	mov	r1, #1
 c228598:	ebfff84e 	bl	c2266d8 <portG_conf_pup>
	 * Configuramos el timer 0 en modo IRQ y habilitamos esta lÃ­nea
	 * Configuramos la lÃ­nea EINT4567 en modo IRQ y la habilitamos
	 * Configuramos la lÃ­nea EINT1 en modo IRQ y la habilitamos
	 */

	uart0_init();
 c22859c:	eb0007d6 	bl	c22a4fc <uart0_init>
	iic_init();
 c2285a0:	ebfff87e 	bl	c2267a0 <iic_init>
	rtc_init();
 c2285a4:	eb0000f3 	bl	c228978 <rtc_init>
	ic_init();
 c2285a8:	ebfffaed 	bl	c227164 <ic_init>
	//		habilitar la lÃ­nea INT_EINT4567
	//		habilitar la lÃ­nea INT_EINT1

	/***************************************************/

	ic_conf_irq(ENABLE, VEC);
 c2285ac:	e3a00001 	mov	r0, #1
 c2285b0:	e3a01000 	mov	r1, #0
 c2285b4:	ebfffafb 	bl	c2271a8 <ic_conf_irq>
	ic_conf_fiq(DISABLE);
 c2285b8:	e3a00000 	mov	r0, #0
 c2285bc:	ebfffb28 	bl	c227264 <ic_conf_fiq>

	ic_conf_line(INT_TIMER0, IRQ);
 c2285c0:	e3a0000d 	mov	r0, #13
 c2285c4:	e3a01000 	mov	r1, #0
 c2285c8:	ebfffb46 	bl	c2272e8 <ic_conf_line>
	ic_conf_line(INT_EINT4567, IRQ);
 c2285cc:	e3a00015 	mov	r0, #21
 c2285d0:	e3a01000 	mov	r1, #0
 c2285d4:	ebfffb43 	bl	c2272e8 <ic_conf_line>
	ic_conf_line(INT_EINT1, IRQ);
 c2285d8:	e3a00018 	mov	r0, #24
 c2285dc:	e3a01000 	mov	r1, #0
 c2285e0:	ebfffb40 	bl	c2272e8 <ic_conf_line>

	//ic_enable(INT_TIMER0);
	//ic_enable(INT_EINT4567);
	//ic_enable(INT_EINT1);

	ic_enable(INT_GLOBAL);
 c2285e4:	e3a0001a 	mov	r0, #26
 c2285e8:	ebfffb6e 	bl	c2273a8 <ic_enable>

	lcd_init();
 c2285ec:	ebfffc33 	bl	c2276c0 <lcd_init>
	//ts_init();
	//ts_on();

	Delay(0);
 c2285f0:	e3a00000 	mov	r0, #0
 c2285f4:	eb0009de 	bl	c22ad74 <Delay>
	return 0;
 c2285f8:	e3a03000 	mov	r3, #0
}
 c2285fc:	e1a00003 	mov	r0, r3
 c228600:	e24bd00c 	sub	sp, fp, #12
 c228604:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228608:	e12fff1e 	bx	lr

0c22860c <read_date>:

void read_date(rtc_time_t* rtc_time)
{
 c22860c:	e1a0c00d 	mov	ip, sp
 c228610:	e92dd800 	push	{fp, ip, lr, pc}
 c228614:	e24cb004 	sub	fp, ip, #4
 c228618:	e24dd008 	sub	sp, sp, #8
 c22861c:	e50b0010 	str	r0, [fp, #-16]
	uart0_puts( "\nDia: " );
 c228620:	e59f00c8 	ldr	r0, [pc, #200]	; c2286f0 <read_date+0xe4>
 c228624:	eb0007f3 	bl	c22a5f8 <uart0_puts>
	rtc_time->mday = uart0_getint();
 c228628:	eb00088f 	bl	c22a86c <uart0_getint>
 c22862c:	e1a03000 	mov	r3, r0
 c228630:	e20320ff 	and	r2, r3, #255	; 0xff
 c228634:	e51b3010 	ldr	r3, [fp, #-16]
 c228638:	e5c32003 	strb	r2, [r3, #3]
	uart0_puts( "\nMes: " );
 c22863c:	e59f00b0 	ldr	r0, [pc, #176]	; c2286f4 <read_date+0xe8>
 c228640:	eb0007ec 	bl	c22a5f8 <uart0_puts>
	rtc_time->mon = uart0_getint();
 c228644:	eb000888 	bl	c22a86c <uart0_getint>
 c228648:	e1a03000 	mov	r3, r0
 c22864c:	e20320ff 	and	r2, r3, #255	; 0xff
 c228650:	e51b3010 	ldr	r3, [fp, #-16]
 c228654:	e5c32005 	strb	r2, [r3, #5]
	uart0_puts( "\nAño: " );
 c228658:	e59f0098 	ldr	r0, [pc, #152]	; c2286f8 <read_date+0xec>
 c22865c:	eb0007e5 	bl	c22a5f8 <uart0_puts>
	rtc_time->year = uart0_getint();
 c228660:	eb000881 	bl	c22a86c <uart0_getint>
 c228664:	e1a03000 	mov	r3, r0
 c228668:	e20320ff 	and	r2, r3, #255	; 0xff
 c22866c:	e51b3010 	ldr	r3, [fp, #-16]
 c228670:	e5c32006 	strb	r2, [r3, #6]
	uart0_puts( "\nDia de la semana: " );
 c228674:	e59f0080 	ldr	r0, [pc, #128]	; c2286fc <read_date+0xf0>
 c228678:	eb0007de 	bl	c22a5f8 <uart0_puts>
	rtc_time->wday = uart0_getint();
 c22867c:	eb00087a 	bl	c22a86c <uart0_getint>
 c228680:	e1a03000 	mov	r3, r0
 c228684:	e20320ff 	and	r2, r3, #255	; 0xff
 c228688:	e51b3010 	ldr	r3, [fp, #-16]
 c22868c:	e5c32004 	strb	r2, [r3, #4]

	uart0_puts( "\nHora: " );
 c228690:	e59f0068 	ldr	r0, [pc, #104]	; c228700 <read_date+0xf4>
 c228694:	eb0007d7 	bl	c22a5f8 <uart0_puts>
	rtc_time->hour = uart0_getint();
 c228698:	eb000873 	bl	c22a86c <uart0_getint>
 c22869c:	e1a03000 	mov	r3, r0
 c2286a0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2286a4:	e51b3010 	ldr	r3, [fp, #-16]
 c2286a8:	e5c32002 	strb	r2, [r3, #2]
	uart0_puts( "\nMinutos: " );
 c2286ac:	e59f0050 	ldr	r0, [pc, #80]	; c228704 <read_date+0xf8>
 c2286b0:	eb0007d0 	bl	c22a5f8 <uart0_puts>
	rtc_time->min = uart0_getint();
 c2286b4:	eb00086c 	bl	c22a86c <uart0_getint>
 c2286b8:	e1a03000 	mov	r3, r0
 c2286bc:	e20320ff 	and	r2, r3, #255	; 0xff
 c2286c0:	e51b3010 	ldr	r3, [fp, #-16]
 c2286c4:	e5c32001 	strb	r2, [r3, #1]
	uart0_puts( "\nSegundos: " );
 c2286c8:	e59f0038 	ldr	r0, [pc, #56]	; c228708 <read_date+0xfc>
 c2286cc:	eb0007c9 	bl	c22a5f8 <uart0_puts>
	rtc_time->sec = uart0_getint();
 c2286d0:	eb000865 	bl	c22a86c <uart0_getint>
 c2286d4:	e1a03000 	mov	r3, r0
 c2286d8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2286dc:	e51b3010 	ldr	r3, [fp, #-16]
 c2286e0:	e5c32000 	strb	r2, [r3]
}
 c2286e4:	e24bd00c 	sub	sp, fp, #12
 c2286e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2286ec:	e12fff1e 	bx	lr
 c2286f0:	0c102200 	.word	0x0c102200
 c2286f4:	0c102208 	.word	0x0c102208
 c2286f8:	0c102210 	.word	0x0c102210
 c2286fc:	0c102218 	.word	0x0c102218
 c228700:	0c10222c 	.word	0x0c10222c
 c228704:	0c102234 	.word	0x0c102234
 c228708:	0c102240 	.word	0x0c102240

0c22870c <rtc_ISR>:

void rtc_ISR() {
 c22870c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c228710:	e1a0c00d 	mov	ip, sp
 c228714:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c228718:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;

	rtc_gettime(&rtc_time);
 c22871c:	e59f0028 	ldr	r0, [pc, #40]	; c22874c <rtc_ISR+0x40>
 c228720:	eb0001be 	bl	c228e20 <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c228724:	e59f0020 	ldr	r0, [pc, #32]	; c22874c <rtc_ISR+0x40>
 c228728:	eb0008c6 	bl	c22aa48 <uart0_put_rtc_time>
	uart0_putchar('\n');
 c22872c:	e3a0000a 	mov	r0, #10
 c228730:	eb00078a 	bl	c22a560 <uart0_putchar>

	ic_cleanflag(INT_TICK);
 c228734:	e3a00014 	mov	r0, #20
 c228738:	ebfffb4d 	bl	c227474 <ic_cleanflag>
}
 c22873c:	e24bd01c 	sub	sp, fp, #28
 c228740:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228744:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c228748:	e25ef004 	subs	pc, lr, #4
 c22874c:	0c10ba0c 	.word	0x0c10ba0c

0c228750 <rtc_alarm_ISR>:

void rtc_alarm_ISR(void) {
 c228750:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c228754:	e1a0c00d 	mov	ip, sp
 c228758:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c22875c:	e24cb004 	sub	fp, ip, #4
	uart0_puts("\nALARM GOES OFF!\n");
 c228760:	e59f0018 	ldr	r0, [pc, #24]	; c228780 <rtc_alarm_ISR+0x30>
 c228764:	eb0007a3 	bl	c22a5f8 <uart0_puts>
	ic_cleanflag(INT_RTC);
 c228768:	e3a00001 	mov	r0, #1
 c22876c:	ebfffb40 	bl	c227474 <ic_cleanflag>
}
 c228770:	e24bd01c 	sub	sp, fp, #28
 c228774:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228778:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c22877c:	e25ef004 	subs	pc, lr, #4
 c228780:	0c10224c 	.word	0x0c10224c

0c228784 <clock_setup>:

void clock_setup() {
 c228784:	e1a0c00d 	mov	ip, sp
 c228788:	e92dd800 	push	{fp, ip, lr, pc}
 c22878c:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;
	uart0_puts("Initial time: \n");
 c228790:	e59f0128 	ldr	r0, [pc, #296]	; c2288c0 <clock_setup+0x13c>
 c228794:	eb000797 	bl	c22a5f8 <uart0_puts>
	rtc_gettime(&rtc_time);
 c228798:	e59f0124 	ldr	r0, [pc, #292]	; c2288c4 <clock_setup+0x140>
 c22879c:	eb00019f 	bl	c228e20 <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c2287a0:	e59f011c 	ldr	r0, [pc, #284]	; c2288c4 <clock_setup+0x140>
 c2287a4:	eb0008a7 	bl	c22aa48 <uart0_put_rtc_time>

	//Ask for time first time
	read_date(&rtc_time);
 c2287a8:	e59f0114 	ldr	r0, [pc, #276]	; c2288c4 <clock_setup+0x140>
 c2287ac:	ebffff96 	bl	c22860c <read_date>
	rtc_puttime(&rtc_time);
 c2287b0:	e59f010c 	ldr	r0, [pc, #268]	; c2288c4 <clock_setup+0x140>
 c2287b4:	eb0000a4 	bl	c228a4c <rtc_puttime>

	//Set alarm 10 seconds from now (imperfect but enough)

	rtc_time.sec += 10;
 c2287b8:	e59f3104 	ldr	r3, [pc, #260]	; c2288c4 <clock_setup+0x140>
 c2287bc:	e5d33000 	ldrb	r3, [r3]
 c2287c0:	e283300a 	add	r3, r3, #10
 c2287c4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2287c8:	e59f30f4 	ldr	r3, [pc, #244]	; c2288c4 <clock_setup+0x140>
 c2287cc:	e5c32000 	strb	r2, [r3]
	if(rtc_time.sec >= 60) {
 c2287d0:	e59f30ec 	ldr	r3, [pc, #236]	; c2288c4 <clock_setup+0x140>
 c2287d4:	e5d33000 	ldrb	r3, [r3]
 c2287d8:	e353003b 	cmp	r3, #59	; 0x3b
 c2287dc:	9a00000b 	bls	c228810 <clock_setup+0x8c>
		rtc_time.sec -= 60;
 c2287e0:	e59f30dc 	ldr	r3, [pc, #220]	; c2288c4 <clock_setup+0x140>
 c2287e4:	e5d33000 	ldrb	r3, [r3]
 c2287e8:	e243303c 	sub	r3, r3, #60	; 0x3c
 c2287ec:	e20320ff 	and	r2, r3, #255	; 0xff
 c2287f0:	e59f30cc 	ldr	r3, [pc, #204]	; c2288c4 <clock_setup+0x140>
 c2287f4:	e5c32000 	strb	r2, [r3]
		rtc_time.min++;
 c2287f8:	e59f30c4 	ldr	r3, [pc, #196]	; c2288c4 <clock_setup+0x140>
 c2287fc:	e5d33001 	ldrb	r3, [r3, #1]
 c228800:	e2833001 	add	r3, r3, #1
 c228804:	e20320ff 	and	r2, r3, #255	; 0xff
 c228808:	e59f30b4 	ldr	r3, [pc, #180]	; c2288c4 <clock_setup+0x140>
 c22880c:	e5c32001 	strb	r2, [r3, #1]
	}

	if(rtc_time.min >= 60) {
 c228810:	e59f30ac 	ldr	r3, [pc, #172]	; c2288c4 <clock_setup+0x140>
 c228814:	e5d33001 	ldrb	r3, [r3, #1]
 c228818:	e353003b 	cmp	r3, #59	; 0x3b
 c22881c:	9a00000b 	bls	c228850 <clock_setup+0xcc>
		rtc_time.min -= 60;
 c228820:	e59f309c 	ldr	r3, [pc, #156]	; c2288c4 <clock_setup+0x140>
 c228824:	e5d33001 	ldrb	r3, [r3, #1]
 c228828:	e243303c 	sub	r3, r3, #60	; 0x3c
 c22882c:	e20320ff 	and	r2, r3, #255	; 0xff
 c228830:	e59f308c 	ldr	r3, [pc, #140]	; c2288c4 <clock_setup+0x140>
 c228834:	e5c32001 	strb	r2, [r3, #1]
		rtc_time.hour++;
 c228838:	e59f3084 	ldr	r3, [pc, #132]	; c2288c4 <clock_setup+0x140>
 c22883c:	e5d33002 	ldrb	r3, [r3, #2]
 c228840:	e2833001 	add	r3, r3, #1
 c228844:	e20320ff 	and	r2, r3, #255	; 0xff
 c228848:	e59f3074 	ldr	r3, [pc, #116]	; c2288c4 <clock_setup+0x140>
 c22884c:	e5c32002 	strb	r2, [r3, #2]
	}

	if(rtc_time.hour >= 24) {
 c228850:	e59f306c 	ldr	r3, [pc, #108]	; c2288c4 <clock_setup+0x140>
 c228854:	e5d33002 	ldrb	r3, [r3, #2]
 c228858:	e3530017 	cmp	r3, #23
 c22885c:	9a00000b 	bls	c228890 <clock_setup+0x10c>
		rtc_time.hour--;
 c228860:	e59f305c 	ldr	r3, [pc, #92]	; c2288c4 <clock_setup+0x140>
 c228864:	e5d33002 	ldrb	r3, [r3, #2]
 c228868:	e2433001 	sub	r3, r3, #1
 c22886c:	e20320ff 	and	r2, r3, #255	; 0xff
 c228870:	e59f304c 	ldr	r3, [pc, #76]	; c2288c4 <clock_setup+0x140>
 c228874:	e5c32002 	strb	r2, [r3, #2]
		rtc_time.mday++;
 c228878:	e59f3044 	ldr	r3, [pc, #68]	; c2288c4 <clock_setup+0x140>
 c22887c:	e5d33003 	ldrb	r3, [r3, #3]
 c228880:	e2833001 	add	r3, r3, #1
 c228884:	e20320ff 	and	r2, r3, #255	; 0xff
 c228888:	e59f3034 	ldr	r3, [pc, #52]	; c2288c4 <clock_setup+0x140>
 c22888c:	e5c32003 	strb	r2, [r3, #3]
	}

	uart0_puts("Alarm time: ");
 c228890:	e59f0030 	ldr	r0, [pc, #48]	; c2288c8 <clock_setup+0x144>
 c228894:	eb000757 	bl	c22a5f8 <uart0_puts>
	uart0_put_rtc_time(&rtc_time);
 c228898:	e59f0024 	ldr	r0, [pc, #36]	; c2288c4 <clock_setup+0x140>
 c22889c:	eb000869 	bl	c22aa48 <uart0_put_rtc_time>
	uart0_putchar('\n');
 c2288a0:	e3a0000a 	mov	r0, #10
 c2288a4:	eb00072d 	bl	c22a560 <uart0_putchar>

	rtc_set_alarm(rtc_alarm_ISR, &rtc_time);
 c2288a8:	e59f001c 	ldr	r0, [pc, #28]	; c2288cc <clock_setup+0x148>
 c2288ac:	e59f1010 	ldr	r1, [pc, #16]	; c2288c4 <clock_setup+0x140>
 c2288b0:	eb00026a 	bl	c229260 <rtc_set_alarm>
}
 c2288b4:	e24bd00c 	sub	sp, fp, #12
 c2288b8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2288bc:	e12fff1e 	bx	lr
 c2288c0:	0c102260 	.word	0x0c102260
 c2288c4:	0c10ba04 	.word	0x0c10ba04
 c2288c8:	0c102270 	.word	0x0c102270
 c2288cc:	0c228750 	.word	0x0c228750

0c2288d0 <startup>:

void startup() {
 c2288d0:	e1a0c00d 	mov	ip, sp
 c2288d4:	e92dd800 	push	{fp, ip, lr, pc}
 c2288d8:	e24cb004 	sub	fp, ip, #4
	kernel_entry();
 c2288dc:	ebfff069 	bl	c224a88 <kernel_entry>
}
 c2288e0:	e24bd00c 	sub	sp, fp, #12
 c2288e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2288e8:	e12fff1e 	bx	lr

0c2288ec <loop>:

int loop(void) {
 c2288ec:	e1a0c00d 	mov	ip, sp
 c2288f0:	e92dd800 	push	{fp, ip, lr, pc}
 c2288f4:	e24cb004 	sub	fp, ip, #4
	return 0;
 c2288f8:	e3a03000 	mov	r3, #0
}
 c2288fc:	e1a00003 	mov	r0, r3
 c228900:	e24bd00c 	sub	sp, fp, #12
 c228904:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228908:	e12fff1e 	bx	lr

0c22890c <main>:

int main(void) {
 c22890c:	e1a0c00d 	mov	ip, sp
 c228910:	e92dd800 	push	{fp, ip, lr, pc}
 c228914:	e24cb004 	sub	fp, ip, #4

	setup();
 c228918:	ebffff05 	bl	c228534 <setup>
	startup();
 c22891c:	ebffffeb 	bl	c2288d0 <startup>

	while (1) {
		loop();
 c228920:	ebfffff1 	bl	c2288ec <loop>
	}
 c228924:	eafffffd 	b	c228920 <main+0x14>

0c228928 <isr_TICK_dummy>:
#include "intcontroller.h"

void isr_TICK_dummy(void)  __attribute__ ((interrupt ("IRQ")));
void isr_ALARM_dummy(void) __attribute__ ((interrupt ("IRQ")));

void isr_TICK_dummy(void){
 c228928:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c22892c:	e1a0c00d 	mov	ip, sp
 c228930:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c228934:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_TICK);
 c228938:	e3a00014 	mov	r0, #20
 c22893c:	ebfffacc 	bl	c227474 <ic_cleanflag>
}
 c228940:	e24bd01c 	sub	sp, fp, #28
 c228944:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228948:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c22894c:	e25ef004 	subs	pc, lr, #4

0c228950 <isr_ALARM_dummy>:

void isr_ALARM_dummy(void){
 c228950:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c228954:	e1a0c00d 	mov	ip, sp
 c228958:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c22895c:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_RTC);
 c228960:	e3a00001 	mov	r0, #1
 c228964:	ebfffac2 	bl	c227474 <ic_cleanflag>
}
 c228968:	e24bd01c 	sub	sp, fp, #28
 c22896c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c228970:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c228974:	e25ef004 	subs	pc, lr, #4

0c228978 <rtc_init>:

void rtc_init( void )
{
 c228978:	e1a0c00d 	mov	ip, sp
 c22897c:	e92dd800 	push	{fp, ip, lr, pc}
 c228980:	e24cb004 	sub	fp, ip, #4
	//Disable Tick interrupt
    rTICINT   = 0x0;
 c228984:	e59f3098 	ldr	r3, [pc, #152]	; c228a24 <rtc_init+0xac>
 c228988:	e3a02000 	mov	r2, #0
 c22898c:	e5c32000 	strb	r2, [r3]

    //Disable alarm
    rRTCALM  = 0x0;
 c228990:	e59f3090 	ldr	r3, [pc, #144]	; c228a28 <rtc_init+0xb0>
 c228994:	e3a02000 	mov	r2, #0
 c228998:	e5c32000 	strb	r2, [r3]

    //Disable Rounding
    rRTCRST  = 0x0;
 c22899c:	e59f3088 	ldr	r3, [pc, #136]	; c228a2c <rtc_init+0xb4>
 c2289a0:	e3a02000 	mov	r2, #0
 c2289a4:	e5c32000 	strb	r2, [r3]


    // RTCCON[2] = 0 merged BCD registers: única opción posible
    // RTCCON[1] = 0 Fuente de reloj primaria: única opción posible: XTAL
    // RTCCON[0] = 1 Enabled register read/write
    rRTCCON  = 0x1;
 c2289a8:	e59f3080 	ldr	r3, [pc, #128]	; c228a30 <rtc_init+0xb8>
 c2289ac:	e3a02001 	mov	r2, #1
 c2289b0:	e5c32000 	strb	r2, [r3]
    rBCDMIN  = 0x0;
    rBCDSEC  = 0x0;
    */

    //Init to 0
    rALMYEAR = 0;
 c2289b4:	e59f3078 	ldr	r3, [pc, #120]	; c228a34 <rtc_init+0xbc>
 c2289b8:	e3a02000 	mov	r2, #0
 c2289bc:	e5c32000 	strb	r2, [r3]
    rALMMON  = 0;
 c2289c0:	e59f3070 	ldr	r3, [pc, #112]	; c228a38 <rtc_init+0xc0>
 c2289c4:	e3a02000 	mov	r2, #0
 c2289c8:	e5c32000 	strb	r2, [r3]
    rALMDAY  = 0;
 c2289cc:	e59f3068 	ldr	r3, [pc, #104]	; c228a3c <rtc_init+0xc4>
 c2289d0:	e3a02000 	mov	r2, #0
 c2289d4:	e5c32000 	strb	r2, [r3]
    rALMHOUR = 0;
 c2289d8:	e59f3060 	ldr	r3, [pc, #96]	; c228a40 <rtc_init+0xc8>
 c2289dc:	e3a02000 	mov	r2, #0
 c2289e0:	e5c32000 	strb	r2, [r3]
    rALMMIN  = 0;
 c2289e4:	e59f3058 	ldr	r3, [pc, #88]	; c228a44 <rtc_init+0xcc>
 c2289e8:	e3a02000 	mov	r2, #0
 c2289ec:	e5c32000 	strb	r2, [r3]
    rALMSEC  = 0;
 c2289f0:	e59f3050 	ldr	r3, [pc, #80]	; c228a48 <rtc_init+0xd0>
 c2289f4:	e3a02000 	mov	r2, #0
 c2289f8:	e5c32000 	strb	r2, [r3]

    rRTCCON &= ~1;
 c2289fc:	e59f302c 	ldr	r3, [pc, #44]	; c228a30 <rtc_init+0xb8>
 c228a00:	e59f2028 	ldr	r2, [pc, #40]	; c228a30 <rtc_init+0xb8>
 c228a04:	e5d22000 	ldrb	r2, [r2]
 c228a08:	e20220ff 	and	r2, r2, #255	; 0xff
 c228a0c:	e3c22001 	bic	r2, r2, #1
 c228a10:	e20220ff 	and	r2, r2, #255	; 0xff
 c228a14:	e5c32000 	strb	r2, [r3]
}
 c228a18:	e24bd00c 	sub	sp, fp, #12
 c228a1c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228a20:	e12fff1e 	bx	lr
 c228a24:	01d7008c 	.word	0x01d7008c
 c228a28:	01d70050 	.word	0x01d70050
 c228a2c:	01d7006c 	.word	0x01d7006c
 c228a30:	01d70040 	.word	0x01d70040
 c228a34:	01d70068 	.word	0x01d70068
 c228a38:	01d70064 	.word	0x01d70064
 c228a3c:	01d70060 	.word	0x01d70060
 c228a40:	01d7005c 	.word	0x01d7005c
 c228a44:	01d70058 	.word	0x01d70058
 c228a48:	01d70054 	.word	0x01d70054

0c228a4c <rtc_puttime>:

void rtc_puttime( rtc_time_t *rtc_time )
{
 c228a4c:	e1a0c00d 	mov	ip, sp
 c228a50:	e92dd800 	push	{fp, ip, lr, pc}
 c228a54:	e24cb004 	sub	fp, ip, #4
 c228a58:	e24dd008 	sub	sp, sp, #8
 c228a5c:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c228a60:	e59f3394 	ldr	r3, [pc, #916]	; c228dfc <rtc_puttime+0x3b0>
 c228a64:	e59f2390 	ldr	r2, [pc, #912]	; c228dfc <rtc_puttime+0x3b0>
 c228a68:	e5d22000 	ldrb	r2, [r2]
 c228a6c:	e20220ff 	and	r2, r2, #255	; 0xff
 c228a70:	e3822001 	orr	r2, r2, #1
 c228a74:	e20220ff 	and	r2, r2, #255	; 0xff
 c228a78:	e5c32000 	strb	r2, [r3]

    rBCDYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c228a7c:	e59f037c 	ldr	r0, [pc, #892]	; c228e00 <rtc_puttime+0x3b4>
 c228a80:	e51b3010 	ldr	r3, [fp, #-16]
 c228a84:	e5d32006 	ldrb	r2, [r3, #6]
 c228a88:	e59f3374 	ldr	r3, [pc, #884]	; c228e04 <rtc_puttime+0x3b8>
 c228a8c:	e0831392 	umull	r1, r3, r2, r3
 c228a90:	e1a031a3 	lsr	r3, r3, #3
 c228a94:	e20320ff 	and	r2, r3, #255	; 0xff
 c228a98:	e59f3364 	ldr	r3, [pc, #868]	; c228e04 <rtc_puttime+0x3b8>
 c228a9c:	e0831392 	umull	r1, r3, r2, r3
 c228aa0:	e1a011a3 	lsr	r1, r3, #3
 c228aa4:	e1a03001 	mov	r3, r1
 c228aa8:	e1a03103 	lsl	r3, r3, #2
 c228aac:	e0833001 	add	r3, r3, r1
 c228ab0:	e1a03083 	lsl	r3, r3, #1
 c228ab4:	e0633002 	rsb	r3, r3, r2
 c228ab8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228abc:	e1a03203 	lsl	r3, r3, #4
 c228ac0:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228ac4:	e51b3010 	ldr	r3, [fp, #-16]
 c228ac8:	e5d32006 	ldrb	r2, [r3, #6]
 c228acc:	e59f3330 	ldr	r3, [pc, #816]	; c228e04 <rtc_puttime+0x3b8>
 c228ad0:	e0831392 	umull	r1, r3, r2, r3
 c228ad4:	e1a011a3 	lsr	r1, r3, #3
 c228ad8:	e1a03001 	mov	r3, r1
 c228adc:	e1a03103 	lsl	r3, r3, #2
 c228ae0:	e0833001 	add	r3, r3, r1
 c228ae4:	e1a03083 	lsl	r3, r3, #1
 c228ae8:	e0633002 	rsb	r3, r3, r2
 c228aec:	e20330ff 	and	r3, r3, #255	; 0xff
 c228af0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228af4:	e1a0200c 	mov	r2, ip
 c228af8:	e1823003 	orr	r3, r2, r3
 c228afc:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b00:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b04:	e5c03000 	strb	r3, [r0]
    rBCDMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c228b08:	e59f02f8 	ldr	r0, [pc, #760]	; c228e08 <rtc_puttime+0x3bc>
 c228b0c:	e51b3010 	ldr	r3, [fp, #-16]
 c228b10:	e5d32005 	ldrb	r2, [r3, #5]
 c228b14:	e59f32e8 	ldr	r3, [pc, #744]	; c228e04 <rtc_puttime+0x3b8>
 c228b18:	e0831392 	umull	r1, r3, r2, r3
 c228b1c:	e1a031a3 	lsr	r3, r3, #3
 c228b20:	e20320ff 	and	r2, r3, #255	; 0xff
 c228b24:	e59f32d8 	ldr	r3, [pc, #728]	; c228e04 <rtc_puttime+0x3b8>
 c228b28:	e0831392 	umull	r1, r3, r2, r3
 c228b2c:	e1a011a3 	lsr	r1, r3, #3
 c228b30:	e1a03001 	mov	r3, r1
 c228b34:	e1a03103 	lsl	r3, r3, #2
 c228b38:	e0833001 	add	r3, r3, r1
 c228b3c:	e1a03083 	lsl	r3, r3, #1
 c228b40:	e0633002 	rsb	r3, r3, r2
 c228b44:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b48:	e1a03203 	lsl	r3, r3, #4
 c228b4c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228b50:	e51b3010 	ldr	r3, [fp, #-16]
 c228b54:	e5d32005 	ldrb	r2, [r3, #5]
 c228b58:	e59f32a4 	ldr	r3, [pc, #676]	; c228e04 <rtc_puttime+0x3b8>
 c228b5c:	e0831392 	umull	r1, r3, r2, r3
 c228b60:	e1a011a3 	lsr	r1, r3, #3
 c228b64:	e1a03001 	mov	r3, r1
 c228b68:	e1a03103 	lsl	r3, r3, #2
 c228b6c:	e0833001 	add	r3, r3, r1
 c228b70:	e1a03083 	lsl	r3, r3, #1
 c228b74:	e0633002 	rsb	r3, r3, r2
 c228b78:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b7c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b80:	e1a0200c 	mov	r2, ip
 c228b84:	e1823003 	orr	r3, r2, r3
 c228b88:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b8c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228b90:	e5c03000 	strb	r3, [r0]
    rBCDDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c228b94:	e59f0270 	ldr	r0, [pc, #624]	; c228e0c <rtc_puttime+0x3c0>
 c228b98:	e51b3010 	ldr	r3, [fp, #-16]
 c228b9c:	e5d32003 	ldrb	r2, [r3, #3]
 c228ba0:	e59f325c 	ldr	r3, [pc, #604]	; c228e04 <rtc_puttime+0x3b8>
 c228ba4:	e0831392 	umull	r1, r3, r2, r3
 c228ba8:	e1a031a3 	lsr	r3, r3, #3
 c228bac:	e20320ff 	and	r2, r3, #255	; 0xff
 c228bb0:	e59f324c 	ldr	r3, [pc, #588]	; c228e04 <rtc_puttime+0x3b8>
 c228bb4:	e0831392 	umull	r1, r3, r2, r3
 c228bb8:	e1a011a3 	lsr	r1, r3, #3
 c228bbc:	e1a03001 	mov	r3, r1
 c228bc0:	e1a03103 	lsl	r3, r3, #2
 c228bc4:	e0833001 	add	r3, r3, r1
 c228bc8:	e1a03083 	lsl	r3, r3, #1
 c228bcc:	e0633002 	rsb	r3, r3, r2
 c228bd0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228bd4:	e1a03203 	lsl	r3, r3, #4
 c228bd8:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228bdc:	e51b3010 	ldr	r3, [fp, #-16]
 c228be0:	e5d32003 	ldrb	r2, [r3, #3]
 c228be4:	e59f3218 	ldr	r3, [pc, #536]	; c228e04 <rtc_puttime+0x3b8>
 c228be8:	e0831392 	umull	r1, r3, r2, r3
 c228bec:	e1a011a3 	lsr	r1, r3, #3
 c228bf0:	e1a03001 	mov	r3, r1
 c228bf4:	e1a03103 	lsl	r3, r3, #2
 c228bf8:	e0833001 	add	r3, r3, r1
 c228bfc:	e1a03083 	lsl	r3, r3, #1
 c228c00:	e0633002 	rsb	r3, r3, r2
 c228c04:	e20330ff 	and	r3, r3, #255	; 0xff
 c228c08:	e20330ff 	and	r3, r3, #255	; 0xff
 c228c0c:	e1a0200c 	mov	r2, ip
 c228c10:	e1823003 	orr	r3, r2, r3
 c228c14:	e20330ff 	and	r3, r3, #255	; 0xff
 c228c18:	e20330ff 	and	r3, r3, #255	; 0xff
 c228c1c:	e5c03000 	strb	r3, [r0]
    rBCDDATE = rtc_time->wday;
 c228c20:	e59f31e8 	ldr	r3, [pc, #488]	; c228e10 <rtc_puttime+0x3c4>
 c228c24:	e51b2010 	ldr	r2, [fp, #-16]
 c228c28:	e5d22004 	ldrb	r2, [r2, #4]
 c228c2c:	e5c32000 	strb	r2, [r3]
    rBCDHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c228c30:	e59f01dc 	ldr	r0, [pc, #476]	; c228e14 <rtc_puttime+0x3c8>
 c228c34:	e51b3010 	ldr	r3, [fp, #-16]
 c228c38:	e5d32002 	ldrb	r2, [r3, #2]
 c228c3c:	e59f31c0 	ldr	r3, [pc, #448]	; c228e04 <rtc_puttime+0x3b8>
 c228c40:	e0831392 	umull	r1, r3, r2, r3
 c228c44:	e1a031a3 	lsr	r3, r3, #3
 c228c48:	e20320ff 	and	r2, r3, #255	; 0xff
 c228c4c:	e59f31b0 	ldr	r3, [pc, #432]	; c228e04 <rtc_puttime+0x3b8>
 c228c50:	e0831392 	umull	r1, r3, r2, r3
 c228c54:	e1a011a3 	lsr	r1, r3, #3
 c228c58:	e1a03001 	mov	r3, r1
 c228c5c:	e1a03103 	lsl	r3, r3, #2
 c228c60:	e0833001 	add	r3, r3, r1
 c228c64:	e1a03083 	lsl	r3, r3, #1
 c228c68:	e0633002 	rsb	r3, r3, r2
 c228c6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228c70:	e1a03203 	lsl	r3, r3, #4
 c228c74:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228c78:	e51b3010 	ldr	r3, [fp, #-16]
 c228c7c:	e5d32002 	ldrb	r2, [r3, #2]
 c228c80:	e59f317c 	ldr	r3, [pc, #380]	; c228e04 <rtc_puttime+0x3b8>
 c228c84:	e0831392 	umull	r1, r3, r2, r3
 c228c88:	e1a011a3 	lsr	r1, r3, #3
 c228c8c:	e1a03001 	mov	r3, r1
 c228c90:	e1a03103 	lsl	r3, r3, #2
 c228c94:	e0833001 	add	r3, r3, r1
 c228c98:	e1a03083 	lsl	r3, r3, #1
 c228c9c:	e0633002 	rsb	r3, r3, r2
 c228ca0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ca4:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ca8:	e1a0200c 	mov	r2, ip
 c228cac:	e1823003 	orr	r3, r2, r3
 c228cb0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228cb4:	e20330ff 	and	r3, r3, #255	; 0xff
 c228cb8:	e5c03000 	strb	r3, [r0]
    rBCDMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c228cbc:	e59f0154 	ldr	r0, [pc, #340]	; c228e18 <rtc_puttime+0x3cc>
 c228cc0:	e51b3010 	ldr	r3, [fp, #-16]
 c228cc4:	e5d32001 	ldrb	r2, [r3, #1]
 c228cc8:	e59f3134 	ldr	r3, [pc, #308]	; c228e04 <rtc_puttime+0x3b8>
 c228ccc:	e0831392 	umull	r1, r3, r2, r3
 c228cd0:	e1a031a3 	lsr	r3, r3, #3
 c228cd4:	e20320ff 	and	r2, r3, #255	; 0xff
 c228cd8:	e59f3124 	ldr	r3, [pc, #292]	; c228e04 <rtc_puttime+0x3b8>
 c228cdc:	e0831392 	umull	r1, r3, r2, r3
 c228ce0:	e1a011a3 	lsr	r1, r3, #3
 c228ce4:	e1a03001 	mov	r3, r1
 c228ce8:	e1a03103 	lsl	r3, r3, #2
 c228cec:	e0833001 	add	r3, r3, r1
 c228cf0:	e1a03083 	lsl	r3, r3, #1
 c228cf4:	e0633002 	rsb	r3, r3, r2
 c228cf8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228cfc:	e1a03203 	lsl	r3, r3, #4
 c228d00:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228d04:	e51b3010 	ldr	r3, [fp, #-16]
 c228d08:	e5d32001 	ldrb	r2, [r3, #1]
 c228d0c:	e59f30f0 	ldr	r3, [pc, #240]	; c228e04 <rtc_puttime+0x3b8>
 c228d10:	e0831392 	umull	r1, r3, r2, r3
 c228d14:	e1a011a3 	lsr	r1, r3, #3
 c228d18:	e1a03001 	mov	r3, r1
 c228d1c:	e1a03103 	lsl	r3, r3, #2
 c228d20:	e0833001 	add	r3, r3, r1
 c228d24:	e1a03083 	lsl	r3, r3, #1
 c228d28:	e0633002 	rsb	r3, r3, r2
 c228d2c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228d30:	e20330ff 	and	r3, r3, #255	; 0xff
 c228d34:	e1a0200c 	mov	r2, ip
 c228d38:	e1823003 	orr	r3, r2, r3
 c228d3c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228d40:	e20330ff 	and	r3, r3, #255	; 0xff
 c228d44:	e5c03000 	strb	r3, [r0]
    rBCDSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c228d48:	e59f00cc 	ldr	r0, [pc, #204]	; c228e1c <rtc_puttime+0x3d0>
 c228d4c:	e51b3010 	ldr	r3, [fp, #-16]
 c228d50:	e5d32000 	ldrb	r2, [r3]
 c228d54:	e59f30a8 	ldr	r3, [pc, #168]	; c228e04 <rtc_puttime+0x3b8>
 c228d58:	e0831392 	umull	r1, r3, r2, r3
 c228d5c:	e1a031a3 	lsr	r3, r3, #3
 c228d60:	e20320ff 	and	r2, r3, #255	; 0xff
 c228d64:	e59f3098 	ldr	r3, [pc, #152]	; c228e04 <rtc_puttime+0x3b8>
 c228d68:	e0831392 	umull	r1, r3, r2, r3
 c228d6c:	e1a011a3 	lsr	r1, r3, #3
 c228d70:	e1a03001 	mov	r3, r1
 c228d74:	e1a03103 	lsl	r3, r3, #2
 c228d78:	e0833001 	add	r3, r3, r1
 c228d7c:	e1a03083 	lsl	r3, r3, #1
 c228d80:	e0633002 	rsb	r3, r3, r2
 c228d84:	e20330ff 	and	r3, r3, #255	; 0xff
 c228d88:	e1a03203 	lsl	r3, r3, #4
 c228d8c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c228d90:	e51b3010 	ldr	r3, [fp, #-16]
 c228d94:	e5d32000 	ldrb	r2, [r3]
 c228d98:	e59f3064 	ldr	r3, [pc, #100]	; c228e04 <rtc_puttime+0x3b8>
 c228d9c:	e0831392 	umull	r1, r3, r2, r3
 c228da0:	e1a011a3 	lsr	r1, r3, #3
 c228da4:	e1a03001 	mov	r3, r1
 c228da8:	e1a03103 	lsl	r3, r3, #2
 c228dac:	e0833001 	add	r3, r3, r1
 c228db0:	e1a03083 	lsl	r3, r3, #1
 c228db4:	e0633002 	rsb	r3, r3, r2
 c228db8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228dbc:	e20330ff 	and	r3, r3, #255	; 0xff
 c228dc0:	e1a0200c 	mov	r2, ip
 c228dc4:	e1823003 	orr	r3, r2, r3
 c228dc8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228dcc:	e20330ff 	and	r3, r3, #255	; 0xff
 c228dd0:	e5c03000 	strb	r3, [r0]

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c228dd4:	e59f3020 	ldr	r3, [pc, #32]	; c228dfc <rtc_puttime+0x3b0>
 c228dd8:	e59f201c 	ldr	r2, [pc, #28]	; c228dfc <rtc_puttime+0x3b0>
 c228ddc:	e5d22000 	ldrb	r2, [r2]
 c228de0:	e20220ff 	and	r2, r2, #255	; 0xff
 c228de4:	e3c22001 	bic	r2, r2, #1
 c228de8:	e20220ff 	and	r2, r2, #255	; 0xff
 c228dec:	e5c32000 	strb	r2, [r3]
}
 c228df0:	e24bd00c 	sub	sp, fp, #12
 c228df4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c228df8:	e12fff1e 	bx	lr
 c228dfc:	01d70040 	.word	0x01d70040
 c228e00:	01d70088 	.word	0x01d70088
 c228e04:	cccccccd 	.word	0xcccccccd
 c228e08:	01d70084 	.word	0x01d70084
 c228e0c:	01d7007c 	.word	0x01d7007c
 c228e10:	01d70080 	.word	0x01d70080
 c228e14:	01d70078 	.word	0x01d70078
 c228e18:	01d70074 	.word	0x01d70074
 c228e1c:	01d70070 	.word	0x01d70070

0c228e20 <rtc_gettime>:

void rtc_gettime( rtc_time_t *rtc_time )
{
 c228e20:	e1a0c00d 	mov	ip, sp
 c228e24:	e92dd800 	push	{fp, ip, lr, pc}
 c228e28:	e24cb004 	sub	fp, ip, #4
 c228e2c:	e24dd008 	sub	sp, sp, #8
 c228e30:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c228e34:	e59f3404 	ldr	r3, [pc, #1028]	; c229240 <rtc_gettime+0x420>
 c228e38:	e59f2400 	ldr	r2, [pc, #1024]	; c229240 <rtc_gettime+0x420>
 c228e3c:	e5d22000 	ldrb	r2, [r2]
 c228e40:	e20220ff 	and	r2, r2, #255	; 0xff
 c228e44:	e3822001 	orr	r2, r2, #1
 c228e48:	e20220ff 	and	r2, r2, #255	; 0xff
 c228e4c:	e5c32000 	strb	r2, [r3]

    rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c228e50:	e59f33ec 	ldr	r3, [pc, #1004]	; c229244 <rtc_gettime+0x424>
 c228e54:	e5d33000 	ldrb	r3, [r3]
 c228e58:	e20330ff 	and	r3, r3, #255	; 0xff
 c228e5c:	e203300f 	and	r3, r3, #15
 c228e60:	e20320ff 	and	r2, r3, #255	; 0xff
 c228e64:	e59f33d8 	ldr	r3, [pc, #984]	; c229244 <rtc_gettime+0x424>
 c228e68:	e5d33000 	ldrb	r3, [r3]
 c228e6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228e70:	e1a03223 	lsr	r3, r3, #4
 c228e74:	e20330ff 	and	r3, r3, #255	; 0xff
 c228e78:	e1a01003 	mov	r1, r3
 c228e7c:	e1a01101 	lsl	r1, r1, #2
 c228e80:	e0813003 	add	r3, r1, r3
 c228e84:	e1a03083 	lsl	r3, r3, #1
 c228e88:	e20330ff 	and	r3, r3, #255	; 0xff
 c228e8c:	e0823003 	add	r3, r2, r3
 c228e90:	e20320ff 	and	r2, r3, #255	; 0xff
 c228e94:	e51b3010 	ldr	r3, [fp, #-16]
 c228e98:	e5c32006 	strb	r2, [r3, #6]
    rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c228e9c:	e59f33a4 	ldr	r3, [pc, #932]	; c229248 <rtc_gettime+0x428>
 c228ea0:	e5d33000 	ldrb	r3, [r3]
 c228ea4:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ea8:	e203300f 	and	r3, r3, #15
 c228eac:	e20320ff 	and	r2, r3, #255	; 0xff
 c228eb0:	e59f3390 	ldr	r3, [pc, #912]	; c229248 <rtc_gettime+0x428>
 c228eb4:	e5d33000 	ldrb	r3, [r3]
 c228eb8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ebc:	e1a03223 	lsr	r3, r3, #4
 c228ec0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ec4:	e1a01003 	mov	r1, r3
 c228ec8:	e1a01101 	lsl	r1, r1, #2
 c228ecc:	e0813003 	add	r3, r1, r3
 c228ed0:	e1a03083 	lsl	r3, r3, #1
 c228ed4:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ed8:	e0823003 	add	r3, r2, r3
 c228edc:	e20320ff 	and	r2, r3, #255	; 0xff
 c228ee0:	e51b3010 	ldr	r3, [fp, #-16]
 c228ee4:	e5c32005 	strb	r2, [r3, #5]
    rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c228ee8:	e59f335c 	ldr	r3, [pc, #860]	; c22924c <rtc_gettime+0x42c>
 c228eec:	e5d33000 	ldrb	r3, [r3]
 c228ef0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228ef4:	e203300f 	and	r3, r3, #15
 c228ef8:	e20320ff 	and	r2, r3, #255	; 0xff
 c228efc:	e59f3348 	ldr	r3, [pc, #840]	; c22924c <rtc_gettime+0x42c>
 c228f00:	e5d33000 	ldrb	r3, [r3]
 c228f04:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f08:	e1a03223 	lsr	r3, r3, #4
 c228f0c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f10:	e1a01003 	mov	r1, r3
 c228f14:	e1a01101 	lsl	r1, r1, #2
 c228f18:	e0813003 	add	r3, r1, r3
 c228f1c:	e1a03083 	lsl	r3, r3, #1
 c228f20:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f24:	e0823003 	add	r3, r2, r3
 c228f28:	e20320ff 	and	r2, r3, #255	; 0xff
 c228f2c:	e51b3010 	ldr	r3, [fp, #-16]
 c228f30:	e5c32003 	strb	r2, [r3, #3]
    rtc_time->wday = rBCDDATE;
 c228f34:	e59f3314 	ldr	r3, [pc, #788]	; c229250 <rtc_gettime+0x430>
 c228f38:	e5d33000 	ldrb	r3, [r3]
 c228f3c:	e20320ff 	and	r2, r3, #255	; 0xff
 c228f40:	e51b3010 	ldr	r3, [fp, #-16]
 c228f44:	e5c32004 	strb	r2, [r3, #4]
    rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c228f48:	e59f3304 	ldr	r3, [pc, #772]	; c229254 <rtc_gettime+0x434>
 c228f4c:	e5d33000 	ldrb	r3, [r3]
 c228f50:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f54:	e203300f 	and	r3, r3, #15
 c228f58:	e20320ff 	and	r2, r3, #255	; 0xff
 c228f5c:	e59f32f0 	ldr	r3, [pc, #752]	; c229254 <rtc_gettime+0x434>
 c228f60:	e5d33000 	ldrb	r3, [r3]
 c228f64:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f68:	e1a03223 	lsr	r3, r3, #4
 c228f6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f70:	e1a01003 	mov	r1, r3
 c228f74:	e1a01101 	lsl	r1, r1, #2
 c228f78:	e0813003 	add	r3, r1, r3
 c228f7c:	e1a03083 	lsl	r3, r3, #1
 c228f80:	e20330ff 	and	r3, r3, #255	; 0xff
 c228f84:	e0823003 	add	r3, r2, r3
 c228f88:	e20320ff 	and	r2, r3, #255	; 0xff
 c228f8c:	e51b3010 	ldr	r3, [fp, #-16]
 c228f90:	e5c32002 	strb	r2, [r3, #2]
    rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c228f94:	e59f32bc 	ldr	r3, [pc, #700]	; c229258 <rtc_gettime+0x438>
 c228f98:	e5d33000 	ldrb	r3, [r3]
 c228f9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c228fa0:	e203300f 	and	r3, r3, #15
 c228fa4:	e20320ff 	and	r2, r3, #255	; 0xff
 c228fa8:	e59f32a8 	ldr	r3, [pc, #680]	; c229258 <rtc_gettime+0x438>
 c228fac:	e5d33000 	ldrb	r3, [r3]
 c228fb0:	e20330ff 	and	r3, r3, #255	; 0xff
 c228fb4:	e1a03223 	lsr	r3, r3, #4
 c228fb8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228fbc:	e1a01003 	mov	r1, r3
 c228fc0:	e1a01101 	lsl	r1, r1, #2
 c228fc4:	e0813003 	add	r3, r1, r3
 c228fc8:	e1a03083 	lsl	r3, r3, #1
 c228fcc:	e20330ff 	and	r3, r3, #255	; 0xff
 c228fd0:	e0823003 	add	r3, r2, r3
 c228fd4:	e20320ff 	and	r2, r3, #255	; 0xff
 c228fd8:	e51b3010 	ldr	r3, [fp, #-16]
 c228fdc:	e5c32001 	strb	r2, [r3, #1]
    rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c228fe0:	e59f3274 	ldr	r3, [pc, #628]	; c22925c <rtc_gettime+0x43c>
 c228fe4:	e5d33000 	ldrb	r3, [r3]
 c228fe8:	e20330ff 	and	r3, r3, #255	; 0xff
 c228fec:	e203300f 	and	r3, r3, #15
 c228ff0:	e20320ff 	and	r2, r3, #255	; 0xff
 c228ff4:	e59f3260 	ldr	r3, [pc, #608]	; c22925c <rtc_gettime+0x43c>
 c228ff8:	e5d33000 	ldrb	r3, [r3]
 c228ffc:	e20330ff 	and	r3, r3, #255	; 0xff
 c229000:	e1a03223 	lsr	r3, r3, #4
 c229004:	e20330ff 	and	r3, r3, #255	; 0xff
 c229008:	e1a01003 	mov	r1, r3
 c22900c:	e1a01101 	lsl	r1, r1, #2
 c229010:	e0813003 	add	r3, r1, r3
 c229014:	e1a03083 	lsl	r3, r3, #1
 c229018:	e20330ff 	and	r3, r3, #255	; 0xff
 c22901c:	e0823003 	add	r3, r2, r3
 c229020:	e20320ff 	and	r2, r3, #255	; 0xff
 c229024:	e51b3010 	ldr	r3, [fp, #-16]
 c229028:	e5c32000 	strb	r2, [r3]
    if( ! rtc_time->sec ){
 c22902c:	e51b3010 	ldr	r3, [fp, #-16]
 c229030:	e5d33000 	ldrb	r3, [r3]
 c229034:	e3530000 	cmp	r3, #0
 c229038:	1a000076 	bne	c229218 <rtc_gettime+0x3f8>
    	//Reread, a second may have elapsed so date is invalid
        rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c22903c:	e59f3200 	ldr	r3, [pc, #512]	; c229244 <rtc_gettime+0x424>
 c229040:	e5d33000 	ldrb	r3, [r3]
 c229044:	e20330ff 	and	r3, r3, #255	; 0xff
 c229048:	e203300f 	and	r3, r3, #15
 c22904c:	e20320ff 	and	r2, r3, #255	; 0xff
 c229050:	e59f31ec 	ldr	r3, [pc, #492]	; c229244 <rtc_gettime+0x424>
 c229054:	e5d33000 	ldrb	r3, [r3]
 c229058:	e20330ff 	and	r3, r3, #255	; 0xff
 c22905c:	e1a03223 	lsr	r3, r3, #4
 c229060:	e20330ff 	and	r3, r3, #255	; 0xff
 c229064:	e1a01003 	mov	r1, r3
 c229068:	e1a01101 	lsl	r1, r1, #2
 c22906c:	e0813003 	add	r3, r1, r3
 c229070:	e1a03083 	lsl	r3, r3, #1
 c229074:	e20330ff 	and	r3, r3, #255	; 0xff
 c229078:	e0823003 	add	r3, r2, r3
 c22907c:	e20320ff 	and	r2, r3, #255	; 0xff
 c229080:	e51b3010 	ldr	r3, [fp, #-16]
 c229084:	e5c32006 	strb	r2, [r3, #6]
        rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c229088:	e59f31b8 	ldr	r3, [pc, #440]	; c229248 <rtc_gettime+0x428>
 c22908c:	e5d33000 	ldrb	r3, [r3]
 c229090:	e20330ff 	and	r3, r3, #255	; 0xff
 c229094:	e203300f 	and	r3, r3, #15
 c229098:	e20320ff 	and	r2, r3, #255	; 0xff
 c22909c:	e59f31a4 	ldr	r3, [pc, #420]	; c229248 <rtc_gettime+0x428>
 c2290a0:	e5d33000 	ldrb	r3, [r3]
 c2290a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290a8:	e1a03223 	lsr	r3, r3, #4
 c2290ac:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290b0:	e1a01003 	mov	r1, r3
 c2290b4:	e1a01101 	lsl	r1, r1, #2
 c2290b8:	e0813003 	add	r3, r1, r3
 c2290bc:	e1a03083 	lsl	r3, r3, #1
 c2290c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290c4:	e0823003 	add	r3, r2, r3
 c2290c8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2290cc:	e51b3010 	ldr	r3, [fp, #-16]
 c2290d0:	e5c32005 	strb	r2, [r3, #5]
        rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c2290d4:	e59f3170 	ldr	r3, [pc, #368]	; c22924c <rtc_gettime+0x42c>
 c2290d8:	e5d33000 	ldrb	r3, [r3]
 c2290dc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290e0:	e203300f 	and	r3, r3, #15
 c2290e4:	e20320ff 	and	r2, r3, #255	; 0xff
 c2290e8:	e59f315c 	ldr	r3, [pc, #348]	; c22924c <rtc_gettime+0x42c>
 c2290ec:	e5d33000 	ldrb	r3, [r3]
 c2290f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290f4:	e1a03223 	lsr	r3, r3, #4
 c2290f8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2290fc:	e1a01003 	mov	r1, r3
 c229100:	e1a01101 	lsl	r1, r1, #2
 c229104:	e0813003 	add	r3, r1, r3
 c229108:	e1a03083 	lsl	r3, r3, #1
 c22910c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229110:	e0823003 	add	r3, r2, r3
 c229114:	e20320ff 	and	r2, r3, #255	; 0xff
 c229118:	e51b3010 	ldr	r3, [fp, #-16]
 c22911c:	e5c32003 	strb	r2, [r3, #3]
        rtc_time->wday = rBCDDATE;
 c229120:	e59f3128 	ldr	r3, [pc, #296]	; c229250 <rtc_gettime+0x430>
 c229124:	e5d33000 	ldrb	r3, [r3]
 c229128:	e20320ff 	and	r2, r3, #255	; 0xff
 c22912c:	e51b3010 	ldr	r3, [fp, #-16]
 c229130:	e5c32004 	strb	r2, [r3, #4]
        rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c229134:	e59f3118 	ldr	r3, [pc, #280]	; c229254 <rtc_gettime+0x434>
 c229138:	e5d33000 	ldrb	r3, [r3]
 c22913c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229140:	e203300f 	and	r3, r3, #15
 c229144:	e20320ff 	and	r2, r3, #255	; 0xff
 c229148:	e59f3104 	ldr	r3, [pc, #260]	; c229254 <rtc_gettime+0x434>
 c22914c:	e5d33000 	ldrb	r3, [r3]
 c229150:	e20330ff 	and	r3, r3, #255	; 0xff
 c229154:	e1a03223 	lsr	r3, r3, #4
 c229158:	e20330ff 	and	r3, r3, #255	; 0xff
 c22915c:	e1a01003 	mov	r1, r3
 c229160:	e1a01101 	lsl	r1, r1, #2
 c229164:	e0813003 	add	r3, r1, r3
 c229168:	e1a03083 	lsl	r3, r3, #1
 c22916c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229170:	e0823003 	add	r3, r2, r3
 c229174:	e20320ff 	and	r2, r3, #255	; 0xff
 c229178:	e51b3010 	ldr	r3, [fp, #-16]
 c22917c:	e5c32002 	strb	r2, [r3, #2]
        rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c229180:	e59f30d0 	ldr	r3, [pc, #208]	; c229258 <rtc_gettime+0x438>
 c229184:	e5d33000 	ldrb	r3, [r3]
 c229188:	e20330ff 	and	r3, r3, #255	; 0xff
 c22918c:	e203300f 	and	r3, r3, #15
 c229190:	e20320ff 	and	r2, r3, #255	; 0xff
 c229194:	e59f30bc 	ldr	r3, [pc, #188]	; c229258 <rtc_gettime+0x438>
 c229198:	e5d33000 	ldrb	r3, [r3]
 c22919c:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291a0:	e1a03223 	lsr	r3, r3, #4
 c2291a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291a8:	e1a01003 	mov	r1, r3
 c2291ac:	e1a01101 	lsl	r1, r1, #2
 c2291b0:	e0813003 	add	r3, r1, r3
 c2291b4:	e1a03083 	lsl	r3, r3, #1
 c2291b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291bc:	e0823003 	add	r3, r2, r3
 c2291c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2291c4:	e51b3010 	ldr	r3, [fp, #-16]
 c2291c8:	e5c32001 	strb	r2, [r3, #1]
        rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c2291cc:	e59f3088 	ldr	r3, [pc, #136]	; c22925c <rtc_gettime+0x43c>
 c2291d0:	e5d33000 	ldrb	r3, [r3]
 c2291d4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291d8:	e203300f 	and	r3, r3, #15
 c2291dc:	e20320ff 	and	r2, r3, #255	; 0xff
 c2291e0:	e59f3074 	ldr	r3, [pc, #116]	; c22925c <rtc_gettime+0x43c>
 c2291e4:	e5d33000 	ldrb	r3, [r3]
 c2291e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291ec:	e1a03223 	lsr	r3, r3, #4
 c2291f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2291f4:	e1a01003 	mov	r1, r3
 c2291f8:	e1a01101 	lsl	r1, r1, #2
 c2291fc:	e0813003 	add	r3, r1, r3
 c229200:	e1a03083 	lsl	r3, r3, #1
 c229204:	e20330ff 	and	r3, r3, #255	; 0xff
 c229208:	e0823003 	add	r3, r2, r3
 c22920c:	e20320ff 	and	r2, r3, #255	; 0xff
 c229210:	e51b3010 	ldr	r3, [fp, #-16]
 c229214:	e5c32000 	strb	r2, [r3]
    }

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c229218:	e59f3020 	ldr	r3, [pc, #32]	; c229240 <rtc_gettime+0x420>
 c22921c:	e59f201c 	ldr	r2, [pc, #28]	; c229240 <rtc_gettime+0x420>
 c229220:	e5d22000 	ldrb	r2, [r2]
 c229224:	e20220ff 	and	r2, r2, #255	; 0xff
 c229228:	e3c22001 	bic	r2, r2, #1
 c22922c:	e20220ff 	and	r2, r2, #255	; 0xff
 c229230:	e5c32000 	strb	r2, [r3]
}
 c229234:	e24bd00c 	sub	sp, fp, #12
 c229238:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22923c:	e12fff1e 	bx	lr
 c229240:	01d70040 	.word	0x01d70040
 c229244:	01d70088 	.word	0x01d70088
 c229248:	01d70084 	.word	0x01d70084
 c22924c:	01d7007c 	.word	0x01d7007c
 c229250:	01d70080 	.word	0x01d70080
 c229254:	01d70078 	.word	0x01d70078
 c229258:	01d70074 	.word	0x01d70074
 c22925c:	01d70070 	.word	0x01d70070

0c229260 <rtc_set_alarm>:

void rtc_set_alarm( void(*isr)(void), rtc_time_t* rtc_time ) {
 c229260:	e1a0c00d 	mov	ip, sp
 c229264:	e92dd800 	push	{fp, ip, lr, pc}
 c229268:	e24cb004 	sub	fp, ip, #4
 c22926c:	e24dd008 	sub	sp, sp, #8
 c229270:	e50b0010 	str	r0, [fp, #-16]
 c229274:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec


    //Set alarm date
    rALMYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c229278:	e59f0380 	ldr	r0, [pc, #896]	; c229600 <rtc_set_alarm+0x3a0>
 c22927c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229280:	e5d32006 	ldrb	r2, [r3, #6]
 c229284:	e59f3378 	ldr	r3, [pc, #888]	; c229604 <rtc_set_alarm+0x3a4>
 c229288:	e0831392 	umull	r1, r3, r2, r3
 c22928c:	e1a031a3 	lsr	r3, r3, #3
 c229290:	e20320ff 	and	r2, r3, #255	; 0xff
 c229294:	e59f3368 	ldr	r3, [pc, #872]	; c229604 <rtc_set_alarm+0x3a4>
 c229298:	e0831392 	umull	r1, r3, r2, r3
 c22929c:	e1a011a3 	lsr	r1, r3, #3
 c2292a0:	e1a03001 	mov	r3, r1
 c2292a4:	e1a03103 	lsl	r3, r3, #2
 c2292a8:	e0833001 	add	r3, r3, r1
 c2292ac:	e1a03083 	lsl	r3, r3, #1
 c2292b0:	e0633002 	rsb	r3, r3, r2
 c2292b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2292b8:	e1a03203 	lsl	r3, r3, #4
 c2292bc:	e203c0ff 	and	ip, r3, #255	; 0xff
 c2292c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2292c4:	e5d32006 	ldrb	r2, [r3, #6]
 c2292c8:	e59f3334 	ldr	r3, [pc, #820]	; c229604 <rtc_set_alarm+0x3a4>
 c2292cc:	e0831392 	umull	r1, r3, r2, r3
 c2292d0:	e1a011a3 	lsr	r1, r3, #3
 c2292d4:	e1a03001 	mov	r3, r1
 c2292d8:	e1a03103 	lsl	r3, r3, #2
 c2292dc:	e0833001 	add	r3, r3, r1
 c2292e0:	e1a03083 	lsl	r3, r3, #1
 c2292e4:	e0633002 	rsb	r3, r3, r2
 c2292e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2292ec:	e20330ff 	and	r3, r3, #255	; 0xff
 c2292f0:	e1a0200c 	mov	r2, ip
 c2292f4:	e1823003 	orr	r3, r2, r3
 c2292f8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2292fc:	e20330ff 	and	r3, r3, #255	; 0xff
 c229300:	e5c03000 	strb	r3, [r0]
    rALMMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c229304:	e59f02fc 	ldr	r0, [pc, #764]	; c229608 <rtc_set_alarm+0x3a8>
 c229308:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22930c:	e5d32005 	ldrb	r2, [r3, #5]
 c229310:	e59f32ec 	ldr	r3, [pc, #748]	; c229604 <rtc_set_alarm+0x3a4>
 c229314:	e0831392 	umull	r1, r3, r2, r3
 c229318:	e1a031a3 	lsr	r3, r3, #3
 c22931c:	e20320ff 	and	r2, r3, #255	; 0xff
 c229320:	e59f32dc 	ldr	r3, [pc, #732]	; c229604 <rtc_set_alarm+0x3a4>
 c229324:	e0831392 	umull	r1, r3, r2, r3
 c229328:	e1a011a3 	lsr	r1, r3, #3
 c22932c:	e1a03001 	mov	r3, r1
 c229330:	e1a03103 	lsl	r3, r3, #2
 c229334:	e0833001 	add	r3, r3, r1
 c229338:	e1a03083 	lsl	r3, r3, #1
 c22933c:	e0633002 	rsb	r3, r3, r2
 c229340:	e20330ff 	and	r3, r3, #255	; 0xff
 c229344:	e1a03203 	lsl	r3, r3, #4
 c229348:	e203c0ff 	and	ip, r3, #255	; 0xff
 c22934c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229350:	e5d32005 	ldrb	r2, [r3, #5]
 c229354:	e59f32a8 	ldr	r3, [pc, #680]	; c229604 <rtc_set_alarm+0x3a4>
 c229358:	e0831392 	umull	r1, r3, r2, r3
 c22935c:	e1a011a3 	lsr	r1, r3, #3
 c229360:	e1a03001 	mov	r3, r1
 c229364:	e1a03103 	lsl	r3, r3, #2
 c229368:	e0833001 	add	r3, r3, r1
 c22936c:	e1a03083 	lsl	r3, r3, #1
 c229370:	e0633002 	rsb	r3, r3, r2
 c229374:	e20330ff 	and	r3, r3, #255	; 0xff
 c229378:	e20330ff 	and	r3, r3, #255	; 0xff
 c22937c:	e1a0200c 	mov	r2, ip
 c229380:	e1823003 	orr	r3, r2, r3
 c229384:	e20330ff 	and	r3, r3, #255	; 0xff
 c229388:	e20330ff 	and	r3, r3, #255	; 0xff
 c22938c:	e5c03000 	strb	r3, [r0]
    rALMDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c229390:	e59f0274 	ldr	r0, [pc, #628]	; c22960c <rtc_set_alarm+0x3ac>
 c229394:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229398:	e5d32003 	ldrb	r2, [r3, #3]
 c22939c:	e59f3260 	ldr	r3, [pc, #608]	; c229604 <rtc_set_alarm+0x3a4>
 c2293a0:	e0831392 	umull	r1, r3, r2, r3
 c2293a4:	e1a031a3 	lsr	r3, r3, #3
 c2293a8:	e20320ff 	and	r2, r3, #255	; 0xff
 c2293ac:	e59f3250 	ldr	r3, [pc, #592]	; c229604 <rtc_set_alarm+0x3a4>
 c2293b0:	e0831392 	umull	r1, r3, r2, r3
 c2293b4:	e1a011a3 	lsr	r1, r3, #3
 c2293b8:	e1a03001 	mov	r3, r1
 c2293bc:	e1a03103 	lsl	r3, r3, #2
 c2293c0:	e0833001 	add	r3, r3, r1
 c2293c4:	e1a03083 	lsl	r3, r3, #1
 c2293c8:	e0633002 	rsb	r3, r3, r2
 c2293cc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2293d0:	e1a03203 	lsl	r3, r3, #4
 c2293d4:	e203c0ff 	and	ip, r3, #255	; 0xff
 c2293d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2293dc:	e5d32003 	ldrb	r2, [r3, #3]
 c2293e0:	e59f321c 	ldr	r3, [pc, #540]	; c229604 <rtc_set_alarm+0x3a4>
 c2293e4:	e0831392 	umull	r1, r3, r2, r3
 c2293e8:	e1a011a3 	lsr	r1, r3, #3
 c2293ec:	e1a03001 	mov	r3, r1
 c2293f0:	e1a03103 	lsl	r3, r3, #2
 c2293f4:	e0833001 	add	r3, r3, r1
 c2293f8:	e1a03083 	lsl	r3, r3, #1
 c2293fc:	e0633002 	rsb	r3, r3, r2
 c229400:	e20330ff 	and	r3, r3, #255	; 0xff
 c229404:	e20330ff 	and	r3, r3, #255	; 0xff
 c229408:	e1a0200c 	mov	r2, ip
 c22940c:	e1823003 	orr	r3, r2, r3
 c229410:	e20330ff 	and	r3, r3, #255	; 0xff
 c229414:	e20330ff 	and	r3, r3, #255	; 0xff
 c229418:	e5c03000 	strb	r3, [r0]
    rALMHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c22941c:	e59f01ec 	ldr	r0, [pc, #492]	; c229610 <rtc_set_alarm+0x3b0>
 c229420:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229424:	e5d32002 	ldrb	r2, [r3, #2]
 c229428:	e59f31d4 	ldr	r3, [pc, #468]	; c229604 <rtc_set_alarm+0x3a4>
 c22942c:	e0831392 	umull	r1, r3, r2, r3
 c229430:	e1a031a3 	lsr	r3, r3, #3
 c229434:	e20320ff 	and	r2, r3, #255	; 0xff
 c229438:	e59f31c4 	ldr	r3, [pc, #452]	; c229604 <rtc_set_alarm+0x3a4>
 c22943c:	e0831392 	umull	r1, r3, r2, r3
 c229440:	e1a011a3 	lsr	r1, r3, #3
 c229444:	e1a03001 	mov	r3, r1
 c229448:	e1a03103 	lsl	r3, r3, #2
 c22944c:	e0833001 	add	r3, r3, r1
 c229450:	e1a03083 	lsl	r3, r3, #1
 c229454:	e0633002 	rsb	r3, r3, r2
 c229458:	e20330ff 	and	r3, r3, #255	; 0xff
 c22945c:	e1a03203 	lsl	r3, r3, #4
 c229460:	e203c0ff 	and	ip, r3, #255	; 0xff
 c229464:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229468:	e5d32002 	ldrb	r2, [r3, #2]
 c22946c:	e59f3190 	ldr	r3, [pc, #400]	; c229604 <rtc_set_alarm+0x3a4>
 c229470:	e0831392 	umull	r1, r3, r2, r3
 c229474:	e1a011a3 	lsr	r1, r3, #3
 c229478:	e1a03001 	mov	r3, r1
 c22947c:	e1a03103 	lsl	r3, r3, #2
 c229480:	e0833001 	add	r3, r3, r1
 c229484:	e1a03083 	lsl	r3, r3, #1
 c229488:	e0633002 	rsb	r3, r3, r2
 c22948c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229490:	e20330ff 	and	r3, r3, #255	; 0xff
 c229494:	e1a0200c 	mov	r2, ip
 c229498:	e1823003 	orr	r3, r2, r3
 c22949c:	e20330ff 	and	r3, r3, #255	; 0xff
 c2294a0:	e20330ff 	and	r3, r3, #255	; 0xff
 c2294a4:	e5c03000 	strb	r3, [r0]
    rALMMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c2294a8:	e59f0164 	ldr	r0, [pc, #356]	; c229614 <rtc_set_alarm+0x3b4>
 c2294ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2294b0:	e5d32001 	ldrb	r2, [r3, #1]
 c2294b4:	e59f3148 	ldr	r3, [pc, #328]	; c229604 <rtc_set_alarm+0x3a4>
 c2294b8:	e0831392 	umull	r1, r3, r2, r3
 c2294bc:	e1a031a3 	lsr	r3, r3, #3
 c2294c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c2294c4:	e59f3138 	ldr	r3, [pc, #312]	; c229604 <rtc_set_alarm+0x3a4>
 c2294c8:	e0831392 	umull	r1, r3, r2, r3
 c2294cc:	e1a011a3 	lsr	r1, r3, #3
 c2294d0:	e1a03001 	mov	r3, r1
 c2294d4:	e1a03103 	lsl	r3, r3, #2
 c2294d8:	e0833001 	add	r3, r3, r1
 c2294dc:	e1a03083 	lsl	r3, r3, #1
 c2294e0:	e0633002 	rsb	r3, r3, r2
 c2294e4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2294e8:	e1a03203 	lsl	r3, r3, #4
 c2294ec:	e203c0ff 	and	ip, r3, #255	; 0xff
 c2294f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2294f4:	e5d32001 	ldrb	r2, [r3, #1]
 c2294f8:	e59f3104 	ldr	r3, [pc, #260]	; c229604 <rtc_set_alarm+0x3a4>
 c2294fc:	e0831392 	umull	r1, r3, r2, r3
 c229500:	e1a011a3 	lsr	r1, r3, #3
 c229504:	e1a03001 	mov	r3, r1
 c229508:	e1a03103 	lsl	r3, r3, #2
 c22950c:	e0833001 	add	r3, r3, r1
 c229510:	e1a03083 	lsl	r3, r3, #1
 c229514:	e0633002 	rsb	r3, r3, r2
 c229518:	e20330ff 	and	r3, r3, #255	; 0xff
 c22951c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229520:	e1a0200c 	mov	r2, ip
 c229524:	e1823003 	orr	r3, r2, r3
 c229528:	e20330ff 	and	r3, r3, #255	; 0xff
 c22952c:	e20330ff 	and	r3, r3, #255	; 0xff
 c229530:	e5c03000 	strb	r3, [r0]
    rALMSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c229534:	e59f00dc 	ldr	r0, [pc, #220]	; c229618 <rtc_set_alarm+0x3b8>
 c229538:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22953c:	e5d32000 	ldrb	r2, [r3]
 c229540:	e59f30bc 	ldr	r3, [pc, #188]	; c229604 <rtc_set_alarm+0x3a4>
 c229544:	e0831392 	umull	r1, r3, r2, r3
 c229548:	e1a031a3 	lsr	r3, r3, #3
 c22954c:	e20320ff 	and	r2, r3, #255	; 0xff
 c229550:	e59f30ac 	ldr	r3, [pc, #172]	; c229604 <rtc_set_alarm+0x3a4>
 c229554:	e0831392 	umull	r1, r3, r2, r3
 c229558:	e1a011a3 	lsr	r1, r3, #3
 c22955c:	e1a03001 	mov	r3, r1
 c229560:	e1a03103 	lsl	r3, r3, #2
 c229564:	e0833001 	add	r3, r3, r1
 c229568:	e1a03083 	lsl	r3, r3, #1
 c22956c:	e0633002 	rsb	r3, r3, r2
 c229570:	e20330ff 	and	r3, r3, #255	; 0xff
 c229574:	e1a03203 	lsl	r3, r3, #4
 c229578:	e203c0ff 	and	ip, r3, #255	; 0xff
 c22957c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229580:	e5d32000 	ldrb	r2, [r3]
 c229584:	e59f3078 	ldr	r3, [pc, #120]	; c229604 <rtc_set_alarm+0x3a4>
 c229588:	e0831392 	umull	r1, r3, r2, r3
 c22958c:	e1a011a3 	lsr	r1, r3, #3
 c229590:	e1a03001 	mov	r3, r1
 c229594:	e1a03103 	lsl	r3, r3, #2
 c229598:	e0833001 	add	r3, r3, r1
 c22959c:	e1a03083 	lsl	r3, r3, #1
 c2295a0:	e0633002 	rsb	r3, r3, r2
 c2295a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2295a8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2295ac:	e1a0200c 	mov	r2, ip
 c2295b0:	e1823003 	orr	r3, r2, r3
 c2295b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c2295b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c2295bc:	e5c03000 	strb	r3, [r0]

	//Enable alarm (bits [7:0] = 1)
    rRTCALM  = 0x7F;
 c2295c0:	e59f3054 	ldr	r3, [pc, #84]	; c22961c <rtc_set_alarm+0x3bc>
 c2295c4:	e3a0207f 	mov	r2, #127	; 0x7f
 c2295c8:	e5c32000 	strb	r2, [r3]

    ic_conf_line(INT_RTC, IRQ);
 c2295cc:	e3a00001 	mov	r0, #1
 c2295d0:	e3a01000 	mov	r1, #0
 c2295d4:	ebfff743 	bl	c2272e8 <ic_conf_line>
    ic_cleanflag(INT_RTC);
 c2295d8:	e3a00001 	mov	r0, #1
 c2295dc:	ebfff7a4 	bl	c227474 <ic_cleanflag>
    ic_enable(INT_RTC);
 c2295e0:	e3a00001 	mov	r0, #1
 c2295e4:	ebfff76f 	bl	c2273a8 <ic_enable>

    pISR_RTC = (unsigned) isr;
 c2295e8:	e59f3030 	ldr	r3, [pc, #48]	; c229620 <rtc_set_alarm+0x3c0>
 c2295ec:	e51b2010 	ldr	r2, [fp, #-16]
 c2295f0:	e5832000 	str	r2, [r3]
}
 c2295f4:	e24bd00c 	sub	sp, fp, #12
 c2295f8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2295fc:	e12fff1e 	bx	lr
 c229600:	01d70068 	.word	0x01d70068
 c229604:	cccccccd 	.word	0xcccccccd
 c229608:	01d70064 	.word	0x01d70064
 c22960c:	01d70060 	.word	0x01d70060
 c229610:	01d7005c 	.word	0x01d7005c
 c229614:	01d70058 	.word	0x01d70058
 c229618:	01d70054 	.word	0x01d70054
 c22961c:	01d70050 	.word	0x01d70050
 c229620:	0c7fff24 	.word	0x0c7fff24

0c229624 <rtc_clear_alarm>:

void rtc_clear_alarm() {
 c229624:	e1a0c00d 	mov	ip, sp
 c229628:	e92dd800 	push	{fp, ip, lr, pc}
 c22962c:	e24cb004 	sub	fp, ip, #4
	ic_disable(INT_RTC);
 c229630:	e3a00001 	mov	r0, #1
 c229634:	ebfff775 	bl	c227410 <ic_disable>
	pISR_RTC = (unsigned) isr_ALARM_dummy;
 c229638:	e59f301c 	ldr	r3, [pc, #28]	; c22965c <rtc_clear_alarm+0x38>
 c22963c:	e59f201c 	ldr	r2, [pc, #28]	; c229660 <rtc_clear_alarm+0x3c>
 c229640:	e5832000 	str	r2, [r3]
    rRTCALM  = 0;
 c229644:	e59f3018 	ldr	r3, [pc, #24]	; c229664 <rtc_clear_alarm+0x40>
 c229648:	e3a02000 	mov	r2, #0
 c22964c:	e5c32000 	strb	r2, [r3]
}
 c229650:	e24bd00c 	sub	sp, fp, #12
 c229654:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229658:	e12fff1e 	bx	lr
 c22965c:	0c7fff24 	.word	0x0c7fff24
 c229660:	0c228950 	.word	0x0c228950
 c229664:	01d70050 	.word	0x01d70050

0c229668 <rtc_open>:

// Sets ISR to RTC ticks (tick_count)
void rtc_open( void (*isr)(void), uint8 tick_count )
{
 c229668:	e1a0c00d 	mov	ip, sp
 c22966c:	e92dd800 	push	{fp, ip, lr, pc}
 c229670:	e24cb004 	sub	fp, ip, #4
 c229674:	e24dd008 	sub	sp, sp, #8
 c229678:	e50b0010 	str	r0, [fp, #-16]
 c22967c:	e1a03001 	mov	r3, r1
 c229680:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    pISR_TICK = (unsigned)isr;
 c229684:	e59f3044 	ldr	r3, [pc, #68]	; c2296d0 <rtc_open+0x68>
 c229688:	e51b2010 	ldr	r2, [fp, #-16]
 c22968c:	e5832000 	str	r2, [r3]

    ic_conf_line(INT_TICK, IRQ);
 c229690:	e3a00014 	mov	r0, #20
 c229694:	e3a01000 	mov	r1, #0
 c229698:	ebfff712 	bl	c2272e8 <ic_conf_line>
    ic_cleanflag(INT_TICK);
 c22969c:	e3a00014 	mov	r0, #20
 c2296a0:	ebfff773 	bl	c227474 <ic_cleanflag>
    ic_enable(INT_TICK);
 c2296a4:	e3a00014 	mov	r0, #20
 c2296a8:	ebfff73e 	bl	c2273a8 <ic_enable>

    rTICINT = 1 << 7 | (tick_count & 0b1111111);
 c2296ac:	e59f2020 	ldr	r2, [pc, #32]	; c2296d4 <rtc_open+0x6c>
 c2296b0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c2296b4:	e1e03c83 	mvn	r3, r3, lsl #25
 c2296b8:	e1e03ca3 	mvn	r3, r3, lsr #25
 c2296bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c2296c0:	e5c23000 	strb	r3, [r2]
}
 c2296c4:	e24bd00c 	sub	sp, fp, #12
 c2296c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2296cc:	e12fff1e 	bx	lr
 c2296d0:	0c7fff70 	.word	0x0c7fff70
 c2296d4:	01d7008c 	.word	0x01d7008c

0c2296d8 <rtc_close>:

// Removes RTC ISR
void rtc_close( void )
{
 c2296d8:	e1a0c00d 	mov	ip, sp
 c2296dc:	e92dd800 	push	{fp, ip, lr, pc}
 c2296e0:	e24cb004 	sub	fp, ip, #4
    rTICINT = 0;
 c2296e4:	e59f3024 	ldr	r3, [pc, #36]	; c229710 <rtc_close+0x38>
 c2296e8:	e3a02000 	mov	r2, #0
 c2296ec:	e5c32000 	strb	r2, [r3]
    ic_disable(INT_TICK);
 c2296f0:	e3a00014 	mov	r0, #20
 c2296f4:	ebfff745 	bl	c227410 <ic_disable>
    pISR_TICK = (unsigned)isr_TICK_dummy;
 c2296f8:	e59f3014 	ldr	r3, [pc, #20]	; c229714 <rtc_close+0x3c>
 c2296fc:	e59f2014 	ldr	r2, [pc, #20]	; c229718 <rtc_close+0x40>
 c229700:	e5832000 	str	r2, [r3]
}
 c229704:	e24bd00c 	sub	sp, fp, #12
 c229708:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22970c:	e12fff1e 	bx	lr
 c229710:	01d7008c 	.word	0x01d7008c
 c229714:	0c7fff70 	.word	0x0c7fff70
 c229718:	0c228928 	.word	0x0c228928

0c22971c <tmr_set_prescaler>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "timer.h"

int tmr_set_prescaler(int p, int  value)
{
 c22971c:	e1a0c00d 	mov	ip, sp
 c229720:	e92dd800 	push	{fp, ip, lr, pc}
 c229724:	e24cb004 	sub	fp, ip, #4
 c229728:	e24dd018 	sub	sp, sp, #24
 c22972c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c229730:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
	int offset = p*8;
 c229734:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229738:	e1a03183 	lsl	r3, r3, #3
 c22973c:	e50b3010 	str	r3, [fp, #-16]
	value &= 0xFF;
 c229740:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c229744:	e20330ff 	and	r3, r3, #255	; 0xff
 c229748:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

	if (p < 0 || p > 3)
 c22974c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229750:	e3530000 	cmp	r3, #0
 c229754:	ba000002 	blt	c229764 <tmr_set_prescaler+0x48>
 c229758:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22975c:	e3530003 	cmp	r3, #3
 c229760:	da000001 	ble	c22976c <tmr_set_prescaler+0x50>
		return -1;
 c229764:	e3e03000 	mvn	r3, #0
 c229768:	ea00001d 	b	c2297e4 <tmr_set_prescaler+0xc8>

	//COMPLETAR: escribir el valor value a partir de la posiciÃ³n offset en el
	//registro rTCFG0, para establecer el valor de pre-escalado del mÃ³dulo p

	int bitfield = value, mask = 0xff, reg = rTCFG0;
 c22976c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c229770:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c229774:	e3a030ff 	mov	r3, #255	; 0xff
 c229778:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c22977c:	e59f3070 	ldr	r3, [pc, #112]	; c2297f4 <tmr_set_prescaler+0xd8>
 c229780:	e5933000 	ldr	r3, [r3]
 c229784:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= offset;
 c229788:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c22978c:	e51b3010 	ldr	r3, [fp, #-16]
 c229790:	e1a03312 	lsl	r3, r2, r3
 c229794:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= offset;
 c229798:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c22979c:	e51b3010 	ldr	r3, [fp, #-16]
 c2297a0:	e1a03312 	lsl	r3, r2, r3
 c2297a4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c2297a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2297ac:	e1e03003 	mvn	r3, r3
 c2297b0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo byte
 c2297b4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2297b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2297bc:	e0023003 	and	r3, r2, r3
 c2297c0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo byte
 c2297c4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2297c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c2297cc:	e1823003 	orr	r3, r2, r3
 c2297d0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG0 = reg;
 c2297d4:	e59f3018 	ldr	r3, [pc, #24]	; c2297f4 <tmr_set_prescaler+0xd8>
 c2297d8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2297dc:	e5832000 	str	r2, [r3]

	return 0;
 c2297e0:	e3a03000 	mov	r3, #0
}
 c2297e4:	e1a00003 	mov	r0, r3
 c2297e8:	e24bd00c 	sub	sp, fp, #12
 c2297ec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c2297f0:	e12fff1e 	bx	lr
 c2297f4:	01d50000 	.word	0x01d50000

0c2297f8 <tmr_set_divider>:

int tmr_set_divider(int d, enum tmr_div div)
{
 c2297f8:	e1a0c00d 	mov	ip, sp
 c2297fc:	e92dd800 	push	{fp, ip, lr, pc}
 c229800:	e24cb004 	sub	fp, ip, #4
 c229804:	e24dd018 	sub	sp, sp, #24
 c229808:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c22980c:	e1a03001 	mov	r3, r1
 c229810:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
	int pos = d*4;
 c229814:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229818:	e1a03103 	lsl	r3, r3, #2
 c22981c:	e50b3010 	str	r3, [fp, #-16]

	if ((d < 0 || d > 5) ||
 c229820:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229824:	e3530000 	cmp	r3, #0
 c229828:	ba000014 	blt	c229880 <tmr_set_divider+0x88>
 c22982c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229830:	e3530005 	cmp	r3, #5
 c229834:	ca000011 	bgt	c229880 <tmr_set_divider+0x88>
 c229838:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c22983c:	e3530004 	cmp	r3, #4
 c229840:	1a000002 	bne	c229850 <tmr_set_divider+0x58>
			(div == D1_32 && d > 3) ||
 c229844:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229848:	e3530003 	cmp	r3, #3
 c22984c:	ca00000b 	bgt	c229880 <tmr_set_divider+0x88>
 c229850:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c229854:	e3530005 	cmp	r3, #5
 c229858:	1a000002 	bne	c229868 <tmr_set_divider+0x70>
			(div == EXTCLK && d != 5) ||
 c22985c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229860:	e3530005 	cmp	r3, #5
 c229864:	1a000005 	bne	c229880 <tmr_set_divider+0x88>
 c229868:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c22986c:	e3530006 	cmp	r3, #6
 c229870:	1a000004 	bne	c229888 <tmr_set_divider+0x90>
			(div == TCLK && d != 4))
 c229874:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c229878:	e3530004 	cmp	r3, #4
 c22987c:	0a000001 	beq	c229888 <tmr_set_divider+0x90>
		return -1;
 c229880:	e3e03000 	mvn	r3, #0
 c229884:	ea000025 	b	c229920 <tmr_set_divider+0x128>

	if (div == EXTCLK || div == TCLK)
 c229888:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c22988c:	e3530005 	cmp	r3, #5
 c229890:	0a000002 	beq	c2298a0 <tmr_set_divider+0xa8>
 c229894:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c229898:	e3530006 	cmp	r3, #6
 c22989c:	1a000001 	bne	c2298a8 <tmr_set_divider+0xb0>
		div = 4;
 c2298a0:	e3a03004 	mov	r3, #4
 c2298a4:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

	//COMPLETAR: escribir el valor div a partir de la posiciÃ³n pos en el
	//registro rTCFG1 para establecer el valor para el divisor d

	int bitfield = div, mask = 0xf, reg = rTCFG1;
 c2298a8:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c2298ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c2298b0:	e3a0300f 	mov	r3, #15
 c2298b4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c2298b8:	e59f3070 	ldr	r3, [pc, #112]	; c229930 <tmr_set_divider+0x138>
 c2298bc:	e5933000 	ldr	r3, [r3]
 c2298c0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= pos;
 c2298c4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c2298c8:	e51b3010 	ldr	r3, [fp, #-16]
 c2298cc:	e1a03312 	lsl	r3, r2, r3
 c2298d0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= pos;
 c2298d4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c2298d8:	e51b3010 	ldr	r3, [fp, #-16]
 c2298dc:	e1a03312 	lsl	r3, r2, r3
 c2298e0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c2298e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2298e8:	e1e03003 	mvn	r3, r3
 c2298ec:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo nibble
 c2298f0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2298f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c2298f8:	e0023003 	and	r3, r2, r3
 c2298fc:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo nibble
 c229900:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c229904:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229908:	e1823003 	orr	r3, r2, r3
 c22990c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG1 = reg;
 c229910:	e59f3018 	ldr	r3, [pc, #24]	; c229930 <tmr_set_divider+0x138>
 c229914:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c229918:	e5832000 	str	r2, [r3]

	return 0;
 c22991c:	e3a03000 	mov	r3, #0
}
 c229920:	e1a00003 	mov	r0, r3
 c229924:	e24bd00c 	sub	sp, fp, #12
 c229928:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22992c:	e12fff1e 	bx	lr
 c229930:	01d50004 	.word	0x01d50004

0c229934 <tmr_set_count>:

int tmr_set_count(enum tmr_timer t, int count, int cmp)
{
 c229934:	e1a0c00d 	mov	ip, sp
 c229938:	e92dd800 	push	{fp, ip, lr, pc}
 c22993c:	e24cb004 	sub	fp, ip, #4
 c229940:	e24dd018 	sub	sp, sp, #24
 c229944:	e1a03000 	mov	r3, r0
 c229948:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c22994c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c229950:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int err = 0;
 c229954:	e3a03000 	mov	r3, #0
 c229958:	e50b3010 	str	r3, [fp, #-16]
	switch (t) {
 c22995c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229960:	e3530005 	cmp	r3, #5
 c229964:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c229968:	ea00002c 	b	c229a20 <tmr_set_count+0xec>
 c22996c:	0c229984 	.word	0x0c229984
 c229970:	0c2299a0 	.word	0x0c2299a0
 c229974:	0c2299bc 	.word	0x0c2299bc
 c229978:	0c2299d8 	.word	0x0c2299d8
 c22997c:	0c2299f4 	.word	0x0c2299f4
 c229980:	0c229a10 	.word	0x0c229a10
		case TIMER0:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer0 (rTCNTB0 y
			//rTCMPB0)
			rTCNTB0 = count;
 c229984:	e59f30b0 	ldr	r3, [pc, #176]	; c229a3c <tmr_set_count+0x108>
 c229988:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c22998c:	e5832000 	str	r2, [r3]
			rTCMPB0 = cmp;
 c229990:	e59f30a8 	ldr	r3, [pc, #168]	; c229a40 <tmr_set_count+0x10c>
 c229994:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c229998:	e5832000 	str	r2, [r3]
			break;
 c22999c:	ea000021 	b	c229a28 <tmr_set_count+0xf4>
		case TIMER1:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer1 (rTCNTB1 y
			//rTCMPB1)
			rTCNTB1 = count;
 c2299a0:	e59f309c 	ldr	r3, [pc, #156]	; c229a44 <tmr_set_count+0x110>
 c2299a4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2299a8:	e5832000 	str	r2, [r3]
			rTCMPB1 = cmp;
 c2299ac:	e59f3094 	ldr	r3, [pc, #148]	; c229a48 <tmr_set_count+0x114>
 c2299b0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c2299b4:	e5832000 	str	r2, [r3]
			 break;
 c2299b8:	ea00001a 	b	c229a28 <tmr_set_count+0xf4>
		case TIMER2:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer2 (rTCNTB2 y
			//rTCMPB2)
			rTCNTB2 = count;
 c2299bc:	e59f3088 	ldr	r3, [pc, #136]	; c229a4c <tmr_set_count+0x118>
 c2299c0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2299c4:	e5832000 	str	r2, [r3]
			rTCMPB2 = cmp;
 c2299c8:	e59f3080 	ldr	r3, [pc, #128]	; c229a50 <tmr_set_count+0x11c>
 c2299cc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c2299d0:	e5832000 	str	r2, [r3]
			 break;
 c2299d4:	ea000013 	b	c229a28 <tmr_set_count+0xf4>
		case TIMER3:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer3 (rTCNTB3 y
			//rTCMPB3)
			rTCNTB3 = count;
 c2299d8:	e59f3074 	ldr	r3, [pc, #116]	; c229a54 <tmr_set_count+0x120>
 c2299dc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2299e0:	e5832000 	str	r2, [r3]
			rTCMPB3 = cmp;
 c2299e4:	e59f306c 	ldr	r3, [pc, #108]	; c229a58 <tmr_set_count+0x124>
 c2299e8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c2299ec:	e5832000 	str	r2, [r3]
			 break;
 c2299f0:	ea00000c 	b	c229a28 <tmr_set_count+0xf4>
		case TIMER4:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer4 (rTCNTB4 y
			//rTCMPB4)
			rTCNTB4 = count;
 c2299f4:	e59f3060 	ldr	r3, [pc, #96]	; c229a5c <tmr_set_count+0x128>
 c2299f8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c2299fc:	e5832000 	str	r2, [r3]
			rTCMPB4 = cmp;
 c229a00:	e59f3058 	ldr	r3, [pc, #88]	; c229a60 <tmr_set_count+0x12c>
 c229a04:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c229a08:	e5832000 	str	r2, [r3]
			 break;
 c229a0c:	ea000005 	b	c229a28 <tmr_set_count+0xf4>
		case TIMER5:
			//COMPLETAR: establecer el valor de cuenta count en el registro de 
			//buffer del timer5 (rTCNTB5)
			rTCNTB5 = count;
 c229a10:	e59f304c 	ldr	r3, [pc, #76]	; c229a64 <tmr_set_count+0x130>
 c229a14:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c229a18:	e5832000 	str	r2, [r3]
			 break;
 c229a1c:	ea000001 	b	c229a28 <tmr_set_count+0xf4>
		default:
			err = -1;
 c229a20:	e3e03000 	mvn	r3, #0
 c229a24:	e50b3010 	str	r3, [fp, #-16]
	}

	return err;
 c229a28:	e51b3010 	ldr	r3, [fp, #-16]
}
 c229a2c:	e1a00003 	mov	r0, r3
 c229a30:	e24bd00c 	sub	sp, fp, #12
 c229a34:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229a38:	e12fff1e 	bx	lr
 c229a3c:	01d5000c 	.word	0x01d5000c
 c229a40:	01d50010 	.word	0x01d50010
 c229a44:	01d50018 	.word	0x01d50018
 c229a48:	01d5001c 	.word	0x01d5001c
 c229a4c:	01d50024 	.word	0x01d50024
 c229a50:	01d50028 	.word	0x01d50028
 c229a54:	01d50030 	.word	0x01d50030
 c229a58:	01d50034 	.word	0x01d50034
 c229a5c:	01d5003c 	.word	0x01d5003c
 c229a60:	01d50040 	.word	0x01d50040
 c229a64:	01d50048 	.word	0x01d50048

0c229a68 <tmr_update>:

int tmr_update(enum tmr_timer t)
{
 c229a68:	e1a0c00d 	mov	ip, sp
 c229a6c:	e92dd800 	push	{fp, ip, lr, pc}
 c229a70:	e24cb004 	sub	fp, ip, #4
 c229a74:	e24dd010 	sub	sp, sp, #16
 c229a78:	e1a03000 	mov	r3, r0
 c229a7c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c229a80:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229a84:	e1a03103 	lsl	r3, r3, #2
 c229a88:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c229a8c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229a90:	e3530000 	cmp	r3, #0
 c229a94:	0a000002 	beq	c229aa4 <tmr_update+0x3c>
		pos += 4;
 c229a98:	e51b3010 	ldr	r3, [fp, #-16]
 c229a9c:	e2833004 	add	r3, r3, #4
 c229aa0:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c229aa4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229aa8:	e3530005 	cmp	r3, #5
 c229aac:	9a000001 	bls	c229ab8 <tmr_update+0x50>
		return -1;
 c229ab0:	e3e03000 	mvn	r3, #0
 c229ab4:	ea000014 	b	c229b0c <tmr_update+0xa4>

	pos++;
 c229ab8:	e51b3010 	ldr	r3, [fp, #-16]
 c229abc:	e2833001 	add	r3, r3, #1
 c229ac0:	e50b3010 	str	r3, [fp, #-16]

	//COMPLETAR: poner a 1 en el registro rTCON el bit indicado por pos 
	// y justo despuÃ©s ponerlo a 0 (deben ser stores distintos, lo hacemos con
	// sentencias C distintas)
	rTCON |= 1 << pos;
 c229ac4:	e59f3050 	ldr	r3, [pc, #80]	; c229b1c <tmr_update+0xb4>
 c229ac8:	e59f204c 	ldr	r2, [pc, #76]	; c229b1c <tmr_update+0xb4>
 c229acc:	e5921000 	ldr	r1, [r2]
 c229ad0:	e3a00001 	mov	r0, #1
 c229ad4:	e51b2010 	ldr	r2, [fp, #-16]
 c229ad8:	e1a02210 	lsl	r2, r0, r2
 c229adc:	e1812002 	orr	r2, r1, r2
 c229ae0:	e5832000 	str	r2, [r3]
	rTCON &= ~(1 << pos);
 c229ae4:	e59f3030 	ldr	r3, [pc, #48]	; c229b1c <tmr_update+0xb4>
 c229ae8:	e59f202c 	ldr	r2, [pc, #44]	; c229b1c <tmr_update+0xb4>
 c229aec:	e5921000 	ldr	r1, [r2]
 c229af0:	e3a00001 	mov	r0, #1
 c229af4:	e51b2010 	ldr	r2, [fp, #-16]
 c229af8:	e1a02210 	lsl	r2, r0, r2
 c229afc:	e1e02002 	mvn	r2, r2
 c229b00:	e0012002 	and	r2, r1, r2
 c229b04:	e5832000 	str	r2, [r3]

	return 0;
 c229b08:	e3a03000 	mov	r3, #0
}
 c229b0c:	e1a00003 	mov	r0, r3
 c229b10:	e24bd00c 	sub	sp, fp, #12
 c229b14:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229b18:	e12fff1e 	bx	lr
 c229b1c:	01d50008 	.word	0x01d50008

0c229b20 <tmr_set_mode>:

int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
{
 c229b20:	e1a0c00d 	mov	ip, sp
 c229b24:	e92dd800 	push	{fp, ip, lr, pc}
 c229b28:	e24cb004 	sub	fp, ip, #4
 c229b2c:	e24dd010 	sub	sp, sp, #16
 c229b30:	e1a02000 	mov	r2, r0
 c229b34:	e1a03001 	mov	r3, r1
 c229b38:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c229b3c:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int err = 0;
 c229b40:	e3a03000 	mov	r3, #0
 c229b44:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c229b48:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229b4c:	e1a03103 	lsl	r3, r3, #2
 c229b50:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c229b54:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229b58:	e3530000 	cmp	r3, #0
 c229b5c:	0a000002 	beq	c229b6c <tmr_set_mode+0x4c>
		pos += 4;
 c229b60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229b64:	e2833004 	add	r3, r3, #4
 c229b68:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (t < 0 || t > 5)
 c229b6c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229b70:	e3530005 	cmp	r3, #5
 c229b74:	9a000001 	bls	c229b80 <tmr_set_mode+0x60>
		return -1;
 c229b78:	e3e03000 	mvn	r3, #0
 c229b7c:	ea000025 	b	c229c18 <tmr_set_mode+0xf8>

	if(t == 5)
 c229b80:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229b84:	e3530005 	cmp	r3, #5
 c229b88:	1a000003 	bne	c229b9c <tmr_set_mode+0x7c>
		pos += 2;
 c229b8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229b90:	e2833002 	add	r3, r3, #2
 c229b94:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c229b98:	ea000002 	b	c229ba8 <tmr_set_mode+0x88>
	else
		pos += 3;
 c229b9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229ba0:	e2833003 	add	r3, r3, #3
 c229ba4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (mode == ONE_SHOT)
 c229ba8:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c229bac:	e3530000 	cmp	r3, #0
 c229bb0:	1a000009 	bne	c229bdc <tmr_set_mode+0xbc>
		//COMPLETAR: poner a 0 el bit autoreload a partir de la posiciÃ³n pos (es
		//el cuarto bit a partir de esa posiciÃ³n)
		rTCON &= ~(1 << pos);
 c229bb4:	e59f306c 	ldr	r3, [pc, #108]	; c229c28 <tmr_set_mode+0x108>
 c229bb8:	e59f2068 	ldr	r2, [pc, #104]	; c229c28 <tmr_set_mode+0x108>
 c229bbc:	e5921000 	ldr	r1, [r2]
 c229bc0:	e3a00001 	mov	r0, #1
 c229bc4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c229bc8:	e1a02210 	lsl	r2, r0, r2
 c229bcc:	e1e02002 	mvn	r2, r2
 c229bd0:	e0012002 	and	r2, r1, r2
 c229bd4:	e5832000 	str	r2, [r3]
 c229bd8:	ea00000d 	b	c229c14 <tmr_set_mode+0xf4>
	else if (mode == RELOAD)
 c229bdc:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c229be0:	e3530001 	cmp	r3, #1
 c229be4:	1a000008 	bne	c229c0c <tmr_set_mode+0xec>
		//COMPLETAR: poner a 1 el bit autoreload a partir de la posiciÃ³n pos (es
		//el cuarto bit a partir de esa posiciÃ³n)
		rTCON |= 1 << pos;
 c229be8:	e59f3038 	ldr	r3, [pc, #56]	; c229c28 <tmr_set_mode+0x108>
 c229bec:	e59f2034 	ldr	r2, [pc, #52]	; c229c28 <tmr_set_mode+0x108>
 c229bf0:	e5921000 	ldr	r1, [r2]
 c229bf4:	e3a00001 	mov	r0, #1
 c229bf8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c229bfc:	e1a02210 	lsl	r2, r0, r2
 c229c00:	e1812002 	orr	r2, r1, r2
 c229c04:	e5832000 	str	r2, [r3]
 c229c08:	ea000001 	b	c229c14 <tmr_set_mode+0xf4>
	else
		err = -1;
 c229c0c:	e3e03000 	mvn	r3, #0
 c229c10:	e50b3010 	str	r3, [fp, #-16]

	return err;
 c229c14:	e51b3010 	ldr	r3, [fp, #-16]
}
 c229c18:	e1a00003 	mov	r0, r3
 c229c1c:	e24bd00c 	sub	sp, fp, #12
 c229c20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229c24:	e12fff1e 	bx	lr
 c229c28:	01d50008 	.word	0x01d50008

0c229c2c <tmr_start>:

int tmr_start(enum tmr_timer t)
{
 c229c2c:	e1a0c00d 	mov	ip, sp
 c229c30:	e92dd800 	push	{fp, ip, lr, pc}
 c229c34:	e24cb004 	sub	fp, ip, #4
 c229c38:	e24dd010 	sub	sp, sp, #16
 c229c3c:	e1a03000 	mov	r3, r0
 c229c40:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c229c44:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229c48:	e1a03103 	lsl	r3, r3, #2
 c229c4c:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c229c50:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229c54:	e3530000 	cmp	r3, #0
 c229c58:	0a000002 	beq	c229c68 <tmr_start+0x3c>
		pos += 4;
 c229c5c:	e51b3010 	ldr	r3, [fp, #-16]
 c229c60:	e2833004 	add	r3, r3, #4
 c229c64:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c229c68:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229c6c:	e3530005 	cmp	r3, #5
 c229c70:	9a000001 	bls	c229c7c <tmr_start+0x50>
		return -1;
 c229c74:	e3e03000 	mvn	r3, #0
 c229c78:	ea000008 	b	c229ca0 <tmr_start+0x74>

	//COMPLETAR: poner a 1 el bit de start a partir de la posiciÃ³n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON |= 1 << pos;
 c229c7c:	e59f302c 	ldr	r3, [pc, #44]	; c229cb0 <tmr_start+0x84>
 c229c80:	e59f2028 	ldr	r2, [pc, #40]	; c229cb0 <tmr_start+0x84>
 c229c84:	e5921000 	ldr	r1, [r2]
 c229c88:	e3a00001 	mov	r0, #1
 c229c8c:	e51b2010 	ldr	r2, [fp, #-16]
 c229c90:	e1a02210 	lsl	r2, r0, r2
 c229c94:	e1812002 	orr	r2, r1, r2
 c229c98:	e5832000 	str	r2, [r3]
	return 0;
 c229c9c:	e3a03000 	mov	r3, #0
}
 c229ca0:	e1a00003 	mov	r0, r3
 c229ca4:	e24bd00c 	sub	sp, fp, #12
 c229ca8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229cac:	e12fff1e 	bx	lr
 c229cb0:	01d50008 	.word	0x01d50008

0c229cb4 <tmr_stop>:

int tmr_stop(enum tmr_timer t)
{
 c229cb4:	e1a0c00d 	mov	ip, sp
 c229cb8:	e92dd800 	push	{fp, ip, lr, pc}
 c229cbc:	e24cb004 	sub	fp, ip, #4
 c229cc0:	e24dd010 	sub	sp, sp, #16
 c229cc4:	e1a03000 	mov	r3, r0
 c229cc8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c229ccc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229cd0:	e1a03103 	lsl	r3, r3, #2
 c229cd4:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c229cd8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229cdc:	e3530000 	cmp	r3, #0
 c229ce0:	0a000002 	beq	c229cf0 <tmr_stop+0x3c>
		pos += 4;
 c229ce4:	e51b3010 	ldr	r3, [fp, #-16]
 c229ce8:	e2833004 	add	r3, r3, #4
 c229cec:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c229cf0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229cf4:	e3530005 	cmp	r3, #5
 c229cf8:	9a000001 	bls	c229d04 <tmr_stop+0x50>
		return -1;
 c229cfc:	e3e03000 	mvn	r3, #0
 c229d00:	ea000009 	b	c229d2c <tmr_stop+0x78>

	//COMPLETAR: poner a 0 el bit de start a partir de la posiciÃ³n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON &= ~(1 << pos);
 c229d04:	e59f3030 	ldr	r3, [pc, #48]	; c229d3c <tmr_stop+0x88>
 c229d08:	e59f202c 	ldr	r2, [pc, #44]	; c229d3c <tmr_stop+0x88>
 c229d0c:	e5921000 	ldr	r1, [r2]
 c229d10:	e3a00001 	mov	r0, #1
 c229d14:	e51b2010 	ldr	r2, [fp, #-16]
 c229d18:	e1a02210 	lsl	r2, r0, r2
 c229d1c:	e1e02002 	mvn	r2, r2
 c229d20:	e0012002 	and	r2, r1, r2
 c229d24:	e5832000 	str	r2, [r3]

	return 0;
 c229d28:	e3a03000 	mov	r3, #0
}
 c229d2c:	e1a00003 	mov	r0, r3
 c229d30:	e24bd00c 	sub	sp, fp, #12
 c229d34:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229d38:	e12fff1e 	bx	lr
 c229d3c:	01d50008 	.word	0x01d50008

0c229d40 <tmr_isrunning>:

int tmr_isrunning(enum tmr_timer t)
{
 c229d40:	e1a0c00d 	mov	ip, sp
 c229d44:	e92dd800 	push	{fp, ip, lr, pc}
 c229d48:	e24cb004 	sub	fp, ip, #4
 c229d4c:	e24dd010 	sub	sp, sp, #16
 c229d50:	e1a03000 	mov	r3, r0
 c229d54:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c229d58:	e3a03000 	mov	r3, #0
 c229d5c:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c229d60:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229d64:	e1a03103 	lsl	r3, r3, #2
 c229d68:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c229d6c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229d70:	e3530000 	cmp	r3, #0
 c229d74:	0a000002 	beq	c229d84 <tmr_isrunning+0x44>
		pos += 4;
 c229d78:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229d7c:	e2833004 	add	r3, r3, #4
 c229d80:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if ((t >= 0) && (t <= 5) 
 c229d84:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c229d88:	e3530005 	cmp	r3, #5
 c229d8c:	8a000009 	bhi	c229db8 <tmr_isrunning+0x78>
			&& (rTCON & (0x1 << pos)))
 c229d90:	e59f3034 	ldr	r3, [pc, #52]	; c229dcc <tmr_isrunning+0x8c>
 c229d94:	e5932000 	ldr	r2, [r3]
 c229d98:	e3a01001 	mov	r1, #1
 c229d9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c229da0:	e1a03311 	lsl	r3, r1, r3
 c229da4:	e0023003 	and	r3, r2, r3
 c229da8:	e3530000 	cmp	r3, #0
 c229dac:	0a000001 	beq	c229db8 <tmr_isrunning+0x78>
		ret = 1;
 c229db0:	e3a03001 	mov	r3, #1
 c229db4:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c229db8:	e51b3010 	ldr	r3, [fp, #-16]
}
 c229dbc:	e1a00003 	mov	r0, r3
 c229dc0:	e24bd00c 	sub	sp, fp, #12
 c229dc4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229dc8:	e12fff1e 	bx	lr
 c229dcc:	01d50008 	.word	0x01d50008

0c229dd0 <isr_TS_dummy>:
static uint8 state;

extern void isr_TS_dummy( void ) __attribute__ ((interrupt ("IRQ")));

void isr_TS_dummy( void )
{
 c229dd0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c229dd4:	e1a0c00d 	mov	ip, sp
 c229dd8:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c229ddc:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_EINT2);
 c229de0:	e3a00017 	mov	r0, #23
 c229de4:	ebfff5a2 	bl	c227474 <ic_cleanflag>
}
 c229de8:	e24bd01c 	sub	sp, fp, #28
 c229dec:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c229df0:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c229df4:	e25ef004 	subs	pc, lr, #4

0c229df8 <ts_init>:
static void ts_scan( uint16 *Vx, uint16 *Vy );
static void ts_calibrate( void );
static void ts_sample2coord( uint16 Vx, uint16 Vy, uint16 *x, uint16 *y );

void ts_init( void )
{
 c229df8:	e1a0c00d 	mov	ip, sp
 c229dfc:	e92dd800 	push	{fp, ip, lr, pc}
 c229e00:	e24cb004 	sub	fp, ip, #4
    lcd_init();
 c229e04:	ebfff62d 	bl	c2276c0 <lcd_init>
    adc_init();
 c229e08:	ebffee52 	bl	c225758 <adc_init>

    //Conf PE[7..4] as Output
    rPCONE &= ~(0xff << 8);
 c229e0c:	e59f3070 	ldr	r3, [pc, #112]	; c229e84 <ts_init+0x8c>
 c229e10:	e59f206c 	ldr	r2, [pc, #108]	; c229e84 <ts_init+0x8c>
 c229e14:	e5922000 	ldr	r2, [r2]
 c229e18:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
 c229e1c:	e5832000 	str	r2, [r3]
    rPCONE |= 0b01010101 << 8;
 c229e20:	e59f305c 	ldr	r3, [pc, #92]	; c229e84 <ts_init+0x8c>
 c229e24:	e59f2058 	ldr	r2, [pc, #88]	; c229e84 <ts_init+0x8c>
 c229e28:	e5922000 	ldr	r2, [r2]
 c229e2c:	e3822c55 	orr	r2, r2, #21760	; 0x5500
 c229e30:	e5832000 	str	r2, [r3]

    //Conecta Yâ con GND dejando el resto de terminales abiertos
    //PE[7..4] = 1011
    rPDATE &= ~(0xf << 4);
 c229e34:	e59f304c 	ldr	r3, [pc, #76]	; c229e88 <ts_init+0x90>
 c229e38:	e59f2048 	ldr	r2, [pc, #72]	; c229e88 <ts_init+0x90>
 c229e3c:	e5922000 	ldr	r2, [r2]
 c229e40:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c229e44:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1011 << 4;
 c229e48:	e59f3038 	ldr	r3, [pc, #56]	; c229e88 <ts_init+0x90>
 c229e4c:	e59f2034 	ldr	r2, [pc, #52]	; c229e88 <ts_init+0x90>
 c229e50:	e5922000 	ldr	r2, [r2]
 c229e54:	e38220b0 	orr	r2, r2, #176	; 0xb0
 c229e58:	e5832000 	str	r2, [r3]

    Delay( 1 );
 c229e5c:	e3a00001 	mov	r0, #1
 c229e60:	eb0003c3 	bl	c22ad74 <Delay>
    portG_conf(2, INPUT);
 c229e64:	e3a00002 	mov	r0, #2
 c229e68:	e3a01000 	mov	r1, #0
 c229e6c:	ebfff086 	bl	c22608c <portG_conf>
    //portG_conf_pup(2, ENABLE);

    ts_on();
 c229e70:	eb000005 	bl	c229e8c <ts_on>
    ts_calibrate();
 c229e74:	eb000033 	bl	c229f48 <ts_calibrate>
}
 c229e78:	e24bd00c 	sub	sp, fp, #12
 c229e7c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229e80:	e12fff1e 	bx	lr
 c229e84:	01d20028 	.word	0x01d20028
 c229e88:	01d2002c 	.word	0x01d2002c

0c229e8c <ts_on>:

void ts_on( void )
{
 c229e8c:	e1a0c00d 	mov	ip, sp
 c229e90:	e92dd800 	push	{fp, ip, lr, pc}
 c229e94:	e24cb004 	sub	fp, ip, #4
    adc_on();
 c229e98:	ebffee39 	bl	c225784 <adc_on>
    state = ON;
 c229e9c:	e59f3010 	ldr	r3, [pc, #16]	; c229eb4 <ts_on+0x28>
 c229ea0:	e3a02001 	mov	r2, #1
 c229ea4:	e5c32000 	strb	r2, [r3]
}
 c229ea8:	e24bd00c 	sub	sp, fp, #12
 c229eac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229eb0:	e12fff1e 	bx	lr
 c229eb4:	0c10ba20 	.word	0x0c10ba20

0c229eb8 <ts_off>:

void ts_off( void )
{
 c229eb8:	e1a0c00d 	mov	ip, sp
 c229ebc:	e92dd800 	push	{fp, ip, lr, pc}
 c229ec0:	e24cb004 	sub	fp, ip, #4
    adc_off();
 c229ec4:	ebffee3f 	bl	c2257c8 <adc_off>
    state = OFF;
 c229ec8:	e59f3010 	ldr	r3, [pc, #16]	; c229ee0 <ts_off+0x28>
 c229ecc:	e3a02000 	mov	r2, #0
 c229ed0:	e5c32000 	strb	r2, [r3]
}
 c229ed4:	e24bd00c 	sub	sp, fp, #12
 c229ed8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229edc:	e12fff1e 	bx	lr
 c229ee0:	0c10ba20 	.word	0x0c10ba20

0c229ee4 <ts_status>:

uint8 ts_status( void )
{
 c229ee4:	e1a0c00d 	mov	ip, sp
 c229ee8:	e92dd800 	push	{fp, ip, lr, pc}
 c229eec:	e24cb004 	sub	fp, ip, #4
	return state;
 c229ef0:	e59f3010 	ldr	r3, [pc, #16]	; c229f08 <ts_status+0x24>
 c229ef4:	e5d33000 	ldrb	r3, [r3]
}
 c229ef8:	e1a00003 	mov	r0, r3
 c229efc:	e24bd00c 	sub	sp, fp, #12
 c229f00:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229f04:	e12fff1e 	bx	lr
 c229f08:	0c10ba20 	.word	0x0c10ba20

0c229f0c <ts_pressed>:

uint8 ts_pressed( void )
{
 c229f0c:	e1a0c00d 	mov	ip, sp
 c229f10:	e92dd800 	push	{fp, ip, lr, pc}
 c229f14:	e24cb004 	sub	fp, ip, #4
    return !(rPDATG & (1 << 2));
 c229f18:	e59f3024 	ldr	r3, [pc, #36]	; c229f44 <ts_pressed+0x38>
 c229f1c:	e5933000 	ldr	r3, [r3]
 c229f20:	e2033004 	and	r3, r3, #4
 c229f24:	e3530000 	cmp	r3, #0
 c229f28:	13a03000 	movne	r3, #0
 c229f2c:	03a03001 	moveq	r3, #1
 c229f30:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c229f34:	e1a00003 	mov	r0, r3
 c229f38:	e24bd00c 	sub	sp, fp, #12
 c229f3c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c229f40:	e12fff1e 	bx	lr
 c229f44:	01d20044 	.word	0x01d20044

0c229f48 <ts_calibrate>:

static void ts_calibrate( void )
{
 c229f48:	e1a0c00d 	mov	ip, sp
 c229f4c:	e92dd800 	push	{fp, ip, lr, pc}
 c229f50:	e24cb004 	sub	fp, ip, #4
 c229f54:	e24dd010 	sub	sp, sp, #16
    uint16 x, y;

	uart0_puts("Calibracion pantalla tactil: \n");
 c229f58:	e59f01d4 	ldr	r0, [pc, #468]	; c22a134 <ts_calibrate+0x1ec>
 c229f5c:	eb0001a5 	bl	c22a5f8 <uart0_puts>
    lcd_on();
 c229f60:	ebfff637 	bl	c227844 <lcd_on>
    do {

    	lcd_clear_color(BLACK);
 c229f64:	e3a0000f 	mov	r0, #15
 c229f68:	ebfff674 	bl	c227940 <lcd_clear_color>
    	lcd_draw_box(0, 0, 0 + PX_ERROR, 0 + PX_ERROR, WHITE, 3);
 c229f6c:	e3a03000 	mov	r3, #0
 c229f70:	e58d3000 	str	r3, [sp]
 c229f74:	e3a03003 	mov	r3, #3
 c229f78:	e58d3004 	str	r3, [sp, #4]
 c229f7c:	e3a00000 	mov	r0, #0
 c229f80:	e3a01000 	mov	r1, #0
 c229f84:	e3a02005 	mov	r2, #5
 c229f88:	e3a03005 	mov	r3, #5
 c229f8c:	ebfff74c 	bl	c227cc4 <lcd_draw_box>
    	uart0_puts("Pulse el punto en la esquina superior izquierda...");
 c229f90:	e59f01a0 	ldr	r0, [pc, #416]	; c22a138 <ts_calibrate+0x1f0>
 c229f94:	eb000197 	bl	c22a5f8 <uart0_puts>

    	while(rPDATG & (1 << 2));
 c229f98:	e1a00000 	nop			; (mov r0, r0)
 c229f9c:	e59f3198 	ldr	r3, [pc, #408]	; c22a13c <ts_calibrate+0x1f4>
 c229fa0:	e5933000 	ldr	r3, [r3]
 c229fa4:	e2033004 	and	r3, r3, #4
 c229fa8:	e3530000 	cmp	r3, #0
 c229fac:	1afffffa 	bne	c229f9c <ts_calibrate+0x54>
        Delay( TS_DOWN_DELAY );
 c229fb0:	e3a00064 	mov	r0, #100	; 0x64
 c229fb4:	eb00036e 	bl	c22ad74 <Delay>
        ts_scan( &Vxmin, &Vymax );
 c229fb8:	e59f0180 	ldr	r0, [pc, #384]	; c22a140 <ts_calibrate+0x1f8>
 c229fbc:	e59f1180 	ldr	r1, [pc, #384]	; c22a144 <ts_calibrate+0x1fc>
 c229fc0:	eb000091 	bl	c22a20c <ts_scan>
    	while(!(rPDATG & (1 << 2)));
 c229fc4:	e1a00000 	nop			; (mov r0, r0)
 c229fc8:	e59f316c 	ldr	r3, [pc, #364]	; c22a13c <ts_calibrate+0x1f4>
 c229fcc:	e5933000 	ldr	r3, [r3]
 c229fd0:	e2033004 	and	r3, r3, #4
 c229fd4:	e3530000 	cmp	r3, #0
 c229fd8:	0afffffa 	beq	c229fc8 <ts_calibrate+0x80>
        Delay( TS_UP_DELAY );
 c229fdc:	e3a000c8 	mov	r0, #200	; 0xc8
 c229fe0:	eb000363 	bl	c22ad74 <Delay>

    	uart0_puts(" Ok\n");
 c229fe4:	e59f015c 	ldr	r0, [pc, #348]	; c22a148 <ts_calibrate+0x200>
 c229fe8:	eb000182 	bl	c22a5f8 <uart0_puts>

    	lcd_clear_color(BLACK);
 c229fec:	e3a0000f 	mov	r0, #15
 c229ff0:	ebfff652 	bl	c227940 <lcd_clear_color>
    	lcd_draw_box(LCD_WIDTH - 1 - PX_ERROR, LCD_HEIGHT - 1 - PX_ERROR, LCD_WIDTH - 1, LCD_HEIGHT - 1, WHITE, 3);
 c229ff4:	e3a03000 	mov	r3, #0
 c229ff8:	e58d3000 	str	r3, [sp]
 c229ffc:	e3a03003 	mov	r3, #3
 c22a000:	e58d3004 	str	r3, [sp, #4]
 c22a004:	e59f0140 	ldr	r0, [pc, #320]	; c22a14c <ts_calibrate+0x204>
 c22a008:	e3a010ea 	mov	r1, #234	; 0xea
 c22a00c:	e59f213c 	ldr	r2, [pc, #316]	; c22a150 <ts_calibrate+0x208>
 c22a010:	e3a030ef 	mov	r3, #239	; 0xef
 c22a014:	ebfff72a 	bl	c227cc4 <lcd_draw_box>
    	uart0_puts("Pulse el punto en la esquina inferior derecha...");
 c22a018:	e59f0134 	ldr	r0, [pc, #308]	; c22a154 <ts_calibrate+0x20c>
 c22a01c:	eb000175 	bl	c22a5f8 <uart0_puts>

    	while(rPDATG & (1 << 2));
 c22a020:	e1a00000 	nop			; (mov r0, r0)
 c22a024:	e59f3110 	ldr	r3, [pc, #272]	; c22a13c <ts_calibrate+0x1f4>
 c22a028:	e5933000 	ldr	r3, [r3]
 c22a02c:	e2033004 	and	r3, r3, #4
 c22a030:	e3530000 	cmp	r3, #0
 c22a034:	1afffffa 	bne	c22a024 <ts_calibrate+0xdc>
        Delay( TS_DOWN_DELAY );
 c22a038:	e3a00064 	mov	r0, #100	; 0x64
 c22a03c:	eb00034c 	bl	c22ad74 <Delay>
        ts_scan( &Vxmax, &Vymin );
 c22a040:	e59f0110 	ldr	r0, [pc, #272]	; c22a158 <ts_calibrate+0x210>
 c22a044:	e59f1110 	ldr	r1, [pc, #272]	; c22a15c <ts_calibrate+0x214>
 c22a048:	eb00006f 	bl	c22a20c <ts_scan>
    	while(!(rPDATG & (1 << 2)));
 c22a04c:	e1a00000 	nop			; (mov r0, r0)
 c22a050:	e59f30e4 	ldr	r3, [pc, #228]	; c22a13c <ts_calibrate+0x1f4>
 c22a054:	e5933000 	ldr	r3, [r3]
 c22a058:	e2033004 	and	r3, r3, #4
 c22a05c:	e3530000 	cmp	r3, #0
 c22a060:	0afffffa 	beq	c22a050 <ts_calibrate+0x108>
        Delay( TS_UP_DELAY );
 c22a064:	e3a000c8 	mov	r0, #200	; 0xc8
 c22a068:	eb000341 	bl	c22ad74 <Delay>

        uart0_puts(" Ok\n");
 c22a06c:	e59f00d4 	ldr	r0, [pc, #212]	; c22a148 <ts_calibrate+0x200>
 c22a070:	eb000160 	bl	c22a5f8 <uart0_puts>

    	lcd_clear_color(BLACK);
 c22a074:	e3a0000f 	mov	r0, #15
 c22a078:	ebfff630 	bl	c227940 <lcd_clear_color>
    	lcd_draw_box(LCD_WIDTH/2 - PX_ERROR / 2, LCD_HEIGHT/2 - PX_ERROR / 2, LCD_WIDTH/2 + PX_ERROR / 2, LCD_HEIGHT/2 + PX_ERROR / 2, WHITE, 3);
 c22a07c:	e3a03000 	mov	r3, #0
 c22a080:	e58d3000 	str	r3, [sp]
 c22a084:	e3a03003 	mov	r3, #3
 c22a088:	e58d3004 	str	r3, [sp, #4]
 c22a08c:	e3a0009e 	mov	r0, #158	; 0x9e
 c22a090:	e3a01076 	mov	r1, #118	; 0x76
 c22a094:	e3a020a2 	mov	r2, #162	; 0xa2
 c22a098:	e3a0307a 	mov	r3, #122	; 0x7a
 c22a09c:	ebfff708 	bl	c227cc4 <lcd_draw_box>

    	uart0_puts("Pulse el punto en el centro...");
 c22a0a0:	e59f00b8 	ldr	r0, [pc, #184]	; c22a160 <ts_calibrate+0x218>
 c22a0a4:	eb000153 	bl	c22a5f8 <uart0_puts>

        ts_getpos( &x, &y );
 c22a0a8:	e24b200e 	sub	r2, fp, #14
 c22a0ac:	e24b3010 	sub	r3, fp, #16
 c22a0b0:	e1a00002 	mov	r0, r2
 c22a0b4:	e1a01003 	mov	r1, r3
 c22a0b8:	eb00002d 	bl	c22a174 <ts_getpos>

    	uart0_puts("X: ");
 c22a0bc:	e59f00a0 	ldr	r0, [pc, #160]	; c22a164 <ts_calibrate+0x21c>
 c22a0c0:	eb00014c 	bl	c22a5f8 <uart0_puts>
    	uart0_putint(x);
 c22a0c4:	e15b30be 	ldrh	r3, [fp, #-14]
 c22a0c8:	e1a00003 	mov	r0, r3
 c22a0cc:	eb00015d 	bl	c22a648 <uart0_putint>
    	uart0_puts(", Y: ");
 c22a0d0:	e59f0090 	ldr	r0, [pc, #144]	; c22a168 <ts_calibrate+0x220>
 c22a0d4:	eb000147 	bl	c22a5f8 <uart0_puts>
    	uart0_putint(y);
 c22a0d8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c22a0dc:	e1a00003 	mov	r0, r3
 c22a0e0:	eb000158 	bl	c22a648 <uart0_putint>
    	uart0_puts("\n");
 c22a0e4:	e59f0080 	ldr	r0, [pc, #128]	; c22a16c <ts_calibrate+0x224>
 c22a0e8:	eb000142 	bl	c22a5f8 <uart0_puts>

    } while( (x > LCD_WIDTH/2+PX_ERROR) || (x < LCD_WIDTH/2-PX_ERROR) || (y > LCD_HEIGHT/2+PX_ERROR) || (y < LCD_HEIGHT/2-PX_ERROR) );
 c22a0ec:	e15b30be 	ldrh	r3, [fp, #-14]
 c22a0f0:	e35300a5 	cmp	r3, #165	; 0xa5
 c22a0f4:	8affff9a 	bhi	c229f64 <ts_calibrate+0x1c>
 c22a0f8:	e15b30be 	ldrh	r3, [fp, #-14]
 c22a0fc:	e353009a 	cmp	r3, #154	; 0x9a
 c22a100:	9affff97 	bls	c229f64 <ts_calibrate+0x1c>
 c22a104:	e15b31b0 	ldrh	r3, [fp, #-16]
 c22a108:	e353007d 	cmp	r3, #125	; 0x7d
 c22a10c:	8affff94 	bhi	c229f64 <ts_calibrate+0x1c>
 c22a110:	e15b31b0 	ldrh	r3, [fp, #-16]
 c22a114:	e3530072 	cmp	r3, #114	; 0x72
 c22a118:	9affff91 	bls	c229f64 <ts_calibrate+0x1c>

    uart0_puts("Calibracion completada\n");
 c22a11c:	e59f004c 	ldr	r0, [pc, #76]	; c22a170 <ts_calibrate+0x228>
 c22a120:	eb000134 	bl	c22a5f8 <uart0_puts>
    lcd_clear();
 c22a124:	ebfff5ee 	bl	c2278e4 <lcd_clear>
}
 c22a128:	e24bd00c 	sub	sp, fp, #12
 c22a12c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a130:	e12fff1e 	bx	lr
 c22a134:	0c102280 	.word	0x0c102280
 c22a138:	0c1022a0 	.word	0x0c1022a0
 c22a13c:	01d20044 	.word	0x01d20044
 c22a140:	0c10ba18 	.word	0x0c10ba18
 c22a144:	0c10ba1e 	.word	0x0c10ba1e
 c22a148:	0c1022d4 	.word	0x0c1022d4
 c22a14c:	0000013a 	.word	0x0000013a
 c22a150:	0000013f 	.word	0x0000013f
 c22a154:	0c1022dc 	.word	0x0c1022dc
 c22a158:	0c10ba1a 	.word	0x0c10ba1a
 c22a15c:	0c10ba1c 	.word	0x0c10ba1c
 c22a160:	0c102310 	.word	0x0c102310
 c22a164:	0c102330 	.word	0x0c102330
 c22a168:	0c102334 	.word	0x0c102334
 c22a16c:	0c10233c 	.word	0x0c10233c
 c22a170:	0c102340 	.word	0x0c102340

0c22a174 <ts_getpos>:

void ts_getpos( uint16 *x, uint16 *y )
{
 c22a174:	e1a0c00d 	mov	ip, sp
 c22a178:	e92dd800 	push	{fp, ip, lr, pc}
 c22a17c:	e24cb004 	sub	fp, ip, #4
 c22a180:	e24dd010 	sub	sp, sp, #16
 c22a184:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c22a188:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
	uint16 Vx, Vy;

	//Esperar a que PG[2]=0
	while(rPDATG & (1 << 2));
 c22a18c:	e1a00000 	nop			; (mov r0, r0)
 c22a190:	e59f3070 	ldr	r3, [pc, #112]	; c22a208 <ts_getpos+0x94>
 c22a194:	e5933000 	ldr	r3, [r3]
 c22a198:	e2033004 	and	r3, r3, #4
 c22a19c:	e3530000 	cmp	r3, #0
 c22a1a0:	1afffffa 	bne	c22a190 <ts_getpos+0x1c>

	//Esperar TS_DOWN_DELAY
	Delay(TS_DOWN_DELAY);
 c22a1a4:	e3a00064 	mov	r0, #100	; 0x64
 c22a1a8:	eb0002f1 	bl	c22ad74 <Delay>

	ts_scan(&Vx, &Vy);
 c22a1ac:	e24b200e 	sub	r2, fp, #14
 c22a1b0:	e24b3010 	sub	r3, fp, #16
 c22a1b4:	e1a00002 	mov	r0, r2
 c22a1b8:	e1a01003 	mov	r1, r3
 c22a1bc:	eb000012 	bl	c22a20c <ts_scan>
	ts_sample2coord(Vx, Vy, x, y);
 c22a1c0:	e15b20be 	ldrh	r2, [fp, #-14]
 c22a1c4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c22a1c8:	e1a00002 	mov	r0, r2
 c22a1cc:	e1a01003 	mov	r1, r3
 c22a1d0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c22a1d4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c22a1d8:	eb000041 	bl	c22a2e4 <ts_sample2coord>

	//Esperar a que PG[2]=1
	while(!(rPDATG & (1 << 2)));
 c22a1dc:	e1a00000 	nop			; (mov r0, r0)
 c22a1e0:	e59f3020 	ldr	r3, [pc, #32]	; c22a208 <ts_getpos+0x94>
 c22a1e4:	e5933000 	ldr	r3, [r3]
 c22a1e8:	e2033004 	and	r3, r3, #4
 c22a1ec:	e3530000 	cmp	r3, #0
 c22a1f0:	0afffffa 	beq	c22a1e0 <ts_getpos+0x6c>

	//Esperar TS_UP_DELAY
	Delay(TS_UP_DELAY);
 c22a1f4:	e3a000c8 	mov	r0, #200	; 0xc8
 c22a1f8:	eb0002dd 	bl	c22ad74 <Delay>
}
 c22a1fc:	e24bd00c 	sub	sp, fp, #12
 c22a200:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a204:	e12fff1e 	bx	lr
 c22a208:	01d20044 	.word	0x01d20044

0c22a20c <ts_scan>:

static void ts_scan( uint16 *Vx, uint16 *Vy )
{
 c22a20c:	e1a0c00d 	mov	ip, sp
 c22a210:	e92dd800 	push	{fp, ip, lr, pc}
 c22a214:	e24cb004 	sub	fp, ip, #4
 c22a218:	e24dd008 	sub	sp, sp, #8
 c22a21c:	e50b0010 	str	r0, [fp, #-16]
 c22a220:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	//PE[7..4] = (0,1,1,0)
    rPDATE &= ~(0xf << 4);
 c22a224:	e59f30b4 	ldr	r3, [pc, #180]	; c22a2e0 <ts_scan+0xd4>
 c22a228:	e59f20b0 	ldr	r2, [pc, #176]	; c22a2e0 <ts_scan+0xd4>
 c22a22c:	e5922000 	ldr	r2, [r2]
 c22a230:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c22a234:	e5832000 	str	r2, [r3]
    rPDATE |= 0b0110 << 4;
 c22a238:	e59f30a0 	ldr	r3, [pc, #160]	; c22a2e0 <ts_scan+0xd4>
 c22a23c:	e59f209c 	ldr	r2, [pc, #156]	; c22a2e0 <ts_scan+0xd4>
 c22a240:	e5922000 	ldr	r2, [r2]
 c22a244:	e3822060 	orr	r2, r2, #96	; 0x60
 c22a248:	e5832000 	str	r2, [r3]

    //leer Vx por canal AIN1

    *Vx = adc_getSample( ADC_AIN1 );
 c22a24c:	e3a00001 	mov	r0, #1
 c22a250:	ebffed75 	bl	c22582c <adc_getSample>
 c22a254:	e1a03000 	mov	r3, r0
 c22a258:	e1a02003 	mov	r2, r3
 c22a25c:	e51b3010 	ldr	r3, [fp, #-16]
 c22a260:	e1c320b0 	strh	r2, [r3]

	//PE[7..4] = (1,0,0,1)
    rPDATE &= ~(0xf << 4);
 c22a264:	e59f3074 	ldr	r3, [pc, #116]	; c22a2e0 <ts_scan+0xd4>
 c22a268:	e59f2070 	ldr	r2, [pc, #112]	; c22a2e0 <ts_scan+0xd4>
 c22a26c:	e5922000 	ldr	r2, [r2]
 c22a270:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c22a274:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1001 << 4;
 c22a278:	e59f3060 	ldr	r3, [pc, #96]	; c22a2e0 <ts_scan+0xd4>
 c22a27c:	e59f205c 	ldr	r2, [pc, #92]	; c22a2e0 <ts_scan+0xd4>
 c22a280:	e5922000 	ldr	r2, [r2]
 c22a284:	e3822090 	orr	r2, r2, #144	; 0x90
 c22a288:	e5832000 	str	r2, [r3]

    //leer Vy por canal AIN0

    *Vy = adc_getSample( ADC_AIN0 );
 c22a28c:	e3a00000 	mov	r0, #0
 c22a290:	ebffed65 	bl	c22582c <adc_getSample>
 c22a294:	e1a03000 	mov	r3, r0
 c22a298:	e1a02003 	mov	r2, r3
 c22a29c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a2a0:	e1c320b0 	strh	r2, [r3]

	//PE[7..4] = (1,0,1,1)
    rPDATE &= ~(0xf << 4);
 c22a2a4:	e59f3034 	ldr	r3, [pc, #52]	; c22a2e0 <ts_scan+0xd4>
 c22a2a8:	e59f2030 	ldr	r2, [pc, #48]	; c22a2e0 <ts_scan+0xd4>
 c22a2ac:	e5922000 	ldr	r2, [r2]
 c22a2b0:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c22a2b4:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1011 << 4;
 c22a2b8:	e59f3020 	ldr	r3, [pc, #32]	; c22a2e0 <ts_scan+0xd4>
 c22a2bc:	e59f201c 	ldr	r2, [pc, #28]	; c22a2e0 <ts_scan+0xd4>
 c22a2c0:	e5922000 	ldr	r2, [r2]
 c22a2c4:	e38220b0 	orr	r2, r2, #176	; 0xb0
 c22a2c8:	e5832000 	str	r2, [r3]

    Delay(1);
 c22a2cc:	e3a00001 	mov	r0, #1
 c22a2d0:	eb0002a7 	bl	c22ad74 <Delay>
}
 c22a2d4:	e24bd00c 	sub	sp, fp, #12
 c22a2d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a2dc:	e12fff1e 	bx	lr
 c22a2e0:	01d2002c 	.word	0x01d2002c

0c22a2e4 <ts_sample2coord>:

static void ts_sample2coord( uint16 Vx, uint16 Vy, uint16 *x, uint16 *y )
{
 c22a2e4:	e1a0c00d 	mov	ip, sp
 c22a2e8:	e92dd800 	push	{fp, ip, lr, pc}
 c22a2ec:	e24cb004 	sub	fp, ip, #4
 c22a2f0:	e24dd010 	sub	sp, sp, #16
 c22a2f4:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
 c22a2f8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c22a2fc:	e14b00be 	strh	r0, [fp, #-14]
 c22a300:	e14b11b0 	strh	r1, [fp, #-16]
	//Interpolate Vx
    if( Vx < Vxmin )
 c22a304:	e59f3168 	ldr	r3, [pc, #360]	; c22a474 <ts_sample2coord+0x190>
 c22a308:	e1d330b0 	ldrh	r3, [r3]
 c22a30c:	e15b20be 	ldrh	r2, [fp, #-14]
 c22a310:	e1520003 	cmp	r2, r3
 c22a314:	2a000003 	bcs	c22a328 <ts_sample2coord+0x44>
        *x = 0;
 c22a318:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a31c:	e3a02000 	mov	r2, #0
 c22a320:	e1c320b0 	strh	r2, [r3]
 c22a324:	ea00001f 	b	c22a3a8 <ts_sample2coord+0xc4>
    else if( Vx > Vxmax )
 c22a328:	e59f3148 	ldr	r3, [pc, #328]	; c22a478 <ts_sample2coord+0x194>
 c22a32c:	e1d330b0 	ldrh	r3, [r3]
 c22a330:	e15b20be 	ldrh	r2, [fp, #-14]
 c22a334:	e1520003 	cmp	r2, r3
 c22a338:	9a000003 	bls	c22a34c <ts_sample2coord+0x68>
        *x = LCD_WIDTH-1;
 c22a33c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a340:	e59f2134 	ldr	r2, [pc, #308]	; c22a47c <ts_sample2coord+0x198>
 c22a344:	e1c320b0 	strh	r2, [r3]
 c22a348:	ea000016 	b	c22a3a8 <ts_sample2coord+0xc4>
    else
        *x = LCD_WIDTH*(Vx-Vxmin) / (Vxmax-Vxmin);
 c22a34c:	e15b20be 	ldrh	r2, [fp, #-14]
 c22a350:	e59f311c 	ldr	r3, [pc, #284]	; c22a474 <ts_sample2coord+0x190>
 c22a354:	e1d330b0 	ldrh	r3, [r3]
 c22a358:	e0632002 	rsb	r2, r3, r2
 c22a35c:	e1a03002 	mov	r3, r2
 c22a360:	e1a03103 	lsl	r3, r3, #2
 c22a364:	e0833002 	add	r3, r3, r2
 c22a368:	e1a03303 	lsl	r3, r3, #6
 c22a36c:	e1a02003 	mov	r2, r3
 c22a370:	e59f3100 	ldr	r3, [pc, #256]	; c22a478 <ts_sample2coord+0x194>
 c22a374:	e1d330b0 	ldrh	r3, [r3]
 c22a378:	e1a01003 	mov	r1, r3
 c22a37c:	e59f30f0 	ldr	r3, [pc, #240]	; c22a474 <ts_sample2coord+0x190>
 c22a380:	e1d330b0 	ldrh	r3, [r3]
 c22a384:	e0633001 	rsb	r3, r3, r1
 c22a388:	e1a00002 	mov	r0, r2
 c22a38c:	e1a01003 	mov	r1, r3
 c22a390:	eb000316 	bl	c22aff0 <__aeabi_idiv>
 c22a394:	e1a03000 	mov	r3, r0
 c22a398:	e1a03803 	lsl	r3, r3, #16
 c22a39c:	e1a02823 	lsr	r2, r3, #16
 c22a3a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a3a4:	e1c320b0 	strh	r2, [r3]

    //Interpolate Vy
    if( Vy < Vymin )
 c22a3a8:	e59f30d0 	ldr	r3, [pc, #208]	; c22a480 <ts_sample2coord+0x19c>
 c22a3ac:	e1d330b0 	ldrh	r3, [r3]
 c22a3b0:	e15b21b0 	ldrh	r2, [fp, #-16]
 c22a3b4:	e1520003 	cmp	r2, r3
 c22a3b8:	2a000003 	bcs	c22a3cc <ts_sample2coord+0xe8>
        *y = 0;
 c22a3bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a3c0:	e3a02000 	mov	r2, #0
 c22a3c4:	e1c320b0 	strh	r2, [r3]
 c22a3c8:	ea00001f 	b	c22a44c <ts_sample2coord+0x168>
    else if( Vy > Vymax )
 c22a3cc:	e59f30b0 	ldr	r3, [pc, #176]	; c22a484 <ts_sample2coord+0x1a0>
 c22a3d0:	e1d330b0 	ldrh	r3, [r3]
 c22a3d4:	e15b21b0 	ldrh	r2, [fp, #-16]
 c22a3d8:	e1520003 	cmp	r2, r3
 c22a3dc:	9a000003 	bls	c22a3f0 <ts_sample2coord+0x10c>
        *y = LCD_HEIGHT-1;
 c22a3e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a3e4:	e3a020ef 	mov	r2, #239	; 0xef
 c22a3e8:	e1c320b0 	strh	r2, [r3]
 c22a3ec:	ea000016 	b	c22a44c <ts_sample2coord+0x168>
    else
        *y = LCD_HEIGHT*(Vy-Vymin) / (Vymax-Vymin);
 c22a3f0:	e15b21b0 	ldrh	r2, [fp, #-16]
 c22a3f4:	e59f3084 	ldr	r3, [pc, #132]	; c22a480 <ts_sample2coord+0x19c>
 c22a3f8:	e1d330b0 	ldrh	r3, [r3]
 c22a3fc:	e0632002 	rsb	r2, r3, r2
 c22a400:	e1a03002 	mov	r3, r2
 c22a404:	e1a03203 	lsl	r3, r3, #4
 c22a408:	e0623003 	rsb	r3, r2, r3
 c22a40c:	e1a03203 	lsl	r3, r3, #4
 c22a410:	e1a02003 	mov	r2, r3
 c22a414:	e59f3068 	ldr	r3, [pc, #104]	; c22a484 <ts_sample2coord+0x1a0>
 c22a418:	e1d330b0 	ldrh	r3, [r3]
 c22a41c:	e1a01003 	mov	r1, r3
 c22a420:	e59f3058 	ldr	r3, [pc, #88]	; c22a480 <ts_sample2coord+0x19c>
 c22a424:	e1d330b0 	ldrh	r3, [r3]
 c22a428:	e0633001 	rsb	r3, r3, r1
 c22a42c:	e1a00002 	mov	r0, r2
 c22a430:	e1a01003 	mov	r1, r3
 c22a434:	eb0002ed 	bl	c22aff0 <__aeabi_idiv>
 c22a438:	e1a03000 	mov	r3, r0
 c22a43c:	e1a03803 	lsl	r3, r3, #16
 c22a440:	e1a02823 	lsr	r2, r3, #16
 c22a444:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a448:	e1c320b0 	strh	r2, [r3]

    //Vy crece cuando y decrece
    *y = LCD_HEIGHT - *y;
 c22a44c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a450:	e1d330b0 	ldrh	r3, [r3]
 c22a454:	e26330f0 	rsb	r3, r3, #240	; 0xf0
 c22a458:	e1a03803 	lsl	r3, r3, #16
 c22a45c:	e1a02823 	lsr	r2, r3, #16
 c22a460:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a464:	e1c320b0 	strh	r2, [r3]
}
 c22a468:	e24bd00c 	sub	sp, fp, #12
 c22a46c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a470:	e12fff1e 	bx	lr
 c22a474:	0c10ba18 	.word	0x0c10ba18
 c22a478:	0c10ba1a 	.word	0x0c10ba1a
 c22a47c:	0000013f 	.word	0x0000013f
 c22a480:	0c10ba1c 	.word	0x0c10ba1c
 c22a484:	0c10ba1e 	.word	0x0c10ba1e

0c22a488 <ts_open>:

void ts_open( void (*isr)(void) )
{
 c22a488:	e1a0c00d 	mov	ip, sp
 c22a48c:	e92dd800 	push	{fp, ip, lr, pc}
 c22a490:	e24cb004 	sub	fp, ip, #4
 c22a494:	e24dd008 	sub	sp, sp, #8
 c22a498:	e50b0010 	str	r0, [fp, #-16]
	pISR_EINT2 = (unsigned) isr;
 c22a49c:	e59f3020 	ldr	r3, [pc, #32]	; c22a4c4 <ts_open+0x3c>
 c22a4a0:	e51b2010 	ldr	r2, [fp, #-16]
 c22a4a4:	e5832000 	str	r2, [r3]
	ic_cleanflag(INT_EINT2);
 c22a4a8:	e3a00017 	mov	r0, #23
 c22a4ac:	ebfff3f0 	bl	c227474 <ic_cleanflag>
	ic_enable(INT_EINT2);
 c22a4b0:	e3a00017 	mov	r0, #23
 c22a4b4:	ebfff3bb 	bl	c2273a8 <ic_enable>
}
 c22a4b8:	e24bd00c 	sub	sp, fp, #12
 c22a4bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a4c0:	e12fff1e 	bx	lr
 c22a4c4:	0c7fff7c 	.word	0x0c7fff7c

0c22a4c8 <ts_close>:

void ts_close( void )
{
 c22a4c8:	e1a0c00d 	mov	ip, sp
 c22a4cc:	e92dd800 	push	{fp, ip, lr, pc}
 c22a4d0:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_EINT2);
 c22a4d4:	e3a00017 	mov	r0, #23
 c22a4d8:	ebfff3cc 	bl	c227410 <ic_disable>
    pISR_EINT2 = (unsigned) isr_TS_dummy;
 c22a4dc:	e59f3010 	ldr	r3, [pc, #16]	; c22a4f4 <ts_close+0x2c>
 c22a4e0:	e59f2010 	ldr	r2, [pc, #16]	; c22a4f8 <ts_close+0x30>
 c22a4e4:	e5832000 	str	r2, [r3]
}
 c22a4e8:	e24bd00c 	sub	sp, fp, #12
 c22a4ec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a4f0:	e12fff1e 	bx	lr
 c22a4f4:	0c7fff7c 	.word	0x0c7fff7c
 c22a4f8:	0c229dd0 	.word	0x0c229dd0

0c22a4fc <uart0_init>:
#include "uart.h"
#include "44b.h"

void uart0_init( void )
{
 c22a4fc:	e1a0c00d 	mov	ip, sp
 c22a500:	e92dd800 	push	{fp, ip, lr, pc}
 c22a504:	e24cb004 	sub	fp, ip, #4
	//*Enable FIFO, Rx normal, Tx normal
	//UFCON0[0] = 1
	//UFCON0[1] = 0  Rx FIFO normal (no reset)
	//UFCON0[2] = 0  Rx FIFO normal (no reset)
    rUFCON0 = 0x1;
 c22a508:	e59f3040 	ldr	r3, [pc, #64]	; c22a550 <uart0_init+0x54>
 c22a50c:	e3a02001 	mov	r2, #1
 c22a510:	e5832000 	str	r2, [r3]

    //Disable Auto Flow Control and disable Request to Send
    //UMCON0[4] = 0
    rUMCON0 = 0x0;
 c22a514:	e59f3038 	ldr	r3, [pc, #56]	; c22a554 <uart0_init+0x58>
 c22a518:	e3a02000 	mov	r2, #0
 c22a51c:	e5832000 	str	r2, [r3]
    //* Formato de la trama:
    //ULCON0[6]   = 0  normal (no infrarrojos)
    //ULCON0[5:3] = 0  sin paridad
    //ULCON0[2]   = 0  1 bit de stop
    //ULCON0[1:0] = 3  8 bits de datos
    rULCON0 = 0x3;
 c22a520:	e3a0361d 	mov	r3, #30408704	; 0x1d00000
 c22a524:	e3a02003 	mov	r2, #3
 c22a528:	e5832000 	str	r2, [r3]

    //* 115200 Baudios
    //UBRDIV0 = 34  64MHz / (115200 Ã 16) â 1
    rUBRDIV0 = 34;
 c22a52c:	e59f3024 	ldr	r3, [pc, #36]	; c22a558 <uart0_init+0x5c>
 c22a530:	e3a02022 	mov	r2, #34	; 0x22
 c22a534:	e5832000 	str	r2, [r3]

    //UCON0[1:0] = 1  Rx: polling/interrupt mode
    //UCON0[3:2] = 1  Tx: polling/interrupt mode
    //UCON0[4]   = 0  no break
    //UCON0[5]   = 0  no loopback
    rUCON0 = 0x5;
 c22a538:	e59f301c 	ldr	r3, [pc, #28]	; c22a55c <uart0_init+0x60>
 c22a53c:	e3a02005 	mov	r2, #5
 c22a540:	e5832000 	str	r2, [r3]
}
 c22a544:	e24bd00c 	sub	sp, fp, #12
 c22a548:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a54c:	e12fff1e 	bx	lr
 c22a550:	01d00008 	.word	0x01d00008
 c22a554:	01d0000c 	.word	0x01d0000c
 c22a558:	01d00028 	.word	0x01d00028
 c22a55c:	01d00004 	.word	0x01d00004

0c22a560 <uart0_putchar>:

void uart0_putchar( char ch )
{
 c22a560:	e1a0c00d 	mov	ip, sp
 c22a564:	e92dd800 	push	{fp, ip, lr, pc}
 c22a568:	e24cb004 	sub	fp, ip, #4
 c22a56c:	e24dd008 	sub	sp, sp, #8
 c22a570:	e1a03000 	mov	r3, r0
 c22a574:	e54b300d 	strb	r3, [fp, #-13]
	//While FIFO is full wait (while UFSTAT0[9] == 1)
    while( rUFSTAT0 & (1 << 9) );
 c22a578:	e1a00000 	nop			; (mov r0, r0)
 c22a57c:	e59f3024 	ldr	r3, [pc, #36]	; c22a5a8 <uart0_putchar+0x48>
 c22a580:	e5933000 	ldr	r3, [r3]
 c22a584:	e2033c02 	and	r3, r3, #512	; 0x200
 c22a588:	e3530000 	cmp	r3, #0
 c22a58c:	1afffffa 	bne	c22a57c <uart0_putchar+0x1c>
    rUTXH0 = ch;
 c22a590:	e59f3014 	ldr	r3, [pc, #20]	; c22a5ac <uart0_putchar+0x4c>
 c22a594:	e55b200d 	ldrb	r2, [fp, #-13]
 c22a598:	e5c32000 	strb	r2, [r3]
}
 c22a59c:	e24bd00c 	sub	sp, fp, #12
 c22a5a0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a5a4:	e12fff1e 	bx	lr
 c22a5a8:	01d00018 	.word	0x01d00018
 c22a5ac:	01d00020 	.word	0x01d00020

0c22a5b0 <uart0_getchar>:

char uart0_getchar( void )
{
 c22a5b0:	e1a0c00d 	mov	ip, sp
 c22a5b4:	e92dd800 	push	{fp, ip, lr, pc}
 c22a5b8:	e24cb004 	sub	fp, ip, #4
	//While FIFO is empty wait (while UFSTAT0[3:0] == 0)
    while( (rUFSTAT0 & 0b1111) == 0 );
 c22a5bc:	e1a00000 	nop			; (mov r0, r0)
 c22a5c0:	e59f3028 	ldr	r3, [pc, #40]	; c22a5f0 <uart0_getchar+0x40>
 c22a5c4:	e5933000 	ldr	r3, [r3]
 c22a5c8:	e203300f 	and	r3, r3, #15
 c22a5cc:	e3530000 	cmp	r3, #0
 c22a5d0:	0afffffa 	beq	c22a5c0 <uart0_getchar+0x10>

    //Read URXH0
    return rURXH0;
 c22a5d4:	e59f3018 	ldr	r3, [pc, #24]	; c22a5f4 <uart0_getchar+0x44>
 c22a5d8:	e5d33000 	ldrb	r3, [r3]
 c22a5dc:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c22a5e0:	e1a00003 	mov	r0, r3
 c22a5e4:	e24bd00c 	sub	sp, fp, #12
 c22a5e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a5ec:	e12fff1e 	bx	lr
 c22a5f0:	01d00018 	.word	0x01d00018
 c22a5f4:	01d00024 	.word	0x01d00024

0c22a5f8 <uart0_puts>:

void uart0_puts( char *s )
{
 c22a5f8:	e1a0c00d 	mov	ip, sp
 c22a5fc:	e92dd800 	push	{fp, ip, lr, pc}
 c22a600:	e24cb004 	sub	fp, ip, #4
 c22a604:	e24dd008 	sub	sp, sp, #8
 c22a608:	e50b0010 	str	r0, [fp, #-16]
    while(*s) {
 c22a60c:	ea000006 	b	c22a62c <uart0_puts+0x34>
    	uart0_putchar(*s);
 c22a610:	e51b3010 	ldr	r3, [fp, #-16]
 c22a614:	e5d33000 	ldrb	r3, [r3]
 c22a618:	e1a00003 	mov	r0, r3
 c22a61c:	ebffffcf 	bl	c22a560 <uart0_putchar>
    	s++;
 c22a620:	e51b3010 	ldr	r3, [fp, #-16]
 c22a624:	e2833001 	add	r3, r3, #1
 c22a628:	e50b3010 	str	r3, [fp, #-16]
    return rURXH0;
}

void uart0_puts( char *s )
{
    while(*s) {
 c22a62c:	e51b3010 	ldr	r3, [fp, #-16]
 c22a630:	e5d33000 	ldrb	r3, [r3]
 c22a634:	e3530000 	cmp	r3, #0
 c22a638:	1afffff4 	bne	c22a610 <uart0_puts+0x18>
    	uart0_putchar(*s);
    	s++;
    }
}
 c22a63c:	e24bd00c 	sub	sp, fp, #12
 c22a640:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a644:	e12fff1e 	bx	lr

0c22a648 <uart0_putint>:

void uart0_putint( int32 i )
{
 c22a648:	e1a0c00d 	mov	ip, sp
 c22a64c:	e92dd800 	push	{fp, ip, lr, pc}
 c22a650:	e24cb004 	sub	fp, ip, #4
 c22a654:	e24dd020 	sub	sp, sp, #32
 c22a658:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
	char s[11 + 1];
	int negative = i < 0;
 c22a65c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c22a660:	e1a03fa3 	lsr	r3, r3, #31
 c22a664:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	char* p = s + 11;
 c22a668:	e24b3020 	sub	r3, fp, #32
 c22a66c:	e283300b 	add	r3, r3, #11
 c22a670:	e50b3010 	str	r3, [fp, #-16]

	*p = '\0';
 c22a674:	e51b3010 	ldr	r3, [fp, #-16]
 c22a678:	e3a02000 	mov	r2, #0
 c22a67c:	e5c32000 	strb	r2, [r3]
	if (negative)
 c22a680:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a684:	e3530000 	cmp	r3, #0
 c22a688:	0a000002 	beq	c22a698 <uart0_putint+0x50>
		i *= -1;
 c22a68c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c22a690:	e2633000 	rsb	r3, r3, #0
 c22a694:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

	do {
		*--p = '0' + ( i % 10 );
 c22a698:	e51b3010 	ldr	r3, [fp, #-16]
 c22a69c:	e2433001 	sub	r3, r3, #1
 c22a6a0:	e50b3010 	str	r3, [fp, #-16]
 c22a6a4:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
 c22a6a8:	e59f3094 	ldr	r3, [pc, #148]	; c22a744 <uart0_putint+0xfc>
 c22a6ac:	e0c32391 	smull	r2, r3, r1, r3
 c22a6b0:	e1a02143 	asr	r2, r3, #2
 c22a6b4:	e1a03fc1 	asr	r3, r1, #31
 c22a6b8:	e0632002 	rsb	r2, r3, r2
 c22a6bc:	e1a03002 	mov	r3, r2
 c22a6c0:	e1a03103 	lsl	r3, r3, #2
 c22a6c4:	e0833002 	add	r3, r3, r2
 c22a6c8:	e1a03083 	lsl	r3, r3, #1
 c22a6cc:	e0632001 	rsb	r2, r3, r1
 c22a6d0:	e20230ff 	and	r3, r2, #255	; 0xff
 c22a6d4:	e2833030 	add	r3, r3, #48	; 0x30
 c22a6d8:	e20320ff 	and	r2, r3, #255	; 0xff
 c22a6dc:	e51b3010 	ldr	r3, [fp, #-16]
 c22a6e0:	e5c32000 	strb	r2, [r3]
		i /= 10;
 c22a6e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c22a6e8:	e59f2054 	ldr	r2, [pc, #84]	; c22a744 <uart0_putint+0xfc>
 c22a6ec:	e0c21293 	smull	r1, r2, r3, r2
 c22a6f0:	e1a02142 	asr	r2, r2, #2
 c22a6f4:	e1a03fc3 	asr	r3, r3, #31
 c22a6f8:	e0633002 	rsb	r3, r3, r2
 c22a6fc:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
	} while(i > 0);
 c22a700:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c22a704:	e3530000 	cmp	r3, #0
 c22a708:	caffffe2 	bgt	c22a698 <uart0_putint+0x50>

	if(negative) {
 c22a70c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a710:	e3530000 	cmp	r3, #0
 c22a714:	0a000005 	beq	c22a730 <uart0_putint+0xe8>
		*--p = '-';
 c22a718:	e51b3010 	ldr	r3, [fp, #-16]
 c22a71c:	e2433001 	sub	r3, r3, #1
 c22a720:	e50b3010 	str	r3, [fp, #-16]
 c22a724:	e51b3010 	ldr	r3, [fp, #-16]
 c22a728:	e3a0202d 	mov	r2, #45	; 0x2d
 c22a72c:	e5c32000 	strb	r2, [r3]
	}

	uart0_puts(p);
 c22a730:	e51b0010 	ldr	r0, [fp, #-16]
 c22a734:	ebffffaf 	bl	c22a5f8 <uart0_puts>
}
 c22a738:	e24bd00c 	sub	sp, fp, #12
 c22a73c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a740:	e12fff1e 	bx	lr
 c22a744:	66666667 	.word	0x66666667

0c22a748 <uart0_puthex>:

void uart0_puthex( uint32 i )
{
 c22a748:	e1a0c00d 	mov	ip, sp
 c22a74c:	e92dd800 	push	{fp, ip, lr, pc}
 c22a750:	e24cb004 	sub	fp, ip, #4
 c22a754:	e24dd018 	sub	sp, sp, #24
 c22a758:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    char buf[8 + 1];
    char *p = buf + 8;
 c22a75c:	e24b301c 	sub	r3, fp, #28
 c22a760:	e2833008 	add	r3, r3, #8
 c22a764:	e50b3010 	str	r3, [fp, #-16]
    uint8 c;

    *p = '\0';
 c22a768:	e51b3010 	ldr	r3, [fp, #-16]
 c22a76c:	e3a02000 	mov	r2, #0
 c22a770:	e5c32000 	strb	r2, [r3]

    do {
        c = i & 0xf;
 c22a774:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22a778:	e20330ff 	and	r3, r3, #255	; 0xff
 c22a77c:	e203300f 	and	r3, r3, #15
 c22a780:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        if( c < 10 )
 c22a784:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22a788:	e3530009 	cmp	r3, #9
 c22a78c:	8a000008 	bhi	c22a7b4 <uart0_puthex+0x6c>
            *--p = '0' + c;
 c22a790:	e51b3010 	ldr	r3, [fp, #-16]
 c22a794:	e2433001 	sub	r3, r3, #1
 c22a798:	e50b3010 	str	r3, [fp, #-16]
 c22a79c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22a7a0:	e2833030 	add	r3, r3, #48	; 0x30
 c22a7a4:	e20320ff 	and	r2, r3, #255	; 0xff
 c22a7a8:	e51b3010 	ldr	r3, [fp, #-16]
 c22a7ac:	e5c32000 	strb	r2, [r3]
 c22a7b0:	ea000007 	b	c22a7d4 <uart0_puthex+0x8c>
        else
            *--p = 'a' + c - 10;
 c22a7b4:	e51b3010 	ldr	r3, [fp, #-16]
 c22a7b8:	e2433001 	sub	r3, r3, #1
 c22a7bc:	e50b3010 	str	r3, [fp, #-16]
 c22a7c0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c22a7c4:	e2833057 	add	r3, r3, #87	; 0x57
 c22a7c8:	e20320ff 	and	r2, r3, #255	; 0xff
 c22a7cc:	e51b3010 	ldr	r3, [fp, #-16]
 c22a7d0:	e5c32000 	strb	r2, [r3]
        i = i >> 4;
 c22a7d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22a7d8:	e1a03223 	lsr	r3, r3, #4
 c22a7dc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    } while( i );
 c22a7e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c22a7e4:	e3530000 	cmp	r3, #0
 c22a7e8:	1affffe1 	bne	c22a774 <uart0_puthex+0x2c>

    uart0_puts( p );
 c22a7ec:	e51b0010 	ldr	r0, [fp, #-16]
 c22a7f0:	ebffff80 	bl	c22a5f8 <uart0_puts>
}
 c22a7f4:	e24bd00c 	sub	sp, fp, #12
 c22a7f8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a7fc:	e12fff1e 	bx	lr

0c22a800 <uart0_gets>:

void uart0_gets( char *s )
{
 c22a800:	e1a0c00d 	mov	ip, sp
 c22a804:	e92dd800 	push	{fp, ip, lr, pc}
 c22a808:	e24cb004 	sub	fp, ip, #4
 c22a80c:	e24dd010 	sub	sp, sp, #16
 c22a810:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	char c = uart0_getchar();
 c22a814:	ebffff65 	bl	c22a5b0 <uart0_getchar>
 c22a818:	e1a03000 	mov	r3, r0
 c22a81c:	e54b300d 	strb	r3, [fp, #-13]

	while(c != '\n') {
 c22a820:	ea000008 	b	c22a848 <uart0_gets+0x48>
		*s = c;
 c22a824:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a828:	e55b200d 	ldrb	r2, [fp, #-13]
 c22a82c:	e5c32000 	strb	r2, [r3]
		s++;
 c22a830:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a834:	e2833001 	add	r3, r3, #1
 c22a838:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		c = uart0_getchar();
 c22a83c:	ebffff5b 	bl	c22a5b0 <uart0_getchar>
 c22a840:	e1a03000 	mov	r3, r0
 c22a844:	e54b300d 	strb	r3, [fp, #-13]

void uart0_gets( char *s )
{
	char c = uart0_getchar();

	while(c != '\n') {
 c22a848:	e55b300d 	ldrb	r3, [fp, #-13]
 c22a84c:	e353000a 	cmp	r3, #10
 c22a850:	1afffff3 	bne	c22a824 <uart0_gets+0x24>
		*s = c;
		s++;
		c = uart0_getchar();
	}

	*s = '\0';
 c22a854:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22a858:	e3a02000 	mov	r2, #0
 c22a85c:	e5c32000 	strb	r2, [r3]
}
 c22a860:	e24bd00c 	sub	sp, fp, #12
 c22a864:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a868:	e12fff1e 	bx	lr

0c22a86c <uart0_getint>:

int32 uart0_getint( void )
{
 c22a86c:	e1a0c00d 	mov	ip, sp
 c22a870:	e92dd800 	push	{fp, ip, lr, pc}
 c22a874:	e24cb004 	sub	fp, ip, #4
 c22a878:	e24dd018 	sub	sp, sp, #24
	char s[11 + 1];
	char* p = s;
 c22a87c:	e24b3020 	sub	r3, fp, #32
 c22a880:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c22a884:	e3a03000 	mov	r3, #0
 c22a888:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c22a88c:	e24b3020 	sub	r3, fp, #32
 c22a890:	e1a00003 	mov	r0, r3
 c22a894:	ebffffd9 	bl	c22a800 <uart0_gets>

	if(s[0] == '\0')
 c22a898:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c22a89c:	e3530000 	cmp	r3, #0
 c22a8a0:	1a000001 	bne	c22a8ac <uart0_getint+0x40>
		return 0;
 c22a8a4:	e3a03000 	mov	r3, #0
 c22a8a8:	ea000021 	b	c22a934 <uart0_getint+0xc8>

	if(s[0]=='-')
 c22a8ac:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c22a8b0:	e353002d 	cmp	r3, #45	; 0x2d
 c22a8b4:	1a000012 	bne	c22a904 <uart0_getint+0x98>
		p++;
 c22a8b8:	e51b3010 	ldr	r3, [fp, #-16]
 c22a8bc:	e2833001 	add	r3, r3, #1
 c22a8c0:	e50b3010 	str	r3, [fp, #-16]

	while(*p) {
 c22a8c4:	ea00000f 	b	c22a908 <uart0_getint+0x9c>
		res = 10 * res + (*p - '0');
 c22a8c8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c22a8cc:	e1a03002 	mov	r3, r2
 c22a8d0:	e1a03103 	lsl	r3, r3, #2
 c22a8d4:	e0833002 	add	r3, r3, r2
 c22a8d8:	e1a03083 	lsl	r3, r3, #1
 c22a8dc:	e1a02003 	mov	r2, r3
 c22a8e0:	e51b3010 	ldr	r3, [fp, #-16]
 c22a8e4:	e5d33000 	ldrb	r3, [r3]
 c22a8e8:	e2433030 	sub	r3, r3, #48	; 0x30
 c22a8ec:	e0823003 	add	r3, r2, r3
 c22a8f0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c22a8f4:	e51b3010 	ldr	r3, [fp, #-16]
 c22a8f8:	e2833001 	add	r3, r3, #1
 c22a8fc:	e50b3010 	str	r3, [fp, #-16]
 c22a900:	ea000000 	b	c22a908 <uart0_getint+0x9c>
		return 0;

	if(s[0]=='-')
		p++;

	while(*p) {
 c22a904:	e1a00000 	nop			; (mov r0, r0)
 c22a908:	e51b3010 	ldr	r3, [fp, #-16]
 c22a90c:	e5d33000 	ldrb	r3, [r3]
 c22a910:	e3530000 	cmp	r3, #0
 c22a914:	1affffeb 	bne	c22a8c8 <uart0_getint+0x5c>
		res = 10 * res + (*p - '0');
		p++;
	}

	if(s[0] == '-')
 c22a918:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c22a91c:	e353002d 	cmp	r3, #45	; 0x2d
 c22a920:	1a000002 	bne	c22a930 <uart0_getint+0xc4>
		res *= -1;
 c22a924:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a928:	e2633000 	rsb	r3, r3, #0
 c22a92c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	return res;
 c22a930:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c22a934:	e1a00003 	mov	r0, r3
 c22a938:	e24bd00c 	sub	sp, fp, #12
 c22a93c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22a940:	e12fff1e 	bx	lr

0c22a944 <uart0_gethex>:

uint32 uart0_gethex( void )
{
 c22a944:	e1a0c00d 	mov	ip, sp
 c22a948:	e92dd800 	push	{fp, ip, lr, pc}
 c22a94c:	e24cb004 	sub	fp, ip, #4
 c22a950:	e24dd018 	sub	sp, sp, #24
	char s[8 + 1];
	char* p = s;
 c22a954:	e24b3020 	sub	r3, fp, #32
 c22a958:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c22a95c:	e3a03000 	mov	r3, #0
 c22a960:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c22a964:	e24b3020 	sub	r3, fp, #32
 c22a968:	e1a00003 	mov	r0, r3
 c22a96c:	ebffffa3 	bl	c22a800 <uart0_gets>

	while(*p) {
 c22a970:	ea00002b 	b	c22aa24 <uart0_gethex+0xe0>
		res = res << 4;
 c22a974:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22a978:	e1a03203 	lsl	r3, r3, #4
 c22a97c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		char c = *p;
 c22a980:	e51b3010 	ldr	r3, [fp, #-16]
 c22a984:	e5d33000 	ldrb	r3, [r3]
 c22a988:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
		if(c >= '0' && c <= '9')
 c22a98c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a990:	e353002f 	cmp	r3, #47	; 0x2f
 c22a994:	9a000008 	bls	c22a9bc <uart0_gethex+0x78>
 c22a998:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a99c:	e3530039 	cmp	r3, #57	; 0x39
 c22a9a0:	8a000005 	bhi	c22a9bc <uart0_gethex+0x78>
			res += c - '0';
 c22a9a4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9a8:	e2433030 	sub	r3, r3, #48	; 0x30
 c22a9ac:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c22a9b0:	e0823003 	add	r3, r2, r3
 c22a9b4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22a9b8:	ea000016 	b	c22aa18 <uart0_gethex+0xd4>
		else if(c >= 'a' && c <= 'f')
 c22a9bc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9c0:	e3530060 	cmp	r3, #96	; 0x60
 c22a9c4:	9a000008 	bls	c22a9ec <uart0_gethex+0xa8>
 c22a9c8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9cc:	e3530066 	cmp	r3, #102	; 0x66
 c22a9d0:	8a000005 	bhi	c22a9ec <uart0_gethex+0xa8>
			res += 10 + c - 'a';
 c22a9d4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9d8:	e2433057 	sub	r3, r3, #87	; 0x57
 c22a9dc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c22a9e0:	e0823003 	add	r3, r2, r3
 c22a9e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c22a9e8:	ea00000a 	b	c22aa18 <uart0_gethex+0xd4>
		else if(c >= 'A' && c <= 'F')
 c22a9ec:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9f0:	e3530040 	cmp	r3, #64	; 0x40
 c22a9f4:	9a000007 	bls	c22aa18 <uart0_gethex+0xd4>
 c22a9f8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22a9fc:	e3530046 	cmp	r3, #70	; 0x46
 c22aa00:	8a000004 	bhi	c22aa18 <uart0_gethex+0xd4>
			res += 10 + c - 'A';
 c22aa04:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c22aa08:	e2433037 	sub	r3, r3, #55	; 0x37
 c22aa0c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c22aa10:	e0823003 	add	r3, r2, r3
 c22aa14:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c22aa18:	e51b3010 	ldr	r3, [fp, #-16]
 c22aa1c:	e2833001 	add	r3, r3, #1
 c22aa20:	e50b3010 	str	r3, [fp, #-16]
	char* p = s;
	int32 res = 0;

	uart0_gets(s);

	while(*p) {
 c22aa24:	e51b3010 	ldr	r3, [fp, #-16]
 c22aa28:	e5d33000 	ldrb	r3, [r3]
 c22aa2c:	e3530000 	cmp	r3, #0
 c22aa30:	1affffcf 	bne	c22a974 <uart0_gethex+0x30>
		else if(c >= 'A' && c <= 'F')
			res += 10 + c - 'A';
		p++;
	}

	return res;
 c22aa34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c22aa38:	e1a00003 	mov	r0, r3
 c22aa3c:	e24bd00c 	sub	sp, fp, #12
 c22aa40:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22aa44:	e12fff1e 	bx	lr

0c22aa48 <uart0_put_rtc_time>:

void uart0_put_rtc_time( rtc_time_t* rtc_time )
{
 c22aa48:	e1a0c00d 	mov	ip, sp
 c22aa4c:	e92dd800 	push	{fp, ip, lr, pc}
 c22aa50:	e24cb004 	sub	fp, ip, #4
 c22aa54:	e24dd008 	sub	sp, sp, #8
 c22aa58:	e50b0010 	str	r0, [fp, #-16]
	uart0_putint( rtc_time->mday );
 c22aa5c:	e51b3010 	ldr	r3, [fp, #-16]
 c22aa60:	e5d33003 	ldrb	r3, [r3, #3]
 c22aa64:	e1a00003 	mov	r0, r3
 c22aa68:	ebfffef6 	bl	c22a648 <uart0_putint>
	uart0_putchar( '/' );
 c22aa6c:	e3a0002f 	mov	r0, #47	; 0x2f
 c22aa70:	ebfffeba 	bl	c22a560 <uart0_putchar>
	uart0_putint( rtc_time->mon );
 c22aa74:	e51b3010 	ldr	r3, [fp, #-16]
 c22aa78:	e5d33005 	ldrb	r3, [r3, #5]
 c22aa7c:	e1a00003 	mov	r0, r3
 c22aa80:	ebfffef0 	bl	c22a648 <uart0_putint>
	uart0_putchar( '/' );
 c22aa84:	e3a0002f 	mov	r0, #47	; 0x2f
 c22aa88:	ebfffeb4 	bl	c22a560 <uart0_putchar>
	uart0_putint( rtc_time->year );
 c22aa8c:	e51b3010 	ldr	r3, [fp, #-16]
 c22aa90:	e5d33006 	ldrb	r3, [r3, #6]
 c22aa94:	e1a00003 	mov	r0, r3
 c22aa98:	ebfffeea 	bl	c22a648 <uart0_putint>
	uart0_putchar( ' ' );
 c22aa9c:	e3a00020 	mov	r0, #32
 c22aaa0:	ebfffeae 	bl	c22a560 <uart0_putchar>
	uart0_putint( rtc_time->hour );
 c22aaa4:	e51b3010 	ldr	r3, [fp, #-16]
 c22aaa8:	e5d33002 	ldrb	r3, [r3, #2]
 c22aaac:	e1a00003 	mov	r0, r3
 c22aab0:	ebfffee4 	bl	c22a648 <uart0_putint>
	uart0_putchar( ':' );
 c22aab4:	e3a0003a 	mov	r0, #58	; 0x3a
 c22aab8:	ebfffea8 	bl	c22a560 <uart0_putchar>
	uart0_putint( rtc_time->min );
 c22aabc:	e51b3010 	ldr	r3, [fp, #-16]
 c22aac0:	e5d33001 	ldrb	r3, [r3, #1]
 c22aac4:	e1a00003 	mov	r0, r3
 c22aac8:	ebfffede 	bl	c22a648 <uart0_putint>
	uart0_putchar( ':' );
 c22aacc:	e3a0003a 	mov	r0, #58	; 0x3a
 c22aad0:	ebfffea2 	bl	c22a560 <uart0_putchar>
	uart0_putint( rtc_time->sec );
 c22aad4:	e51b3010 	ldr	r3, [fp, #-16]
 c22aad8:	e5d33000 	ldrb	r3, [r3]
 c22aadc:	e1a00003 	mov	r0, r3
 c22aae0:	ebfffed8 	bl	c22a648 <uart0_putint>
}
 c22aae4:	e24bd00c 	sub	sp, fp, #12
 c22aae8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22aaec:	e12fff1e 	bx	lr

0c22aaf0 <uda1341ts_init>:

static uint8 volume;
static uint8 state;

void uda1341ts_init( void )
{
 c22aaf0:	e1a0c00d 	mov	ip, sp
 c22aaf4:	e92dd800 	push	{fp, ip, lr, pc}
 c22aaf8:	e24cb004 	sub	fp, ip, #4
    L3_init();
 c22aafc:	ebffea5f 	bl	c225480 <L3_init>

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c22ab00:	e3a00016 	mov	r0, #22
 c22ab04:	e3a01000 	mov	r1, #0
 c22ab08:	ebffea84 	bl	c225520 <L3_putByte>
    L3_putByte( (1 << 6) | (2 << 4), L3_DATA_MODE );
 c22ab0c:	e3a00060 	mov	r0, #96	; 0x60
 c22ab10:	e3a01001 	mov	r1, #1
 c22ab14:	ebffea81 	bl	c225520 <L3_putByte>
    L3_putByte( (2 << 4), L3_DATA_MODE );
 c22ab18:	e3a00020 	mov	r0, #32
 c22ab1c:	e3a01001 	mov	r1, #1
 c22ab20:	ebffea7e 	bl	c225520 <L3_putByte>

    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE  );
 c22ab24:	e3a00014 	mov	r0, #20
 c22ab28:	e3a01000 	mov	r1, #0
 c22ab2c:	ebffea7b 	bl	c225520 <L3_putByte>
    L3_putByte( EA | (2), L3_DATA_MODE );
 c22ab30:	e3a000c2 	mov	r0, #194	; 0xc2
 c22ab34:	e3a01001 	mov	r1, #1
 c22ab38:	ebffea78 	bl	c225520 <L3_putByte>
    L3_putByte( ED | 1, L3_DATA_MODE );
 c22ab3c:	e3a000e1 	mov	r0, #225	; 0xe1
 c22ab40:	e3a01001 	mov	r1, #1
 c22ab44:	ebffea75 	bl	c225520 <L3_putByte>

    uda1341ts_setvol( VOL_MAX );
 c22ab48:	e3a0003f 	mov	r0, #63	; 0x3f
 c22ab4c:	eb000066 	bl	c22acec <uda1341ts_setvol>

    uda1341ts_on( UDA_DAC );
 c22ab50:	e3a00001 	mov	r0, #1
 c22ab54:	eb00001b 	bl	c22abc8 <uda1341ts_on>
    uda1341ts_on( UDA_ADC );
 c22ab58:	e3a00002 	mov	r0, #2
 c22ab5c:	eb000019 	bl	c22abc8 <uda1341ts_on>
}
 c22ab60:	e24bd00c 	sub	sp, fp, #12
 c22ab64:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ab68:	e12fff1e 	bx	lr

0c22ab6c <uda1341ts_mute>:

void uda1341ts_mute( uint8 on )
{
 c22ab6c:	e1a0c00d 	mov	ip, sp
 c22ab70:	e92dd800 	push	{fp, ip, lr, pc}
 c22ab74:	e24cb004 	sub	fp, ip, #4
 c22ab78:	e24dd008 	sub	sp, sp, #8
 c22ab7c:	e1a03000 	mov	r3, r0
 c22ab80:	e54b300d 	strb	r3, [fp, #-13]
	//DATA0[7:6] = 2 y DATA0[2]=1/0 (0 no mute, 1 mute)
    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE );
 c22ab84:	e3a00014 	mov	r0, #20
 c22ab88:	e3a01000 	mov	r1, #0
 c22ab8c:	ebffea63 	bl	c225520 <L3_putByte>
    L3_putByte( (0x2 << 6) | ((on & 1) << 2) , L3_DATA_MODE);
 c22ab90:	e55b300d 	ldrb	r3, [fp, #-13]
 c22ab94:	e2033001 	and	r3, r3, #1
 c22ab98:	e1a03103 	lsl	r3, r3, #2
 c22ab9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c22aba0:	e1e03c83 	mvn	r3, r3, lsl #25
 c22aba4:	e1e03ca3 	mvn	r3, r3, lsr #25
 c22aba8:	e20330ff 	and	r3, r3, #255	; 0xff
 c22abac:	e20330ff 	and	r3, r3, #255	; 0xff
 c22abb0:	e1a00003 	mov	r0, r3
 c22abb4:	e3a01001 	mov	r1, #1
 c22abb8:	ebffea58 	bl	c225520 <L3_putByte>
}
 c22abbc:	e24bd00c 	sub	sp, fp, #12
 c22abc0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22abc4:	e12fff1e 	bx	lr

0c22abc8 <uda1341ts_on>:

void uda1341ts_on( enum UDA_converter_t converter )
{
 c22abc8:	e1a0c00d 	mov	ip, sp
 c22abcc:	e92dd800 	push	{fp, ip, lr, pc}
 c22abd0:	e24cb004 	sub	fp, ip, #4
 c22abd4:	e24dd008 	sub	sp, sp, #8
 c22abd8:	e1a03000 	mov	r3, r0
 c22abdc:	e54b300d 	strb	r3, [fp, #-13]
    state |= converter;
 c22abe0:	e59f304c 	ldr	r3, [pc, #76]	; c22ac34 <uda1341ts_on+0x6c>
 c22abe4:	e5d32000 	ldrb	r2, [r3]
 c22abe8:	e55b300d 	ldrb	r3, [fp, #-13]
 c22abec:	e1823003 	orr	r3, r2, r3
 c22abf0:	e20320ff 	and	r2, r3, #255	; 0xff
 c22abf4:	e59f3038 	ldr	r3, [pc, #56]	; c22ac34 <uda1341ts_on+0x6c>
 c22abf8:	e5c32000 	strb	r2, [r3]

    //STATUS[6]=1 y STATUS[5]=1 6dB de ganancia
    //STATUS[4]=0 y STATUS[3]=0 non inverting ADC/DAC polarity
    //STATUS[2]=0 no double speed

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c22abfc:	e3a00016 	mov	r0, #22
 c22ac00:	e3a01000 	mov	r1, #0
 c22ac04:	ebffea45 	bl	c225520 <L3_putByte>
    L3_putByte( (0x1 << 7) | (0b11000 << 2) | state , L3_DATA_MODE);
 c22ac08:	e59f3024 	ldr	r3, [pc, #36]	; c22ac34 <uda1341ts_on+0x6c>
 c22ac0c:	e5d33000 	ldrb	r3, [r3]
 c22ac10:	e1e03d83 	mvn	r3, r3, lsl #27
 c22ac14:	e1e03da3 	mvn	r3, r3, lsr #27
 c22ac18:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ac1c:	e1a00003 	mov	r0, r3
 c22ac20:	e3a01001 	mov	r1, #1
 c22ac24:	ebffea3d 	bl	c225520 <L3_putByte>
}
 c22ac28:	e24bd00c 	sub	sp, fp, #12
 c22ac2c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ac30:	e12fff1e 	bx	lr
 c22ac34:	0c10ba23 	.word	0x0c10ba23

0c22ac38 <uda1341ts_off>:

void uda1341ts_off( enum UDA_converter_t converter )
{
 c22ac38:	e1a0c00d 	mov	ip, sp
 c22ac3c:	e92dd800 	push	{fp, ip, lr, pc}
 c22ac40:	e24cb004 	sub	fp, ip, #4
 c22ac44:	e24dd008 	sub	sp, sp, #8
 c22ac48:	e1a03000 	mov	r3, r0
 c22ac4c:	e54b300d 	strb	r3, [fp, #-13]
    state &= ~converter;
 c22ac50:	e55b300d 	ldrb	r3, [fp, #-13]
 c22ac54:	e1e03003 	mvn	r3, r3
 c22ac58:	e20320ff 	and	r2, r3, #255	; 0xff
 c22ac5c:	e59f3050 	ldr	r3, [pc, #80]	; c22acb4 <uda1341ts_off+0x7c>
 c22ac60:	e5d33000 	ldrb	r3, [r3]
 c22ac64:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ac68:	e0023003 	and	r3, r2, r3
 c22ac6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ac70:	e20320ff 	and	r2, r3, #255	; 0xff
 c22ac74:	e59f3038 	ldr	r3, [pc, #56]	; c22acb4 <uda1341ts_off+0x7c>
 c22ac78:	e5c32000 	strb	r2, [r3]
    //STATUS[7]=1 y STATUS[1:0]=X valor según corresponda
    //STATUS[6]=1 y STATUS[5]=1 6dB de ganancia
    //STATUS[4]=0 y STATUS[3]=0 non inverting ADC/DAC polarity
    //STATUS[2]=0 no double speed

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c22ac7c:	e3a00016 	mov	r0, #22
 c22ac80:	e3a01000 	mov	r1, #0
 c22ac84:	ebffea25 	bl	c225520 <L3_putByte>
    L3_putByte( (0x1 << 7) | (0b11000 << 2) | state , L3_DATA_MODE);
 c22ac88:	e59f3024 	ldr	r3, [pc, #36]	; c22acb4 <uda1341ts_off+0x7c>
 c22ac8c:	e5d33000 	ldrb	r3, [r3]
 c22ac90:	e1e03d83 	mvn	r3, r3, lsl #27
 c22ac94:	e1e03da3 	mvn	r3, r3, lsr #27
 c22ac98:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ac9c:	e1a00003 	mov	r0, r3
 c22aca0:	e3a01001 	mov	r1, #1
 c22aca4:	ebffea1d 	bl	c225520 <L3_putByte>
}
 c22aca8:	e24bd00c 	sub	sp, fp, #12
 c22acac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22acb0:	e12fff1e 	bx	lr
 c22acb4:	0c10ba23 	.word	0x0c10ba23

0c22acb8 <uda1341ts_status>:

uint8 uda1341ts_status( enum UDA_converter_t converter )
{
 c22acb8:	e1a0c00d 	mov	ip, sp
 c22acbc:	e92dd800 	push	{fp, ip, lr, pc}
 c22acc0:	e24cb004 	sub	fp, ip, #4
 c22acc4:	e24dd008 	sub	sp, sp, #8
 c22acc8:	e1a03000 	mov	r3, r0
 c22accc:	e54b300d 	strb	r3, [fp, #-13]
    return state;
 c22acd0:	e59f3010 	ldr	r3, [pc, #16]	; c22ace8 <uda1341ts_status+0x30>
 c22acd4:	e5d33000 	ldrb	r3, [r3]
}
 c22acd8:	e1a00003 	mov	r0, r3
 c22acdc:	e24bd00c 	sub	sp, fp, #12
 c22ace0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ace4:	e12fff1e 	bx	lr
 c22ace8:	0c10ba23 	.word	0x0c10ba23

0c22acec <uda1341ts_setvol>:

void uda1341ts_setvol( uint8 vol )
{
 c22acec:	e1a0c00d 	mov	ip, sp
 c22acf0:	e92dd800 	push	{fp, ip, lr, pc}
 c22acf4:	e24cb004 	sub	fp, ip, #4
 c22acf8:	e24dd008 	sub	sp, sp, #8
 c22acfc:	e1a03000 	mov	r3, r0
 c22ad00:	e54b300d 	strb	r3, [fp, #-13]
	volume = vol;
 c22ad04:	e59f303c 	ldr	r3, [pc, #60]	; c22ad48 <uda1341ts_setvol+0x5c>
 c22ad08:	e55b200d 	ldrb	r2, [fp, #-13]
 c22ad0c:	e5c32000 	strb	r2, [r3]

	//DATA0[7:6] = 0 y DATA0[5:0]=atenuación (a mayor atenuación, menor volumen)
    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE );
 c22ad10:	e3a00014 	mov	r0, #20
 c22ad14:	e3a01000 	mov	r1, #0
 c22ad18:	ebffea00 	bl	c225520 <L3_putByte>
    L3_putByte( 0x3f - (vol & 0x3f) , L3_DATA_MODE );
 c22ad1c:	e55b300d 	ldrb	r3, [fp, #-13]
 c22ad20:	e1e03003 	mvn	r3, r3
 c22ad24:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ad28:	e203303f 	and	r3, r3, #63	; 0x3f
 c22ad2c:	e20330ff 	and	r3, r3, #255	; 0xff
 c22ad30:	e1a00003 	mov	r0, r3
 c22ad34:	e3a01001 	mov	r1, #1
 c22ad38:	ebffe9f8 	bl	c225520 <L3_putByte>
}
 c22ad3c:	e24bd00c 	sub	sp, fp, #12
 c22ad40:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ad44:	e12fff1e 	bx	lr
 c22ad48:	0c10ba22 	.word	0x0c10ba22

0c22ad4c <uda1341ts_getvol>:

uint8 uda1341ts_getvol( void )
{
 c22ad4c:	e1a0c00d 	mov	ip, sp
 c22ad50:	e92dd800 	push	{fp, ip, lr, pc}
 c22ad54:	e24cb004 	sub	fp, ip, #4
    return volume;
 c22ad58:	e59f3010 	ldr	r3, [pc, #16]	; c22ad70 <uda1341ts_getvol+0x24>
 c22ad5c:	e5d33000 	ldrb	r3, [r3]
}
 c22ad60:	e1a00003 	mov	r0, r3
 c22ad64:	e24bd00c 	sub	sp, fp, #12
 c22ad68:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ad6c:	e12fff1e 	bx	lr
 c22ad70:	0c10ba22 	.word	0x0c10ba22

0c22ad74 <Delay>:

void Delay(int time)
// time=0: adjust the Delay function by WatchDog timer.//
// time>0: the number of loop time//
// 100us resolution.//
{
 c22ad74:	e1a0c00d 	mov	ip, sp
 c22ad78:	e92dd800 	push	{fp, ip, lr, pc}
 c22ad7c:	e24cb004 	sub	fp, ip, #4
 c22ad80:	e24dd010 	sub	sp, sp, #16
 c22ad84:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	int i,adjust=0;
 c22ad88:	e3a03000 	mov	r3, #0
 c22ad8c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if(time==0)
 c22ad90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22ad94:	e3530000 	cmp	r3, #0
 c22ad98:	1a000021 	bne	c22ae24 <Delay+0xb0>
	{
		time=200;
 c22ad9c:	e3a030c8 	mov	r3, #200	; 0xc8
 c22ada0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		adjust=1;
 c22ada4:	e3a03001 	mov	r3, #1
 c22ada8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		delayLoopCount=400;
 c22adac:	e59f30d8 	ldr	r3, [pc, #216]	; c22ae8c <Delay+0x118>
 c22adb0:	e3a02e19 	mov	r2, #400	; 0x190
 c22adb4:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
 c22adb8:	e59f30d0 	ldr	r3, [pc, #208]	; c22ae90 <Delay+0x11c>
 c22adbc:	e59f20d0 	ldr	r2, [pc, #208]	; c22ae94 <Delay+0x120>
 c22adc0:	e5832000 	str	r2, [r3]
		rWTDAT=0xffff;
 c22adc4:	e59f30cc 	ldr	r3, [pc, #204]	; c22ae98 <Delay+0x124>
 c22adc8:	e59f20cc 	ldr	r2, [pc, #204]	; c22ae9c <Delay+0x128>
 c22adcc:	e5832000 	str	r2, [r3]
		rWTCNT=0xffff;
 c22add0:	e59f30c8 	ldr	r3, [pc, #200]	; c22aea0 <Delay+0x12c>
 c22add4:	e59f20c0 	ldr	r2, [pc, #192]	; c22ae9c <Delay+0x128>
 c22add8:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
 c22addc:	e59f30ac 	ldr	r3, [pc, #172]	; c22ae90 <Delay+0x11c>
 c22ade0:	e59f20bc 	ldr	r2, [pc, #188]	; c22aea4 <Delay+0x130>
 c22ade4:	e5832000 	str	r2, [r3]
	}
	for(;time>0;time--)
 c22ade8:	ea00000d 	b	c22ae24 <Delay+0xb0>
		for(i=0;i<delayLoopCount;i++);
 c22adec:	e3a03000 	mov	r3, #0
 c22adf0:	e50b3010 	str	r3, [fp, #-16]
 c22adf4:	ea000002 	b	c22ae04 <Delay+0x90>
 c22adf8:	e51b3010 	ldr	r3, [fp, #-16]
 c22adfc:	e2833001 	add	r3, r3, #1
 c22ae00:	e50b3010 	str	r3, [fp, #-16]
 c22ae04:	e59f3080 	ldr	r3, [pc, #128]	; c22ae8c <Delay+0x118>
 c22ae08:	e5933000 	ldr	r3, [r3]
 c22ae0c:	e51b2010 	ldr	r2, [fp, #-16]
 c22ae10:	e1520003 	cmp	r2, r3
 c22ae14:	bafffff7 	blt	c22adf8 <Delay+0x84>
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
		rWTDAT=0xffff;
		rWTCNT=0xffff;
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
	}
	for(;time>0;time--)
 c22ae18:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22ae1c:	e2433001 	sub	r3, r3, #1
 c22ae20:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c22ae24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c22ae28:	e3530000 	cmp	r3, #0
 c22ae2c:	caffffee 	bgt	c22adec <Delay+0x78>
		for(i=0;i<delayLoopCount;i++);
	if(adjust==1)
 c22ae30:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c22ae34:	e3530001 	cmp	r3, #1
 c22ae38:	1a000010 	bne	c22ae80 <Delay+0x10c>
	{
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);
 c22ae3c:	e59f304c 	ldr	r3, [pc, #76]	; c22ae90 <Delay+0x11c>
 c22ae40:	e59f204c 	ldr	r2, [pc, #76]	; c22ae94 <Delay+0x120>
 c22ae44:	e5832000 	str	r2, [r3]
		i=0xffff-rWTCNT;   //  1count/16us?????????//
 c22ae48:	e59f3050 	ldr	r3, [pc, #80]	; c22aea0 <Delay+0x12c>
 c22ae4c:	e5933000 	ldr	r3, [r3]
 c22ae50:	e2633cff 	rsb	r3, r3, #65280	; 0xff00
 c22ae54:	e28330ff 	add	r3, r3, #255	; 0xff
 c22ae58:	e50b3010 	str	r3, [fp, #-16]
		delayLoopCount=8000000/(i*64);	//400*100/(i*64/200)   //
 c22ae5c:	e51b3010 	ldr	r3, [fp, #-16]
 c22ae60:	e1a03303 	lsl	r3, r3, #6
 c22ae64:	e59f003c 	ldr	r0, [pc, #60]	; c22aea8 <Delay+0x134>
 c22ae68:	e1a01003 	mov	r1, r3
 c22ae6c:	eb00005f 	bl	c22aff0 <__aeabi_idiv>
 c22ae70:	e1a03000 	mov	r3, r0
 c22ae74:	e1a02003 	mov	r2, r3
 c22ae78:	e59f300c 	ldr	r3, [pc, #12]	; c22ae8c <Delay+0x118>
 c22ae7c:	e5832000 	str	r2, [r3]
	}
}
 c22ae80:	e24bd00c 	sub	sp, fp, #12
 c22ae84:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22ae88:	e12fff1e 	bx	lr
 c22ae8c:	0c100144 	.word	0x0c100144
 c22ae90:	01d30000 	.word	0x01d30000
 c22ae94:	00003f10 	.word	0x00003f10
 c22ae98:	01d30004 	.word	0x01d30004
 c22ae9c:	0000ffff 	.word	0x0000ffff
 c22aea0:	01d30008 	.word	0x01d30008
 c22aea4:	00003f30 	.word	0x00003f30
 c22aea8:	007a1200 	.word	0x007a1200

0c22aeac <sleep>:

inline void sleep(void)
{
 c22aeac:	e1a0c00d 	mov	ip, sp
 c22aeb0:	e92dd800 	push	{fp, ip, lr, pc}
 c22aeb4:	e24cb004 	sub	fp, ip, #4
    rCLKCON |= (1 << 2);    // Pone a la CPU en estado IDLE
 c22aeb8:	e59f3018 	ldr	r3, [pc, #24]	; c22aed8 <sleep+0x2c>
 c22aebc:	e59f2014 	ldr	r2, [pc, #20]	; c22aed8 <sleep+0x2c>
 c22aec0:	e5922000 	ldr	r2, [r2]
 c22aec4:	e3822004 	orr	r2, r2, #4
 c22aec8:	e5832000 	str	r2, [r3]
}
 c22aecc:	e24bd00c 	sub	sp, fp, #12
 c22aed0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c22aed4:	e12fff1e 	bx	lr
 c22aed8:	01d80004 	.word	0x01d80004

0c22aedc <__aeabi_uidiv>:
 c22aedc:	e2512001 	subs	r2, r1, #1
 c22aee0:	012fff1e 	bxeq	lr
 c22aee4:	3a000036 	bcc	c22afc4 <__aeabi_uidiv+0xe8>
 c22aee8:	e1500001 	cmp	r0, r1
 c22aeec:	9a000022 	bls	c22af7c <__aeabi_uidiv+0xa0>
 c22aef0:	e1110002 	tst	r1, r2
 c22aef4:	0a000023 	beq	c22af88 <__aeabi_uidiv+0xac>
 c22aef8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
 c22aefc:	01a01181 	lsleq	r1, r1, #3
 c22af00:	03a03008 	moveq	r3, #8
 c22af04:	13a03001 	movne	r3, #1
 c22af08:	e3510201 	cmp	r1, #268435456	; 0x10000000
 c22af0c:	31510000 	cmpcc	r1, r0
 c22af10:	31a01201 	lslcc	r1, r1, #4
 c22af14:	31a03203 	lslcc	r3, r3, #4
 c22af18:	3afffffa 	bcc	c22af08 <__aeabi_uidiv+0x2c>
 c22af1c:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
 c22af20:	31510000 	cmpcc	r1, r0
 c22af24:	31a01081 	lslcc	r1, r1, #1
 c22af28:	31a03083 	lslcc	r3, r3, #1
 c22af2c:	3afffffa 	bcc	c22af1c <__aeabi_uidiv+0x40>
 c22af30:	e3a02000 	mov	r2, #0
 c22af34:	e1500001 	cmp	r0, r1
 c22af38:	20400001 	subcs	r0, r0, r1
 c22af3c:	21822003 	orrcs	r2, r2, r3
 c22af40:	e15000a1 	cmp	r0, r1, lsr #1
 c22af44:	204000a1 	subcs	r0, r0, r1, lsr #1
 c22af48:	218220a3 	orrcs	r2, r2, r3, lsr #1
 c22af4c:	e1500121 	cmp	r0, r1, lsr #2
 c22af50:	20400121 	subcs	r0, r0, r1, lsr #2
 c22af54:	21822123 	orrcs	r2, r2, r3, lsr #2
 c22af58:	e15001a1 	cmp	r0, r1, lsr #3
 c22af5c:	204001a1 	subcs	r0, r0, r1, lsr #3
 c22af60:	218221a3 	orrcs	r2, r2, r3, lsr #3
 c22af64:	e3500000 	cmp	r0, #0
 c22af68:	11b03223 	lsrsne	r3, r3, #4
 c22af6c:	11a01221 	lsrne	r1, r1, #4
 c22af70:	1affffef 	bne	c22af34 <__aeabi_uidiv+0x58>
 c22af74:	e1a00002 	mov	r0, r2
 c22af78:	e12fff1e 	bx	lr
 c22af7c:	03a00001 	moveq	r0, #1
 c22af80:	13a00000 	movne	r0, #0
 c22af84:	e12fff1e 	bx	lr
 c22af88:	e3510801 	cmp	r1, #65536	; 0x10000
 c22af8c:	21a01821 	lsrcs	r1, r1, #16
 c22af90:	23a02010 	movcs	r2, #16
 c22af94:	33a02000 	movcc	r2, #0
 c22af98:	e3510c01 	cmp	r1, #256	; 0x100
 c22af9c:	21a01421 	lsrcs	r1, r1, #8
 c22afa0:	22822008 	addcs	r2, r2, #8
 c22afa4:	e3510010 	cmp	r1, #16
 c22afa8:	21a01221 	lsrcs	r1, r1, #4
 c22afac:	22822004 	addcs	r2, r2, #4
 c22afb0:	e3510004 	cmp	r1, #4
 c22afb4:	82822003 	addhi	r2, r2, #3
 c22afb8:	908220a1 	addls	r2, r2, r1, lsr #1
 c22afbc:	e1a00230 	lsr	r0, r0, r2
 c22afc0:	e12fff1e 	bx	lr
 c22afc4:	e3500000 	cmp	r0, #0
 c22afc8:	13e00000 	mvnne	r0, #0
 c22afcc:	ea000059 	b	c22b138 <__aeabi_idiv0>

0c22afd0 <__aeabi_uidivmod>:
 c22afd0:	e3510000 	cmp	r1, #0
 c22afd4:	0afffffa 	beq	c22afc4 <__aeabi_uidiv+0xe8>
 c22afd8:	e92d4003 	push	{r0, r1, lr}
 c22afdc:	ebffffbe 	bl	c22aedc <__aeabi_uidiv>
 c22afe0:	e8bd4006 	pop	{r1, r2, lr}
 c22afe4:	e0030092 	mul	r3, r2, r0
 c22afe8:	e0411003 	sub	r1, r1, r3
 c22afec:	e12fff1e 	bx	lr

0c22aff0 <__aeabi_idiv>:
 c22aff0:	e3510000 	cmp	r1, #0
 c22aff4:	0a000043 	beq	c22b108 <.divsi3_skip_div0_test+0x110>

0c22aff8 <.divsi3_skip_div0_test>:
 c22aff8:	e020c001 	eor	ip, r0, r1
 c22affc:	42611000 	rsbmi	r1, r1, #0
 c22b000:	e2512001 	subs	r2, r1, #1
 c22b004:	0a000027 	beq	c22b0a8 <.divsi3_skip_div0_test+0xb0>
 c22b008:	e1b03000 	movs	r3, r0
 c22b00c:	42603000 	rsbmi	r3, r0, #0
 c22b010:	e1530001 	cmp	r3, r1
 c22b014:	9a000026 	bls	c22b0b4 <.divsi3_skip_div0_test+0xbc>
 c22b018:	e1110002 	tst	r1, r2
 c22b01c:	0a000028 	beq	c22b0c4 <.divsi3_skip_div0_test+0xcc>
 c22b020:	e311020e 	tst	r1, #-536870912	; 0xe0000000
 c22b024:	01a01181 	lsleq	r1, r1, #3
 c22b028:	03a02008 	moveq	r2, #8
 c22b02c:	13a02001 	movne	r2, #1
 c22b030:	e3510201 	cmp	r1, #268435456	; 0x10000000
 c22b034:	31510003 	cmpcc	r1, r3
 c22b038:	31a01201 	lslcc	r1, r1, #4
 c22b03c:	31a02202 	lslcc	r2, r2, #4
 c22b040:	3afffffa 	bcc	c22b030 <.divsi3_skip_div0_test+0x38>
 c22b044:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
 c22b048:	31510003 	cmpcc	r1, r3
 c22b04c:	31a01081 	lslcc	r1, r1, #1
 c22b050:	31a02082 	lslcc	r2, r2, #1
 c22b054:	3afffffa 	bcc	c22b044 <.divsi3_skip_div0_test+0x4c>
 c22b058:	e3a00000 	mov	r0, #0
 c22b05c:	e1530001 	cmp	r3, r1
 c22b060:	20433001 	subcs	r3, r3, r1
 c22b064:	21800002 	orrcs	r0, r0, r2
 c22b068:	e15300a1 	cmp	r3, r1, lsr #1
 c22b06c:	204330a1 	subcs	r3, r3, r1, lsr #1
 c22b070:	218000a2 	orrcs	r0, r0, r2, lsr #1
 c22b074:	e1530121 	cmp	r3, r1, lsr #2
 c22b078:	20433121 	subcs	r3, r3, r1, lsr #2
 c22b07c:	21800122 	orrcs	r0, r0, r2, lsr #2
 c22b080:	e15301a1 	cmp	r3, r1, lsr #3
 c22b084:	204331a1 	subcs	r3, r3, r1, lsr #3
 c22b088:	218001a2 	orrcs	r0, r0, r2, lsr #3
 c22b08c:	e3530000 	cmp	r3, #0
 c22b090:	11b02222 	lsrsne	r2, r2, #4
 c22b094:	11a01221 	lsrne	r1, r1, #4
 c22b098:	1affffef 	bne	c22b05c <.divsi3_skip_div0_test+0x64>
 c22b09c:	e35c0000 	cmp	ip, #0
 c22b0a0:	42600000 	rsbmi	r0, r0, #0
 c22b0a4:	e12fff1e 	bx	lr
 c22b0a8:	e13c0000 	teq	ip, r0
 c22b0ac:	42600000 	rsbmi	r0, r0, #0
 c22b0b0:	e12fff1e 	bx	lr
 c22b0b4:	33a00000 	movcc	r0, #0
 c22b0b8:	01a00fcc 	asreq	r0, ip, #31
 c22b0bc:	03800001 	orreq	r0, r0, #1
 c22b0c0:	e12fff1e 	bx	lr
 c22b0c4:	e3510801 	cmp	r1, #65536	; 0x10000
 c22b0c8:	21a01821 	lsrcs	r1, r1, #16
 c22b0cc:	23a02010 	movcs	r2, #16
 c22b0d0:	33a02000 	movcc	r2, #0
 c22b0d4:	e3510c01 	cmp	r1, #256	; 0x100
 c22b0d8:	21a01421 	lsrcs	r1, r1, #8
 c22b0dc:	22822008 	addcs	r2, r2, #8
 c22b0e0:	e3510010 	cmp	r1, #16
 c22b0e4:	21a01221 	lsrcs	r1, r1, #4
 c22b0e8:	22822004 	addcs	r2, r2, #4
 c22b0ec:	e3510004 	cmp	r1, #4
 c22b0f0:	82822003 	addhi	r2, r2, #3
 c22b0f4:	908220a1 	addls	r2, r2, r1, lsr #1
 c22b0f8:	e35c0000 	cmp	ip, #0
 c22b0fc:	e1a00233 	lsr	r0, r3, r2
 c22b100:	42600000 	rsbmi	r0, r0, #0
 c22b104:	e12fff1e 	bx	lr
 c22b108:	e3500000 	cmp	r0, #0
 c22b10c:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
 c22b110:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
 c22b114:	ea000007 	b	c22b138 <__aeabi_idiv0>

0c22b118 <__aeabi_idivmod>:
 c22b118:	e3510000 	cmp	r1, #0
 c22b11c:	0afffff9 	beq	c22b108 <.divsi3_skip_div0_test+0x110>
 c22b120:	e92d4003 	push	{r0, r1, lr}
 c22b124:	ebffffb3 	bl	c22aff8 <.divsi3_skip_div0_test>
 c22b128:	e8bd4006 	pop	{r1, r2, lr}
 c22b12c:	e0030092 	mul	r3, r2, r0
 c22b130:	e0411003 	sub	r1, r1, r3
 c22b134:	e12fff1e 	bx	lr

0c22b138 <__aeabi_idiv0>:
 c22b138:	e12fff1e 	bx	lr
