
prac2a.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000223c  0c100000  0c100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .bss          000c56ec  0c10223c  0c10223c  0000a23c  2**2
                  ALLOC
  2 .text         000089e4  0c1c7928  0c1c7928  0000f928  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .debug_abbrev 0000175d  00000000  00000000  0001830c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00004469  00000000  00000000  00019a69  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   000020b9  00000000  00000000  0001ded2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0009127a  00000000  00000000  0001ff8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00001d90  00000000  00000000  000b1205  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000d69  00000000  00000000  000b2f95  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubtypes 00000789  00000000  00000000  000b3cfe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000003a0  00000000  00000000  000b4488  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000f47  00000000  00000000  000b4828  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002a  00000000  00000000  000b576f  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000030  00000000  00000000  000b5799  2**0
                  CONTENTS, READONLY
 14 .debug_frame  0000180c  00000000  00000000  000b57cc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c1c7928 <test_EEPROM>:
#include "test_EEPROM.h"
#include "../at24c04.h"
#include "../44b.h"
#include "../uart.h"

void test_EEPROM(void) {
 c1c7928:	e1a0c00d 	mov	ip, sp
 c1c792c:	e92dd800 	push	{fp, ip, lr, pc}
 c1c7930:	e24cb004 	sub	fp, ip, #4
 c1c7934:	e24dde41 	sub	sp, sp, #1040	; 0x410
    uint8 buffer[AT24C04_DEPTH], buffer_aux[AT24C04_DEPTH];
    uint16 i, j;
    uint32 addr, data;

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );
 c1c7938:	e59f04b8 	ldr	r0, [pc, #1208]	; c1c7df8 <Image_ZI_Limit+0x4d0>
 c1c793c:	eb001fe6 	bl	c1cf8dc <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7940:	e3a03000 	mov	r3, #0
 c1c7944:	e14b30be 	strh	r3, [fp, #-14]
 c1c7948:	ea000009 	b	c1c7974 <test_EEPROM+0x4c>
		at24c04_byteread( i, &buffer[i] );
 c1c794c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7950:	e24b2f86 	sub	r2, fp, #536	; 0x218
 c1c7954:	e0823003 	add	r3, r2, r3
 c1c7958:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c795c:	e1a00002 	mov	r0, r2
 c1c7960:	e1a01003 	mov	r1, r3
 c1c7964:	eb000d17 	bl	c1cadc8 <at24c04_byteread>

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7968:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c796c:	e2833001 	add	r3, r3, #1
 c1c7970:	e14b30be 	strh	r3, [fp, #-14]
 c1c7974:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7978:	e59f347c 	ldr	r3, [pc, #1148]	; c1c7dfc <Image_ZI_Limit+0x4d4>
 c1c797c:	e1520003 	cmp	r2, r3
 c1c7980:	9afffff1 	bls	c1c794c <test_EEPROM+0x24>
		at24c04_byteread( i, &buffer[i] );
	uart0_puts( " - Lectura aleatoria (" );
 c1c7984:	e59f0474 	ldr	r0, [pc, #1140]	; c1c7e00 <Image_ZI_Limit+0x4d8>
 c1c7988:	eb001fd3 	bl	c1cf8dc <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c1c798c:	e3a00c02 	mov	r0, #512	; 0x200
 c1c7990:	eb001fe5 	bl	c1cf92c <uart0_putint>
	uart0_puts( " bytes)\n" );
 c1c7994:	e59f0468 	ldr	r0, [pc, #1128]	; c1c7e04 <Image_ZI_Limit+0x4dc>
 c1c7998:	eb001fcf 	bl	c1cf8dc <uart0_puts>

	/************************************/
	at24c04_load( buffer_aux );
 c1c799c:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c1c79a0:	e243300c 	sub	r3, r3, #12
 c1c79a4:	e243300c 	sub	r3, r3, #12
 c1c79a8:	e1a00003 	mov	r0, r3
 c1c79ac:	eb000d35 	bl	c1cae88 <at24c04_load>
	uart0_puts( " - Lectura secuencial (" );
 c1c79b0:	e59f0450 	ldr	r0, [pc, #1104]	; c1c7e08 <Image_ZI_Limit+0x4e0>
 c1c79b4:	eb001fc8 	bl	c1cf8dc <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c1c79b8:	e3a00c02 	mov	r0, #512	; 0x200
 c1c79bc:	eb001fda 	bl	c1cf92c <uart0_putint>
	uart0_puts( " bytes)" );
 c1c79c0:	e59f0444 	ldr	r0, [pc, #1092]	; c1c7e0c <Image_ZI_Limit+0x4e4>
 c1c79c4:	eb001fc4 	bl	c1cf8dc <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c79c8:	e3a03000 	mov	r3, #0
 c1c79cc:	e14b30be 	strh	r3, [fp, #-14]
 c1c79d0:	ea000012 	b	c1c7a20 <test_EEPROM+0xf8>
		if( buffer[i] != buffer_aux[i] )
 c1c79d4:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c79d8:	e59f3430 	ldr	r3, [pc, #1072]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c79dc:	e24b000c 	sub	r0, fp, #12
 c1c79e0:	e0802002 	add	r2, r0, r2
 c1c79e4:	e0823003 	add	r3, r2, r3
 c1c79e8:	e5d32000 	ldrb	r2, [r3]
 c1c79ec:	e15b10be 	ldrh	r1, [fp, #-14]
 c1c79f0:	e59f341c 	ldr	r3, [pc, #1052]	; c1c7e14 <Image_ZI_Limit+0x4ec>
 c1c79f4:	e24b000c 	sub	r0, fp, #12
 c1c79f8:	e0801001 	add	r1, r0, r1
 c1c79fc:	e0813003 	add	r3, r1, r3
 c1c7a00:	e5d33000 	ldrb	r3, [r3]
 c1c7a04:	e1520003 	cmp	r2, r3
 c1c7a08:	0a000001 	beq	c1c7a14 <test_EEPROM+0xec>
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );
 c1c7a0c:	e59f0404 	ldr	r0, [pc, #1028]	; c1c7e18 <Image_ZI_Limit+0x4f0>
 c1c7a10:	eb001fb1 	bl	c1cf8dc <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7a14:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7a18:	e2833001 	add	r3, r3, #1
 c1c7a1c:	e14b30be 	strh	r3, [fp, #-14]
 c1c7a20:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7a24:	e59f33d0 	ldr	r3, [pc, #976]	; c1c7dfc <Image_ZI_Limit+0x4d4>
 c1c7a28:	e1520003 	cmp	r2, r3
 c1c7a2c:	9affffe8 	bls	c1c79d4 <test_EEPROM+0xac>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );
 c1c7a30:	e59f03e4 	ldr	r0, [pc, #996]	; c1c7e1c <Image_ZI_Limit+0x4f4>
 c1c7a34:	eb001fa8 	bl	c1cf8dc <uart0_puts>

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c1c7a38:	e3a03000 	mov	r3, #0
 c1c7a3c:	e14b30be 	strh	r3, [fp, #-14]
 c1c7a40:	ea000066 	b	c1c7be0 <test_EEPROM+0x2b8>
		uart0_puts( "\n" );
 c1c7a44:	e59f03d4 	ldr	r0, [pc, #980]	; c1c7e20 <Image_ZI_Limit+0x4f8>
 c1c7a48:	eb001fa3 	bl	c1cf8dc <uart0_puts>
		if( i<<4 <= 0xf )
 c1c7a4c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7a50:	e1a03203 	lsl	r3, r3, #4
 c1c7a54:	e353000f 	cmp	r3, #15
 c1c7a58:	ca000002 	bgt	c1c7a68 <test_EEPROM+0x140>
			uart0_puts( "00" );
 c1c7a5c:	e59f03c0 	ldr	r0, [pc, #960]	; c1c7e24 <Image_ZI_Limit+0x4fc>
 c1c7a60:	eb001f9d 	bl	c1cf8dc <uart0_puts>
 c1c7a64:	ea000005 	b	c1c7a80 <test_EEPROM+0x158>
		else if( i<<4 <= 0xff )
 c1c7a68:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7a6c:	e1a03203 	lsl	r3, r3, #4
 c1c7a70:	e35300ff 	cmp	r3, #255	; 0xff
 c1c7a74:	ca000001 	bgt	c1c7a80 <test_EEPROM+0x158>
			uart0_putchar( '0' );
 c1c7a78:	e3a00030 	mov	r0, #48	; 0x30
 c1c7a7c:	eb001f70 	bl	c1cf844 <uart0_putchar>
		uart0_puthex( i<<4 );
 c1c7a80:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7a84:	e1a03203 	lsl	r3, r3, #4
 c1c7a88:	e1a00003 	mov	r0, r3
 c1c7a8c:	eb001fe6 	bl	c1cfa2c <uart0_puthex>
		uart0_puts( "h:"  );
 c1c7a90:	e59f0390 	ldr	r0, [pc, #912]	; c1c7e28 <Image_ZI_Limit+0x500>
 c1c7a94:	eb001f90 	bl	c1cf8dc <uart0_puts>
		for( j=0; j<16; j++ )
 c1c7a98:	e3a03000 	mov	r3, #0
 c1c7a9c:	e14b31b0 	strh	r3, [fp, #-16]
 c1c7aa0:	ea00001a 	b	c1c7b10 <test_EEPROM+0x1e8>
		{
			if( buffer[(i<<4)+j] <= 0xf )
 c1c7aa4:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7aa8:	e1a02203 	lsl	r2, r3, #4
 c1c7aac:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7ab0:	e0822003 	add	r2, r2, r3
 c1c7ab4:	e59f3354 	ldr	r3, [pc, #852]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7ab8:	e24b100c 	sub	r1, fp, #12
 c1c7abc:	e0812002 	add	r2, r1, r2
 c1c7ac0:	e0823003 	add	r3, r2, r3
 c1c7ac4:	e5d33000 	ldrb	r3, [r3]
 c1c7ac8:	e353000f 	cmp	r3, #15
 c1c7acc:	8a000001 	bhi	c1c7ad8 <test_EEPROM+0x1b0>
				uart0_putchar( '0' );
 c1c7ad0:	e3a00030 	mov	r0, #48	; 0x30
 c1c7ad4:	eb001f5a 	bl	c1cf844 <uart0_putchar>
			uart0_puthex( buffer[(i<<4)+j] );
 c1c7ad8:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7adc:	e1a02203 	lsl	r2, r3, #4
 c1c7ae0:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7ae4:	e0822003 	add	r2, r2, r3
 c1c7ae8:	e59f3320 	ldr	r3, [pc, #800]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7aec:	e24b000c 	sub	r0, fp, #12
 c1c7af0:	e0802002 	add	r2, r0, r2
 c1c7af4:	e0823003 	add	r3, r2, r3
 c1c7af8:	e5d33000 	ldrb	r3, [r3]
 c1c7afc:	e1a00003 	mov	r0, r3
 c1c7b00:	eb001fc9 	bl	c1cfa2c <uart0_puthex>
			uart0_puts( "00" );
		else if( i<<4 <= 0xff )
			uart0_putchar( '0' );
		uart0_puthex( i<<4 );
		uart0_puts( "h:"  );
		for( j=0; j<16; j++ )
 c1c7b04:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7b08:	e2833001 	add	r3, r3, #1
 c1c7b0c:	e14b31b0 	strh	r3, [fp, #-16]
 c1c7b10:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7b14:	e353000f 	cmp	r3, #15
 c1c7b18:	9affffe1 	bls	c1c7aa4 <test_EEPROM+0x17c>
		{
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
 c1c7b1c:	e59f0308 	ldr	r0, [pc, #776]	; c1c7e2c <Image_ZI_Limit+0x504>
 c1c7b20:	eb001f6d 	bl	c1cf8dc <uart0_puts>
		for( j=0; j<16; j++ )
 c1c7b24:	e3a03000 	mov	r3, #0
 c1c7b28:	e14b31b0 	strh	r3, [fp, #-16]
 c1c7b2c:	ea000025 	b	c1c7bc8 <test_EEPROM+0x2a0>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
 c1c7b30:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7b34:	e1a02203 	lsl	r2, r3, #4
 c1c7b38:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7b3c:	e0822003 	add	r2, r2, r3
 c1c7b40:	e59f32c8 	ldr	r3, [pc, #712]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7b44:	e24b100c 	sub	r1, fp, #12
 c1c7b48:	e0812002 	add	r2, r1, r2
 c1c7b4c:	e0823003 	add	r3, r2, r3
 c1c7b50:	e5d33000 	ldrb	r3, [r3]
 c1c7b54:	e353001f 	cmp	r3, #31
 c1c7b58:	9a000014 	bls	c1c7bb0 <test_EEPROM+0x288>
 c1c7b5c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7b60:	e1a02203 	lsl	r2, r3, #4
 c1c7b64:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7b68:	e0822003 	add	r2, r2, r3
 c1c7b6c:	e59f329c 	ldr	r3, [pc, #668]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7b70:	e24b000c 	sub	r0, fp, #12
 c1c7b74:	e0802002 	add	r2, r0, r2
 c1c7b78:	e0823003 	add	r3, r2, r3
 c1c7b7c:	e5d33000 	ldrb	r3, [r3]
 c1c7b80:	e353007e 	cmp	r3, #126	; 0x7e
 c1c7b84:	8a000009 	bhi	c1c7bb0 <test_EEPROM+0x288>
 c1c7b88:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7b8c:	e1a02203 	lsl	r2, r3, #4
 c1c7b90:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7b94:	e0822003 	add	r2, r2, r3
 c1c7b98:	e59f3270 	ldr	r3, [pc, #624]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7b9c:	e24b100c 	sub	r1, fp, #12
 c1c7ba0:	e0812002 	add	r2, r1, r2
 c1c7ba4:	e0823003 	add	r3, r2, r3
 c1c7ba8:	e5d33000 	ldrb	r3, [r3]
 c1c7bac:	ea000000 	b	c1c7bb4 <test_EEPROM+0x28c>
 c1c7bb0:	e3a0302e 	mov	r3, #46	; 0x2e
 c1c7bb4:	e1a00003 	mov	r0, r3
 c1c7bb8:	eb001f21 	bl	c1cf844 <uart0_putchar>
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
		for( j=0; j<16; j++ )
 c1c7bbc:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7bc0:	e2833001 	add	r3, r3, #1
 c1c7bc4:	e14b31b0 	strh	r3, [fp, #-16]
 c1c7bc8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1c7bcc:	e353000f 	cmp	r3, #15
 c1c7bd0:	9affffd6 	bls	c1c7b30 <test_EEPROM+0x208>

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c1c7bd4:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7bd8:	e2833001 	add	r3, r3, #1
 c1c7bdc:	e14b30be 	strh	r3, [fp, #-14]
 c1c7be0:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7be4:	e353001f 	cmp	r3, #31
 c1c7be8:	9affff95 	bls	c1c7a44 <test_EEPROM+0x11c>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
	};

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );
 c1c7bec:	e59f023c 	ldr	r0, [pc, #572]	; c1c7e30 <Image_ZI_Limit+0x508>
 c1c7bf0:	eb001f39 	bl	c1cf8dc <uart0_puts>

	for( i=0; i<5; i++ )
 c1c7bf4:	e3a03000 	mov	r3, #0
 c1c7bf8:	e14b30be 	strh	r3, [fp, #-14]
 c1c7bfc:	ea000012 	b	c1c7c4c <test_EEPROM+0x324>
	{
		uart0_puts( "  - Introduzca una direccion (0h-1ffh): " );
 c1c7c00:	e59f022c 	ldr	r0, [pc, #556]	; c1c7e34 <Image_ZI_Limit+0x50c>
 c1c7c04:	eb001f34 	bl	c1cf8dc <uart0_puts>
		addr = uart0_gethex( );
 c1c7c08:	eb002006 	bl	c1cfc28 <uart0_gethex>
 c1c7c0c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
		uart0_puts( "  - Introduzca el dato (0h-ffh): " );
 c1c7c10:	e59f0220 	ldr	r0, [pc, #544]	; c1c7e38 <Image_ZI_Limit+0x510>
 c1c7c14:	eb001f30 	bl	c1cf8dc <uart0_puts>
		data = uart0_gethex( );
 c1c7c18:	eb002002 	bl	c1cfc28 <uart0_gethex>
 c1c7c1c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
		buffer[addr] = data;
 c1c7c20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1c7c24:	e20320ff 	and	r2, r3, #255	; 0xff
 c1c7c28:	e59f31e0 	ldr	r3, [pc, #480]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7c2c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c1c7c30:	e24b000c 	sub	r0, fp, #12
 c1c7c34:	e0801001 	add	r1, r0, r1
 c1c7c38:	e0813003 	add	r3, r1, r3
 c1c7c3c:	e5c32000 	strb	r2, [r3]

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i<5; i++ )
 c1c7c40:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7c44:	e2833001 	add	r3, r3, #1
 c1c7c48:	e14b30be 	strh	r3, [fp, #-14]
 c1c7c4c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7c50:	e3530004 	cmp	r3, #4
 c1c7c54:	9affffe9 	bls	c1c7c00 <test_EEPROM+0x2d8>
		buffer[addr] = data;
	}

	/************************************/

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );
 c1c7c58:	e59f01dc 	ldr	r0, [pc, #476]	; c1c7e3c <Image_ZI_Limit+0x514>
 c1c7c5c:	eb001f1e 	bl	c1cf8dc <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7c60:	e3a03000 	mov	r3, #0
 c1c7c64:	e14b30be 	strh	r3, [fp, #-14]
 c1c7c68:	ea00000c 	b	c1c7ca0 <test_EEPROM+0x378>
		at24c04_bytewrite( i, buffer[i] );
 c1c7c6c:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7c70:	e59f3198 	ldr	r3, [pc, #408]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7c74:	e24b100c 	sub	r1, fp, #12
 c1c7c78:	e0812002 	add	r2, r1, r2
 c1c7c7c:	e0823003 	add	r3, r2, r3
 c1c7c80:	e5d33000 	ldrb	r3, [r3]
 c1c7c84:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7c88:	e1a00002 	mov	r0, r2
 c1c7c8c:	e1a01003 	mov	r1, r3
 c1c7c90:	eb000c29 	bl	c1cad3c <at24c04_bytewrite>

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7c94:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7c98:	e2833001 	add	r3, r3, #1
 c1c7c9c:	e14b30be 	strh	r3, [fp, #-14]
 c1c7ca0:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7ca4:	e59f3150 	ldr	r3, [pc, #336]	; c1c7dfc <Image_ZI_Limit+0x4d4>
 c1c7ca8:	e1520003 	cmp	r2, r3
 c1c7cac:	9affffee 	bls	c1c7c6c <test_EEPROM+0x344>
		at24c04_bytewrite( i, buffer[i] );
	uart0_puts( " - Escritura aleatoria (" );
 c1c7cb0:	e59f0188 	ldr	r0, [pc, #392]	; c1c7e40 <Image_ZI_Limit+0x518>
 c1c7cb4:	eb001f08 	bl	c1cf8dc <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c1c7cb8:	e3a00c02 	mov	r0, #512	; 0x200
 c1c7cbc:	eb001f1a 	bl	c1cf92c <uart0_putint>
	uart0_puts( " bytes)\n" );
 c1c7cc0:	e59f013c 	ldr	r0, [pc, #316]	; c1c7e04 <Image_ZI_Limit+0x4dc>
 c1c7cc4:	eb001f04 	bl	c1cf8dc <uart0_puts>

	at24c04_load( buffer_aux );
 c1c7cc8:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c1c7ccc:	e243300c 	sub	r3, r3, #12
 c1c7cd0:	e243300c 	sub	r3, r3, #12
 c1c7cd4:	e1a00003 	mov	r0, r3
 c1c7cd8:	eb000c6a 	bl	c1cae88 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7cdc:	e3a03000 	mov	r3, #0
 c1c7ce0:	e14b30be 	strh	r3, [fp, #-14]
 c1c7ce4:	ea000012 	b	c1c7d34 <test_EEPROM+0x40c>
		if( buffer[i] != buffer_aux[i] )
 c1c7ce8:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7cec:	e59f311c 	ldr	r3, [pc, #284]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7cf0:	e24b000c 	sub	r0, fp, #12
 c1c7cf4:	e0802002 	add	r2, r0, r2
 c1c7cf8:	e0823003 	add	r3, r2, r3
 c1c7cfc:	e5d32000 	ldrb	r2, [r3]
 c1c7d00:	e15b10be 	ldrh	r1, [fp, #-14]
 c1c7d04:	e59f3108 	ldr	r3, [pc, #264]	; c1c7e14 <Image_ZI_Limit+0x4ec>
 c1c7d08:	e24b000c 	sub	r0, fp, #12
 c1c7d0c:	e0801001 	add	r1, r0, r1
 c1c7d10:	e0813003 	add	r3, r1, r3
 c1c7d14:	e5d33000 	ldrb	r3, [r3]
 c1c7d18:	e1520003 	cmp	r2, r3
 c1c7d1c:	0a000001 	beq	c1c7d28 <test_EEPROM+0x400>
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );
 c1c7d20:	e59f011c 	ldr	r0, [pc, #284]	; c1c7e44 <Image_ZI_Limit+0x51c>
 c1c7d24:	eb001eec 	bl	c1cf8dc <uart0_puts>
	uart0_puts( " - Escritura aleatoria (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7d28:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7d2c:	e2833001 	add	r3, r3, #1
 c1c7d30:	e14b30be 	strh	r3, [fp, #-14]
 c1c7d34:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7d38:	e59f30bc 	ldr	r3, [pc, #188]	; c1c7dfc <Image_ZI_Limit+0x4d4>
 c1c7d3c:	e1520003 	cmp	r2, r3
 c1c7d40:	9affffe8 	bls	c1c7ce8 <test_EEPROM+0x3c0>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );

	/************************************/

	at24c04_store( buffer );
 c1c7d44:	e24b3f86 	sub	r3, fp, #536	; 0x218
 c1c7d48:	e1a00003 	mov	r0, r3
 c1c7d4c:	eb000c7b 	bl	c1caf40 <at24c04_store>
	uart0_puts( " - Escritura secuencial (" );
 c1c7d50:	e59f00f0 	ldr	r0, [pc, #240]	; c1c7e48 <Image_ZI_Limit+0x520>
 c1c7d54:	eb001ee0 	bl	c1cf8dc <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c1c7d58:	e3a00c02 	mov	r0, #512	; 0x200
 c1c7d5c:	eb001ef2 	bl	c1cf92c <uart0_putint>
	uart0_puts( " bytes)\n" );
 c1c7d60:	e59f009c 	ldr	r0, [pc, #156]	; c1c7e04 <Image_ZI_Limit+0x4dc>
 c1c7d64:	eb001edc 	bl	c1cf8dc <uart0_puts>

	at24c04_load( buffer_aux );
 c1c7d68:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c1c7d6c:	e243300c 	sub	r3, r3, #12
 c1c7d70:	e243300c 	sub	r3, r3, #12
 c1c7d74:	e1a00003 	mov	r0, r3
 c1c7d78:	eb000c42 	bl	c1cae88 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7d7c:	e3a03000 	mov	r3, #0
 c1c7d80:	e14b30be 	strh	r3, [fp, #-14]
 c1c7d84:	ea000012 	b	c1c7dd4 <test_EEPROM+0x4ac>
		if( buffer[i] != buffer_aux[i] )
 c1c7d88:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7d8c:	e59f307c 	ldr	r3, [pc, #124]	; c1c7e10 <Image_ZI_Limit+0x4e8>
 c1c7d90:	e24b100c 	sub	r1, fp, #12
 c1c7d94:	e0812002 	add	r2, r1, r2
 c1c7d98:	e0823003 	add	r3, r2, r3
 c1c7d9c:	e5d32000 	ldrb	r2, [r3]
 c1c7da0:	e15b10be 	ldrh	r1, [fp, #-14]
 c1c7da4:	e59f3068 	ldr	r3, [pc, #104]	; c1c7e14 <Image_ZI_Limit+0x4ec>
 c1c7da8:	e24b000c 	sub	r0, fp, #12
 c1c7dac:	e0801001 	add	r1, r0, r1
 c1c7db0:	e0813003 	add	r3, r1, r3
 c1c7db4:	e5d33000 	ldrb	r3, [r3]
 c1c7db8:	e1520003 	cmp	r2, r3
 c1c7dbc:	0a000001 	beq	c1c7dc8 <test_EEPROM+0x4a0>
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );
 c1c7dc0:	e59f0084 	ldr	r0, [pc, #132]	; c1c7e4c <Image_ZI_Limit+0x524>
 c1c7dc4:	eb001ec4 	bl	c1cf8dc <uart0_puts>
	uart0_puts( " - Escritura secuencial (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c1c7dc8:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c7dcc:	e2833001 	add	r3, r3, #1
 c1c7dd0:	e14b30be 	strh	r3, [fp, #-14]
 c1c7dd4:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c7dd8:	e59f301c 	ldr	r3, [pc, #28]	; c1c7dfc <Image_ZI_Limit+0x4d4>
 c1c7ddc:	e1520003 	cmp	r2, r3
 c1c7de0:	9affffe8 	bls	c1c7d88 <test_EEPROM+0x460>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );

	/************************************/

	uart0_puts( "\nApague la placa y vuelva a cargar y ejecutar el programa.\n" );
 c1c7de4:	e59f0064 	ldr	r0, [pc, #100]	; c1c7e50 <Image_ZI_Limit+0x528>
 c1c7de8:	eb001ebb 	bl	c1cf8dc <uart0_puts>
}
 c1c7dec:	e24bd00c 	sub	sp, fp, #12
 c1c7df0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c7df4:	e12fff1e 	bx	lr
 c1c7df8:	0c100150 	.word	0x0c100150
 c1c7dfc:	000001ff 	.word	0x000001ff
 c1c7e00:	0c100188 	.word	0x0c100188
 c1c7e04:	0c1001a0 	.word	0x0c1001a0
 c1c7e08:	0c1001ac 	.word	0x0c1001ac
 c1c7e0c:	0c1001c4 	.word	0x0c1001c4
 c1c7e10:	fffffdf4 	.word	0xfffffdf4
 c1c7e14:	fffffbf4 	.word	0xfffffbf4
 c1c7e18:	0c1001cc 	.word	0x0c1001cc
 c1c7e1c:	0c100208 	.word	0x0c100208
 c1c7e20:	0c10024c 	.word	0x0c10024c
 c1c7e24:	0c100250 	.word	0x0c100250
 c1c7e28:	0c100254 	.word	0x0c100254
 c1c7e2c:	0c100258 	.word	0x0c100258
 c1c7e30:	0c10025c 	.word	0x0c10025c
 c1c7e34:	0c10029c 	.word	0x0c10029c
 c1c7e38:	0c1002c8 	.word	0x0c1002c8
 c1c7e3c:	0c1002ec 	.word	0x0c1002ec
 c1c7e40:	0c100328 	.word	0x0c100328
 c1c7e44:	0c100344 	.word	0x0c100344
 c1c7e48:	0c10036c 	.word	0x0c10036c
 c1c7e4c:	0c100388 	.word	0x0c100388
 c1c7e50:	0c1003b0 	.word	0x0c1003b0

0c1c7e54 <test_WAV>:

#define REC_BUFFER      ((int16 *)0x0c700000)
#define REC_SIZE        (320000)  /* (5,0 s) * (2 canales) * (2 B/canal) * (16000 muestras/s) = 320000 B  */

void test_WAV( void )
{
 c1c7e54:	e1a0c00d 	mov	ip, sp
 c1c7e58:	e92dd800 	push	{fp, ip, lr, pc}
 c1c7e5c:	e24cb004 	sub	fp, ip, #4
 c1c7e60:	e24dd008 	sub	sp, sp, #8
    uint8 vol;
    boolean flag;

    uda1341ts_init();
 c1c7e64:	eb001fda 	bl	c1cfdd4 <uda1341ts_init>

    /************************************/

    uart0_puts( "\n\nReproducción de audio no comprimido (estéreo, 16b, 16KHz) por pooling:\n" );
 c1c7e68:	e59f0598 	ldr	r0, [pc, #1432]	; c1c8408 <test_WAV+0x5b4>
 c1c7e6c:	eb001e9a 	bl	c1cf8dc <uart0_puts>

    iis_init( IIS_POLLING );
 c1c7e70:	e3a00002 	mov	r0, #2
 c1c7e74:	eb000f7e 	bl	c1cbc74 <iis_init>

    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche... " );
 c1c7e78:	e59f058c 	ldr	r0, [pc, #1420]	; c1c840c <test_WAV+0x5b8>
 c1c7e7c:	eb001e96 	bl	c1cf8dc <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c1c7e80:	e3a00020 	mov	r0, #32
 c1c7e84:	eb002051 	bl	c1cffd0 <uda1341ts_setvol>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c1c7e88:	e59f0580 	ldr	r0, [pc, #1408]	; c1c8410 <test_WAV+0x5bc>
 c1c7e8c:	e59f1580 	ldr	r1, [pc, #1408]	; c1c8414 <test_WAV+0x5c0>
 c1c7e90:	e3a02000 	mov	r2, #0
 c1c7e94:	eb000ff7 	bl	c1cbe78 <iis_play>
    uart0_puts( "OK\n" );
 c1c7e98:	e59f0578 	ldr	r0, [pc, #1400]	; c1c8418 <test_WAV+0x5c4>
 c1c7e9c:	eb001e8e 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche... " );
 c1c7ea0:	e59f0574 	ldr	r0, [pc, #1396]	; c1c841c <test_WAV+0x5c8>
 c1c7ea4:	eb001e8c 	bl	c1cf8dc <uart0_puts>
    for( vol=0; vol<63; vol++ )
 c1c7ea8:	e3a03000 	mov	r3, #0
 c1c7eac:	e54b300d 	strb	r3, [fp, #-13]
 c1c7eb0:	ea000009 	b	c1c7edc <test_WAV+0x88>
    {
        uda1341ts_setvol( vol );
 c1c7eb4:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7eb8:	e1a00003 	mov	r0, r3
 c1c7ebc:	eb002043 	bl	c1cffd0 <uda1341ts_setvol>
        iis_play( DTMF1, DTMF_SIZE, FALSE );
 c1c7ec0:	e59f0558 	ldr	r0, [pc, #1368]	; c1c8420 <test_WAV+0x5cc>
 c1c7ec4:	e3a01c19 	mov	r1, #6400	; 0x1900
 c1c7ec8:	e3a02000 	mov	r2, #0
 c1c7ecc:	eb000fe9 	bl	c1cbe78 <iis_play>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche... " );
    for( vol=0; vol<63; vol++ )
 c1c7ed0:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7ed4:	e2833001 	add	r3, r3, #1
 c1c7ed8:	e54b300d 	strb	r3, [fp, #-13]
 c1c7edc:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7ee0:	e353003e 	cmp	r3, #62	; 0x3e
 c1c7ee4:	9afffff2 	bls	c1c7eb4 <test_WAV+0x60>
    {
        uda1341ts_setvol( vol );
        iis_play( DTMF1, DTMF_SIZE, FALSE );
    }
    uart0_puts( "OK\n" );
 c1c7ee8:	e59f0528 	ldr	r0, [pc, #1320]	; c1c8418 <test_WAV+0x5c4>
 c1c7eec:	eb001e7a 	bl	c1cf8dc <uart0_puts>
    uda1341ts_setvol( VOL_MAX );
 c1c7ef0:	e3a0003f 	mov	r0, #63	; 0x3f
 c1c7ef4:	eb002035 	bl	c1cffd0 <uda1341ts_setvol>
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
    uart0_puts( "OK\n" );
	*/
    /************************************/

    uart0_puts( "\nReproducción de audio no comprimido (estéreo, 16b, 16KHz) por DMA:\n" );
 c1c7ef8:	e59f0524 	ldr	r0, [pc, #1316]	; c1c8424 <test_WAV+0x5d0>
 c1c7efc:	eb001e76 	bl	c1cf8dc <uart0_puts>

    iis_init( IIS_DMA );
 c1c7f00:	e3a00001 	mov	r0, #1
 c1c7f04:	eb000f5a 	bl	c1cbc74 <iis_init>

    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche..." );
 c1c7f08:	e59f0518 	ldr	r0, [pc, #1304]	; c1c8428 <test_WAV+0x5d4>
 c1c7f0c:	eb001e72 	bl	c1cf8dc <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c1c7f10:	e3a00020 	mov	r0, #32
 c1c7f14:	eb00202d 	bl	c1cffd0 <uda1341ts_setvol>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c1c7f18:	e59f04f0 	ldr	r0, [pc, #1264]	; c1c8410 <test_WAV+0x5bc>
 c1c7f1c:	e59f14f0 	ldr	r1, [pc, #1264]	; c1c8414 <test_WAV+0x5c0>
 c1c7f20:	e3a02000 	mov	r2, #0
 c1c7f24:	eb000fd3 	bl	c1cbe78 <iis_play>
    while( iis_status() )
 c1c7f28:	ea000003 	b	c1c7f3c <test_WAV+0xe8>
    {
        Delay(500);
 c1c7f2c:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c1c7f30:	eb002048 	bl	c1d0058 <Delay>
        uart0_putchar( '.' );
 c1c7f34:	e3a0002e 	mov	r0, #46	; 0x2e
 c1c7f38:	eb001e41 	bl	c1cf844 <uart0_putchar>
    /************************************/

    uart0_puts( "  - Reproducción a volumen medio: escuche..." );
    uda1341ts_setvol( VOL_MED );
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
    while( iis_status() )
 c1c7f3c:	eb0010a2 	bl	c1cc1cc <iis_status>
 c1c7f40:	e1a03000 	mov	r3, r0
 c1c7f44:	e3530000 	cmp	r3, #0
 c1c7f48:	1afffff7 	bne	c1c7f2c <test_WAV+0xd8>
    {
        Delay(500);
        uart0_putchar( '.' );
    }
    uart0_puts( " OK\n" );
 c1c7f4c:	e59f04d8 	ldr	r0, [pc, #1240]	; c1c842c <test_WAV+0x5d8>
 c1c7f50:	eb001e61 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche..." );
 c1c7f54:	e59f04d4 	ldr	r0, [pc, #1236]	; c1c8430 <test_WAV+0x5dc>
 c1c7f58:	eb001e5f 	bl	c1cf8dc <uart0_puts>
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
 c1c7f5c:	e59f04ac 	ldr	r0, [pc, #1196]	; c1c8410 <test_WAV+0x5bc>
 c1c7f60:	e59f14ac 	ldr	r1, [pc, #1196]	; c1c8414 <test_WAV+0x5c0>
 c1c7f64:	e3a02000 	mov	r2, #0
 c1c7f68:	eb000fc2 	bl	c1cbe78 <iis_play>
    vol = 0;
 c1c7f6c:	e3a03000 	mov	r3, #0
 c1c7f70:	e54b300d 	strb	r3, [fp, #-13]
    while( iis_status() )
 c1c7f74:	ea00000d 	b	c1c7fb0 <test_WAV+0x15c>
    {
        uda1341ts_setvol( vol );
 c1c7f78:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7f7c:	e1a00003 	mov	r0, r3
 c1c7f80:	eb002012 	bl	c1cffd0 <uda1341ts_setvol>
        vol = ( vol != 63 ? vol+1 : 0 );
 c1c7f84:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7f88:	e353003f 	cmp	r3, #63	; 0x3f
 c1c7f8c:	0a000003 	beq	c1c7fa0 <test_WAV+0x14c>
 c1c7f90:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c7f94:	e2833001 	add	r3, r3, #1
 c1c7f98:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c7f9c:	ea000000 	b	c1c7fa4 <test_WAV+0x150>
 c1c7fa0:	e3a03000 	mov	r3, #0
 c1c7fa4:	e54b300d 	strb	r3, [fp, #-13]
        Delay( 20 );
 c1c7fa8:	e3a00014 	mov	r0, #20
 c1c7fac:	eb002029 	bl	c1d0058 <Delay>
    /************************************/

    uart0_puts( "  - Reproducción a volumen variable: escuche..." );
    iis_play( NOKIATUNE, NOKIATUNE_SIZE, FALSE );
    vol = 0;
    while( iis_status() )
 c1c7fb0:	eb001085 	bl	c1cc1cc <iis_status>
 c1c7fb4:	e1a03000 	mov	r3, r0
 c1c7fb8:	e3530000 	cmp	r3, #0
 c1c7fbc:	1affffed 	bne	c1c7f78 <test_WAV+0x124>
    {
        uda1341ts_setvol( vol );
        vol = ( vol != 63 ? vol+1 : 0 );
        Delay( 20 );
    }
    uart0_puts( " OK\n" );
 c1c7fc0:	e59f0464 	ldr	r0, [pc, #1124]	; c1c842c <test_WAV+0x5d8>
 c1c7fc4:	eb001e44 	bl	c1cf8dc <uart0_puts>
    uda1341ts_setvol( VOL_MAX );
 c1c7fc8:	e3a0003f 	mov	r0, #63	; 0x3f
 c1c7fcc:	eb001fff 	bl	c1cffd0 <uda1341ts_setvol>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos..." );
 c1c7fd0:	e59f045c 	ldr	r0, [pc, #1116]	; c1c8434 <test_WAV+0x5e0>
 c1c7fd4:	eb001e40 	bl	c1cf8dc <uart0_puts>
    D8Led_digit( 8 );
 c1c7fd8:	e3a00008 	mov	r0, #8
 c1c7fdc:	eb0009b9 	bl	c1ca6c8 <D8Led_digit>
    iis_rec( REC_BUFFER, REC_SIZE );
 c1c7fe0:	e3a006c7 	mov	r0, #208666624	; 0xc700000
 c1c7fe4:	e59f144c 	ldr	r1, [pc, #1100]	; c1c8438 <test_WAV+0x5e4>
 c1c7fe8:	eb00100e 	bl	c1cc028 <iis_rec>
    while( iis_status() )
 c1c7fec:	ea000003 	b	c1c8000 <test_WAV+0x1ac>
    {
        Delay( 500 );
 c1c7ff0:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c1c7ff4:	eb002017 	bl	c1d0058 <Delay>
        uart0_putchar( '.' );
 c1c7ff8:	e3a0002e 	mov	r0, #46	; 0x2e
 c1c7ffc:	eb001e10 	bl	c1cf844 <uart0_putchar>
    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos..." );
    D8Led_digit( 8 );
    iis_rec( REC_BUFFER, REC_SIZE );
    while( iis_status() )
 c1c8000:	eb001071 	bl	c1cc1cc <iis_status>
 c1c8004:	e1a03000 	mov	r3, r0
 c1c8008:	e3530000 	cmp	r3, #0
 c1c800c:	1afffff7 	bne	c1c7ff0 <test_WAV+0x19c>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    D8Led_off();
 c1c8010:	eb00098c 	bl	c1ca648 <D8Led_off>
    uart0_puts( " OK\n" );
 c1c8014:	e59f0410 	ldr	r0, [pc, #1040]	; c1c842c <test_WAV+0x5d8>
 c1c8018:	eb001e2f 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "  - Reproducción de grabación: escuche..." );
 c1c801c:	e59f0418 	ldr	r0, [pc, #1048]	; c1c843c <test_WAV+0x5e8>
 c1c8020:	eb001e2d 	bl	c1cf8dc <uart0_puts>
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
 c1c8024:	e3a006c7 	mov	r0, #208666624	; 0xc700000
 c1c8028:	e59f1408 	ldr	r1, [pc, #1032]	; c1c8438 <test_WAV+0x5e4>
 c1c802c:	e3a02000 	mov	r2, #0
 c1c8030:	eb000f90 	bl	c1cbe78 <iis_play>
    while( iis_status() )
 c1c8034:	ea000003 	b	c1c8048 <test_WAV+0x1f4>
    {
        Delay( 500 );
 c1c8038:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c1c803c:	eb002005 	bl	c1d0058 <Delay>
        uart0_putchar( '.' );
 c1c8040:	e3a0002e 	mov	r0, #46	; 0x2e
 c1c8044:	eb001dfe 	bl	c1cf844 <uart0_putchar>
    }
    D8Led_off();
    uart0_puts( " OK\n" );
    uart0_puts( "  - Reproducción de grabación: escuche..." );
    iis_play( REC_BUFFER, REC_SIZE, FALSE );
    while( iis_status() )
 c1c8048:	eb00105f 	bl	c1cc1cc <iis_status>
 c1c804c:	e1a03000 	mov	r3, r0
 c1c8050:	e3530000 	cmp	r3, #0
 c1c8054:	1afffff7 	bne	c1c8038 <test_WAV+0x1e4>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    uart0_puts( " OK\n" );
 c1c8058:	e59f03cc 	ldr	r0, [pc, #972]	; c1c842c <test_WAV+0x5d8>
 c1c805c:	eb001e1e 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua: escuche...\n" );
 c1c8060:	e59f03d8 	ldr	r0, [pc, #984]	; c1c8440 <test_WAV+0x5ec>
 c1c8064:	eb001e1c 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "    (para finalizar presione cualquier tecla)\n    " );
 c1c8068:	e59f03d4 	ldr	r0, [pc, #980]	; c1c8444 <test_WAV+0x5f0>
 c1c806c:	eb001e1a 	bl	c1cf8dc <uart0_puts>
    uda1341ts_setvol( VOL_MED );
 c1c8070:	e3a00020 	mov	r0, #32
 c1c8074:	eb001fd5 	bl	c1cffd0 <uda1341ts_setvol>
    iis_playWawFile( NOKIATUNE, TRUE );
 c1c8078:	e59f0390 	ldr	r0, [pc, #912]	; c1c8410 <test_WAV+0x5bc>
 c1c807c:	e3a01001 	mov	r1, #1
 c1c8080:	eb00105e 	bl	c1cc200 <iis_playWawFile>
    while( kb_scan() < 0 )
 c1c8084:	ea000003 	b	c1c8098 <test_WAV+0x244>
    {
        Delay( 500 );
 c1c8088:	e3a00f7d 	mov	r0, #500	; 0x1f4
 c1c808c:	eb001ff1 	bl	c1d0058 <Delay>
        uart0_putchar( '.' );
 c1c8090:	e3a0002e 	mov	r0, #46	; 0x2e
 c1c8094:	eb001dea 	bl	c1cf844 <uart0_putchar>

    uart0_puts( "  - Reproducción continua: escuche...\n" );
    uart0_puts( "    (para finalizar presione cualquier tecla)\n    " );
    uda1341ts_setvol( VOL_MED );
    iis_playWawFile( NOKIATUNE, TRUE );
    while( kb_scan() < 0 )
 c1c8098:	eb0011c8 	bl	c1cc7c0 <kb_scan>
 c1c809c:	e1a03000 	mov	r3, r0
 c1c80a0:	e3530000 	cmp	r3, #0
 c1c80a4:	bafffff7 	blt	c1c8088 <test_WAV+0x234>
    {
        Delay( 500 );
        uart0_putchar( '.' );
    }
    uart0_puts("Introduce un entero:");
 c1c80a8:	e59f0398 	ldr	r0, [pc, #920]	; c1c8448 <test_WAV+0x5f4>
 c1c80ac:	eb001e0a 	bl	c1cf8dc <uart0_puts>
    uart0_getint();
 c1c80b0:	eb001ea6 	bl	c1cfb50 <uart0_getint>
    iis_pause();
 c1c80b4:	eb00102c 	bl	c1cc16c <iis_pause>
    uart0_puts( " OK\n" );
 c1c80b8:	e59f036c 	ldr	r0, [pc, #876]	; c1c842c <test_WAV+0x5d8>
 c1c80bc:	eb001e06 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua con pause: escuche...\n" );
 c1c80c0:	e59f0384 	ldr	r0, [pc, #900]	; c1c844c <test_WAV+0x5f8>
 c1c80c4:	eb001e04 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
 c1c80c8:	e59f0380 	ldr	r0, [pc, #896]	; c1c8450 <test_WAV+0x5fc>
 c1c80cc:	eb001e02 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
 c1c80d0:	e59f037c 	ldr	r0, [pc, #892]	; c1c8454 <test_WAV+0x600>
 c1c80d4:	eb001e00 	bl	c1cf8dc <uart0_puts>
    iis_playWawFile( NOKIATUNE, TRUE );
 c1c80d8:	e59f0330 	ldr	r0, [pc, #816]	; c1c8410 <test_WAV+0x5bc>
 c1c80dc:	e3a01001 	mov	r1, #1
 c1c80e0:	eb001046 	bl	c1cc200 <iis_playWawFile>
    flag = FALSE;
 c1c80e4:	e3a03000 	mov	r3, #0
 c1c80e8:	e54b300e 	strb	r3, [fp, #-14]
    while( kb_scan() < 0 )
 c1c80ec:	ea00000e 	b	c1c812c <test_WAV+0x2d8>
    {
        if( flag )
 c1c80f0:	e55b300e 	ldrb	r3, [fp, #-14]
 c1c80f4:	e3530000 	cmp	r3, #0
 c1c80f8:	0a000003 	beq	c1c810c <test_WAV+0x2b8>
        {
            iis_continue();
 c1c80fc:	eb001026 	bl	c1cc19c <iis_continue>
            uart0_puts( "    PLAY\n" );
 c1c8100:	e59f0350 	ldr	r0, [pc, #848]	; c1c8458 <test_WAV+0x604>
 c1c8104:	eb001df4 	bl	c1cf8dc <uart0_puts>
 c1c8108:	ea000002 	b	c1c8118 <test_WAV+0x2c4>
        }
        else
        {
           iis_pause();
 c1c810c:	eb001016 	bl	c1cc16c <iis_pause>
           uart0_puts( "    PAUSE\n" );
 c1c8110:	e59f0344 	ldr	r0, [pc, #836]	; c1c845c <test_WAV+0x608>
 c1c8114:	eb001df0 	bl	c1cf8dc <uart0_puts>
        }
        flag = !flag;
 c1c8118:	e55b300e 	ldrb	r3, [fp, #-14]
 c1c811c:	e3530000 	cmp	r3, #0
 c1c8120:	13a03000 	movne	r3, #0
 c1c8124:	03a03001 	moveq	r3, #1
 c1c8128:	e54b300e 	strb	r3, [fp, #-14]
    uart0_puts( "  - Reproducción continua con pause: escuche...\n" );
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
    iis_playWawFile( NOKIATUNE, TRUE );
    flag = FALSE;
    while( kb_scan() < 0 )
 c1c812c:	eb0011a3 	bl	c1cc7c0 <kb_scan>
 c1c8130:	e1a03000 	mov	r3, r0
 c1c8134:	e3530000 	cmp	r3, #0
 c1c8138:	baffffec 	blt	c1c80f0 <test_WAV+0x29c>
           iis_pause();
           uart0_puts( "    PAUSE\n" );
        }
        flag = !flag;
    };
    iis_pause();
 c1c813c:	eb00100a 	bl	c1cc16c <iis_pause>
    uart0_puts( "    ... OK\n" );
 c1c8140:	e59f0318 	ldr	r0, [pc, #792]	; c1c8460 <test_WAV+0x60c>
 c1c8144:	eb001de4 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción continua con mute: escuche...\n" );
 c1c8148:	e59f0314 	ldr	r0, [pc, #788]	; c1c8464 <test_WAV+0x610>
 c1c814c:	eb001de2 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
 c1c8150:	e59f02f8 	ldr	r0, [pc, #760]	; c1c8450 <test_WAV+0x5fc>
 c1c8154:	eb001de0 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
 c1c8158:	e59f02f4 	ldr	r0, [pc, #756]	; c1c8454 <test_WAV+0x600>
 c1c815c:	eb001dde 	bl	c1cf8dc <uart0_puts>
    iis_playWawFile( NOKIATUNE, TRUE );
 c1c8160:	e59f02a8 	ldr	r0, [pc, #680]	; c1c8410 <test_WAV+0x5bc>
 c1c8164:	e3a01001 	mov	r1, #1
 c1c8168:	eb001024 	bl	c1cc200 <iis_playWawFile>
    flag = FALSE;
 c1c816c:	e3a03000 	mov	r3, #0
 c1c8170:	e54b300e 	strb	r3, [fp, #-14]
    while( kb_scan() < 0 )
 c1c8174:	ea000010 	b	c1c81bc <test_WAV+0x368>
    {
        if( flag )
 c1c8178:	e55b300e 	ldrb	r3, [fp, #-14]
 c1c817c:	e3530000 	cmp	r3, #0
 c1c8180:	0a000004 	beq	c1c8198 <test_WAV+0x344>
        {
            uda1341ts_mute( MUTE_OFF );
 c1c8184:	e3a00000 	mov	r0, #0
 c1c8188:	eb001f30 	bl	c1cfe50 <uda1341ts_mute>
            uart0_puts( "    MUTE OFF\n" );
 c1c818c:	e59f02d4 	ldr	r0, [pc, #724]	; c1c8468 <test_WAV+0x614>
 c1c8190:	eb001dd1 	bl	c1cf8dc <uart0_puts>
 c1c8194:	ea000003 	b	c1c81a8 <test_WAV+0x354>
        }
        else
        {
            uda1341ts_mute( MUTE_ON );
 c1c8198:	e3a00001 	mov	r0, #1
 c1c819c:	eb001f2b 	bl	c1cfe50 <uda1341ts_mute>
            uart0_puts( "    MUTE ON\n" );
 c1c81a0:	e59f02c4 	ldr	r0, [pc, #708]	; c1c846c <test_WAV+0x618>
 c1c81a4:	eb001dcc 	bl	c1cf8dc <uart0_puts>
        }
        flag = !flag;
 c1c81a8:	e55b300e 	ldrb	r3, [fp, #-14]
 c1c81ac:	e3530000 	cmp	r3, #0
 c1c81b0:	13a03000 	movne	r3, #0
 c1c81b4:	03a03001 	moveq	r3, #1
 c1c81b8:	e54b300e 	strb	r3, [fp, #-14]
    uart0_puts( "  - Reproducción continua con mute: escuche...\n" );
    uart0_puts( "    (para finalizar presione la tecla 0)\n" );
    uart0_puts( "    (para parar/continuar presione cualquier otra tecla)\n" );
    iis_playWawFile( NOKIATUNE, TRUE );
    flag = FALSE;
    while( kb_scan() < 0 )
 c1c81bc:	eb00117f 	bl	c1cc7c0 <kb_scan>
 c1c81c0:	e1a03000 	mov	r3, r0
 c1c81c4:	e3530000 	cmp	r3, #0
 c1c81c8:	baffffea 	blt	c1c8178 <test_WAV+0x324>
            uda1341ts_mute( MUTE_ON );
            uart0_puts( "    MUTE ON\n" );
        }
        flag = !flag;
    };
    iis_pause();
 c1c81cc:	eb000fe6 	bl	c1cc16c <iis_pause>
    uart0_puts( "    ... OK\n" );
 c1c81d0:	e59f0288 	ldr	r0, [pc, #648]	; c1c8460 <test_WAV+0x60c>
 c1c81d4:	eb001dc0 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproduccion libre de sonido: pulse el teclado y escuche...\n" );
 c1c81d8:	e59f0290 	ldr	r0, [pc, #656]	; c1c8470 <test_WAV+0x61c>
 c1c81dc:	eb001dbe 	bl	c1cf8dc <uart0_puts>
    while( 1 )
        switch( kb_scan() )
 c1c81e0:	eb001176 	bl	c1cc7c0 <kb_scan>
 c1c81e4:	e1a03000 	mov	r3, r0
 c1c81e8:	e353000f 	cmp	r3, #15
 c1c81ec:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c1c81f0:	ea000082 	b	c1c8400 <test_WAV+0x5ac>
 c1c81f4:	0c1c8234 	.word	0x0c1c8234
 c1c81f8:	0c1c8244 	.word	0x0c1c8244
 c1c81fc:	0c1c8254 	.word	0x0c1c8254
 c1c8200:	0c1c8264 	.word	0x0c1c8264
 c1c8204:	0c1c8274 	.word	0x0c1c8274
 c1c8208:	0c1c8284 	.word	0x0c1c8284
 c1c820c:	0c1c8294 	.word	0x0c1c8294
 c1c8210:	0c1c82a4 	.word	0x0c1c82a4
 c1c8214:	0c1c82d8 	.word	0x0c1c82d8
 c1c8218:	0c1c82e8 	.word	0x0c1c82e8
 c1c821c:	0c1c82f8 	.word	0x0c1c82f8
 c1c8220:	0c1c8308 	.word	0x0c1c8308
 c1c8224:	0c1c833c 	.word	0x0c1c833c
 c1c8228:	0c1c834c 	.word	0x0c1c834c
 c1c822c:	0c1c835c 	.word	0x0c1c835c
 c1c8230:	0c1c836c 	.word	0x0c1c836c
        {
            case 0:
                iis_playWawFile( DTMF1, FALSE );
 c1c8234:	e59f01e4 	ldr	r0, [pc, #484]	; c1c8420 <test_WAV+0x5cc>
 c1c8238:	e3a01000 	mov	r1, #0
 c1c823c:	eb000fef 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8240:	ea00006f 	b	c1c8404 <test_WAV+0x5b0>
            case 1:
                iis_playWawFile( DTMF2, FALSE );
 c1c8244:	e59f0228 	ldr	r0, [pc, #552]	; c1c8474 <test_WAV+0x620>
 c1c8248:	e3a01000 	mov	r1, #0
 c1c824c:	eb000feb 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8250:	ea00006b 	b	c1c8404 <test_WAV+0x5b0>
            case 2:
                iis_playWawFile( DTMF3, FALSE );
 c1c8254:	e59f021c 	ldr	r0, [pc, #540]	; c1c8478 <test_WAV+0x624>
 c1c8258:	e3a01000 	mov	r1, #0
 c1c825c:	eb000fe7 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8260:	ea000067 	b	c1c8404 <test_WAV+0x5b0>
            case 3:
                iis_playWawFile( INVITACION, FALSE );
 c1c8264:	e59f0210 	ldr	r0, [pc, #528]	; c1c847c <test_WAV+0x628>
 c1c8268:	e3a01000 	mov	r1, #0
 c1c826c:	eb000fe3 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8270:	ea000063 	b	c1c8404 <test_WAV+0x5b0>
            case 4:
                iis_playWawFile( DTMF4, FALSE );
 c1c8274:	e59f0204 	ldr	r0, [pc, #516]	; c1c8480 <test_WAV+0x62c>
 c1c8278:	e3a01000 	mov	r1, #0
 c1c827c:	eb000fdf 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8280:	ea00005f 	b	c1c8404 <test_WAV+0x5b0>
            case 5:
                iis_playWawFile( DTMF5, FALSE );
 c1c8284:	e59f01f8 	ldr	r0, [pc, #504]	; c1c8484 <test_WAV+0x630>
 c1c8288:	e3a01000 	mov	r1, #0
 c1c828c:	eb000fdb 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8290:	ea00005b 	b	c1c8404 <test_WAV+0x5b0>
            case 6:
                iis_playWawFile( DTMF6, FALSE );
 c1c8294:	e59f01ec 	ldr	r0, [pc, #492]	; c1c8488 <test_WAV+0x634>
 c1c8298:	e3a01000 	mov	r1, #0
 c1c829c:	eb000fd7 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c82a0:	ea000057 	b	c1c8404 <test_WAV+0x5b0>
            case 7:
                iis_playWawFile( LLAMADA, FALSE );
 c1c82a4:	e59f01e0 	ldr	r0, [pc, #480]	; c1c848c <test_WAV+0x638>
 c1c82a8:	e3a01000 	mov	r1, #0
 c1c82ac:	eb000fd3 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c1c82b0:	e59f01d4 	ldr	r0, [pc, #468]	; c1c848c <test_WAV+0x638>
 c1c82b4:	e3a01000 	mov	r1, #0
 c1c82b8:	eb000fd0 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c1c82bc:	e59f01c8 	ldr	r0, [pc, #456]	; c1c848c <test_WAV+0x638>
 c1c82c0:	e3a01000 	mov	r1, #0
 c1c82c4:	eb000fcd 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( LLAMADA, FALSE );
 c1c82c8:	e59f01bc 	ldr	r0, [pc, #444]	; c1c848c <test_WAV+0x638>
 c1c82cc:	e3a01000 	mov	r1, #0
 c1c82d0:	eb000fca 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c82d4:	ea00004a 	b	c1c8404 <test_WAV+0x5b0>
            case 8:
                iis_playWawFile( DTMF7, FALSE );
 c1c82d8:	e59f01b0 	ldr	r0, [pc, #432]	; c1c8490 <test_WAV+0x63c>
 c1c82dc:	e3a01000 	mov	r1, #0
 c1c82e0:	eb000fc6 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c82e4:	ea000046 	b	c1c8404 <test_WAV+0x5b0>
            case 9:
                iis_playWawFile( DTMF8, FALSE );
 c1c82e8:	e59f01a4 	ldr	r0, [pc, #420]	; c1c8494 <test_WAV+0x640>
 c1c82ec:	e3a01000 	mov	r1, #0
 c1c82f0:	eb000fc2 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c82f4:	ea000042 	b	c1c8404 <test_WAV+0x5b0>
            case 0xa:
                iis_playWawFile( DTMF9, FALSE );
 c1c82f8:	e59f0198 	ldr	r0, [pc, #408]	; c1c8498 <test_WAV+0x644>
 c1c82fc:	e3a01000 	mov	r1, #0
 c1c8300:	eb000fbe 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8304:	ea00003e 	b	c1c8404 <test_WAV+0x5b0>
            case 0xb:
                iis_playWawFile( CONGESTION, FALSE );
 c1c8308:	e59f018c 	ldr	r0, [pc, #396]	; c1c849c <test_WAV+0x648>
 c1c830c:	e3a01000 	mov	r1, #0
 c1c8310:	eb000fba 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c1c8314:	e59f0180 	ldr	r0, [pc, #384]	; c1c849c <test_WAV+0x648>
 c1c8318:	e3a01000 	mov	r1, #0
 c1c831c:	eb000fb7 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c1c8320:	e59f0174 	ldr	r0, [pc, #372]	; c1c849c <test_WAV+0x648>
 c1c8324:	e3a01000 	mov	r1, #0
 c1c8328:	eb000fb4 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( CONGESTION, FALSE );
 c1c832c:	e59f0168 	ldr	r0, [pc, #360]	; c1c849c <test_WAV+0x648>
 c1c8330:	e3a01000 	mov	r1, #0
 c1c8334:	eb000fb1 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8338:	ea000031 	b	c1c8404 <test_WAV+0x5b0>
            case 0xc:
                iis_playWawFile( DTMFSTAR, FALSE );
 c1c833c:	e59f015c 	ldr	r0, [pc, #348]	; c1c84a0 <test_WAV+0x64c>
 c1c8340:	e3a01000 	mov	r1, #0
 c1c8344:	eb000fad 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8348:	ea00002d 	b	c1c8404 <test_WAV+0x5b0>
            case 0xd:
                iis_playWawFile( DTMF0, FALSE );
 c1c834c:	e3a00531 	mov	r0, #205520896	; 0xc400000
 c1c8350:	e3a01000 	mov	r1, #0
 c1c8354:	eb000fa9 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8358:	ea000029 	b	c1c8404 <test_WAV+0x5b0>
            case 0xe:
                iis_playWawFile( DTMFSHARP, FALSE );
 c1c835c:	e59f0140 	ldr	r0, [pc, #320]	; c1c84a4 <test_WAV+0x650>
 c1c8360:	e3a01000 	mov	r1, #0
 c1c8364:	eb000fa5 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c8368:	ea000025 	b	c1c8404 <test_WAV+0x5b0>
            case 0xf:
                iis_playWawFile( OCUPADO, FALSE );
 c1c836c:	e59f0134 	ldr	r0, [pc, #308]	; c1c84a8 <test_WAV+0x654>
 c1c8370:	e3a01000 	mov	r1, #0
 c1c8374:	eb000fa1 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c8378:	e59f0128 	ldr	r0, [pc, #296]	; c1c84a8 <test_WAV+0x654>
 c1c837c:	e3a01000 	mov	r1, #0
 c1c8380:	eb000f9e 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c8384:	e59f011c 	ldr	r0, [pc, #284]	; c1c84a8 <test_WAV+0x654>
 c1c8388:	e3a01000 	mov	r1, #0
 c1c838c:	eb000f9b 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c8390:	e59f0110 	ldr	r0, [pc, #272]	; c1c84a8 <test_WAV+0x654>
 c1c8394:	e3a01000 	mov	r1, #0
 c1c8398:	eb000f98 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c839c:	e59f0104 	ldr	r0, [pc, #260]	; c1c84a8 <test_WAV+0x654>
 c1c83a0:	e3a01000 	mov	r1, #0
 c1c83a4:	eb000f95 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83a8:	e59f00f8 	ldr	r0, [pc, #248]	; c1c84a8 <test_WAV+0x654>
 c1c83ac:	e3a01000 	mov	r1, #0
 c1c83b0:	eb000f92 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83b4:	e59f00ec 	ldr	r0, [pc, #236]	; c1c84a8 <test_WAV+0x654>
 c1c83b8:	e3a01000 	mov	r1, #0
 c1c83bc:	eb000f8f 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83c0:	e59f00e0 	ldr	r0, [pc, #224]	; c1c84a8 <test_WAV+0x654>
 c1c83c4:	e3a01000 	mov	r1, #0
 c1c83c8:	eb000f8c 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83cc:	e59f00d4 	ldr	r0, [pc, #212]	; c1c84a8 <test_WAV+0x654>
 c1c83d0:	e3a01000 	mov	r1, #0
 c1c83d4:	eb000f89 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83d8:	e59f00c8 	ldr	r0, [pc, #200]	; c1c84a8 <test_WAV+0x654>
 c1c83dc:	e3a01000 	mov	r1, #0
 c1c83e0:	eb000f86 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83e4:	e59f00bc 	ldr	r0, [pc, #188]	; c1c84a8 <test_WAV+0x654>
 c1c83e8:	e3a01000 	mov	r1, #0
 c1c83ec:	eb000f83 	bl	c1cc200 <iis_playWawFile>
                iis_playWawFile( OCUPADO, FALSE );
 c1c83f0:	e59f00b0 	ldr	r0, [pc, #176]	; c1c84a8 <test_WAV+0x654>
 c1c83f4:	e3a01000 	mov	r1, #0
 c1c83f8:	eb000f80 	bl	c1cc200 <iis_playWawFile>
                break;
 c1c83fc:	ea000000 	b	c1c8404 <test_WAV+0x5b0>
            default:
            	continue;
 c1c8400:	e1a00000 	nop			; (mov r0, r0)
        };
 c1c8404:	eaffff75 	b	c1c81e0 <test_WAV+0x38c>
 c1c8408:	0c1003ec 	.word	0x0c1003ec
 c1c840c:	0c100438 	.word	0x0c100438
 c1c8410:	0c41a000 	.word	0x0c41a000
 c1c8414:	00055f00 	.word	0x00055f00
 c1c8418:	0c100468 	.word	0x0c100468
 c1c841c:	0c10046c 	.word	0x0c10046c
 c1c8420:	0c402000 	.word	0x0c402000
 c1c8424:	0c1004a0 	.word	0x0c1004a0
 c1c8428:	0c1004e8 	.word	0x0c1004e8
 c1c842c:	0c100518 	.word	0x0c100518
 c1c8430:	0c100520 	.word	0x0c100520
 c1c8434:	0c100550 	.word	0x0c100550
 c1c8438:	0004e200 	.word	0x0004e200
 c1c843c:	0c100594 	.word	0x0c100594
 c1c8440:	0c1005c0 	.word	0x0c1005c0
 c1c8444:	0c1005e8 	.word	0x0c1005e8
 c1c8448:	0c10061c 	.word	0x0c10061c
 c1c844c:	0c100634 	.word	0x0c100634
 c1c8450:	0c100668 	.word	0x0c100668
 c1c8454:	0c100694 	.word	0x0c100694
 c1c8458:	0c1006d0 	.word	0x0c1006d0
 c1c845c:	0c1006dc 	.word	0x0c1006dc
 c1c8460:	0c1006e8 	.word	0x0c1006e8
 c1c8464:	0c1006f4 	.word	0x0c1006f4
 c1c8468:	0c100724 	.word	0x0c100724
 c1c846c:	0c100734 	.word	0x0c100734
 c1c8470:	0c100744 	.word	0x0c100744
 c1c8474:	0c404000 	.word	0x0c404000
 c1c8478:	0c406000 	.word	0x0c406000
 c1c847c:	0c47a000 	.word	0x0c47a000
 c1c8480:	0c408000 	.word	0x0c408000
 c1c8484:	0c40a000 	.word	0x0c40a000
 c1c8488:	0c40c000 	.word	0x0c40c000
 c1c848c:	0c4fa000 	.word	0x0c4fa000
 c1c8490:	0c40e000 	.word	0x0c40e000
 c1c8494:	0c410000 	.word	0x0c410000
 c1c8498:	0c412000 	.word	0x0c412000
 c1c849c:	0c54a000 	.word	0x0c54a000
 c1c84a0:	0c414000 	.word	0x0c414000
 c1c84a4:	0c418000 	.word	0x0c418000
 c1c84a8:	0c56a000 	.word	0x0c56a000

0c1c84ac <test_sound_effects>:
void audiodelay_put( audiodelay_t *buffer, int16 ch0, int16 ch1 );
void audiodelay_get( audiodelay_t *buffer, int16 *ch0, int16 *ch1 );


void test_sound_effects( void )
{
 c1c84ac:	e1a0c00d 	mov	ip, sp
 c1c84b0:	e92dd800 	push	{fp, ip, lr, pc}
 c1c84b4:	e24cb004 	sub	fp, ip, #4
 c1c84b8:	e24dd010 	sub	sp, sp, #16
	uint32 i, vol;
	int16 ch0, ch1;
	int16 ch0_aux, ch1_aux;

    uda1341ts_init();
 c1c84bc:	eb001e44 	bl	c1cfdd4 <uda1341ts_init>
    iis_init( IIS_POLLING );
 c1c84c0:	e3a00002 	mov	r0, #2
 c1c84c4:	eb000dea 	bl	c1cbc74 <iis_init>

    /************************************/

    uart0_puts( "\n\nReproducción de sonido tabulado (LA central 440 Hz)\n" );
 c1c84c8:	e59f0c54 	ldr	r0, [pc, #3156]	; c1c9124 <test_sound_effects+0xc78>
 c1c84cc:	eb001d02 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
 c1c84d0:	e59f0c50 	ldr	r0, [pc, #3152]	; c1c9128 <test_sound_effects+0xc7c>
 c1c84d4:	eb001d00 	bl	c1cf8dc <uart0_puts>

    /************************************/

	uart0_puts( "  - Sinusoide: escuche... " );
 c1c84d8:	e59f0c4c 	ldr	r0, [pc, #3148]	; c1c912c <test_sound_effects+0xc80>
 c1c84dc:	eb001cfe 	bl	c1cf8dc <uart0_puts>
	i = 0;
 c1c84e0:	e3a03000 	mov	r3, #0
 c1c84e4:	e50b3010 	str	r3, [fp, #-16]
	while( kb_scan() < 0 )
 c1c84e8:	ea000018 	b	c1c8550 <test_sound_effects+0xa4>
	{
		iis_putSample( sine[i], sine[i] );
 c1c84ec:	e59f2c3c 	ldr	r2, [pc, #3132]	; c1c9130 <test_sound_effects+0xc84>
 c1c84f0:	e51b3010 	ldr	r3, [fp, #-16]
 c1c84f4:	e1a03083 	lsl	r3, r3, #1
 c1c84f8:	e0823003 	add	r3, r2, r3
 c1c84fc:	e1d320b0 	ldrh	r2, [r3]
 c1c8500:	e59f1c28 	ldr	r1, [pc, #3112]	; c1c9130 <test_sound_effects+0xc84>
 c1c8504:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8508:	e1a03083 	lsl	r3, r3, #1
 c1c850c:	e0813003 	add	r3, r1, r3
 c1c8510:	e1d330b0 	ldrh	r3, [r3]
 c1c8514:	e1a02802 	lsl	r2, r2, #16
 c1c8518:	e1a02842 	asr	r2, r2, #16
 c1c851c:	e1a03803 	lsl	r3, r3, #16
 c1c8520:	e1a03843 	asr	r3, r3, #16
 c1c8524:	e1a00002 	mov	r0, r2
 c1c8528:	e1a01003 	mov	r1, r3
 c1c852c:	eb000e16 	bl	c1cbd8c <iis_putSample>
		if( ++i > WAVETABLE_SIZE )
 c1c8530:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8534:	e2833001 	add	r3, r3, #1
 c1c8538:	e50b3010 	str	r3, [fp, #-16]
 c1c853c:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8540:	e3530024 	cmp	r3, #36	; 0x24
 c1c8544:	9a000001 	bls	c1c8550 <test_sound_effects+0xa4>
			i = 0;
 c1c8548:	e3a03000 	mov	r3, #0
 c1c854c:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

	uart0_puts( "  - Sinusoide: escuche... " );
	i = 0;
	while( kb_scan() < 0 )
 c1c8550:	eb00109a 	bl	c1cc7c0 <kb_scan>
 c1c8554:	e1a03000 	mov	r3, r0
 c1c8558:	e3530000 	cmp	r3, #0
 c1c855c:	baffffe2 	blt	c1c84ec <test_sound_effects+0x40>
		iis_putSample( sine[i], sine[i] );
		if( ++i > WAVETABLE_SIZE )
			i = 0;
	}

	uart0_getint();
 c1c8560:	eb001d7a 	bl	c1cfb50 <uart0_getint>
	uart0_puts( "\nOK\n" );
 c1c8564:	e59f0bc8 	ldr	r0, [pc, #3016]	; c1c9134 <test_sound_effects+0xc88>
 c1c8568:	eb001cdb 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Onda cuadrada: escuche... " );
 c1c856c:	e59f0bc4 	ldr	r0, [pc, #3012]	; c1c9138 <test_sound_effects+0xc8c>
 c1c8570:	eb001cd9 	bl	c1cf8dc <uart0_puts>
	i = 0;
 c1c8574:	e3a03000 	mov	r3, #0
 c1c8578:	e50b3010 	str	r3, [fp, #-16]
    while( kb_scan() < 0 )
 c1c857c:	ea000018 	b	c1c85e4 <test_sound_effects+0x138>
    {
     	iis_putSample( square[i], square[i] );
 c1c8580:	e59f2bb4 	ldr	r2, [pc, #2996]	; c1c913c <test_sound_effects+0xc90>
 c1c8584:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8588:	e1a03083 	lsl	r3, r3, #1
 c1c858c:	e0823003 	add	r3, r2, r3
 c1c8590:	e1d320b0 	ldrh	r2, [r3]
 c1c8594:	e59f1ba0 	ldr	r1, [pc, #2976]	; c1c913c <test_sound_effects+0xc90>
 c1c8598:	e51b3010 	ldr	r3, [fp, #-16]
 c1c859c:	e1a03083 	lsl	r3, r3, #1
 c1c85a0:	e0813003 	add	r3, r1, r3
 c1c85a4:	e1d330b0 	ldrh	r3, [r3]
 c1c85a8:	e1a02802 	lsl	r2, r2, #16
 c1c85ac:	e1a02842 	asr	r2, r2, #16
 c1c85b0:	e1a03803 	lsl	r3, r3, #16
 c1c85b4:	e1a03843 	asr	r3, r3, #16
 c1c85b8:	e1a00002 	mov	r0, r2
 c1c85bc:	e1a01003 	mov	r1, r3
 c1c85c0:	eb000df1 	bl	c1cbd8c <iis_putSample>
     	if( ++i > WAVETABLE_SIZE )
 c1c85c4:	e51b3010 	ldr	r3, [fp, #-16]
 c1c85c8:	e2833001 	add	r3, r3, #1
 c1c85cc:	e50b3010 	str	r3, [fp, #-16]
 c1c85d0:	e51b3010 	ldr	r3, [fp, #-16]
 c1c85d4:	e3530024 	cmp	r3, #36	; 0x24
 c1c85d8:	9a000001 	bls	c1c85e4 <test_sound_effects+0x138>
     		i = 0;
 c1c85dc:	e3a03000 	mov	r3, #0
 c1c85e0:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

    uart0_puts( "  - Onda cuadrada: escuche... " );
	i = 0;
    while( kb_scan() < 0 )
 c1c85e4:	eb001075 	bl	c1cc7c0 <kb_scan>
 c1c85e8:	e1a03000 	mov	r3, r0
 c1c85ec:	e3530000 	cmp	r3, #0
 c1c85f0:	baffffe2 	blt	c1c8580 <test_sound_effects+0xd4>
    {
     	iis_putSample( square[i], square[i] );
     	if( ++i > WAVETABLE_SIZE )
     		i = 0;
    }
    uart0_getint();
 c1c85f4:	eb001d55 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c85f8:	e59f0b40 	ldr	r0, [pc, #2880]	; c1c9140 <test_sound_effects+0xc94>
 c1c85fc:	eb001cb6 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Onda triangular: escuche... " );
 c1c8600:	e59f0b3c 	ldr	r0, [pc, #2876]	; c1c9144 <test_sound_effects+0xc98>
 c1c8604:	eb001cb4 	bl	c1cf8dc <uart0_puts>
    i = 0;
 c1c8608:	e3a03000 	mov	r3, #0
 c1c860c:	e50b3010 	str	r3, [fp, #-16]
	while( kb_scan() < 0 )
 c1c8610:	ea000018 	b	c1c8678 <test_sound_effects+0x1cc>
    {
     	iis_putSample( triangle[i], triangle[i] );
 c1c8614:	e59f2b2c 	ldr	r2, [pc, #2860]	; c1c9148 <test_sound_effects+0xc9c>
 c1c8618:	e51b3010 	ldr	r3, [fp, #-16]
 c1c861c:	e1a03083 	lsl	r3, r3, #1
 c1c8620:	e0823003 	add	r3, r2, r3
 c1c8624:	e1d320b0 	ldrh	r2, [r3]
 c1c8628:	e59f1b18 	ldr	r1, [pc, #2840]	; c1c9148 <test_sound_effects+0xc9c>
 c1c862c:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8630:	e1a03083 	lsl	r3, r3, #1
 c1c8634:	e0813003 	add	r3, r1, r3
 c1c8638:	e1d330b0 	ldrh	r3, [r3]
 c1c863c:	e1a02802 	lsl	r2, r2, #16
 c1c8640:	e1a02842 	asr	r2, r2, #16
 c1c8644:	e1a03803 	lsl	r3, r3, #16
 c1c8648:	e1a03843 	asr	r3, r3, #16
 c1c864c:	e1a00002 	mov	r0, r2
 c1c8650:	e1a01003 	mov	r1, r3
 c1c8654:	eb000dcc 	bl	c1cbd8c <iis_putSample>
     	if( ++i > WAVETABLE_SIZE )
 c1c8658:	e51b3010 	ldr	r3, [fp, #-16]
 c1c865c:	e2833001 	add	r3, r3, #1
 c1c8660:	e50b3010 	str	r3, [fp, #-16]
 c1c8664:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8668:	e3530024 	cmp	r3, #36	; 0x24
 c1c866c:	9a000001 	bls	c1c8678 <test_sound_effects+0x1cc>
     		i = 0;
 c1c8670:	e3a03000 	mov	r3, #0
 c1c8674:	e50b3010 	str	r3, [fp, #-16]

    /************************************/

    uart0_puts( "  - Onda triangular: escuche... " );
    i = 0;
	while( kb_scan() < 0 )
 c1c8678:	eb001050 	bl	c1cc7c0 <kb_scan>
 c1c867c:	e1a03000 	mov	r3, r0
 c1c8680:	e3530000 	cmp	r3, #0
 c1c8684:	baffffe2 	blt	c1c8614 <test_sound_effects+0x168>
    {
     	iis_putSample( triangle[i], triangle[i] );
     	if( ++i > WAVETABLE_SIZE )
     		i = 0;
    }
	uart0_getint();
 c1c8688:	eb001d30 	bl	c1cfb50 <uart0_getint>
	uart0_puts( "OK\n" );
 c1c868c:	e59f0aac 	ldr	r0, [pc, #2732]	; c1c9140 <test_sound_effects+0xc94>
 c1c8690:	eb001c91 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "\nEfectos de audio (dominio temporal)\n" );
 c1c8694:	e59f0ab0 	ldr	r0, [pc, #2736]	; c1c914c <test_sound_effects+0xca0>
 c1c8698:	eb001c8f 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos... " );
 c1c869c:	e59f0aac 	ldr	r0, [pc, #2732]	; c1c9150 <test_sound_effects+0xca4>
 c1c86a0:	eb001c8d 	bl	c1cf8dc <uart0_puts>
    D8Led_digit( 8 );
 c1c86a4:	e3a00008 	mov	r0, #8
 c1c86a8:	eb000806 	bl	c1ca6c8 <D8Led_digit>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c86ac:	e3a03000 	mov	r3, #0
 c1c86b0:	e50b3010 	str	r3, [fp, #-16]
 c1c86b4:	ea00000d 	b	c1c86f0 <test_sound_effects+0x244>
     	iis_getSample( &(buffer.ch0[i]), &(buffer.ch1[i]) );
 c1c86b8:	e51b3010 	ldr	r3, [fp, #-16]
 c1c86bc:	e1a02083 	lsl	r2, r3, #1
 c1c86c0:	e59f3a8c 	ldr	r3, [pc, #2700]	; c1c9154 <test_sound_effects+0xca8>
 c1c86c4:	e0822003 	add	r2, r2, r3
 c1c86c8:	e51b3010 	ldr	r3, [fp, #-16]
 c1c86cc:	e1a01083 	lsl	r1, r3, #1
 c1c86d0:	e59f3a80 	ldr	r3, [pc, #2688]	; c1c9158 <test_sound_effects+0xcac>
 c1c86d4:	e0813003 	add	r3, r1, r3
 c1c86d8:	e1a00002 	mov	r0, r2
 c1c86dc:	e1a01003 	mov	r1, r3
 c1c86e0:	eb000dc3 	bl	c1cbdf4 <iis_getSample>

    /************************************/

    uart0_puts( "  - Grabacion: hable mientras los 7 segmentos estén encendidos... " );
    D8Led_digit( 8 );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c86e4:	e51b3010 	ldr	r3, [fp, #-16]
 c1c86e8:	e2833001 	add	r3, r3, #1
 c1c86ec:	e50b3010 	str	r3, [fp, #-16]
 c1c86f0:	e51b2010 	ldr	r2, [fp, #-16]
 c1c86f4:	e59f3a60 	ldr	r3, [pc, #2656]	; c1c915c <test_sound_effects+0xcb0>
 c1c86f8:	e1520003 	cmp	r2, r3
 c1c86fc:	9affffed 	bls	c1c86b8 <test_sound_effects+0x20c>
     	iis_getSample( &(buffer.ch0[i]), &(buffer.ch1[i]) );
    D8Led_off();
 c1c8700:	eb0007d0 	bl	c1ca648 <D8Led_off>
    uart0_puts( "OK\n" );
 c1c8704:	e59f0a34 	ldr	r0, [pc, #2612]	; c1c9140 <test_sound_effects+0xc94>
 c1c8708:	eb001c73 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a velocidad normal: escuche... " );
 c1c870c:	e59f0a4c 	ldr	r0, [pc, #2636]	; c1c9160 <test_sound_effects+0xcb4>
 c1c8710:	eb001c71 	bl	c1cf8dc <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c8714:	e3a03000 	mov	r3, #0
 c1c8718:	e50b3010 	str	r3, [fp, #-16]
 c1c871c:	ea000015 	b	c1c8778 <test_sound_effects+0x2cc>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c1c8720:	e59f2a2c 	ldr	r2, [pc, #2604]	; c1c9154 <test_sound_effects+0xca8>
 c1c8724:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8728:	e1a03083 	lsl	r3, r3, #1
 c1c872c:	e0823003 	add	r3, r2, r3
 c1c8730:	e1d320b0 	ldrh	r2, [r3]
 c1c8734:	e59f1a18 	ldr	r1, [pc, #2584]	; c1c9154 <test_sound_effects+0xca8>
 c1c8738:	e51b3010 	ldr	r3, [fp, #-16]
 c1c873c:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c1c8740:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c8744:	e1a03083 	lsl	r3, r3, #1
 c1c8748:	e0813003 	add	r3, r1, r3
 c1c874c:	e1d330b0 	ldrh	r3, [r3]
 c1c8750:	e1a02802 	lsl	r2, r2, #16
 c1c8754:	e1a02842 	asr	r2, r2, #16
 c1c8758:	e1a03803 	lsl	r3, r3, #16
 c1c875c:	e1a03843 	asr	r3, r3, #16
 c1c8760:	e1a00002 	mov	r0, r2
 c1c8764:	e1a01003 	mov	r1, r3
 c1c8768:	eb000d87 	bl	c1cbd8c <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a velocidad normal: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c876c:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8770:	e2833001 	add	r3, r3, #1
 c1c8774:	e50b3010 	str	r3, [fp, #-16]
 c1c8778:	e51b2010 	ldr	r2, [fp, #-16]
 c1c877c:	e59f39d8 	ldr	r3, [pc, #2520]	; c1c915c <test_sound_effects+0xcb0>
 c1c8780:	e1520003 	cmp	r2, r3
 c1c8784:	9affffe5 	bls	c1c8720 <test_sound_effects+0x274>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );
 c1c8788:	e59f09b0 	ldr	r0, [pc, #2480]	; c1c9140 <test_sound_effects+0xc94>
 c1c878c:	eb001c52 	bl	c1cf8dc <uart0_puts>

    uart0_puts( "  - Reproducción a media velocidad: escuche... " );
 c1c8790:	e59f09cc 	ldr	r0, [pc, #2508]	; c1c9164 <test_sound_effects+0xcb8>
 c1c8794:	eb001c50 	bl	c1cf8dc <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c8798:	e3a03000 	mov	r3, #0
 c1c879c:	e50b3010 	str	r3, [fp, #-16]
 c1c87a0:	ea000028 	b	c1c8848 <test_sound_effects+0x39c>
    {
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );	    // cada muestra almacenada se reproduce 2 veces
 c1c87a4:	e59f29a8 	ldr	r2, [pc, #2472]	; c1c9154 <test_sound_effects+0xca8>
 c1c87a8:	e51b3010 	ldr	r3, [fp, #-16]
 c1c87ac:	e1a03083 	lsl	r3, r3, #1
 c1c87b0:	e0823003 	add	r3, r2, r3
 c1c87b4:	e1d320b0 	ldrh	r2, [r3]
 c1c87b8:	e59f1994 	ldr	r1, [pc, #2452]	; c1c9154 <test_sound_effects+0xca8>
 c1c87bc:	e51b3010 	ldr	r3, [fp, #-16]
 c1c87c0:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c1c87c4:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c87c8:	e1a03083 	lsl	r3, r3, #1
 c1c87cc:	e0813003 	add	r3, r1, r3
 c1c87d0:	e1d330b0 	ldrh	r3, [r3]
 c1c87d4:	e1a02802 	lsl	r2, r2, #16
 c1c87d8:	e1a02842 	asr	r2, r2, #16
 c1c87dc:	e1a03803 	lsl	r3, r3, #16
 c1c87e0:	e1a03843 	asr	r3, r3, #16
 c1c87e4:	e1a00002 	mov	r0, r2
 c1c87e8:	e1a01003 	mov	r1, r3
 c1c87ec:	eb000d66 	bl	c1cbd8c <iis_putSample>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c1c87f0:	e59f295c 	ldr	r2, [pc, #2396]	; c1c9154 <test_sound_effects+0xca8>
 c1c87f4:	e51b3010 	ldr	r3, [fp, #-16]
 c1c87f8:	e1a03083 	lsl	r3, r3, #1
 c1c87fc:	e0823003 	add	r3, r2, r3
 c1c8800:	e1d320b0 	ldrh	r2, [r3]
 c1c8804:	e59f1948 	ldr	r1, [pc, #2376]	; c1c9154 <test_sound_effects+0xca8>
 c1c8808:	e51b3010 	ldr	r3, [fp, #-16]
 c1c880c:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c1c8810:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c8814:	e1a03083 	lsl	r3, r3, #1
 c1c8818:	e0813003 	add	r3, r1, r3
 c1c881c:	e1d330b0 	ldrh	r3, [r3]
 c1c8820:	e1a02802 	lsl	r2, r2, #16
 c1c8824:	e1a02842 	asr	r2, r2, #16
 c1c8828:	e1a03803 	lsl	r3, r3, #16
 c1c882c:	e1a03843 	asr	r3, r3, #16
 c1c8830:	e1a00002 	mov	r0, r2
 c1c8834:	e1a01003 	mov	r1, r3
 c1c8838:	eb000d53 	bl	c1cbd8c <iis_putSample>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );

    uart0_puts( "  - Reproducción a media velocidad: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c883c:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8840:	e2833001 	add	r3, r3, #1
 c1c8844:	e50b3010 	str	r3, [fp, #-16]
 c1c8848:	e51b2010 	ldr	r2, [fp, #-16]
 c1c884c:	e59f3908 	ldr	r3, [pc, #2312]	; c1c915c <test_sound_effects+0xcb0>
 c1c8850:	e1520003 	cmp	r2, r3
 c1c8854:	9affffd2 	bls	c1c87a4 <test_sound_effects+0x2f8>
    {
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );	    // cada muestra almacenada se reproduce 2 veces
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
     }
    uart0_puts( "OK\n" );
 c1c8858:	e59f08e0 	ldr	r0, [pc, #2272]	; c1c9140 <test_sound_effects+0xc94>
 c1c885c:	eb001c1e 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción a doble velocidad: escuche... " );
 c1c8860:	e59f0900 	ldr	r0, [pc, #2304]	; c1c9168 <test_sound_effects+0xcbc>
 c1c8864:	eb001c1c 	bl	c1cf8dc <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i+=2 )		 	// se reproduce 1 de cada 2 muestras almacenadas
 c1c8868:	e3a03000 	mov	r3, #0
 c1c886c:	e50b3010 	str	r3, [fp, #-16]
 c1c8870:	ea000015 	b	c1c88cc <test_sound_effects+0x420>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
 c1c8874:	e59f28d8 	ldr	r2, [pc, #2264]	; c1c9154 <test_sound_effects+0xca8>
 c1c8878:	e51b3010 	ldr	r3, [fp, #-16]
 c1c887c:	e1a03083 	lsl	r3, r3, #1
 c1c8880:	e0823003 	add	r3, r2, r3
 c1c8884:	e1d320b0 	ldrh	r2, [r3]
 c1c8888:	e59f18c4 	ldr	r1, [pc, #2244]	; c1c9154 <test_sound_effects+0xca8>
 c1c888c:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8890:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c1c8894:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c8898:	e1a03083 	lsl	r3, r3, #1
 c1c889c:	e0813003 	add	r3, r1, r3
 c1c88a0:	e1d330b0 	ldrh	r3, [r3]
 c1c88a4:	e1a02802 	lsl	r2, r2, #16
 c1c88a8:	e1a02842 	asr	r2, r2, #16
 c1c88ac:	e1a03803 	lsl	r3, r3, #16
 c1c88b0:	e1a03843 	asr	r3, r3, #16
 c1c88b4:	e1a00002 	mov	r0, r2
 c1c88b8:	e1a01003 	mov	r1, r3
 c1c88bc:	eb000d32 	bl	c1cbd8c <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción a doble velocidad: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i+=2 )		 	// se reproduce 1 de cada 2 muestras almacenadas
 c1c88c0:	e51b3010 	ldr	r3, [fp, #-16]
 c1c88c4:	e2833002 	add	r3, r3, #2
 c1c88c8:	e50b3010 	str	r3, [fp, #-16]
 c1c88cc:	e51b2010 	ldr	r2, [fp, #-16]
 c1c88d0:	e59f3884 	ldr	r3, [pc, #2180]	; c1c915c <test_sound_effects+0xcb0>
 c1c88d4:	e1520003 	cmp	r2, r3
 c1c88d8:	9affffe5 	bls	c1c8874 <test_sound_effects+0x3c8>
     	iis_putSample( buffer.ch0[i], buffer.ch1[i] );
    uart0_puts( "OK\n" );
 c1c88dc:	e59f085c 	ldr	r0, [pc, #2140]	; c1c9140 <test_sound_effects+0xc94>
 c1c88e0:	eb001bfd 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reproducción inversa: escuche... " );
 c1c88e4:	e59f0880 	ldr	r0, [pc, #2176]	; c1c916c <test_sound_effects+0xcc0>
 c1c88e8:	eb001bfb 	bl	c1cf8dc <uart0_puts>
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c88ec:	e3a03000 	mov	r3, #0
 c1c88f0:	e50b3010 	str	r3, [fp, #-16]
 c1c88f4:	ea000019 	b	c1c8960 <test_sound_effects+0x4b4>
     	iis_putSample( buffer.ch0[AUDIOBUFFER_SIZE-i], buffer.ch1[AUDIOBUFFER_SIZE-i] );
 c1c88f8:	e51b3010 	ldr	r3, [fp, #-16]
 c1c88fc:	e2633a27 	rsb	r3, r3, #159744	; 0x27000
 c1c8900:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c8904:	e59f2848 	ldr	r2, [pc, #2120]	; c1c9154 <test_sound_effects+0xca8>
 c1c8908:	e1a03083 	lsl	r3, r3, #1
 c1c890c:	e0823003 	add	r3, r2, r3
 c1c8910:	e1d320b0 	ldrh	r2, [r3]
 c1c8914:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8918:	e2633a27 	rsb	r3, r3, #159744	; 0x27000
 c1c891c:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c8920:	e59f182c 	ldr	r1, [pc, #2092]	; c1c9154 <test_sound_effects+0xca8>
 c1c8924:	e2833a27 	add	r3, r3, #159744	; 0x27000
 c1c8928:	e2833c01 	add	r3, r3, #256	; 0x100
 c1c892c:	e1a03083 	lsl	r3, r3, #1
 c1c8930:	e0813003 	add	r3, r1, r3
 c1c8934:	e1d330b0 	ldrh	r3, [r3]
 c1c8938:	e1a02802 	lsl	r2, r2, #16
 c1c893c:	e1a02842 	asr	r2, r2, #16
 c1c8940:	e1a03803 	lsl	r3, r3, #16
 c1c8944:	e1a03843 	asr	r3, r3, #16
 c1c8948:	e1a00002 	mov	r0, r2
 c1c894c:	e1a01003 	mov	r1, r3
 c1c8950:	eb000d0d 	bl	c1cbd8c <iis_putSample>
    uart0_puts( "OK\n" );

    /************************************/

    uart0_puts( "  - Reproducción inversa: escuche... " );
    for( i=0; i<AUDIOBUFFER_SIZE; i++ )
 c1c8954:	e51b3010 	ldr	r3, [fp, #-16]
 c1c8958:	e2833001 	add	r3, r3, #1
 c1c895c:	e50b3010 	str	r3, [fp, #-16]
 c1c8960:	e51b2010 	ldr	r2, [fp, #-16]
 c1c8964:	e59f37f0 	ldr	r3, [pc, #2032]	; c1c915c <test_sound_effects+0xcb0>
 c1c8968:	e1520003 	cmp	r2, r3
 c1c896c:	9affffe1 	bls	c1c88f8 <test_sound_effects+0x44c>
     	iis_putSample( buffer.ch0[AUDIOBUFFER_SIZE-i], buffer.ch1[AUDIOBUFFER_SIZE-i] );
    uart0_puts( "OK\n" );
 c1c8970:	e59f07c8 	ldr	r0, [pc, #1992]	; c1c9140 <test_sound_effects+0xc94>
 c1c8974:	eb001bd8 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
 c1c8978:	e59f07a8 	ldr	r0, [pc, #1960]	; c1c9128 <test_sound_effects+0xc7c>
 c1c897c:	eb001bd6 	bl	c1cf8dc <uart0_puts>
    uart0_puts( "  - Loopback: hable y escuche... " );
 c1c8980:	e59f07e8 	ldr	r0, [pc, #2024]	; c1c9170 <test_sound_effects+0xcc4>
 c1c8984:	eb001bd4 	bl	c1cf8dc <uart0_puts>
    while( kb_scan() < 0 )
 c1c8988:	ea00000d 	b	c1c89c4 <test_sound_effects+0x518>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c898c:	e24b2012 	sub	r2, fp, #18
 c1c8990:	e24b3014 	sub	r3, fp, #20
 c1c8994:	e1a00002 	mov	r0, r2
 c1c8998:	e1a01003 	mov	r1, r3
 c1c899c:	eb000d14 	bl	c1cbdf4 <iis_getSample>
     	iis_putSample( ch0, ch1 );
 c1c89a0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c89a4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c89a8:	e1a02802 	lsl	r2, r2, #16
 c1c89ac:	e1a02842 	asr	r2, r2, #16
 c1c89b0:	e1a03803 	lsl	r3, r3, #16
 c1c89b4:	e1a03843 	asr	r3, r3, #16
 c1c89b8:	e1a00002 	mov	r0, r2
 c1c89bc:	e1a01003 	mov	r1, r3
 c1c89c0:	eb000cf1 	bl	c1cbd8c <iis_putSample>

    /************************************/

    uart0_puts( "(para finalizar presione cualquier tecla)\n" );
    uart0_puts( "  - Loopback: hable y escuche... " );
    while( kb_scan() < 0 )
 c1c89c4:	eb000f7d 	bl	c1cc7c0 <kb_scan>
 c1c89c8:	e1a03000 	mov	r3, r0
 c1c89cc:	e3530000 	cmp	r3, #0
 c1c89d0:	baffffed 	blt	c1c898c <test_sound_effects+0x4e0>
    {
     	iis_getSample( &ch0, &ch1 );
     	iis_putSample( ch0, ch1 );
    }
    uart0_getint();
 c1c89d4:	eb001c5d 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c89d8:	e59f0760 	ldr	r0, [pc, #1888]	; c1c9140 <test_sound_effects+0xc94>
 c1c89dc:	eb001bbe 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (8 ms): hable y escuche... " );
 c1c89e0:	e59f078c 	ldr	r0, [pc, #1932]	; c1c9174 <test_sound_effects+0xcc8>
 c1c89e4:	eb001bbc 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 128 );
 c1c89e8:	e59f0788 	ldr	r0, [pc, #1928]	; c1c9178 <test_sound_effects+0xccc>
 c1c89ec:	e3a01080 	mov	r1, #128	; 0x80
 c1c89f0:	eb0001e7 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c89f4:	ea00003f 	b	c1c8af8 <test_sound_effects+0x64c>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c89f8:	e24b2012 	sub	r2, fp, #18
 c1c89fc:	e24b3014 	sub	r3, fp, #20
 c1c8a00:	e1a00002 	mov	r0, r2
 c1c8a04:	e1a01003 	mov	r1, r3
 c1c8a08:	eb000cf9 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c8a0c:	e24b2016 	sub	r2, fp, #22
 c1c8a10:	e24b3018 	sub	r3, fp, #24
 c1c8a14:	e59f075c 	ldr	r0, [pc, #1884]	; c1c9178 <test_sound_effects+0xccc>
 c1c8a18:	e1a01002 	mov	r1, r2
 c1c8a1c:	e1a02003 	mov	r2, r3
 c1c8a20:	eb00023c 	bl	c1c9318 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c1c8a24:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c8a28:	e1a03803 	lsl	r3, r3, #16
 c1c8a2c:	e1a03843 	asr	r3, r3, #16
 c1c8a30:	e1a030c3 	asr	r3, r3, #1
 c1c8a34:	e1a03803 	lsl	r3, r3, #16
 c1c8a38:	e1a03823 	lsr	r3, r3, #16
 c1c8a3c:	e1a03803 	lsl	r3, r3, #16
 c1c8a40:	e1a02823 	lsr	r2, r3, #16
 c1c8a44:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c8a48:	e1a03803 	lsl	r3, r3, #16
 c1c8a4c:	e1a03823 	lsr	r3, r3, #16
 c1c8a50:	e0823003 	add	r3, r2, r3
 c1c8a54:	e1a03803 	lsl	r3, r3, #16
 c1c8a58:	e1a03823 	lsr	r3, r3, #16
 c1c8a5c:	e1a03803 	lsl	r3, r3, #16
 c1c8a60:	e1a03823 	lsr	r3, r3, #16
 c1c8a64:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c1c8a68:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8a6c:	e1a03803 	lsl	r3, r3, #16
 c1c8a70:	e1a03843 	asr	r3, r3, #16
 c1c8a74:	e1a030c3 	asr	r3, r3, #1
 c1c8a78:	e1a03803 	lsl	r3, r3, #16
 c1c8a7c:	e1a03823 	lsr	r3, r3, #16
 c1c8a80:	e1a03803 	lsl	r3, r3, #16
 c1c8a84:	e1a02823 	lsr	r2, r3, #16
 c1c8a88:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8a8c:	e1a03803 	lsl	r3, r3, #16
 c1c8a90:	e1a03823 	lsr	r3, r3, #16
 c1c8a94:	e0823003 	add	r3, r2, r3
 c1c8a98:	e1a03803 	lsl	r3, r3, #16
 c1c8a9c:	e1a03823 	lsr	r3, r3, #16
 c1c8aa0:	e1a03803 	lsl	r3, r3, #16
 c1c8aa4:	e1a03823 	lsr	r3, r3, #16
 c1c8aa8:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c1c8aac:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c1c8ab0:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8ab4:	e1a02802 	lsl	r2, r2, #16
 c1c8ab8:	e1a02842 	asr	r2, r2, #16
 c1c8abc:	e1a03803 	lsl	r3, r3, #16
 c1c8ac0:	e1a03843 	asr	r3, r3, #16
 c1c8ac4:	e1a00002 	mov	r0, r2
 c1c8ac8:	e1a01003 	mov	r1, r3
 c1c8acc:	eb000cae 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c8ad0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8ad4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8ad8:	e1a02802 	lsl	r2, r2, #16
 c1c8adc:	e1a02842 	asr	r2, r2, #16
 c1c8ae0:	e1a03803 	lsl	r3, r3, #16
 c1c8ae4:	e1a03843 	asr	r3, r3, #16
 c1c8ae8:	e59f0688 	ldr	r0, [pc, #1672]	; c1c9178 <test_sound_effects+0xccc>
 c1c8aec:	e1a01002 	mov	r1, r2
 c1c8af0:	e1a02003 	mov	r2, r3
 c1c8af4:	eb0001d5 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (8 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 128 );
    while( kb_scan() < 0 )
 c1c8af8:	eb000f30 	bl	c1cc7c0 <kb_scan>
 c1c8afc:	e1a03000 	mov	r3, r0
 c1c8b00:	e3530000 	cmp	r3, #0
 c1c8b04:	baffffbb 	blt	c1c89f8 <test_sound_effects+0x54c>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c1c8b08:	eb001c10 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c8b0c:	e59f062c 	ldr	r0, [pc, #1580]	; c1c9140 <test_sound_effects+0xc94>
 c1c8b10:	eb001b71 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (45 ms): hable y escuche... " );
 c1c8b14:	e59f0660 	ldr	r0, [pc, #1632]	; c1c917c <test_sound_effects+0xcd0>
 c1c8b18:	eb001b6f 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 720 );
 c1c8b1c:	e59f0654 	ldr	r0, [pc, #1620]	; c1c9178 <test_sound_effects+0xccc>
 c1c8b20:	e3a01e2d 	mov	r1, #720	; 0x2d0
 c1c8b24:	eb00019a 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c8b28:	ea00003f 	b	c1c8c2c <test_sound_effects+0x780>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c8b2c:	e24b2012 	sub	r2, fp, #18
 c1c8b30:	e24b3014 	sub	r3, fp, #20
 c1c8b34:	e1a00002 	mov	r0, r2
 c1c8b38:	e1a01003 	mov	r1, r3
 c1c8b3c:	eb000cac 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c8b40:	e24b2016 	sub	r2, fp, #22
 c1c8b44:	e24b3018 	sub	r3, fp, #24
 c1c8b48:	e59f0628 	ldr	r0, [pc, #1576]	; c1c9178 <test_sound_effects+0xccc>
 c1c8b4c:	e1a01002 	mov	r1, r2
 c1c8b50:	e1a02003 	mov	r2, r3
 c1c8b54:	eb0001ef 	bl	c1c9318 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c1c8b58:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c8b5c:	e1a03803 	lsl	r3, r3, #16
 c1c8b60:	e1a03843 	asr	r3, r3, #16
 c1c8b64:	e1a030c3 	asr	r3, r3, #1
 c1c8b68:	e1a03803 	lsl	r3, r3, #16
 c1c8b6c:	e1a03823 	lsr	r3, r3, #16
 c1c8b70:	e1a03803 	lsl	r3, r3, #16
 c1c8b74:	e1a02823 	lsr	r2, r3, #16
 c1c8b78:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c8b7c:	e1a03803 	lsl	r3, r3, #16
 c1c8b80:	e1a03823 	lsr	r3, r3, #16
 c1c8b84:	e0823003 	add	r3, r2, r3
 c1c8b88:	e1a03803 	lsl	r3, r3, #16
 c1c8b8c:	e1a03823 	lsr	r3, r3, #16
 c1c8b90:	e1a03803 	lsl	r3, r3, #16
 c1c8b94:	e1a03823 	lsr	r3, r3, #16
 c1c8b98:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c1c8b9c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8ba0:	e1a03803 	lsl	r3, r3, #16
 c1c8ba4:	e1a03843 	asr	r3, r3, #16
 c1c8ba8:	e1a030c3 	asr	r3, r3, #1
 c1c8bac:	e1a03803 	lsl	r3, r3, #16
 c1c8bb0:	e1a03823 	lsr	r3, r3, #16
 c1c8bb4:	e1a03803 	lsl	r3, r3, #16
 c1c8bb8:	e1a02823 	lsr	r2, r3, #16
 c1c8bbc:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8bc0:	e1a03803 	lsl	r3, r3, #16
 c1c8bc4:	e1a03823 	lsr	r3, r3, #16
 c1c8bc8:	e0823003 	add	r3, r2, r3
 c1c8bcc:	e1a03803 	lsl	r3, r3, #16
 c1c8bd0:	e1a03823 	lsr	r3, r3, #16
 c1c8bd4:	e1a03803 	lsl	r3, r3, #16
 c1c8bd8:	e1a03823 	lsr	r3, r3, #16
 c1c8bdc:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c1c8be0:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c1c8be4:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8be8:	e1a02802 	lsl	r2, r2, #16
 c1c8bec:	e1a02842 	asr	r2, r2, #16
 c1c8bf0:	e1a03803 	lsl	r3, r3, #16
 c1c8bf4:	e1a03843 	asr	r3, r3, #16
 c1c8bf8:	e1a00002 	mov	r0, r2
 c1c8bfc:	e1a01003 	mov	r1, r3
 c1c8c00:	eb000c61 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c8c04:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8c08:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8c0c:	e1a02802 	lsl	r2, r2, #16
 c1c8c10:	e1a02842 	asr	r2, r2, #16
 c1c8c14:	e1a03803 	lsl	r3, r3, #16
 c1c8c18:	e1a03843 	asr	r3, r3, #16
 c1c8c1c:	e59f0554 	ldr	r0, [pc, #1364]	; c1c9178 <test_sound_effects+0xccc>
 c1c8c20:	e1a01002 	mov	r1, r2
 c1c8c24:	e1a02003 	mov	r2, r3
 c1c8c28:	eb000188 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (45 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 720 );
    while( kb_scan() < 0 )
 c1c8c2c:	eb000ee3 	bl	c1cc7c0 <kb_scan>
 c1c8c30:	e1a03000 	mov	r3, r0
 c1c8c34:	e3530000 	cmp	r3, #0
 c1c8c38:	baffffbb 	blt	c1c8b2c <test_sound_effects+0x680>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c1c8c3c:	eb001bc3 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c8c40:	e59f04f8 	ldr	r0, [pc, #1272]	; c1c9140 <test_sound_effects+0xc94>
 c1c8c44:	eb001b24 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (85 ms): hable y escuche... " );
 c1c8c48:	e59f0530 	ldr	r0, [pc, #1328]	; c1c9180 <test_sound_effects+0xcd4>
 c1c8c4c:	eb001b22 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 1280 );
 c1c8c50:	e59f0520 	ldr	r0, [pc, #1312]	; c1c9178 <test_sound_effects+0xccc>
 c1c8c54:	e3a01c05 	mov	r1, #1280	; 0x500
 c1c8c58:	eb00014d 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c8c5c:	ea00003f 	b	c1c8d60 <test_sound_effects+0x8b4>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c8c60:	e24b2012 	sub	r2, fp, #18
 c1c8c64:	e24b3014 	sub	r3, fp, #20
 c1c8c68:	e1a00002 	mov	r0, r2
 c1c8c6c:	e1a01003 	mov	r1, r3
 c1c8c70:	eb000c5f 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c8c74:	e24b2016 	sub	r2, fp, #22
 c1c8c78:	e24b3018 	sub	r3, fp, #24
 c1c8c7c:	e59f04f4 	ldr	r0, [pc, #1268]	; c1c9178 <test_sound_effects+0xccc>
 c1c8c80:	e1a01002 	mov	r1, r2
 c1c8c84:	e1a02003 	mov	r2, r3
 c1c8c88:	eb0001a2 	bl	c1c9318 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c1c8c8c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c8c90:	e1a03803 	lsl	r3, r3, #16
 c1c8c94:	e1a03843 	asr	r3, r3, #16
 c1c8c98:	e1a030c3 	asr	r3, r3, #1
 c1c8c9c:	e1a03803 	lsl	r3, r3, #16
 c1c8ca0:	e1a03823 	lsr	r3, r3, #16
 c1c8ca4:	e1a03803 	lsl	r3, r3, #16
 c1c8ca8:	e1a02823 	lsr	r2, r3, #16
 c1c8cac:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c8cb0:	e1a03803 	lsl	r3, r3, #16
 c1c8cb4:	e1a03823 	lsr	r3, r3, #16
 c1c8cb8:	e0823003 	add	r3, r2, r3
 c1c8cbc:	e1a03803 	lsl	r3, r3, #16
 c1c8cc0:	e1a03823 	lsr	r3, r3, #16
 c1c8cc4:	e1a03803 	lsl	r3, r3, #16
 c1c8cc8:	e1a03823 	lsr	r3, r3, #16
 c1c8ccc:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c1c8cd0:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8cd4:	e1a03803 	lsl	r3, r3, #16
 c1c8cd8:	e1a03843 	asr	r3, r3, #16
 c1c8cdc:	e1a030c3 	asr	r3, r3, #1
 c1c8ce0:	e1a03803 	lsl	r3, r3, #16
 c1c8ce4:	e1a03823 	lsr	r3, r3, #16
 c1c8ce8:	e1a03803 	lsl	r3, r3, #16
 c1c8cec:	e1a02823 	lsr	r2, r3, #16
 c1c8cf0:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8cf4:	e1a03803 	lsl	r3, r3, #16
 c1c8cf8:	e1a03823 	lsr	r3, r3, #16
 c1c8cfc:	e0823003 	add	r3, r2, r3
 c1c8d00:	e1a03803 	lsl	r3, r3, #16
 c1c8d04:	e1a03823 	lsr	r3, r3, #16
 c1c8d08:	e1a03803 	lsl	r3, r3, #16
 c1c8d0c:	e1a03823 	lsr	r3, r3, #16
 c1c8d10:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c1c8d14:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c1c8d18:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8d1c:	e1a02802 	lsl	r2, r2, #16
 c1c8d20:	e1a02842 	asr	r2, r2, #16
 c1c8d24:	e1a03803 	lsl	r3, r3, #16
 c1c8d28:	e1a03843 	asr	r3, r3, #16
 c1c8d2c:	e1a00002 	mov	r0, r2
 c1c8d30:	e1a01003 	mov	r1, r3
 c1c8d34:	eb000c14 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c8d38:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8d3c:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8d40:	e1a02802 	lsl	r2, r2, #16
 c1c8d44:	e1a02842 	asr	r2, r2, #16
 c1c8d48:	e1a03803 	lsl	r3, r3, #16
 c1c8d4c:	e1a03843 	asr	r3, r3, #16
 c1c8d50:	e59f0420 	ldr	r0, [pc, #1056]	; c1c9178 <test_sound_effects+0xccc>
 c1c8d54:	e1a01002 	mov	r1, r2
 c1c8d58:	e1a02003 	mov	r2, r3
 c1c8d5c:	eb00013b 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (85 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 1280 );
    while( kb_scan() < 0 )
 c1c8d60:	eb000e96 	bl	c1cc7c0 <kb_scan>
 c1c8d64:	e1a03000 	mov	r3, r0
 c1c8d68:	e3530000 	cmp	r3, #0
 c1c8d6c:	baffffbb 	blt	c1c8c60 <test_sound_effects+0x7b4>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c1c8d70:	eb001b76 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c8d74:	e59f03c4 	ldr	r0, [pc, #964]	; c1c9140 <test_sound_effects+0xc94>
 c1c8d78:	eb001ad7 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo (150 ms): hable y escuche... " );
 c1c8d7c:	e59f0400 	ldr	r0, [pc, #1024]	; c1c9184 <test_sound_effects+0xcd8>
 c1c8d80:	eb001ad5 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 2400 );
 c1c8d84:	e59f03ec 	ldr	r0, [pc, #1004]	; c1c9178 <test_sound_effects+0xccc>
 c1c8d88:	e3a01e96 	mov	r1, #2400	; 0x960
 c1c8d8c:	eb000100 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c8d90:	ea00003f 	b	c1c8e94 <test_sound_effects+0x9e8>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c8d94:	e24b2012 	sub	r2, fp, #18
 c1c8d98:	e24b3014 	sub	r3, fp, #20
 c1c8d9c:	e1a00002 	mov	r0, r2
 c1c8da0:	e1a01003 	mov	r1, r3
 c1c8da4:	eb000c12 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c8da8:	e24b2016 	sub	r2, fp, #22
 c1c8dac:	e24b3018 	sub	r3, fp, #24
 c1c8db0:	e59f03c0 	ldr	r0, [pc, #960]	; c1c9178 <test_sound_effects+0xccc>
 c1c8db4:	e1a01002 	mov	r1, r2
 c1c8db8:	e1a02003 	mov	r2, r3
 c1c8dbc:	eb000155 	bl	c1c9318 <audiodelay_get>
     	ch0_aux = ch0 + (ch0_aux >> 1);
 c1c8dc0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c8dc4:	e1a03803 	lsl	r3, r3, #16
 c1c8dc8:	e1a03843 	asr	r3, r3, #16
 c1c8dcc:	e1a030c3 	asr	r3, r3, #1
 c1c8dd0:	e1a03803 	lsl	r3, r3, #16
 c1c8dd4:	e1a03823 	lsr	r3, r3, #16
 c1c8dd8:	e1a03803 	lsl	r3, r3, #16
 c1c8ddc:	e1a02823 	lsr	r2, r3, #16
 c1c8de0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c8de4:	e1a03803 	lsl	r3, r3, #16
 c1c8de8:	e1a03823 	lsr	r3, r3, #16
 c1c8dec:	e0823003 	add	r3, r2, r3
 c1c8df0:	e1a03803 	lsl	r3, r3, #16
 c1c8df4:	e1a03823 	lsr	r3, r3, #16
 c1c8df8:	e1a03803 	lsl	r3, r3, #16
 c1c8dfc:	e1a03823 	lsr	r3, r3, #16
 c1c8e00:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
     	ch1_aux = ch1 + (ch1_aux >> 1);
 c1c8e04:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8e08:	e1a03803 	lsl	r3, r3, #16
 c1c8e0c:	e1a03843 	asr	r3, r3, #16
 c1c8e10:	e1a030c3 	asr	r3, r3, #1
 c1c8e14:	e1a03803 	lsl	r3, r3, #16
 c1c8e18:	e1a03823 	lsr	r3, r3, #16
 c1c8e1c:	e1a03803 	lsl	r3, r3, #16
 c1c8e20:	e1a02823 	lsr	r2, r3, #16
 c1c8e24:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8e28:	e1a03803 	lsl	r3, r3, #16
 c1c8e2c:	e1a03823 	lsr	r3, r3, #16
 c1c8e30:	e0823003 	add	r3, r2, r3
 c1c8e34:	e1a03803 	lsl	r3, r3, #16
 c1c8e38:	e1a03823 	lsr	r3, r3, #16
 c1c8e3c:	e1a03803 	lsl	r3, r3, #16
 c1c8e40:	e1a03823 	lsr	r3, r3, #16
 c1c8e44:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
     	iis_putSample( ch0_aux, ch1_aux );
 c1c8e48:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
 c1c8e4c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8e50:	e1a02802 	lsl	r2, r2, #16
 c1c8e54:	e1a02842 	asr	r2, r2, #16
 c1c8e58:	e1a03803 	lsl	r3, r3, #16
 c1c8e5c:	e1a03843 	asr	r3, r3, #16
 c1c8e60:	e1a00002 	mov	r0, r2
 c1c8e64:	e1a01003 	mov	r1, r3
 c1c8e68:	eb000bc7 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c8e6c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8e70:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8e74:	e1a02802 	lsl	r2, r2, #16
 c1c8e78:	e1a02842 	asr	r2, r2, #16
 c1c8e7c:	e1a03803 	lsl	r3, r3, #16
 c1c8e80:	e1a03843 	asr	r3, r3, #16
 c1c8e84:	e59f02ec 	ldr	r0, [pc, #748]	; c1c9178 <test_sound_effects+0xccc>
 c1c8e88:	e1a01002 	mov	r1, r2
 c1c8e8c:	e1a02003 	mov	r2, r3
 c1c8e90:	eb0000ee 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo (150 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 2400 );
    while( kb_scan() < 0 )
 c1c8e94:	eb000e49 	bl	c1cc7c0 <kb_scan>
 c1c8e98:	e1a03000 	mov	r3, r0
 c1c8e9c:	e3530000 	cmp	r3, #0
 c1c8ea0:	baffffbb 	blt	c1c8d94 <test_sound_effects+0x8e8>
     	ch0_aux = ch0 + (ch0_aux >> 1);
     	ch1_aux = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0_aux, ch1_aux );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c1c8ea4:	eb001b29 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c8ea8:	e59f0290 	ldr	r0, [pc, #656]	; c1c9140 <test_sound_effects+0xc94>
 c1c8eac:	eb001a8a 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Echo & fade (1 s): hable y escuche... " );
 c1c8eb0:	e59f02d0 	ldr	r0, [pc, #720]	; c1c9188 <test_sound_effects+0xcdc>
 c1c8eb4:	eb001a88 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 16000 );
 c1c8eb8:	e59f02b8 	ldr	r0, [pc, #696]	; c1c9178 <test_sound_effects+0xccc>
 c1c8ebc:	e3a01dfa 	mov	r1, #16000	; 0x3e80
 c1c8ec0:	eb0000b3 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c8ec4:	ea00003f 	b	c1c8fc8 <test_sound_effects+0xb1c>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c8ec8:	e24b2012 	sub	r2, fp, #18
 c1c8ecc:	e24b3014 	sub	r3, fp, #20
 c1c8ed0:	e1a00002 	mov	r0, r2
 c1c8ed4:	e1a01003 	mov	r1, r3
 c1c8ed8:	eb000bc5 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c8edc:	e24b2016 	sub	r2, fp, #22
 c1c8ee0:	e24b3018 	sub	r3, fp, #24
 c1c8ee4:	e59f028c 	ldr	r0, [pc, #652]	; c1c9178 <test_sound_effects+0xccc>
 c1c8ee8:	e1a01002 	mov	r1, r2
 c1c8eec:	e1a02003 	mov	r2, r3
 c1c8ef0:	eb000108 	bl	c1c9318 <audiodelay_get>
      	ch0 = ch0 + (ch0_aux >> 1);
 c1c8ef4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c8ef8:	e1a03803 	lsl	r3, r3, #16
 c1c8efc:	e1a03843 	asr	r3, r3, #16
 c1c8f00:	e1a030c3 	asr	r3, r3, #1
 c1c8f04:	e1a03803 	lsl	r3, r3, #16
 c1c8f08:	e1a03823 	lsr	r3, r3, #16
 c1c8f0c:	e1a03803 	lsl	r3, r3, #16
 c1c8f10:	e1a02823 	lsr	r2, r3, #16
 c1c8f14:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c8f18:	e1a03803 	lsl	r3, r3, #16
 c1c8f1c:	e1a03823 	lsr	r3, r3, #16
 c1c8f20:	e0823003 	add	r3, r2, r3
 c1c8f24:	e1a03803 	lsl	r3, r3, #16
 c1c8f28:	e1a03823 	lsr	r3, r3, #16
 c1c8f2c:	e1a03803 	lsl	r3, r3, #16
 c1c8f30:	e1a03823 	lsr	r3, r3, #16
 c1c8f34:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
      	ch1 = ch1 + (ch1_aux >> 1);
 c1c8f38:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c8f3c:	e1a03803 	lsl	r3, r3, #16
 c1c8f40:	e1a03843 	asr	r3, r3, #16
 c1c8f44:	e1a030c3 	asr	r3, r3, #1
 c1c8f48:	e1a03803 	lsl	r3, r3, #16
 c1c8f4c:	e1a03823 	lsr	r3, r3, #16
 c1c8f50:	e1a03803 	lsl	r3, r3, #16
 c1c8f54:	e1a02823 	lsr	r2, r3, #16
 c1c8f58:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8f5c:	e1a03803 	lsl	r3, r3, #16
 c1c8f60:	e1a03823 	lsr	r3, r3, #16
 c1c8f64:	e0823003 	add	r3, r2, r3
 c1c8f68:	e1a03803 	lsl	r3, r3, #16
 c1c8f6c:	e1a03823 	lsr	r3, r3, #16
 c1c8f70:	e1a03803 	lsl	r3, r3, #16
 c1c8f74:	e1a03823 	lsr	r3, r3, #16
 c1c8f78:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
     	iis_putSample( ch0, ch1 );
 c1c8f7c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8f80:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8f84:	e1a02802 	lsl	r2, r2, #16
 c1c8f88:	e1a02842 	asr	r2, r2, #16
 c1c8f8c:	e1a03803 	lsl	r3, r3, #16
 c1c8f90:	e1a03843 	asr	r3, r3, #16
 c1c8f94:	e1a00002 	mov	r0, r2
 c1c8f98:	e1a01003 	mov	r1, r3
 c1c8f9c:	eb000b7a 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c8fa0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c8fa4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c8fa8:	e1a02802 	lsl	r2, r2, #16
 c1c8fac:	e1a02842 	asr	r2, r2, #16
 c1c8fb0:	e1a03803 	lsl	r3, r3, #16
 c1c8fb4:	e1a03843 	asr	r3, r3, #16
 c1c8fb8:	e59f01b8 	ldr	r0, [pc, #440]	; c1c9178 <test_sound_effects+0xccc>
 c1c8fbc:	e1a01002 	mov	r1, r2
 c1c8fc0:	e1a02003 	mov	r2, r3
 c1c8fc4:	eb0000a1 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Echo & fade (1 s): hable y escuche... " );
    audiodelay_init( &delay_buffer, 16000 );
    while( kb_scan() < 0 )
 c1c8fc8:	eb000dfc 	bl	c1cc7c0 <kb_scan>
 c1c8fcc:	e1a03000 	mov	r3, r0
 c1c8fd0:	e3530000 	cmp	r3, #0
 c1c8fd4:	baffffbb 	blt	c1c8ec8 <test_sound_effects+0xa1c>
      	ch0 = ch0 + (ch0_aux >> 1);
      	ch1 = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0, ch1 );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
    }
    uart0_getint();
 c1c8fd8:	eb001adc 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c8fdc:	e59f015c 	ldr	r0, [pc, #348]	; c1c9140 <test_sound_effects+0xc94>
 c1c8fe0:	eb001a3d 	bl	c1cf8dc <uart0_puts>

    /************************************/

    uart0_puts( "  - Reverberación (echo & fade 100 ms): hable y escuche... " );
 c1c8fe4:	e59f01a0 	ldr	r0, [pc, #416]	; c1c918c <test_sound_effects+0xce0>
 c1c8fe8:	eb001a3b 	bl	c1cf8dc <uart0_puts>
    audiodelay_init( &delay_buffer, 1600 );
 c1c8fec:	e59f0184 	ldr	r0, [pc, #388]	; c1c9178 <test_sound_effects+0xccc>
 c1c8ff0:	e3a01d19 	mov	r1, #1600	; 0x640
 c1c8ff4:	eb000066 	bl	c1c9194 <audiodelay_init>
    while( kb_scan() < 0 )
 c1c8ff8:	ea00003f 	b	c1c90fc <test_sound_effects+0xc50>
    {
     	iis_getSample( &ch0, &ch1 );
 c1c8ffc:	e24b2012 	sub	r2, fp, #18
 c1c9000:	e24b3014 	sub	r3, fp, #20
 c1c9004:	e1a00002 	mov	r0, r2
 c1c9008:	e1a01003 	mov	r1, r3
 c1c900c:	eb000b78 	bl	c1cbdf4 <iis_getSample>
    	audiodelay_get( &delay_buffer, &ch0_aux, &ch1_aux );
 c1c9010:	e24b2016 	sub	r2, fp, #22
 c1c9014:	e24b3018 	sub	r3, fp, #24
 c1c9018:	e59f0158 	ldr	r0, [pc, #344]	; c1c9178 <test_sound_effects+0xccc>
 c1c901c:	e1a01002 	mov	r1, r2
 c1c9020:	e1a02003 	mov	r2, r3
 c1c9024:	eb0000bb 	bl	c1c9318 <audiodelay_get>
      	ch0 = ch0 + (ch0_aux >> 1);
 c1c9028:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1c902c:	e1a03803 	lsl	r3, r3, #16
 c1c9030:	e1a03843 	asr	r3, r3, #16
 c1c9034:	e1a030c3 	asr	r3, r3, #1
 c1c9038:	e1a03803 	lsl	r3, r3, #16
 c1c903c:	e1a03823 	lsr	r3, r3, #16
 c1c9040:	e1a03803 	lsl	r3, r3, #16
 c1c9044:	e1a02823 	lsr	r2, r3, #16
 c1c9048:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1c904c:	e1a03803 	lsl	r3, r3, #16
 c1c9050:	e1a03823 	lsr	r3, r3, #16
 c1c9054:	e0823003 	add	r3, r2, r3
 c1c9058:	e1a03803 	lsl	r3, r3, #16
 c1c905c:	e1a03823 	lsr	r3, r3, #16
 c1c9060:	e1a03803 	lsl	r3, r3, #16
 c1c9064:	e1a03823 	lsr	r3, r3, #16
 c1c9068:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
      	ch1 = ch1 + (ch1_aux >> 1);
 c1c906c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1c9070:	e1a03803 	lsl	r3, r3, #16
 c1c9074:	e1a03843 	asr	r3, r3, #16
 c1c9078:	e1a030c3 	asr	r3, r3, #1
 c1c907c:	e1a03803 	lsl	r3, r3, #16
 c1c9080:	e1a03823 	lsr	r3, r3, #16
 c1c9084:	e1a03803 	lsl	r3, r3, #16
 c1c9088:	e1a02823 	lsr	r2, r3, #16
 c1c908c:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c9090:	e1a03803 	lsl	r3, r3, #16
 c1c9094:	e1a03823 	lsr	r3, r3, #16
 c1c9098:	e0823003 	add	r3, r2, r3
 c1c909c:	e1a03803 	lsl	r3, r3, #16
 c1c90a0:	e1a03823 	lsr	r3, r3, #16
 c1c90a4:	e1a03803 	lsl	r3, r3, #16
 c1c90a8:	e1a03823 	lsr	r3, r3, #16
 c1c90ac:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
     	iis_putSample( ch0, ch1 );
 c1c90b0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c90b4:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c90b8:	e1a02802 	lsl	r2, r2, #16
 c1c90bc:	e1a02842 	asr	r2, r2, #16
 c1c90c0:	e1a03803 	lsl	r3, r3, #16
 c1c90c4:	e1a03843 	asr	r3, r3, #16
 c1c90c8:	e1a00002 	mov	r0, r2
 c1c90cc:	e1a01003 	mov	r1, r3
 c1c90d0:	eb000b2d 	bl	c1cbd8c <iis_putSample>
    	audiodelay_put( &delay_buffer, ch0, ch1 );
 c1c90d4:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c90d8:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
 c1c90dc:	e1a02802 	lsl	r2, r2, #16
 c1c90e0:	e1a02842 	asr	r2, r2, #16
 c1c90e4:	e1a03803 	lsl	r3, r3, #16
 c1c90e8:	e1a03843 	asr	r3, r3, #16
 c1c90ec:	e59f0084 	ldr	r0, [pc, #132]	; c1c9178 <test_sound_effects+0xccc>
 c1c90f0:	e1a01002 	mov	r1, r2
 c1c90f4:	e1a02003 	mov	r2, r3
 c1c90f8:	eb000054 	bl	c1c9250 <audiodelay_put>

    /************************************/

    uart0_puts( "  - Reverberación (echo & fade 100 ms): hable y escuche... " );
    audiodelay_init( &delay_buffer, 1600 );
    while( kb_scan() < 0 )
 c1c90fc:	eb000daf 	bl	c1cc7c0 <kb_scan>
 c1c9100:	e1a03000 	mov	r3, r0
 c1c9104:	e3530000 	cmp	r3, #0
 c1c9108:	baffffbb 	blt	c1c8ffc <test_sound_effects+0xb50>
      	ch0 = ch0 + (ch0_aux >> 1);
      	ch1 = ch1 + (ch1_aux >> 1);
     	iis_putSample( ch0, ch1 );
    	audiodelay_put( &delay_buffer, ch0, ch1 );
     }
    uart0_getint();
 c1c910c:	eb001a8f 	bl	c1cfb50 <uart0_getint>
    uart0_puts( "OK\n" );
 c1c9110:	e59f0028 	ldr	r0, [pc, #40]	; c1c9140 <test_sound_effects+0xc94>
 c1c9114:	eb0019f0 	bl	c1cf8dc <uart0_puts>

    uart0_puts( "Going into infinite loop...\n" );
 c1c9118:	e59f0070 	ldr	r0, [pc, #112]	; c1c9190 <test_sound_effects+0xce4>
 c1c911c:	eb0019ee 	bl	c1cf8dc <uart0_puts>


    /************************************/

    while(1);
 c1c9120:	eafffffe 	b	c1c9120 <test_sound_effects+0xc74>
 c1c9124:	0c100788 	.word	0x0c100788
 c1c9128:	0c1007c0 	.word	0x0c1007c0
 c1c912c:	0c1007ec 	.word	0x0c1007ec
 c1c9130:	0c100090 	.word	0x0c100090
 c1c9134:	0c100808 	.word	0x0c100808
 c1c9138:	0c100810 	.word	0x0c100810
 c1c913c:	0c100048 	.word	0x0c100048
 c1c9140:	0c100830 	.word	0x0c100830
 c1c9144:	0c100834 	.word	0x0c100834
 c1c9148:	0c100000 	.word	0x0c100000
 c1c914c:	0c100858 	.word	0x0c100858
 c1c9150:	0c100880 	.word	0x0c100880
 c1c9154:	0c10b910 	.word	0x0c10b910
 c1c9158:	0c159b10 	.word	0x0c159b10
 c1c915c:	000270ff 	.word	0x000270ff
 c1c9160:	0c1008c4 	.word	0x0c1008c4
 c1c9164:	0c1008f8 	.word	0x0c1008f8
 c1c9168:	0c100928 	.word	0x0c100928
 c1c916c:	0c100958 	.word	0x0c100958
 c1c9170:	0c100980 	.word	0x0c100980
 c1c9174:	0c1009a4 	.word	0x0c1009a4
 c1c9178:	0c1a7d10 	.word	0x0c1a7d10
 c1c917c:	0c1009cc 	.word	0x0c1009cc
 c1c9180:	0c1009f4 	.word	0x0c1009f4
 c1c9184:	0c100a1c 	.word	0x0c100a1c
 c1c9188:	0c100a44 	.word	0x0c100a44
 c1c918c:	0c100a70 	.word	0x0c100a70
 c1c9190:	0c100aac 	.word	0x0c100aac

0c1c9194 <audiodelay_init>:

}

void audiodelay_init( audiodelay_t *buffer, uint16 size )
{
 c1c9194:	e1a0c00d 	mov	ip, sp
 c1c9198:	e92dd800 	push	{fp, ip, lr, pc}
 c1c919c:	e24cb004 	sub	fp, ip, #4
 c1c91a0:	e24dd010 	sub	sp, sp, #16
 c1c91a4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1c91a8:	e1a03001 	mov	r3, r1
 c1c91ac:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
	uint16 i;

	for( i=0; i<size; i++ )
 c1c91b0:	e3a03000 	mov	r3, #0
 c1c91b4:	e14b30be 	strh	r3, [fp, #-14]
 c1c91b8:	ea00000f 	b	c1c91fc <audiodelay_init+0x68>
	{
		buffer->ch0[i] = 0;
 c1c91bc:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c91c0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1c91c4:	e1a03083 	lsl	r3, r3, #1
 c1c91c8:	e0823003 	add	r3, r2, r3
 c1c91cc:	e3a02000 	mov	r2, #0
 c1c91d0:	e1c320b0 	strh	r2, [r3]
		buffer->ch1[i] = 0;
 c1c91d4:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c91d8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1c91dc:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c1c91e0:	e1a03083 	lsl	r3, r3, #1
 c1c91e4:	e0823003 	add	r3, r2, r3
 c1c91e8:	e3a02000 	mov	r2, #0
 c1c91ec:	e1c320b0 	strh	r2, [r3]

void audiodelay_init( audiodelay_t *buffer, uint16 size )
{
	uint16 i;

	for( i=0; i<size; i++ )
 c1c91f0:	e15b30be 	ldrh	r3, [fp, #-14]
 c1c91f4:	e2833001 	add	r3, r3, #1
 c1c91f8:	e14b30be 	strh	r3, [fp, #-14]
 c1c91fc:	e15b20be 	ldrh	r2, [fp, #-14]
 c1c9200:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c1c9204:	e1520003 	cmp	r2, r3
 c1c9208:	3affffeb 	bcc	c1c91bc <audiodelay_init+0x28>
	{
		buffer->ch0[i] = 0;
		buffer->ch1[i] = 0;
	}
	buffer->head = 0;
 c1c920c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1c9210:	e59f3030 	ldr	r3, [pc, #48]	; c1c9248 <audiodelay_init+0xb4>
 c1c9214:	e3a01000 	mov	r1, #0
 c1c9218:	e18210b3 	strh	r1, [r2, r3]
	buffer->tail = 0;
 c1c921c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1c9220:	e59f3024 	ldr	r3, [pc, #36]	; c1c924c <audiodelay_init+0xb8>
 c1c9224:	e3a01000 	mov	r1, #0
 c1c9228:	e18210b3 	strh	r1, [r2, r3]
	buffer->size = size;
 c1c922c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1c9230:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c1c9234:	e15b11ba 	ldrh	r1, [fp, #-26]	; 0xffffffe6
 c1c9238:	e18210b3 	strh	r1, [r2, r3]
}
 c1c923c:	e24bd00c 	sub	sp, fp, #12
 c1c9240:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9244:	e12fff1e 	bx	lr
 c1c9248:	0001f402 	.word	0x0001f402
 c1c924c:	0001f404 	.word	0x0001f404

0c1c9250 <audiodelay_put>:

void audiodelay_put( audiodelay_t *buffer, int16 ch0, int16 ch1 )
{
 c1c9250:	e1a0c00d 	mov	ip, sp
 c1c9254:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9258:	e24cb004 	sub	fp, ip, #4
 c1c925c:	e24dd008 	sub	sp, sp, #8
 c1c9260:	e50b0010 	str	r0, [fp, #-16]
 c1c9264:	e1a03002 	mov	r3, r2
 c1c9268:	e14b11b2 	strh	r1, [fp, #-18]	; 0xffffffee
 c1c926c:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
	buffer->ch0[buffer->head] = ch0;
 c1c9270:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9274:	e59f3098 	ldr	r3, [pc, #152]	; c1c9314 <audiodelay_put+0xc4>
 c1c9278:	e19230b3 	ldrh	r3, [r2, r3]
 c1c927c:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9280:	e1a03083 	lsl	r3, r3, #1
 c1c9284:	e0823003 	add	r3, r2, r3
 c1c9288:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1c928c:	e1c320b0 	strh	r2, [r3]
	buffer->ch1[buffer->head] = ch1;
 c1c9290:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9294:	e59f3078 	ldr	r3, [pc, #120]	; c1c9314 <audiodelay_put+0xc4>
 c1c9298:	e19230b3 	ldrh	r3, [r2, r3]
 c1c929c:	e51b2010 	ldr	r2, [fp, #-16]
 c1c92a0:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c1c92a4:	e1a03083 	lsl	r3, r3, #1
 c1c92a8:	e0823003 	add	r3, r2, r3
 c1c92ac:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c1c92b0:	e1c320b0 	strh	r2, [r3]
	if( ++(buffer->head) == buffer->size )
 c1c92b4:	e51b2010 	ldr	r2, [fp, #-16]
 c1c92b8:	e59f3054 	ldr	r3, [pc, #84]	; c1c9314 <audiodelay_put+0xc4>
 c1c92bc:	e19230b3 	ldrh	r3, [r2, r3]
 c1c92c0:	e2833001 	add	r3, r3, #1
 c1c92c4:	e1a03803 	lsl	r3, r3, #16
 c1c92c8:	e1a01823 	lsr	r1, r3, #16
 c1c92cc:	e51b2010 	ldr	r2, [fp, #-16]
 c1c92d0:	e59f303c 	ldr	r3, [pc, #60]	; c1c9314 <audiodelay_put+0xc4>
 c1c92d4:	e18210b3 	strh	r1, [r2, r3]
 c1c92d8:	e51b2010 	ldr	r2, [fp, #-16]
 c1c92dc:	e59f3030 	ldr	r3, [pc, #48]	; c1c9314 <audiodelay_put+0xc4>
 c1c92e0:	e19220b3 	ldrh	r2, [r2, r3]
 c1c92e4:	e51b1010 	ldr	r1, [fp, #-16]
 c1c92e8:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c1c92ec:	e19130b3 	ldrh	r3, [r1, r3]
 c1c92f0:	e1520003 	cmp	r2, r3
 c1c92f4:	1a000003 	bne	c1c9308 <audiodelay_put+0xb8>
		buffer->head = 0;
 c1c92f8:	e51b2010 	ldr	r2, [fp, #-16]
 c1c92fc:	e59f3010 	ldr	r3, [pc, #16]	; c1c9314 <audiodelay_put+0xc4>
 c1c9300:	e3a01000 	mov	r1, #0
 c1c9304:	e18210b3 	strh	r1, [r2, r3]
}
 c1c9308:	e24bd00c 	sub	sp, fp, #12
 c1c930c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9310:	e12fff1e 	bx	lr
 c1c9314:	0001f402 	.word	0x0001f402

0c1c9318 <audiodelay_get>:

void audiodelay_get( audiodelay_t *buffer, int16 *ch0, int16 *ch1 )
{
 c1c9318:	e1a0c00d 	mov	ip, sp
 c1c931c:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9320:	e24cb004 	sub	fp, ip, #4
 c1c9324:	e24dd010 	sub	sp, sp, #16
 c1c9328:	e50b0010 	str	r0, [fp, #-16]
 c1c932c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
 c1c9330:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	*ch0 = buffer->ch0[buffer->tail];
 c1c9334:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9338:	e59f30a0 	ldr	r3, [pc, #160]	; c1c93e0 <audiodelay_get+0xc8>
 c1c933c:	e19230b3 	ldrh	r3, [r2, r3]
 c1c9340:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9344:	e1a03083 	lsl	r3, r3, #1
 c1c9348:	e0823003 	add	r3, r2, r3
 c1c934c:	e1d320b0 	ldrh	r2, [r3]
 c1c9350:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1c9354:	e1c320b0 	strh	r2, [r3]
	*ch1 = buffer->ch1[buffer->tail];
 c1c9358:	e51b2010 	ldr	r2, [fp, #-16]
 c1c935c:	e59f307c 	ldr	r3, [pc, #124]	; c1c93e0 <audiodelay_get+0xc8>
 c1c9360:	e19230b3 	ldrh	r3, [r2, r3]
 c1c9364:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9368:	e2833c7d 	add	r3, r3, #32000	; 0x7d00
 c1c936c:	e1a03083 	lsl	r3, r3, #1
 c1c9370:	e0823003 	add	r3, r2, r3
 c1c9374:	e1d320b0 	ldrh	r2, [r3]
 c1c9378:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1c937c:	e1c320b0 	strh	r2, [r3]
	if( ++(buffer->tail) == buffer->size )
 c1c9380:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9384:	e59f3054 	ldr	r3, [pc, #84]	; c1c93e0 <audiodelay_get+0xc8>
 c1c9388:	e19230b3 	ldrh	r3, [r2, r3]
 c1c938c:	e2833001 	add	r3, r3, #1
 c1c9390:	e1a03803 	lsl	r3, r3, #16
 c1c9394:	e1a01823 	lsr	r1, r3, #16
 c1c9398:	e51b2010 	ldr	r2, [fp, #-16]
 c1c939c:	e59f303c 	ldr	r3, [pc, #60]	; c1c93e0 <audiodelay_get+0xc8>
 c1c93a0:	e18210b3 	strh	r1, [r2, r3]
 c1c93a4:	e51b2010 	ldr	r2, [fp, #-16]
 c1c93a8:	e59f3030 	ldr	r3, [pc, #48]	; c1c93e0 <audiodelay_get+0xc8>
 c1c93ac:	e19220b3 	ldrh	r2, [r2, r3]
 c1c93b0:	e51b1010 	ldr	r1, [fp, #-16]
 c1c93b4:	e3a03b7d 	mov	r3, #128000	; 0x1f400
 c1c93b8:	e19130b3 	ldrh	r3, [r1, r3]
 c1c93bc:	e1520003 	cmp	r2, r3
 c1c93c0:	1a000003 	bne	c1c93d4 <audiodelay_get+0xbc>
		buffer->tail = 0;
 c1c93c4:	e51b2010 	ldr	r2, [fp, #-16]
 c1c93c8:	e59f3010 	ldr	r3, [pc, #16]	; c1c93e0 <audiodelay_get+0xc8>
 c1c93cc:	e3a01000 	mov	r1, #0
 c1c93d0:	e18210b3 	strh	r1, [r2, r3]
}
 c1c93d4:	e24bd00c 	sub	sp, fp, #12
 c1c93d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c93dc:	e12fff1e 	bx	lr
 c1c93e0:	0001f404 	.word	0x0001f404

0c1c93e4 <cyclic>:
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void cyclic( void )
{
 c1c93e4:	e1a0c00d 	mov	ip, sp
 c1c93e8:	e92dd800 	push	{fp, ip, lr, pc}
 c1c93ec:	e24cb004 	sub	fp, ip, #4
 c1c93f0:	e24dd008 	sub	sp, sp, #8
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando una aplicación cyclic executive\n" );
 c1c93f4:	e59f0128 	ldr	r0, [pc, #296]	; c1c9524 <cyclic+0x140>
 c1c93f8:	eb001937 	bl	c1cf8dc <uart0_puts>
    uart0_puts(     " ------------------------------------------\n\n" ) ;
 c1c93fc:	e59f0124 	ldr	r0, [pc, #292]	; c1c9528 <cyclic+0x144>
 c1c9400:	eb001935 	bl	c1cf8dc <uart0_puts>

    flagTask5 = FALSE;    /* Inicializa flags */
 c1c9404:	e59f3120 	ldr	r3, [pc, #288]	; c1c952c <cyclic+0x148>
 c1c9408:	e3a02000 	mov	r2, #0
 c1c940c:	e5c32000 	strb	r2, [r3]
    flagTask6 = FALSE;
 c1c9410:	e59f3118 	ldr	r3, [pc, #280]	; c1c9530 <cyclic+0x14c>
 c1c9414:	e3a02000 	mov	r2, #0
 c1c9418:	e5c32000 	strb	r2, [r3]
    flagPb    = FALSE;
 c1c941c:	e59f3110 	ldr	r3, [pc, #272]	; c1c9534 <cyclic+0x150>
 c1c9420:	e3a02000 	mov	r2, #0
 c1c9424:	e5c32000 	strb	r2, [r3]
    flagTimer = FALSE;
 c1c9428:	e59f3108 	ldr	r3, [pc, #264]	; c1c9538 <cyclic+0x154>
 c1c942c:	e3a02000 	mov	r2, #0
 c1c9430:	e5c32000 	strb	r2, [r3]

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c1c9434:	eb00023e 	bl	c1c9d34 <Task1>
    Task2();
 c1c9438:	eb000253 	bl	c1c9d8c <Task2>
    Task3();
 c1c943c:	eb000295 	bl	c1c9e98 <Task3>
    Task4();
 c1c9440:	eb0002bd 	bl	c1c9f3c <Task4>
    Task5();
 c1c9444:	eb0002e1 	bl	c1c9fd0 <Task5>
    Task6();
 c1c9448:	eb000305 	bl	c1ca064 <Task6>
    Task7();
 c1c944c:	eb000323 	bl	c1ca0e0 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c1c9450:	e59f30e4 	ldr	r3, [pc, #228]	; c1c953c <cyclic+0x158>
 c1c9454:	e59f20e4 	ldr	r2, [pc, #228]	; c1c9540 <cyclic+0x15c>
 c1c9458:	e5832000 	str	r2, [r3]
	ic_enable(INT_EINT4567);
 c1c945c:	e3a00015 	mov	r0, #21
 c1c9460:	eb000c79 	bl	c1cc64c <ic_enable>

	//MINOR_PERIOD: 50ms
	tmr_set_mode(TIMER0, RELOAD);
 c1c9464:	e3a00000 	mov	r0, #0
 c1c9468:	e3a01001 	mov	r1, #1
 c1c946c:	eb001664 	bl	c1cee04 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 10);
 c1c9470:	e3a00000 	mov	r0, #0
 c1c9474:	e3a0100a 	mov	r1, #10
 c1c9478:	eb001560 	bl	c1cea00 <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c1c947c:	e3a00000 	mov	r0, #0
 c1c9480:	e3a01002 	mov	r1, #2
 c1c9484:	eb001594 	bl	c1ceadc <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c1c9488:	e3a00000 	mov	r0, #0
 c1c948c:	e59f10b0 	ldr	r1, [pc, #176]	; c1c9544 <cyclic+0x160>
 c1c9490:	e3a02001 	mov	r2, #1
 c1c9494:	eb0015df 	bl	c1cec18 <tmr_set_count>

	tmr_update(TIMER0);
 c1c9498:	e3a00000 	mov	r0, #0
 c1c949c:	eb00162a 	bl	c1ced4c <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c1c94a0:	e59f30a0 	ldr	r3, [pc, #160]	; c1c9548 <cyclic+0x164>
 c1c94a4:	e59f20a0 	ldr	r2, [pc, #160]	; c1c954c <cyclic+0x168>
 c1c94a8:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c1c94ac:	e3a00000 	mov	r0, #0
 c1c94b0:	eb001696 	bl	c1cef10 <tmr_start>

	ic_enable(INT_TIMER0);
 c1c94b4:	e3a0000d 	mov	r0, #13
 c1c94b8:	eb000c63 	bl	c1cc64c <ic_enable>
 c1c94bc:	ea000000 	b	c1c94c4 <cyclic+0xe0>
        {
        	flagTimer = FALSE;
        	(*pjobs[i])();              /* Las tareas que forman el trabajo se ejecutan en esta hebra (background) */
        	i = ( i==NUM_JOBS-1 ? 0 : i+1 );
        }
    }
 c1c94c0:	e1a00000 	nop			; (mov r0, r0)

	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c1c94c4:	eb001b31 	bl	c1d0190 <sleep>
        if( flagTimer )
 c1c94c8:	e59f3068 	ldr	r3, [pc, #104]	; c1c9538 <cyclic+0x154>
 c1c94cc:	e5d33000 	ldrb	r3, [r3]
 c1c94d0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c94d4:	e3530000 	cmp	r3, #0
 c1c94d8:	0afffff8 	beq	c1c94c0 <cyclic+0xdc>
        {
        	flagTimer = FALSE;
 c1c94dc:	e59f3054 	ldr	r3, [pc, #84]	; c1c9538 <cyclic+0x154>
 c1c94e0:	e3a02000 	mov	r2, #0
 c1c94e4:	e5c32000 	strb	r2, [r3]
        	(*pjobs[i])();              /* Las tareas que forman el trabajo se ejecutan en esta hebra (background) */
 c1c94e8:	e55b200d 	ldrb	r2, [fp, #-13]
 c1c94ec:	e59f305c 	ldr	r3, [pc, #92]	; c1c9550 <cyclic+0x16c>
 c1c94f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 c1c94f4:	e1a0e00f 	mov	lr, pc
 c1c94f8:	e12fff13 	bx	r3
        	i = ( i==NUM_JOBS-1 ? 0 : i+1 );
 c1c94fc:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c9500:	e35300c7 	cmp	r3, #199	; 0xc7
 c1c9504:	0a000003 	beq	c1c9518 <cyclic+0x134>
 c1c9508:	e55b300d 	ldrb	r3, [fp, #-13]
 c1c950c:	e2833001 	add	r3, r3, #1
 c1c9510:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c9514:	ea000000 	b	c1c951c <cyclic+0x138>
 c1c9518:	e3a03000 	mov	r3, #0
 c1c951c:	e54b300d 	strb	r3, [fp, #-13]
        }
    }
 c1c9520:	eaffffe7 	b	c1c94c4 <cyclic+0xe0>
 c1c9524:	0c100dec 	.word	0x0c100dec
 c1c9528:	0c100e1c 	.word	0x0c100e1c
 c1c952c:	0c1c7117 	.word	0x0c1c7117
 c1c9530:	0c1c7118 	.word	0x0c1c7118
 c1c9534:	0c1c7119 	.word	0x0c1c7119
 c1c9538:	0c1c711a 	.word	0x0c1c711a
 c1c953c:	0c7fff74 	.word	0x0c7fff74
 c1c9540:	0c1ca158 	.word	0x0c1ca158
 c1c9544:	00009c40 	.word	0x00009c40
 c1c9548:	0c7fff54 	.word	0x0c7fff54
 c1c954c:	0c1ca298 	.word	0x0c1ca298
 c1c9550:	0c100acc 	.word	0x0c100acc

0c1c9554 <JobA>:
}

/*******************************************************************/

void JobA( void )
{
 c1c9554:	e1a0c00d 	mov	ip, sp
 c1c9558:	e92dd800 	push	{fp, ip, lr, pc}
 c1c955c:	e24cb004 	sub	fp, ip, #4
    Task2();
 c1c9560:	eb000209 	bl	c1c9d8c <Task2>
    Task7();
 c1c9564:	eb0002dd 	bl	c1ca0e0 <Task7>
}
 c1c9568:	e24bd00c 	sub	sp, fp, #12
 c1c956c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9570:	e12fff1e 	bx	lr

0c1c9574 <JobB>:

void JobB( void )
{
 c1c9574:	e1a0c00d 	mov	ip, sp
 c1c9578:	e92dd800 	push	{fp, ip, lr, pc}
 c1c957c:	e24cb004 	sub	fp, ip, #4
    Task2();
 c1c9580:	eb000201 	bl	c1c9d8c <Task2>
    Task5();
 c1c9584:	eb000291 	bl	c1c9fd0 <Task5>
    Task6();
 c1c9588:	eb0002b5 	bl	c1ca064 <Task6>
    Task7();
 c1c958c:	eb0002d3 	bl	c1ca0e0 <Task7>
}
 c1c9590:	e24bd00c 	sub	sp, fp, #12
 c1c9594:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9598:	e12fff1e 	bx	lr

0c1c959c <JobC>:

void JobC( void )
{
 c1c959c:	e1a0c00d 	mov	ip, sp
 c1c95a0:	e92dd800 	push	{fp, ip, lr, pc}
 c1c95a4:	e24cb004 	sub	fp, ip, #4
    Task2();
 c1c95a8:	eb0001f7 	bl	c1c9d8c <Task2>
    Task5();
 c1c95ac:	eb000287 	bl	c1c9fd0 <Task5>
    Task6();
 c1c95b0:	eb0002ab 	bl	c1ca064 <Task6>
    Task1();
 c1c95b4:	eb0001de 	bl	c1c9d34 <Task1>
    Task7();
 c1c95b8:	eb0002c8 	bl	c1ca0e0 <Task7>
}
 c1c95bc:	e24bd00c 	sub	sp, fp, #12
 c1c95c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c95c4:	e12fff1e 	bx	lr

0c1c95c8 <JobD>:

void JobD( void )
{
 c1c95c8:	e1a0c00d 	mov	ip, sp
 c1c95cc:	e92dd800 	push	{fp, ip, lr, pc}
 c1c95d0:	e24cb004 	sub	fp, ip, #4
    Task2();
 c1c95d4:	eb0001ec 	bl	c1c9d8c <Task2>
    Task5();
 c1c95d8:	eb00027c 	bl	c1c9fd0 <Task5>
    Task6();
 c1c95dc:	eb0002a0 	bl	c1ca064 <Task6>
    Task1();
 c1c95e0:	eb0001d3 	bl	c1c9d34 <Task1>
    Task3();
 c1c95e4:	eb00022b 	bl	c1c9e98 <Task3>
    Task7();
 c1c95e8:	eb0002bc 	bl	c1ca0e0 <Task7>
}
 c1c95ec:	e24bd00c 	sub	sp, fp, #12
 c1c95f0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c95f4:	e12fff1e 	bx	lr

0c1c95f8 <JobE>:

void JobE( void )
{
 c1c95f8:	e1a0c00d 	mov	ip, sp
 c1c95fc:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9600:	e24cb004 	sub	fp, ip, #4
    Task2();
 c1c9604:	eb0001e0 	bl	c1c9d8c <Task2>
    Task5();
 c1c9608:	eb000270 	bl	c1c9fd0 <Task5>
    Task6();
 c1c960c:	eb000294 	bl	c1ca064 <Task6>
    Task1();
 c1c9610:	eb0001c7 	bl	c1c9d34 <Task1>
    Task3();
 c1c9614:	eb00021f 	bl	c1c9e98 <Task3>
    Task4();
 c1c9618:	eb000247 	bl	c1c9f3c <Task4>
    Task7();
 c1c961c:	eb0002af 	bl	c1ca0e0 <Task7>
}
 c1c9620:	e24bd00c 	sub	sp, fp, #12
 c1c9624:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9628:	e12fff1e 	bx	lr

0c1c962c <foreback>:
void isr_pb( void ) __attribute__ ((interrupt ("IRQ")));
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void foreback( void ) {
 c1c962c:	e1a0c00d 	mov	ip, sp
 c1c9630:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9634:	e24cb004 	sub	fp, ip, #4
    rtc_init();
    pbs_init();
    keypad_init();
*/

    uart0_puts( "\n\n Ejecutando una aplicación foreground/background\n" );
 c1c9638:	e59f01e8 	ldr	r0, [pc, #488]	; c1c9828 <foreback+0x1fc>
 c1c963c:	eb0018a6 	bl	c1cf8dc <uart0_puts>
    uart0_puts( " -----------------------------------------------\n\n" ) ;
 c1c9640:	e59f01e4 	ldr	r0, [pc, #484]	; c1c982c <foreback+0x200>
 c1c9644:	eb0018a4 	bl	c1cf8dc <uart0_puts>

    flagTask5      = FALSE;    /* Inicializa flags */
 c1c9648:	e59f31e0 	ldr	r3, [pc, #480]	; c1c9830 <foreback+0x204>
 c1c964c:	e3a02000 	mov	r2, #0
 c1c9650:	e5c32000 	strb	r2, [r3]
    flagTask6      = FALSE;
 c1c9654:	e59f31d8 	ldr	r3, [pc, #472]	; c1c9834 <foreback+0x208>
 c1c9658:	e3a02000 	mov	r2, #0
 c1c965c:	e5c32000 	strb	r2, [r3]
    flagPb         = FALSE;
 c1c9660:	e59f31d0 	ldr	r3, [pc, #464]	; c1c9838 <foreback+0x20c>
 c1c9664:	e3a02000 	mov	r2, #0
 c1c9668:	e5c32000 	strb	r2, [r3]
    flagToggleLeds = FALSE;
 c1c966c:	e59f31c8 	ldr	r3, [pc, #456]	; c1c983c <foreback+0x210>
 c1c9670:	e3a02000 	mov	r2, #0
 c1c9674:	e5c32000 	strb	r2, [r3]
    flagReadKeypad = FALSE;
 c1c9678:	e59f31c0 	ldr	r3, [pc, #448]	; c1c9840 <foreback+0x214>
 c1c967c:	e3a02000 	mov	r2, #0
 c1c9680:	e5c32000 	strb	r2, [r3]
    flagWriteRTC   = FALSE;
 c1c9684:	e59f31b8 	ldr	r3, [pc, #440]	; c1c9844 <foreback+0x218>
 c1c9688:	e3a02000 	mov	r2, #0
 c1c968c:	e5c32000 	strb	r2, [r3]
    flagWriteTicks = FALSE;
 c1c9690:	e59f31b0 	ldr	r3, [pc, #432]	; c1c9848 <foreback+0x21c>
 c1c9694:	e3a02000 	mov	r2, #0
 c1c9698:	e5c32000 	strb	r2, [r3]

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c1c969c:	eb0001a4 	bl	c1c9d34 <Task1>
    Task2();
 c1c96a0:	eb0001b9 	bl	c1c9d8c <Task2>
    Task3();
 c1c96a4:	eb0001fb 	bl	c1c9e98 <Task3>
    Task4();
 c1c96a8:	eb000223 	bl	c1c9f3c <Task4>
    Task5();
 c1c96ac:	eb000247 	bl	c1c9fd0 <Task5>
    Task6();
 c1c96b0:	eb00026b 	bl	c1ca064 <Task6>
    Task7();
 c1c96b4:	eb000289 	bl	c1ca0e0 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c1c96b8:	e59f318c 	ldr	r3, [pc, #396]	; c1c984c <foreback+0x220>
 c1c96bc:	e59f218c 	ldr	r2, [pc, #396]	; c1c9850 <foreback+0x224>
 c1c96c0:	e5832000 	str	r2, [r3]
    ic_enable(INT_EINT4567);
 c1c96c4:	e3a00015 	mov	r0, #21
 c1c96c8:	eb000bdf 	bl	c1cc64c <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c1c96cc:	e3a00000 	mov	r0, #0
 c1c96d0:	e3a01001 	mov	r1, #1
 c1c96d4:	eb0015ca 	bl	c1cee04 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c1c96d8:	e3a00000 	mov	r0, #0
 c1c96dc:	e3a01001 	mov	r1, #1
 c1c96e0:	eb0014c6 	bl	c1cea00 <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c1c96e4:	e3a00000 	mov	r0, #0
 c1c96e8:	e3a01002 	mov	r1, #2
 c1c96ec:	eb0014fa 	bl	c1ceadc <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c1c96f0:	e3a00000 	mov	r0, #0
 c1c96f4:	e59f1158 	ldr	r1, [pc, #344]	; c1c9854 <foreback+0x228>
 c1c96f8:	e3a02001 	mov	r2, #1
 c1c96fc:	eb001545 	bl	c1cec18 <tmr_set_count>

	tmr_update(TIMER0);
 c1c9700:	e3a00000 	mov	r0, #0
 c1c9704:	eb001590 	bl	c1ced4c <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c1c9708:	e59f3148 	ldr	r3, [pc, #328]	; c1c9858 <foreback+0x22c>
 c1c970c:	e59f2148 	ldr	r2, [pc, #328]	; c1c985c <foreback+0x230>
 c1c9710:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c1c9714:	e3a00000 	mov	r0, #0
 c1c9718:	eb0015fc 	bl	c1cef10 <tmr_start>

	ic_enable(INT_TIMER0);
 c1c971c:	e3a0000d 	mov	r0, #13
 c1c9720:	eb000bc9 	bl	c1cc64c <ic_enable>
 c1c9724:	ea000000 	b	c1c972c <foreback+0x100>
        if( flagPb )
        {
            flagPb = FALSE;
            Task7();
        }
    }
 c1c9728:	e1a00000 	nop			; (mov r0, r0)

	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c1c972c:	eb001a97 	bl	c1d0190 <sleep>
        if( flagToggleLeds )            /* Las tareas se ejecutan en esta hebra (background) en orden de aparición en el código */
 c1c9730:	e59f3104 	ldr	r3, [pc, #260]	; c1c983c <foreback+0x210>
 c1c9734:	e5d33000 	ldrb	r3, [r3]
 c1c9738:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c973c:	e3530000 	cmp	r3, #0
 c1c9740:	0a000003 	beq	c1c9754 <foreback+0x128>
        {
            flagToggleLeds = FALSE;
 c1c9744:	e59f30f0 	ldr	r3, [pc, #240]	; c1c983c <foreback+0x210>
 c1c9748:	e3a02000 	mov	r2, #0
 c1c974c:	e5c32000 	strb	r2, [r3]
            Task1();
 c1c9750:	eb000177 	bl	c1c9d34 <Task1>
        }
        if( flagReadKeypad )
 c1c9754:	e59f30e4 	ldr	r3, [pc, #228]	; c1c9840 <foreback+0x214>
 c1c9758:	e5d33000 	ldrb	r3, [r3]
 c1c975c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c9760:	e3530000 	cmp	r3, #0
 c1c9764:	0a000003 	beq	c1c9778 <foreback+0x14c>
        {
            flagReadKeypad = FALSE;
 c1c9768:	e59f30d0 	ldr	r3, [pc, #208]	; c1c9840 <foreback+0x214>
 c1c976c:	e3a02000 	mov	r2, #0
 c1c9770:	e5c32000 	strb	r2, [r3]
            Task2();
 c1c9774:	eb000184 	bl	c1c9d8c <Task2>
        }
        if( flagWriteRTC )
 c1c9778:	e59f30c4 	ldr	r3, [pc, #196]	; c1c9844 <foreback+0x218>
 c1c977c:	e5d33000 	ldrb	r3, [r3]
 c1c9780:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c9784:	e3530000 	cmp	r3, #0
 c1c9788:	0a000003 	beq	c1c979c <foreback+0x170>
        {
            flagWriteRTC = FALSE;
 c1c978c:	e59f30b0 	ldr	r3, [pc, #176]	; c1c9844 <foreback+0x218>
 c1c9790:	e3a02000 	mov	r2, #0
 c1c9794:	e5c32000 	strb	r2, [r3]
            Task3();
 c1c9798:	eb0001be 	bl	c1c9e98 <Task3>
        }
        if( flagWriteTicks )
 c1c979c:	e59f30a4 	ldr	r3, [pc, #164]	; c1c9848 <foreback+0x21c>
 c1c97a0:	e5d33000 	ldrb	r3, [r3]
 c1c97a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c97a8:	e3530000 	cmp	r3, #0
 c1c97ac:	0a000003 	beq	c1c97c0 <foreback+0x194>
        {
            flagWriteTicks = FALSE;
 c1c97b0:	e59f3090 	ldr	r3, [pc, #144]	; c1c9848 <foreback+0x21c>
 c1c97b4:	e3a02000 	mov	r2, #0
 c1c97b8:	e5c32000 	strb	r2, [r3]
            Task4();
 c1c97bc:	eb0001de 	bl	c1c9f3c <Task4>
        }
        if( flagTask5 )
 c1c97c0:	e59f3068 	ldr	r3, [pc, #104]	; c1c9830 <foreback+0x204>
 c1c97c4:	e5d33000 	ldrb	r3, [r3]
 c1c97c8:	e3530000 	cmp	r3, #0
 c1c97cc:	0a000003 	beq	c1c97e0 <foreback+0x1b4>
        {
            flagTask5 = FALSE;
 c1c97d0:	e59f3058 	ldr	r3, [pc, #88]	; c1c9830 <foreback+0x204>
 c1c97d4:	e3a02000 	mov	r2, #0
 c1c97d8:	e5c32000 	strb	r2, [r3]
            Task5();
 c1c97dc:	eb0001fb 	bl	c1c9fd0 <Task5>
        }
        if( flagTask6 )
 c1c97e0:	e59f304c 	ldr	r3, [pc, #76]	; c1c9834 <foreback+0x208>
 c1c97e4:	e5d33000 	ldrb	r3, [r3]
 c1c97e8:	e3530000 	cmp	r3, #0
 c1c97ec:	0a000003 	beq	c1c9800 <foreback+0x1d4>
        {
            flagTask6 = FALSE;
 c1c97f0:	e59f303c 	ldr	r3, [pc, #60]	; c1c9834 <foreback+0x208>
 c1c97f4:	e3a02000 	mov	r2, #0
 c1c97f8:	e5c32000 	strb	r2, [r3]
            Task6();
 c1c97fc:	eb000218 	bl	c1ca064 <Task6>
        }
        if( flagPb )
 c1c9800:	e59f3030 	ldr	r3, [pc, #48]	; c1c9838 <foreback+0x20c>
 c1c9804:	e5d33000 	ldrb	r3, [r3]
 c1c9808:	e20330ff 	and	r3, r3, #255	; 0xff
 c1c980c:	e3530000 	cmp	r3, #0
 c1c9810:	0affffc4 	beq	c1c9728 <foreback+0xfc>
        {
            flagPb = FALSE;
 c1c9814:	e59f301c 	ldr	r3, [pc, #28]	; c1c9838 <foreback+0x20c>
 c1c9818:	e3a02000 	mov	r2, #0
 c1c981c:	e5c32000 	strb	r2, [r3]
            Task7();
 c1c9820:	eb00022e 	bl	c1ca0e0 <Task7>
        }
    }
 c1c9824:	eaffffc0 	b	c1c972c <foreback+0x100>
 c1c9828:	0c100e4c 	.word	0x0c100e4c
 c1c982c:	0c100e80 	.word	0x0c100e80
 c1c9830:	0c1c7117 	.word	0x0c1c7117
 c1c9834:	0c1c7118 	.word	0x0c1c7118
 c1c9838:	0c1c7119 	.word	0x0c1c7119
 c1c983c:	0c1c711c 	.word	0x0c1c711c
 c1c9840:	0c1c711b 	.word	0x0c1c711b
 c1c9844:	0c1c711e 	.word	0x0c1c711e
 c1c9848:	0c1c711d 	.word	0x0c1c711d
 c1c984c:	0c7fff74 	.word	0x0c7fff74
 c1c9850:	0c1ca158 	.word	0x0c1ca158
 c1c9854:	00009c40 	.word	0x00009c40
 c1c9858:	0c7fff54 	.word	0x0c7fff54
 c1c985c:	0c1ca298 	.word	0x0c1ca298

0c1c9860 <delete_task>:
#include "../intcontroller.h"

static task_t tasks[MAX_TASKS];   /* Lista ordenada de TCBs */

void delete_task( uint32 id )
{
 c1c9860:	e1a0c00d 	mov	ip, sp
 c1c9864:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9868:	e24cb004 	sub	fp, ip, #4
 c1c986c:	e24dd008 	sub	sp, sp, #8
 c1c9870:	e50b0010 	str	r0, [fp, #-16]
    tasks[id].pfunction = NULL;
 c1c9874:	e59f3074 	ldr	r3, [pc, #116]	; c1c98f0 <delete_task+0x90>
 c1c9878:	e51b2010 	ldr	r2, [fp, #-16]
 c1c987c:	e3a01000 	mov	r1, #0
 c1c9880:	e7831202 	str	r1, [r3, r2, lsl #4]
    tasks[id].period = 0;
 c1c9884:	e59f1064 	ldr	r1, [pc, #100]	; c1c98f0 <delete_task+0x90>
 c1c9888:	e51b2010 	ldr	r2, [fp, #-16]
 c1c988c:	e3a03004 	mov	r3, #4
 c1c9890:	e1a02202 	lsl	r2, r2, #4
 c1c9894:	e0812002 	add	r2, r1, r2
 c1c9898:	e0823003 	add	r3, r2, r3
 c1c989c:	e3a02000 	mov	r2, #0
 c1c98a0:	e5832000 	str	r2, [r3]
    tasks[id].ticks = 0;
 c1c98a4:	e59f1044 	ldr	r1, [pc, #68]	; c1c98f0 <delete_task+0x90>
 c1c98a8:	e51b2010 	ldr	r2, [fp, #-16]
 c1c98ac:	e3a03008 	mov	r3, #8
 c1c98b0:	e1a02202 	lsl	r2, r2, #4
 c1c98b4:	e0812002 	add	r2, r1, r2
 c1c98b8:	e0823003 	add	r3, r2, r3
 c1c98bc:	e3a02000 	mov	r2, #0
 c1c98c0:	e5832000 	str	r2, [r3]
    tasks[id].ready = FALSE;
 c1c98c4:	e59f1024 	ldr	r1, [pc, #36]	; c1c98f0 <delete_task+0x90>
 c1c98c8:	e51b2010 	ldr	r2, [fp, #-16]
 c1c98cc:	e3a03008 	mov	r3, #8
 c1c98d0:	e1a02202 	lsl	r2, r2, #4
 c1c98d4:	e0812002 	add	r2, r1, r2
 c1c98d8:	e0823003 	add	r3, r2, r3
 c1c98dc:	e3a02000 	mov	r2, #0
 c1c98e0:	e5c32004 	strb	r2, [r3, #4]
}
 c1c98e4:	e24bd00c 	sub	sp, fp, #12
 c1c98e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c98ec:	e12fff1e 	bx	lr
 c1c98f0:	0c10223c 	.word	0x0c10223c

0c1c98f4 <create_task>:

uint32 create_task( void (*pfunction)( void ), uint32 period )
{
 c1c98f4:	e1a0c00d 	mov	ip, sp
 c1c98f8:	e92dd800 	push	{fp, ip, lr, pc}
 c1c98fc:	e24cb004 	sub	fp, ip, #4
 c1c9900:	e24dd010 	sub	sp, sp, #16
 c1c9904:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1c9908:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    uint32 id;

    for( id=0; id<MAX_TASKS && tasks[id].pfunction ; id++ ); /* Busca la primera entrada libre (con función no NULL) de la lista de TCB */
 c1c990c:	e3a03000 	mov	r3, #0
 c1c9910:	e50b3010 	str	r3, [fp, #-16]
 c1c9914:	ea000002 	b	c1c9924 <create_task+0x30>
 c1c9918:	e51b3010 	ldr	r3, [fp, #-16]
 c1c991c:	e2833001 	add	r3, r3, #1
 c1c9920:	e50b3010 	str	r3, [fp, #-16]
 c1c9924:	e51b3010 	ldr	r3, [fp, #-16]
 c1c9928:	e3530009 	cmp	r3, #9
 c1c992c:	8a000004 	bhi	c1c9944 <create_task+0x50>
 c1c9930:	e59f309c 	ldr	r3, [pc, #156]	; c1c99d4 <create_task+0xe0>
 c1c9934:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9938:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c1c993c:	e3530000 	cmp	r3, #0
 c1c9940:	1afffff4 	bne	c1c9918 <create_task+0x24>

    tasks[id].pfunction = pfunction;
 c1c9944:	e59f3088 	ldr	r3, [pc, #136]	; c1c99d4 <create_task+0xe0>
 c1c9948:	e51b2010 	ldr	r2, [fp, #-16]
 c1c994c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c1c9950:	e7831202 	str	r1, [r3, r2, lsl #4]
    tasks[id].period = period;
 c1c9954:	e59f1078 	ldr	r1, [pc, #120]	; c1c99d4 <create_task+0xe0>
 c1c9958:	e51b2010 	ldr	r2, [fp, #-16]
 c1c995c:	e3a03004 	mov	r3, #4
 c1c9960:	e1a02202 	lsl	r2, r2, #4
 c1c9964:	e0812002 	add	r2, r1, r2
 c1c9968:	e0823003 	add	r3, r2, r3
 c1c996c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1c9970:	e5832000 	str	r2, [r3]
    tasks[id].ticks = 0;
 c1c9974:	e59f1058 	ldr	r1, [pc, #88]	; c1c99d4 <create_task+0xe0>
 c1c9978:	e51b2010 	ldr	r2, [fp, #-16]
 c1c997c:	e3a03008 	mov	r3, #8
 c1c9980:	e1a02202 	lsl	r2, r2, #4
 c1c9984:	e0812002 	add	r2, r1, r2
 c1c9988:	e0823003 	add	r3, r2, r3
 c1c998c:	e3a02000 	mov	r2, #0
 c1c9990:	e5832000 	str	r2, [r3]
    tasks[id].ready = FALSE;
 c1c9994:	e59f1038 	ldr	r1, [pc, #56]	; c1c99d4 <create_task+0xe0>
 c1c9998:	e51b2010 	ldr	r2, [fp, #-16]
 c1c999c:	e3a03008 	mov	r3, #8
 c1c99a0:	e1a02202 	lsl	r2, r2, #4
 c1c99a4:	e0812002 	add	r2, r1, r2
 c1c99a8:	e0823003 	add	r3, r2, r3
 c1c99ac:	e3a02000 	mov	r2, #0
 c1c99b0:	e5c32004 	strb	r2, [r3, #4]

    (*pfunction)();     /* Asume que la primera llamada a la tarea la inicializa */
 c1c99b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1c99b8:	e1a0e00f 	mov	lr, pc
 c1c99bc:	e12fff13 	bx	r3

    return id;
 c1c99c0:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1c99c4:	e1a00003 	mov	r0, r3
 c1c99c8:	e24bd00c 	sub	sp, fp, #12
 c1c99cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c99d0:	e12fff1e 	bx	lr
 c1c99d4:	0c10223c 	.word	0x0c10223c

0c1c99d8 <scheduler_init>:

void scheduler_init( void )
{
 c1c99d8:	e1a0c00d 	mov	ip, sp
 c1c99dc:	e92dd800 	push	{fp, ip, lr, pc}
 c1c99e0:	e24cb004 	sub	fp, ip, #4
 c1c99e4:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )
 c1c99e8:	e3a03000 	mov	r3, #0
 c1c99ec:	e50b3010 	str	r3, [fp, #-16]
 c1c99f0:	ea000004 	b	c1c9a08 <scheduler_init+0x30>
        delete_task( id );
 c1c99f4:	e51b0010 	ldr	r0, [fp, #-16]
 c1c99f8:	ebffff98 	bl	c1c9860 <delete_task>

void scheduler_init( void )
{
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )
 c1c99fc:	e51b3010 	ldr	r3, [fp, #-16]
 c1c9a00:	e2833001 	add	r3, r3, #1
 c1c9a04:	e50b3010 	str	r3, [fp, #-16]
 c1c9a08:	e51b3010 	ldr	r3, [fp, #-16]
 c1c9a0c:	e3530009 	cmp	r3, #9
 c1c9a10:	9afffff7 	bls	c1c99f4 <scheduler_init+0x1c>
        delete_task( id );
}
 c1c9a14:	e24bd00c 	sub	sp, fp, #12
 c1c9a18:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9a1c:	e12fff1e 	bx	lr

0c1c9a20 <scheduler>:

void scheduler( void ) /* Esta funcion es la ISR del timer0 */
{
 c1c9a20:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1c9a24:	e1a0c00d 	mov	ip, sp
 c1c9a28:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1c9a2c:	e24cb004 	sub	fp, ip, #4
 c1c9a30:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    ic_cleanflag(INT_TIMER0);
 c1c9a34:	e3a0000d 	mov	r0, #13
 c1c9a38:	eb000b36 	bl	c1cc718 <ic_cleanflag>

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c1c9a3c:	e3a03000 	mov	r3, #0
 c1c9a40:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 c1c9a44:	ea000036 	b	c1c9b24 <scheduler+0x104>
        if( tasks[id].pfunction )
 c1c9a48:	e59f30f0 	ldr	r3, [pc, #240]	; c1c9b40 <scheduler+0x120>
 c1c9a4c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1c9a50:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c1c9a54:	e3530000 	cmp	r3, #0
 c1c9a58:	0a00002e 	beq	c1c9b18 <scheduler+0xf8>
            if( ++tasks[id].ticks == tasks[id].period ) /* Si el contador de ticks equivale a su periodo de ejecución: */
 c1c9a5c:	e59f10dc 	ldr	r1, [pc, #220]	; c1c9b40 <scheduler+0x120>
 c1c9a60:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1c9a64:	e3a03008 	mov	r3, #8
 c1c9a68:	e1a02202 	lsl	r2, r2, #4
 c1c9a6c:	e0812002 	add	r2, r1, r2
 c1c9a70:	e0823003 	add	r3, r2, r3
 c1c9a74:	e5933000 	ldr	r3, [r3]
 c1c9a78:	e2832001 	add	r2, r3, #1
 c1c9a7c:	e59f00bc 	ldr	r0, [pc, #188]	; c1c9b40 <scheduler+0x120>
 c1c9a80:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c1c9a84:	e3a03008 	mov	r3, #8
 c1c9a88:	e1a01201 	lsl	r1, r1, #4
 c1c9a8c:	e0801001 	add	r1, r0, r1
 c1c9a90:	e0813003 	add	r3, r1, r3
 c1c9a94:	e5832000 	str	r2, [r3]
 c1c9a98:	e59f10a0 	ldr	r1, [pc, #160]	; c1c9b40 <scheduler+0x120>
 c1c9a9c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1c9aa0:	e3a03008 	mov	r3, #8
 c1c9aa4:	e1a02202 	lsl	r2, r2, #4
 c1c9aa8:	e0812002 	add	r2, r1, r2
 c1c9aac:	e0823003 	add	r3, r2, r3
 c1c9ab0:	e5932000 	ldr	r2, [r3]
 c1c9ab4:	e59f0084 	ldr	r0, [pc, #132]	; c1c9b40 <scheduler+0x120>
 c1c9ab8:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c1c9abc:	e3a03004 	mov	r3, #4
 c1c9ac0:	e1a01201 	lsl	r1, r1, #4
 c1c9ac4:	e0801001 	add	r1, r0, r1
 c1c9ac8:	e0813003 	add	r3, r1, r3
 c1c9acc:	e5933000 	ldr	r3, [r3]
 c1c9ad0:	e1520003 	cmp	r2, r3
 c1c9ad4:	1a00000f 	bne	c1c9b18 <scheduler+0xf8>
            {
                tasks[id].ticks = 0;                    /* Inicializa a 0 su contador de ticks */
 c1c9ad8:	e59f1060 	ldr	r1, [pc, #96]	; c1c9b40 <scheduler+0x120>
 c1c9adc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1c9ae0:	e3a03008 	mov	r3, #8
 c1c9ae4:	e1a02202 	lsl	r2, r2, #4
 c1c9ae8:	e0812002 	add	r2, r1, r2
 c1c9aec:	e0823003 	add	r3, r2, r3
 c1c9af0:	e3a02000 	mov	r2, #0
 c1c9af4:	e5832000 	str	r2, [r3]
                tasks[id].ready = TRUE;                 /* Pasa la tarea a estado "preparado" */
 c1c9af8:	e59f1040 	ldr	r1, [pc, #64]	; c1c9b40 <scheduler+0x120>
 c1c9afc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1c9b00:	e3a03008 	mov	r3, #8
 c1c9b04:	e1a02202 	lsl	r2, r2, #4
 c1c9b08:	e0812002 	add	r2, r1, r2
 c1c9b0c:	e0823003 	add	r3, r2, r3
 c1c9b10:	e3a02001 	mov	r2, #1
 c1c9b14:	e5c32004 	strb	r2, [r3, #4]
{
    uint32 id;

    ic_cleanflag(INT_TIMER0);

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c1c9b18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1c9b1c:	e2833001 	add	r3, r3, #1
 c1c9b20:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 c1c9b24:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1c9b28:	e3530009 	cmp	r3, #9
 c1c9b2c:	9affffc5 	bls	c1c9a48 <scheduler+0x28>
            if( ++tasks[id].ticks == tasks[id].period ) /* Si el contador de ticks equivale a su periodo de ejecución: */
            {
                tasks[id].ticks = 0;                    /* Inicializa a 0 su contador de ticks */
                tasks[id].ready = TRUE;                 /* Pasa la tarea a estado "preparado" */
            }
}
 c1c9b30:	e24bd01c 	sub	sp, fp, #28
 c1c9b34:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1c9b38:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1c9b3c:	e25ef004 	subs	pc, lr, #4
 c1c9b40:	0c10223c 	.word	0x0c10223c

0c1c9b44 <dispacher>:

void dispacher( void )
{
 c1c9b44:	e1a0c00d 	mov	ip, sp
 c1c9b48:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9b4c:	e24cb004 	sub	fp, ip, #4
 c1c9b50:	e24dd008 	sub	sp, sp, #8
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c1c9b54:	e3a03000 	mov	r3, #0
 c1c9b58:	e50b3010 	str	r3, [fp, #-16]
 c1c9b5c:	ea000018 	b	c1c9bc4 <dispacher+0x80>
        if( tasks[id].ready == TRUE )                   /* Si la tarea está en estado "preparado": */
 c1c9b60:	e59f1074 	ldr	r1, [pc, #116]	; c1c9bdc <dispacher+0x98>
 c1c9b64:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9b68:	e3a03008 	mov	r3, #8
 c1c9b6c:	e1a02202 	lsl	r2, r2, #4
 c1c9b70:	e0812002 	add	r2, r1, r2
 c1c9b74:	e0823003 	add	r3, r2, r3
 c1c9b78:	e5d33004 	ldrb	r3, [r3, #4]
 c1c9b7c:	e3530001 	cmp	r3, #1
 c1c9b80:	1a00000c 	bne	c1c9bb8 <dispacher+0x74>
        {
            (*tasks[id].pfunction)();                   /* La ejecuta */
 c1c9b84:	e59f3050 	ldr	r3, [pc, #80]	; c1c9bdc <dispacher+0x98>
 c1c9b88:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9b8c:	e7933202 	ldr	r3, [r3, r2, lsl #4]
 c1c9b90:	e1a0e00f 	mov	lr, pc
 c1c9b94:	e12fff13 	bx	r3
            tasks[id].ready = FALSE;                    /* Pasa la tarea a estado "no preparado" */
 c1c9b98:	e59f103c 	ldr	r1, [pc, #60]	; c1c9bdc <dispacher+0x98>
 c1c9b9c:	e51b2010 	ldr	r2, [fp, #-16]
 c1c9ba0:	e3a03008 	mov	r3, #8
 c1c9ba4:	e1a02202 	lsl	r2, r2, #4
 c1c9ba8:	e0812002 	add	r2, r1, r2
 c1c9bac:	e0823003 	add	r3, r2, r3
 c1c9bb0:	e3a02000 	mov	r2, #0
 c1c9bb4:	e5c32004 	strb	r2, [r3, #4]

void dispacher( void )
{
    uint32 id;

    for( id=0; id<MAX_TASKS; id++ )                     /* Recorre la lista completa de TCB */
 c1c9bb8:	e51b3010 	ldr	r3, [fp, #-16]
 c1c9bbc:	e2833001 	add	r3, r3, #1
 c1c9bc0:	e50b3010 	str	r3, [fp, #-16]
 c1c9bc4:	e51b3010 	ldr	r3, [fp, #-16]
 c1c9bc8:	e3530009 	cmp	r3, #9
 c1c9bcc:	9affffe3 	bls	c1c9b60 <dispacher+0x1c>
        if( tasks[id].ready == TRUE )                   /* Si la tarea está en estado "preparado": */
        {
            (*tasks[id].pfunction)();                   /* La ejecuta */
            tasks[id].ready = FALSE;                    /* Pasa la tarea a estado "no preparado" */
        }
}
 c1c9bd0:	e24bd00c 	sub	sp, fp, #12
 c1c9bd4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9bd8:	e12fff1e 	bx	lr
 c1c9bdc:	0c10223c 	.word	0x0c10223c

0c1c9be0 <non_expropiative_kernel>:
void isr_pb( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void non_expropiative_kernel( void )
{
 c1c9be0:	e1a0c00d 	mov	ip, sp
 c1c9be4:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9be8:	e24cb004 	sub	fp, ip, #4
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando kernel de planificación no expropiativa\n" );
 c1c9bec:	e59f00fc 	ldr	r0, [pc, #252]	; c1c9cf0 <non_expropiative_kernel+0x110>
 c1c9bf0:	eb001739 	bl	c1cf8dc <uart0_puts>
    uart0_puts( " --------------------------------------------------\n\n" ) ;
 c1c9bf4:	e59f00f8 	ldr	r0, [pc, #248]	; c1c9cf4 <non_expropiative_kernel+0x114>
 c1c9bf8:	eb001737 	bl	c1cf8dc <uart0_puts>

    flagTask5  = FALSE;               /* Inicializa flags */
 c1c9bfc:	e59f30f4 	ldr	r3, [pc, #244]	; c1c9cf8 <non_expropiative_kernel+0x118>
 c1c9c00:	e3a02000 	mov	r2, #0
 c1c9c04:	e5c32000 	strb	r2, [r3]
    flagTask6  = FALSE;
 c1c9c08:	e59f30ec 	ldr	r3, [pc, #236]	; c1c9cfc <non_expropiative_kernel+0x11c>
 c1c9c0c:	e3a02000 	mov	r2, #0
 c1c9c10:	e5c32000 	strb	r2, [r3]
    flagPb     = FALSE;
 c1c9c14:	e59f30e4 	ldr	r3, [pc, #228]	; c1c9d00 <non_expropiative_kernel+0x120>
 c1c9c18:	e3a02000 	mov	r2, #0
 c1c9c1c:	e5c32000 	strb	r2, [r3]

    scheduler_init();                 /* Inicializa el kernel */
 c1c9c20:	ebffff6c 	bl	c1c99d8 <scheduler_init>

    create_task( Task2, 5 );          /* Crea las tareas de la aplicación... */
 c1c9c24:	e59f00d8 	ldr	r0, [pc, #216]	; c1c9d04 <non_expropiative_kernel+0x124>
 c1c9c28:	e3a01005 	mov	r1, #5
 c1c9c2c:	ebffff30 	bl	c1c98f4 <create_task>
    create_task( Task7, 5 );          /* ... el kernel asigna la prioridad según orden de creación: Task2 > Task5 > Task6 > ... */
 c1c9c30:	e59f00d0 	ldr	r0, [pc, #208]	; c1c9d08 <non_expropiative_kernel+0x128>
 c1c9c34:	e3a01005 	mov	r1, #5
 c1c9c38:	ebffff2d 	bl	c1c98f4 <create_task>
    create_task( Task5, 10 );         /* ... las tareas más frecuentes tienen mayor prioridad (criterio Rate-Monotonic-Scheduling) */
 c1c9c3c:	e59f00c8 	ldr	r0, [pc, #200]	; c1c9d0c <non_expropiative_kernel+0x12c>
 c1c9c40:	e3a0100a 	mov	r1, #10
 c1c9c44:	ebffff2a 	bl	c1c98f4 <create_task>
    create_task( Task6, 10 );
 c1c9c48:	e59f00c0 	ldr	r0, [pc, #192]	; c1c9d10 <non_expropiative_kernel+0x130>
 c1c9c4c:	e3a0100a 	mov	r1, #10
 c1c9c50:	ebffff27 	bl	c1c98f4 <create_task>
    create_task( Task1, 50 );
 c1c9c54:	e59f00b8 	ldr	r0, [pc, #184]	; c1c9d14 <non_expropiative_kernel+0x134>
 c1c9c58:	e3a01032 	mov	r1, #50	; 0x32
 c1c9c5c:	ebffff24 	bl	c1c98f4 <create_task>
    create_task( Task3, 100 );
 c1c9c60:	e59f00b0 	ldr	r0, [pc, #176]	; c1c9d18 <non_expropiative_kernel+0x138>
 c1c9c64:	e3a01064 	mov	r1, #100	; 0x64
 c1c9c68:	ebffff21 	bl	c1c98f4 <create_task>
    create_task( Task4, 1000 );
 c1c9c6c:	e59f00a8 	ldr	r0, [pc, #168]	; c1c9d1c <non_expropiative_kernel+0x13c>
 c1c9c70:	e3a01ffa 	mov	r1, #1000	; 0x3e8
 c1c9c74:	ebffff1e 	bl	c1c98f4 <create_task>

    pISR_EINT4567 = (unsigned) isr_pb;
 c1c9c78:	e59f30a0 	ldr	r3, [pc, #160]	; c1c9d20 <non_expropiative_kernel+0x140>
 c1c9c7c:	e59f20a0 	ldr	r2, [pc, #160]	; c1c9d24 <non_expropiative_kernel+0x144>
 c1c9c80:	e5832000 	str	r2, [r3]
   	ic_enable(INT_EINT4567);
 c1c9c84:	e3a00015 	mov	r0, #21
 c1c9c88:	eb000a6f 	bl	c1cc64c <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c1c9c8c:	e3a00000 	mov	r0, #0
 c1c9c90:	e3a01001 	mov	r1, #1
 c1c9c94:	eb00145a 	bl	c1cee04 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c1c9c98:	e3a00000 	mov	r0, #0
 c1c9c9c:	e3a01001 	mov	r1, #1
 c1c9ca0:	eb001356 	bl	c1cea00 <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c1c9ca4:	e3a00000 	mov	r0, #0
 c1c9ca8:	e3a01002 	mov	r1, #2
 c1c9cac:	eb00138a 	bl	c1ceadc <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c1c9cb0:	e3a00000 	mov	r0, #0
 c1c9cb4:	e59f106c 	ldr	r1, [pc, #108]	; c1c9d28 <non_expropiative_kernel+0x148>
 c1c9cb8:	e3a02001 	mov	r2, #1
 c1c9cbc:	eb0013d5 	bl	c1cec18 <tmr_set_count>

   	tmr_update(TIMER0);
 c1c9cc0:	e3a00000 	mov	r0, #0
 c1c9cc4:	eb001420 	bl	c1ced4c <tmr_update>

   	pISR_TIMER0 =(unsigned)scheduler;
 c1c9cc8:	e59f305c 	ldr	r3, [pc, #92]	; c1c9d2c <non_expropiative_kernel+0x14c>
 c1c9ccc:	e59f205c 	ldr	r2, [pc, #92]	; c1c9d30 <non_expropiative_kernel+0x150>
 c1c9cd0:	e5832000 	str	r2, [r3]
   	tmr_start(TIMER0);
 c1c9cd4:	e3a00000 	mov	r0, #0
 c1c9cd8:	eb00148c 	bl	c1cef10 <tmr_start>

   	ic_enable(INT_TIMER0);
 c1c9cdc:	e3a0000d 	mov	r0, #13
 c1c9ce0:	eb000a59 	bl	c1cc64c <ic_enable>

    while( 1 )
    {
        sleep();                /* Entra en estado IDLE, sale por interrupción */
 c1c9ce4:	eb001929 	bl	c1d0190 <sleep>
        dispacher();            /* Las tareas preparadas se ejecutan en esta hebra (background) en orden de prioridad */
 c1c9ce8:	ebffff95 	bl	c1c9b44 <dispacher>
    }
 c1c9cec:	eafffffc 	b	c1c9ce4 <non_expropiative_kernel+0x104>
 c1c9cf0:	0c100eb4 	.word	0x0c100eb4
 c1c9cf4:	0c100eec 	.word	0x0c100eec
 c1c9cf8:	0c1c7117 	.word	0x0c1c7117
 c1c9cfc:	0c1c7118 	.word	0x0c1c7118
 c1c9d00:	0c1c7119 	.word	0x0c1c7119
 c1c9d04:	0c1c9d8c 	.word	0x0c1c9d8c
 c1c9d08:	0c1ca0e0 	.word	0x0c1ca0e0
 c1c9d0c:	0c1c9fd0 	.word	0x0c1c9fd0
 c1c9d10:	0c1ca064 	.word	0x0c1ca064
 c1c9d14:	0c1c9d34 	.word	0x0c1c9d34
 c1c9d18:	0c1c9e98 	.word	0x0c1c9e98
 c1c9d1c:	0c1c9f3c 	.word	0x0c1c9f3c
 c1c9d20:	0c7fff74 	.word	0x0c7fff74
 c1c9d24:	0c1ca158 	.word	0x0c1ca158
 c1c9d28:	00009c40 	.word	0x00009c40
 c1c9d2c:	0c7fff54 	.word	0x0c7fff54
 c1c9d30:	0c1c9a20 	.word	0x0c1c9a20

0c1c9d34 <Task1>:
}

/*******************************************************************/

void Task1( void )  /* Cada 0,5 segundos (50 ticks) alterna el led que se enciende */
{
 c1c9d34:	e1a0c00d 	mov	ip, sp
 c1c9d38:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9d3c:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;

    if( init )
 c1c9d40:	e59f303c 	ldr	r3, [pc, #60]	; c1c9d84 <Task1+0x50>
 c1c9d44:	e5d33000 	ldrb	r3, [r3]
 c1c9d48:	e3530000 	cmp	r3, #0
 c1c9d4c:	0a000007 	beq	c1c9d70 <Task1+0x3c>
    {
        init = FALSE;
 c1c9d50:	e59f302c 	ldr	r3, [pc, #44]	; c1c9d84 <Task1+0x50>
 c1c9d54:	e3a02000 	mov	r2, #0
 c1c9d58:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 1: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1c9d5c:	e59f0024 	ldr	r0, [pc, #36]	; c1c9d88 <Task1+0x54>
 c1c9d60:	eb0016dd 	bl	c1cf8dc <uart0_puts>
        led1_on();
 c1c9d64:	eb000d99 	bl	c1cd3d0 <led1_on>
        led2_off();
 c1c9d68:	eb000dc8 	bl	c1cd490 <led2_off>
 c1c9d6c:	ea000001 	b	c1c9d78 <Task1+0x44>
    }
    else
    {
        led1_switch();
 c1c9d70:	eb000dd6 	bl	c1cd4d0 <led1_switch>
        led2_switch();
 c1c9d74:	eb000de5 	bl	c1cd510 <led2_switch>
    }
}
 c1c9d78:	e24bd00c 	sub	sp, fp, #12
 c1c9d7c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9d80:	e12fff1e 	bx	lr
 c1c9d84:	0c1000de 	.word	0x0c1000de
 c1c9d88:	0c100f24 	.word	0x0c100f24

0c1c9d8c <Task2>:

void Task2( void )  /* Cada 50 ms (5 ticks) muestrea el keypad y envía el scancode a otras tareas */
{
 c1c9d8c:	e1a0c00d 	mov	ip, sp
 c1c9d90:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9d94:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;
    static enum { wait_keydown, scan, wait_keyup } state;

    if( init )
 c1c9d98:	e59f30e0 	ldr	r3, [pc, #224]	; c1c9e80 <Task2+0xf4>
 c1c9d9c:	e5d33000 	ldrb	r3, [r3]
 c1c9da0:	e3530000 	cmp	r3, #0
 c1c9da4:	0a000008 	beq	c1c9dcc <Task2+0x40>
    {
        init  = FALSE;
 c1c9da8:	e59f30d0 	ldr	r3, [pc, #208]	; c1c9e80 <Task2+0xf4>
 c1c9dac:	e3a02000 	mov	r2, #0
 c1c9db0:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 2: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1c9db4:	e59f00c8 	ldr	r0, [pc, #200]	; c1c9e84 <Task2+0xf8>
 c1c9db8:	eb0016c7 	bl	c1cf8dc <uart0_puts>
        state = wait_keydown;
 c1c9dbc:	e59f30c4 	ldr	r3, [pc, #196]	; c1c9e88 <Task2+0xfc>
 c1c9dc0:	e3a02000 	mov	r2, #0
 c1c9dc4:	e5c32000 	strb	r2, [r3]
 c1c9dc8:	ea000029 	b	c1c9e74 <Task2+0xe8>
    }
    else switch( state )
 c1c9dcc:	e59f30b4 	ldr	r3, [pc, #180]	; c1c9e88 <Task2+0xfc>
 c1c9dd0:	e5d33000 	ldrb	r3, [r3]
 c1c9dd4:	e3530001 	cmp	r3, #1
 c1c9dd8:	0a00000b 	beq	c1c9e0c <Task2+0x80>
 c1c9ddc:	e3530002 	cmp	r3, #2
 c1c9de0:	0a000018 	beq	c1c9e48 <Task2+0xbc>
 c1c9de4:	e3530000 	cmp	r3, #0
 c1c9de8:	1a000021 	bne	c1c9e74 <Task2+0xe8>
    {
        case wait_keydown:
            if( kb_scan() >= 0 )
 c1c9dec:	eb000a73 	bl	c1cc7c0 <kb_scan>
 c1c9df0:	e1a03000 	mov	r3, r0
 c1c9df4:	e3530000 	cmp	r3, #0
 c1c9df8:	ba00001a 	blt	c1c9e68 <Task2+0xdc>
                state = scan;
 c1c9dfc:	e59f3084 	ldr	r3, [pc, #132]	; c1c9e88 <Task2+0xfc>
 c1c9e00:	e3a02001 	mov	r2, #1
 c1c9e04:	e5c32000 	strb	r2, [r3]
            break;
 c1c9e08:	ea000019 	b	c1c9e74 <Task2+0xe8>
        case scan:
            scancode = kb_scan();
 c1c9e0c:	eb000a6b 	bl	c1cc7c0 <kb_scan>
 c1c9e10:	e1a03000 	mov	r3, r0
 c1c9e14:	e20320ff 	and	r2, r3, #255	; 0xff
 c1c9e18:	e59f306c 	ldr	r3, [pc, #108]	; c1c9e8c <Task2+0x100>
 c1c9e1c:	e5c32000 	strb	r2, [r3]
            if( scancode >= 0 )
            {
                flagTask5 = TRUE;
 c1c9e20:	e59f3068 	ldr	r3, [pc, #104]	; c1c9e90 <Task2+0x104>
 c1c9e24:	e3a02001 	mov	r2, #1
 c1c9e28:	e5c32000 	strb	r2, [r3]
                flagTask6 = TRUE;
 c1c9e2c:	e59f3060 	ldr	r3, [pc, #96]	; c1c9e94 <Task2+0x108>
 c1c9e30:	e3a02001 	mov	r2, #1
 c1c9e34:	e5c32000 	strb	r2, [r3]
            }
            state = wait_keyup;
 c1c9e38:	e59f3048 	ldr	r3, [pc, #72]	; c1c9e88 <Task2+0xfc>
 c1c9e3c:	e3a02002 	mov	r2, #2
 c1c9e40:	e5c32000 	strb	r2, [r3]
            break;
 c1c9e44:	ea00000a 	b	c1c9e74 <Task2+0xe8>
        case wait_keyup:
            if( kb_scan() < 0 )
 c1c9e48:	eb000a5c 	bl	c1cc7c0 <kb_scan>
 c1c9e4c:	e1a03000 	mov	r3, r0
 c1c9e50:	e3530000 	cmp	r3, #0
 c1c9e54:	aa000005 	bge	c1c9e70 <Task2+0xe4>
                state = wait_keydown;
 c1c9e58:	e59f3028 	ldr	r3, [pc, #40]	; c1c9e88 <Task2+0xfc>
 c1c9e5c:	e3a02000 	mov	r2, #0
 c1c9e60:	e5c32000 	strb	r2, [r3]
            break;
 c1c9e64:	ea000002 	b	c1c9e74 <Task2+0xe8>
    else switch( state )
    {
        case wait_keydown:
            if( kb_scan() >= 0 )
                state = scan;
            break;
 c1c9e68:	e1a00000 	nop			; (mov r0, r0)
 c1c9e6c:	ea000000 	b	c1c9e74 <Task2+0xe8>
            state = wait_keyup;
            break;
        case wait_keyup:
            if( kb_scan() < 0 )
                state = wait_keydown;
            break;
 c1c9e70:	e1a00000 	nop			; (mov r0, r0)
    }
}
 c1c9e74:	e24bd00c 	sub	sp, fp, #12
 c1c9e78:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9e7c:	e12fff1e 	bx	lr
 c1c9e80:	0c1000dd 	.word	0x0c1000dd
 c1c9e84:	0c100f38 	.word	0x0c100f38
 c1c9e88:	0c1022e0 	.word	0x0c1022e0
 c1c9e8c:	0c1c7116 	.word	0x0c1c7116
 c1c9e90:	0c1c7117 	.word	0x0c1c7117
 c1c9e94:	0c1c7118 	.word	0x0c1c7118

0c1c9e98 <Task3>:

void Task3( void  )  /* Cada segundo (100 ticks) muestra por la UART0 la hora del RTC */
{
 c1c9e98:	e1a0c00d 	mov	ip, sp
 c1c9e9c:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9ea0:	e24cb004 	sub	fp, ip, #4
 c1c9ea4:	e24dd008 	sub	sp, sp, #8
    static boolean init = TRUE;
    rtc_time_t rtc_time;

    if( init )
 c1c9ea8:	e59f307c 	ldr	r3, [pc, #124]	; c1c9f2c <Task3+0x94>
 c1c9eac:	e5d33000 	ldrb	r3, [r3]
 c1c9eb0:	e3530000 	cmp	r3, #0
 c1c9eb4:	0a000005 	beq	c1c9ed0 <Task3+0x38>
    {
        init = FALSE;
 c1c9eb8:	e59f306c 	ldr	r3, [pc, #108]	; c1c9f2c <Task3+0x94>
 c1c9ebc:	e3a02000 	mov	r2, #0
 c1c9ec0:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 3: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1c9ec4:	e59f0064 	ldr	r0, [pc, #100]	; c1c9f30 <Task3+0x98>
 c1c9ec8:	eb001683 	bl	c1cf8dc <uart0_puts>
 c1c9ecc:	ea000013 	b	c1c9f20 <Task3+0x88>
    }
    else
    {
        rtc_gettime( &rtc_time );
 c1c9ed0:	e24b3014 	sub	r3, fp, #20
 c1c9ed4:	e1a00003 	mov	r0, r3
 c1c9ed8:	eb001089 	bl	c1ce104 <rtc_gettime>
        uart0_puts( "  (Task 3) Hora: " );
 c1c9edc:	e59f0050 	ldr	r0, [pc, #80]	; c1c9f34 <Task3+0x9c>
 c1c9ee0:	eb00167d 	bl	c1cf8dc <uart0_puts>
        uart0_putint( rtc_time.hour );
 c1c9ee4:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c1c9ee8:	e1a00003 	mov	r0, r3
 c1c9eec:	eb00168e 	bl	c1cf92c <uart0_putint>
        uart0_putchar( ':' );
 c1c9ef0:	e3a0003a 	mov	r0, #58	; 0x3a
 c1c9ef4:	eb001652 	bl	c1cf844 <uart0_putchar>
        uart0_putint( rtc_time.min );
 c1c9ef8:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
 c1c9efc:	e1a00003 	mov	r0, r3
 c1c9f00:	eb001689 	bl	c1cf92c <uart0_putint>
        uart0_putchar( ':' );
 c1c9f04:	e3a0003a 	mov	r0, #58	; 0x3a
 c1c9f08:	eb00164d 	bl	c1cf844 <uart0_putchar>
        uart0_putint( rtc_time.sec );
 c1c9f0c:	e55b3014 	ldrb	r3, [fp, #-20]	; 0xffffffec
 c1c9f10:	e1a00003 	mov	r0, r3
 c1c9f14:	eb001684 	bl	c1cf92c <uart0_putint>
        uart0_puts( "\n" );
 c1c9f18:	e59f0018 	ldr	r0, [pc, #24]	; c1c9f38 <Task3+0xa0>
 c1c9f1c:	eb00166e 	bl	c1cf8dc <uart0_puts>
    }
}
 c1c9f20:	e24bd00c 	sub	sp, fp, #12
 c1c9f24:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9f28:	e12fff1e 	bx	lr
 c1c9f2c:	0c1000dc 	.word	0x0c1000dc
 c1c9f30:	0c100f4c 	.word	0x0c100f4c
 c1c9f34:	0c100f60 	.word	0x0c100f60
 c1c9f38:	0c100f74 	.word	0x0c100f74

0c1c9f3c <Task4>:

void Task4( void )  /* Cada 10 segundos (1000 ticks) muestra por la UART0 los ticks transcurridos */
{
 c1c9f3c:	e1a0c00d 	mov	ip, sp
 c1c9f40:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9f44:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;
    static uint32 ticks;

    if( init )
 c1c9f48:	e59f306c 	ldr	r3, [pc, #108]	; c1c9fbc <Task4+0x80>
 c1c9f4c:	e5d33000 	ldrb	r3, [r3]
 c1c9f50:	e3530000 	cmp	r3, #0
 c1c9f54:	0a000008 	beq	c1c9f7c <Task4+0x40>
    {
        init = FALSE;
 c1c9f58:	e59f305c 	ldr	r3, [pc, #92]	; c1c9fbc <Task4+0x80>
 c1c9f5c:	e3a02000 	mov	r2, #0
 c1c9f60:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 4: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1c9f64:	e59f0054 	ldr	r0, [pc, #84]	; c1c9fc0 <Task4+0x84>
 c1c9f68:	eb00165b 	bl	c1cf8dc <uart0_puts>
        ticks = 0;
 c1c9f6c:	e59f3050 	ldr	r3, [pc, #80]	; c1c9fc4 <Task4+0x88>
 c1c9f70:	e3a02000 	mov	r2, #0
 c1c9f74:	e5832000 	str	r2, [r3]
 c1c9f78:	ea00000c 	b	c1c9fb0 <Task4+0x74>
    }
    else
    {
        ticks += TICKS_PER_SEC * 10;
 c1c9f7c:	e59f3040 	ldr	r3, [pc, #64]	; c1c9fc4 <Task4+0x88>
 c1c9f80:	e5933000 	ldr	r3, [r3]
 c1c9f84:	e2832ffa 	add	r2, r3, #1000	; 0x3e8
 c1c9f88:	e59f3034 	ldr	r3, [pc, #52]	; c1c9fc4 <Task4+0x88>
 c1c9f8c:	e5832000 	str	r2, [r3]
        uart0_puts( "  (Task 4) Ticks: " );
 c1c9f90:	e59f0030 	ldr	r0, [pc, #48]	; c1c9fc8 <Task4+0x8c>
 c1c9f94:	eb001650 	bl	c1cf8dc <uart0_puts>
        uart0_putint( ticks );
 c1c9f98:	e59f3024 	ldr	r3, [pc, #36]	; c1c9fc4 <Task4+0x88>
 c1c9f9c:	e5933000 	ldr	r3, [r3]
 c1c9fa0:	e1a00003 	mov	r0, r3
 c1c9fa4:	eb001660 	bl	c1cf92c <uart0_putint>
        uart0_puts( "\n" );
 c1c9fa8:	e59f001c 	ldr	r0, [pc, #28]	; c1c9fcc <Task4+0x90>
 c1c9fac:	eb00164a 	bl	c1cf8dc <uart0_puts>
    }
}
 c1c9fb0:	e24bd00c 	sub	sp, fp, #12
 c1c9fb4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1c9fb8:	e12fff1e 	bx	lr
 c1c9fbc:	0c1000db 	.word	0x0c1000db
 c1c9fc0:	0c100f78 	.word	0x0c100f78
 c1c9fc4:	0c1022dc 	.word	0x0c1022dc
 c1c9fc8:	0c100f8c 	.word	0x0c100f8c
 c1c9fcc:	0c100f74 	.word	0x0c100f74

0c1c9fd0 <Task5>:

void Task5( void )  /* Cada vez que reciba un scancode lo muestra por la UART0 */
{
 c1c9fd0:	e1a0c00d 	mov	ip, sp
 c1c9fd4:	e92dd800 	push	{fp, ip, lr, pc}
 c1c9fd8:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;

    if( init )
 c1c9fdc:	e59f3068 	ldr	r3, [pc, #104]	; c1ca04c <Task5+0x7c>
 c1c9fe0:	e5d33000 	ldrb	r3, [r3]
 c1c9fe4:	e3530000 	cmp	r3, #0
 c1c9fe8:	0a000005 	beq	c1ca004 <Task5+0x34>
    {
        init = FALSE;
 c1c9fec:	e59f3058 	ldr	r3, [pc, #88]	; c1ca04c <Task5+0x7c>
 c1c9ff0:	e3a02000 	mov	r2, #0
 c1c9ff4:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 5: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1c9ff8:	e59f0050 	ldr	r0, [pc, #80]	; c1ca050 <Task5+0x80>
 c1c9ffc:	eb001636 	bl	c1cf8dc <uart0_puts>
 c1ca000:	ea00000e 	b	c1ca040 <Task5+0x70>
    }
    else if( flagTask5 )
 c1ca004:	e59f3048 	ldr	r3, [pc, #72]	; c1ca054 <Task5+0x84>
 c1ca008:	e5d33000 	ldrb	r3, [r3]
 c1ca00c:	e3530000 	cmp	r3, #0
 c1ca010:	0a00000a 	beq	c1ca040 <Task5+0x70>
    {
        flagTask5 = FALSE;
 c1ca014:	e59f3038 	ldr	r3, [pc, #56]	; c1ca054 <Task5+0x84>
 c1ca018:	e3a02000 	mov	r2, #0
 c1ca01c:	e5c32000 	strb	r2, [r3]
        uart0_puts( "  (Task 5) Tecla pulsada: " );
 c1ca020:	e59f0030 	ldr	r0, [pc, #48]	; c1ca058 <Task5+0x88>
 c1ca024:	eb00162c 	bl	c1cf8dc <uart0_puts>
        uart0_puthex( scancode );
 c1ca028:	e59f302c 	ldr	r3, [pc, #44]	; c1ca05c <Task5+0x8c>
 c1ca02c:	e5d33000 	ldrb	r3, [r3]
 c1ca030:	e1a00003 	mov	r0, r3
 c1ca034:	eb00167c 	bl	c1cfa2c <uart0_puthex>
        uart0_puts( "\n" );
 c1ca038:	e59f0020 	ldr	r0, [pc, #32]	; c1ca060 <Task5+0x90>
 c1ca03c:	eb001626 	bl	c1cf8dc <uart0_puts>
    }
}
 c1ca040:	e24bd00c 	sub	sp, fp, #12
 c1ca044:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca048:	e12fff1e 	bx	lr
 c1ca04c:	0c1000da 	.word	0x0c1000da
 c1ca050:	0c100fa0 	.word	0x0c100fa0
 c1ca054:	0c1c7117 	.word	0x0c1c7117
 c1ca058:	0c100fb4 	.word	0x0c100fb4
 c1ca05c:	0c1c7116 	.word	0x0c1c7116
 c1ca060:	0c100f74 	.word	0x0c100f74

0c1ca064 <Task6>:

void Task6( void )  /* Cada vez que reciba un scancode lo muestra por los 7 segmentos */
{
 c1ca064:	e1a0c00d 	mov	ip, sp
 c1ca068:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca06c:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;

    if( init )
 c1ca070:	e59f3058 	ldr	r3, [pc, #88]	; c1ca0d0 <Task6+0x6c>
 c1ca074:	e5d33000 	ldrb	r3, [r3]
 c1ca078:	e3530000 	cmp	r3, #0
 c1ca07c:	0a000005 	beq	c1ca098 <Task6+0x34>
    {
        init = FALSE;
 c1ca080:	e59f3048 	ldr	r3, [pc, #72]	; c1ca0d0 <Task6+0x6c>
 c1ca084:	e3a02000 	mov	r2, #0
 c1ca088:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 6: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1ca08c:	e59f0040 	ldr	r0, [pc, #64]	; c1ca0d4 <Task6+0x70>
 c1ca090:	eb001611 	bl	c1cf8dc <uart0_puts>
 c1ca094:	ea00000a 	b	c1ca0c4 <Task6+0x60>
    }
    else if( flagTask6 )
 c1ca098:	e59f3038 	ldr	r3, [pc, #56]	; c1ca0d8 <Task6+0x74>
 c1ca09c:	e5d33000 	ldrb	r3, [r3]
 c1ca0a0:	e3530000 	cmp	r3, #0
 c1ca0a4:	0a000006 	beq	c1ca0c4 <Task6+0x60>
    {
        flagTask6 = FALSE;
 c1ca0a8:	e59f3028 	ldr	r3, [pc, #40]	; c1ca0d8 <Task6+0x74>
 c1ca0ac:	e3a02000 	mov	r2, #0
 c1ca0b0:	e5c32000 	strb	r2, [r3]
        D8Led_digit(scancode);
 c1ca0b4:	e59f3020 	ldr	r3, [pc, #32]	; c1ca0dc <Task6+0x78>
 c1ca0b8:	e5d33000 	ldrb	r3, [r3]
 c1ca0bc:	e1a00003 	mov	r0, r3
 c1ca0c0:	eb000180 	bl	c1ca6c8 <D8Led_digit>
    }
}
 c1ca0c4:	e24bd00c 	sub	sp, fp, #12
 c1ca0c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca0cc:	e12fff1e 	bx	lr
 c1ca0d0:	0c1000d9 	.word	0x0c1000d9
 c1ca0d4:	0c100fd0 	.word	0x0c100fd0
 c1ca0d8:	0c1c7118 	.word	0x0c1c7118
 c1ca0dc:	0c1c7116 	.word	0x0c1c7116

0c1ca0e0 <Task7>:

void Task7( void )  /* Cada vez que se presione un pulsador lo avisa por la UART0 */
{
 c1ca0e0:	e1a0c00d 	mov	ip, sp
 c1ca0e4:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca0e8:	e24cb004 	sub	fp, ip, #4
    static boolean init = TRUE;

    if( init )
 c1ca0ec:	e59f3054 	ldr	r3, [pc, #84]	; c1ca148 <Task7+0x68>
 c1ca0f0:	e5d33000 	ldrb	r3, [r3]
 c1ca0f4:	e3530000 	cmp	r3, #0
 c1ca0f8:	0a000005 	beq	c1ca114 <Task7+0x34>
    {
        init = FALSE;
 c1ca0fc:	e59f3044 	ldr	r3, [pc, #68]	; c1ca148 <Task7+0x68>
 c1ca100:	e3a02000 	mov	r2, #0
 c1ca104:	e5c32000 	strb	r2, [r3]
        uart0_puts( " Task 7: iniciada.\n" );  /* Muestra un mensaje inicial en la UART0 (no es necesario semáforo) */
 c1ca108:	e59f003c 	ldr	r0, [pc, #60]	; c1ca14c <Task7+0x6c>
 c1ca10c:	eb0015f2 	bl	c1cf8dc <uart0_puts>
 c1ca110:	ea000009 	b	c1ca13c <Task7+0x5c>
    }
    else if( flagPb )
 c1ca114:	e59f3034 	ldr	r3, [pc, #52]	; c1ca150 <Task7+0x70>
 c1ca118:	e5d33000 	ldrb	r3, [r3]
 c1ca11c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca120:	e3530000 	cmp	r3, #0
 c1ca124:	0a000004 	beq	c1ca13c <Task7+0x5c>
    {
        flagPb = FALSE;
 c1ca128:	e59f3020 	ldr	r3, [pc, #32]	; c1ca150 <Task7+0x70>
 c1ca12c:	e3a02000 	mov	r2, #0
 c1ca130:	e5c32000 	strb	r2, [r3]
        uart0_puts( "  (Task 7) Se ha pulsado algún pushbutton...\n" );
 c1ca134:	e59f0018 	ldr	r0, [pc, #24]	; c1ca154 <Task7+0x74>
 c1ca138:	eb0015e7 	bl	c1cf8dc <uart0_puts>
    }
}
 c1ca13c:	e24bd00c 	sub	sp, fp, #12
 c1ca140:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca144:	e12fff1e 	bx	lr
 c1ca148:	0c1000d8 	.word	0x0c1000d8
 c1ca14c:	0c100fe4 	.word	0x0c100fe4
 c1ca150:	0c1c7119 	.word	0x0c1c7119
 c1ca154:	0c100ff8 	.word	0x0c100ff8

0c1ca158 <isr_pb>:

/*******************************************************************/


void isr_pb( void )
{
 c1ca158:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1ca15c:	e1a0c00d 	mov	ip, sp
 c1ca160:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1ca164:	e24cb004 	sub	fp, ip, #4
    flagPb = TRUE;
 c1ca168:	e59f3028 	ldr	r3, [pc, #40]	; c1ca198 <isr_pb+0x40>
 c1ca16c:	e3a02001 	mov	r2, #1
 c1ca170:	e5c32000 	strb	r2, [r3]
    rEXTINTPND = (1 << 2) | (1 << 3);
 c1ca174:	e59f3020 	ldr	r3, [pc, #32]	; c1ca19c <isr_pb+0x44>
 c1ca178:	e3a0200c 	mov	r2, #12
 c1ca17c:	e5832000 	str	r2, [r3]
	ic_cleanflag(INT_EINT4567);
 c1ca180:	e3a00015 	mov	r0, #21
 c1ca184:	eb000963 	bl	c1cc718 <ic_cleanflag>
}
 c1ca188:	e24bd01c 	sub	sp, fp, #28
 c1ca18c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1ca190:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1ca194:	e25ef004 	subs	pc, lr, #4
 c1ca198:	0c1c7119 	.word	0x0c1c7119
 c1ca19c:	01d20054 	.word	0x01d20054

0c1ca1a0 <queue>:
void isr_tick( void ) __attribute__ ((interrupt ("IRQ")));

/*******************************************************************/

void queue( void )
{
 c1ca1a0:	e1a0c00d 	mov	ip, sp
 c1ca1a4:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca1a8:	e24cb004 	sub	fp, ip, #4
 c1ca1ac:	e24dd008 	sub	sp, sp, #8
    segs_init();
    rtc_init();
    pbs_init();
    keypad_init();*/

    uart0_puts( "\n\n Ejecutando una aplicación como cola de funciones\n" );
 c1ca1b0:	e59f00c4 	ldr	r0, [pc, #196]	; c1ca27c <queue+0xdc>
 c1ca1b4:	eb0015c8 	bl	c1cf8dc <uart0_puts>
    uart0_puts( " ------------------------------------------------\n\n" ) ;
 c1ca1b8:	e59f00c0 	ldr	r0, [pc, #192]	; c1ca280 <queue+0xe0>
 c1ca1bc:	eb0015c6 	bl	c1cf8dc <uart0_puts>

    fifo_init();             /* Inicializa cola de funciones */
 c1ca1c0:	eb000086 	bl	c1ca3e0 <fifo_init>

    Task1();    /* Ejecuta por primera vez a las funciones para inicializarlas */
 c1ca1c4:	ebfffeda 	bl	c1c9d34 <Task1>
    Task2();
 c1ca1c8:	ebfffeef 	bl	c1c9d8c <Task2>
    Task3();
 c1ca1cc:	ebffff31 	bl	c1c9e98 <Task3>
    Task4();
 c1ca1d0:	ebffff59 	bl	c1c9f3c <Task4>
    Task5();
 c1ca1d4:	ebffff7d 	bl	c1c9fd0 <Task5>
    Task6();
 c1ca1d8:	ebffffa1 	bl	c1ca064 <Task6>
    Task7();
 c1ca1dc:	ebffffbf 	bl	c1ca0e0 <Task7>

    pISR_EINT4567 = (unsigned) isr_pb;
 c1ca1e0:	e59f309c 	ldr	r3, [pc, #156]	; c1ca284 <queue+0xe4>
 c1ca1e4:	e59f209c 	ldr	r2, [pc, #156]	; c1ca288 <queue+0xe8>
 c1ca1e8:	e5832000 	str	r2, [r3]
    ic_enable(INT_EINT4567);
 c1ca1ec:	e3a00015 	mov	r0, #21
 c1ca1f0:	eb000915 	bl	c1cc64c <ic_enable>

    //10ms
    tmr_set_mode(TIMER0, RELOAD);
 c1ca1f4:	e3a00000 	mov	r0, #0
 c1ca1f8:	e3a01001 	mov	r1, #1
 c1ca1fc:	eb001300 	bl	c1cee04 <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 1);
 c1ca200:	e3a00000 	mov	r0, #0
 c1ca204:	e3a01001 	mov	r1, #1
 c1ca208:	eb0011fc 	bl	c1cea00 <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c1ca20c:	e3a00000 	mov	r0, #0
 c1ca210:	e3a01002 	mov	r1, #2
 c1ca214:	eb001230 	bl	c1ceadc <tmr_set_divider>
	tmr_set_count(TIMER0, 40000, 1);
 c1ca218:	e3a00000 	mov	r0, #0
 c1ca21c:	e59f1068 	ldr	r1, [pc, #104]	; c1ca28c <queue+0xec>
 c1ca220:	e3a02001 	mov	r2, #1
 c1ca224:	eb00127b 	bl	c1cec18 <tmr_set_count>

	tmr_update(TIMER0);
 c1ca228:	e3a00000 	mov	r0, #0
 c1ca22c:	eb0012c6 	bl	c1ced4c <tmr_update>

	pISR_TIMER0 =(unsigned)isr_tick;
 c1ca230:	e59f3058 	ldr	r3, [pc, #88]	; c1ca290 <queue+0xf0>
 c1ca234:	e59f2058 	ldr	r2, [pc, #88]	; c1ca294 <queue+0xf4>
 c1ca238:	e5832000 	str	r2, [r3]
	tmr_start(TIMER0);
 c1ca23c:	e3a00000 	mov	r0, #0
 c1ca240:	eb001332 	bl	c1cef10 <tmr_start>

	ic_enable(INT_TIMER0);
 c1ca244:	e3a0000d 	mov	r0, #13
 c1ca248:	eb0008ff 	bl	c1cc64c <ic_enable>

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
 c1ca24c:	eb0017cf 	bl	c1d0190 <sleep>
        while( !fifo_is_empty() )
 c1ca250:	ea000004 	b	c1ca268 <queue+0xc8>
        {
            pf = fifo_dequeue();
 c1ca254:	eb0000a0 	bl	c1ca4dc <fifo_dequeue>
 c1ca258:	e50b0010 	str	r0, [fp, #-16]
            (*pf)();                    /* Las tareas encoladas se ejecutan en esta hebra (background) en orden de encolado */
 c1ca25c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ca260:	e1a0e00f 	mov	lr, pc
 c1ca264:	e12fff13 	bx	r3
	ic_enable(INT_TIMER0);

    while( 1 )
    {
        sleep();                        /* Entra en estado IDLE, sale por interrupción */
        while( !fifo_is_empty() )
 c1ca268:	eb0000cb 	bl	c1ca59c <fifo_is_empty>
 c1ca26c:	e1a03000 	mov	r3, r0
 c1ca270:	e3530000 	cmp	r3, #0
 c1ca274:	0afffff6 	beq	c1ca254 <queue+0xb4>
        {
            pf = fifo_dequeue();
            (*pf)();                    /* Las tareas encoladas se ejecutan en esta hebra (background) en orden de encolado */
        }
    }
 c1ca278:	eafffff3 	b	c1ca24c <queue+0xac>
 c1ca27c:	0c101028 	.word	0x0c101028
 c1ca280:	0c101060 	.word	0x0c101060
 c1ca284:	0c7fff74 	.word	0x0c7fff74
 c1ca288:	0c1ca158 	.word	0x0c1ca158
 c1ca28c:	00009c40 	.word	0x00009c40
 c1ca290:	0c7fff54 	.word	0x0c7fff54
 c1ca294:	0c1ca298 	.word	0x0c1ca298

0c1ca298 <isr_tick>:
}

#endif

void isr_tick( void )
{
 c1ca298:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1ca29c:	e1a0c00d 	mov	ip, sp
 c1ca2a0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1ca2a4:	e24cb004 	sub	fp, ip, #4
    static uint16 cont5ticks    = 5;
    static uint16 cont50ticks   = 50;
    static uint16 cont100ticks  = 100;
    static uint16 cont1000ticks = 1000;

    if( !(--cont5ticks) )
 c1ca2a8:	e59f3110 	ldr	r3, [pc, #272]	; c1ca3c0 <isr_tick+0x128>
 c1ca2ac:	e1d330b0 	ldrh	r3, [r3]
 c1ca2b0:	e2433001 	sub	r3, r3, #1
 c1ca2b4:	e1a03803 	lsl	r3, r3, #16
 c1ca2b8:	e1a02823 	lsr	r2, r3, #16
 c1ca2bc:	e59f30fc 	ldr	r3, [pc, #252]	; c1ca3c0 <isr_tick+0x128>
 c1ca2c0:	e1c320b0 	strh	r2, [r3]
 c1ca2c4:	e59f30f4 	ldr	r3, [pc, #244]	; c1ca3c0 <isr_tick+0x128>
 c1ca2c8:	e1d330b0 	ldrh	r3, [r3]
 c1ca2cc:	e3530000 	cmp	r3, #0
 c1ca2d0:	1a000004 	bne	c1ca2e8 <isr_tick+0x50>
    {
        cont5ticks = 5;
 c1ca2d4:	e59f30e4 	ldr	r3, [pc, #228]	; c1ca3c0 <isr_tick+0x128>
 c1ca2d8:	e3a02005 	mov	r2, #5
 c1ca2dc:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task2 );
 c1ca2e0:	e59f00dc 	ldr	r0, [pc, #220]	; c1ca3c4 <isr_tick+0x12c>
 c1ca2e4:	eb00004d 	bl	c1ca420 <fifo_enqueue>
    }
    if( !(--cont50ticks) )
 c1ca2e8:	e59f30d8 	ldr	r3, [pc, #216]	; c1ca3c8 <isr_tick+0x130>
 c1ca2ec:	e1d330b0 	ldrh	r3, [r3]
 c1ca2f0:	e2433001 	sub	r3, r3, #1
 c1ca2f4:	e1a03803 	lsl	r3, r3, #16
 c1ca2f8:	e1a02823 	lsr	r2, r3, #16
 c1ca2fc:	e59f30c4 	ldr	r3, [pc, #196]	; c1ca3c8 <isr_tick+0x130>
 c1ca300:	e1c320b0 	strh	r2, [r3]
 c1ca304:	e59f30bc 	ldr	r3, [pc, #188]	; c1ca3c8 <isr_tick+0x130>
 c1ca308:	e1d330b0 	ldrh	r3, [r3]
 c1ca30c:	e3530000 	cmp	r3, #0
 c1ca310:	1a000004 	bne	c1ca328 <isr_tick+0x90>
    {
        cont50ticks = 50;
 c1ca314:	e59f30ac 	ldr	r3, [pc, #172]	; c1ca3c8 <isr_tick+0x130>
 c1ca318:	e3a02032 	mov	r2, #50	; 0x32
 c1ca31c:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task1 );
 c1ca320:	e59f00a4 	ldr	r0, [pc, #164]	; c1ca3cc <isr_tick+0x134>
 c1ca324:	eb00003d 	bl	c1ca420 <fifo_enqueue>
    }
    if( !(--cont100ticks) )
 c1ca328:	e59f30a0 	ldr	r3, [pc, #160]	; c1ca3d0 <isr_tick+0x138>
 c1ca32c:	e1d330b0 	ldrh	r3, [r3]
 c1ca330:	e2433001 	sub	r3, r3, #1
 c1ca334:	e1a03803 	lsl	r3, r3, #16
 c1ca338:	e1a02823 	lsr	r2, r3, #16
 c1ca33c:	e59f308c 	ldr	r3, [pc, #140]	; c1ca3d0 <isr_tick+0x138>
 c1ca340:	e1c320b0 	strh	r2, [r3]
 c1ca344:	e59f3084 	ldr	r3, [pc, #132]	; c1ca3d0 <isr_tick+0x138>
 c1ca348:	e1d330b0 	ldrh	r3, [r3]
 c1ca34c:	e3530000 	cmp	r3, #0
 c1ca350:	1a000004 	bne	c1ca368 <isr_tick+0xd0>
    {
        cont100ticks = 100;
 c1ca354:	e59f3074 	ldr	r3, [pc, #116]	; c1ca3d0 <isr_tick+0x138>
 c1ca358:	e3a02064 	mov	r2, #100	; 0x64
 c1ca35c:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task3 );
 c1ca360:	e59f006c 	ldr	r0, [pc, #108]	; c1ca3d4 <isr_tick+0x13c>
 c1ca364:	eb00002d 	bl	c1ca420 <fifo_enqueue>
    }
    if( !(--cont1000ticks) )
 c1ca368:	e59f3068 	ldr	r3, [pc, #104]	; c1ca3d8 <isr_tick+0x140>
 c1ca36c:	e1d330b0 	ldrh	r3, [r3]
 c1ca370:	e2433001 	sub	r3, r3, #1
 c1ca374:	e1a03803 	lsl	r3, r3, #16
 c1ca378:	e1a02823 	lsr	r2, r3, #16
 c1ca37c:	e59f3054 	ldr	r3, [pc, #84]	; c1ca3d8 <isr_tick+0x140>
 c1ca380:	e1c320b0 	strh	r2, [r3]
 c1ca384:	e59f304c 	ldr	r3, [pc, #76]	; c1ca3d8 <isr_tick+0x140>
 c1ca388:	e1d330b0 	ldrh	r3, [r3]
 c1ca38c:	e3530000 	cmp	r3, #0
 c1ca390:	1a000004 	bne	c1ca3a8 <isr_tick+0x110>
    {
        cont1000ticks = 1000;
 c1ca394:	e59f303c 	ldr	r3, [pc, #60]	; c1ca3d8 <isr_tick+0x140>
 c1ca398:	e3a02ffa 	mov	r2, #1000	; 0x3e8
 c1ca39c:	e1c320b0 	strh	r2, [r3]
        fifo_enqueue( Task4 );
 c1ca3a0:	e59f0034 	ldr	r0, [pc, #52]	; c1ca3dc <isr_tick+0x144>
 c1ca3a4:	eb00001d 	bl	c1ca420 <fifo_enqueue>
    }

    ic_cleanflag(INT_TIMER0);
 c1ca3a8:	e3a0000d 	mov	r0, #13
 c1ca3ac:	eb0008d9 	bl	c1cc718 <ic_cleanflag>
};
 c1ca3b0:	e24bd01c 	sub	sp, fp, #28
 c1ca3b4:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1ca3b8:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1ca3bc:	e25ef004 	subs	pc, lr, #4
 c1ca3c0:	0c1000e0 	.word	0x0c1000e0
 c1ca3c4:	0c1c9d8c 	.word	0x0c1c9d8c
 c1ca3c8:	0c1000e2 	.word	0x0c1000e2
 c1ca3cc:	0c1c9d34 	.word	0x0c1c9d34
 c1ca3d0:	0c1000e4 	.word	0x0c1000e4
 c1ca3d4:	0c1c9e98 	.word	0x0c1c9e98
 c1ca3d8:	0c1000e6 	.word	0x0c1000e6
 c1ca3dc:	0c1c9f3c 	.word	0x0c1c9f3c

0c1ca3e0 <fifo_init>:


/*******************************************************************/

void fifo_init( void )
{
 c1ca3e0:	e1a0c00d 	mov	ip, sp
 c1ca3e4:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca3e8:	e24cb004 	sub	fp, ip, #4
    fifo.head = 0;
 c1ca3ec:	e59f3028 	ldr	r3, [pc, #40]	; c1ca41c <fifo_init+0x3c>
 c1ca3f0:	e3a02000 	mov	r2, #0
 c1ca3f4:	e1c320b0 	strh	r2, [r3]
    fifo.tail = 0;
 c1ca3f8:	e59f301c 	ldr	r3, [pc, #28]	; c1ca41c <fifo_init+0x3c>
 c1ca3fc:	e3a02000 	mov	r2, #0
 c1ca400:	e1c320b2 	strh	r2, [r3, #2]
    fifo.size = 0;
 c1ca404:	e59f3010 	ldr	r3, [pc, #16]	; c1ca41c <fifo_init+0x3c>
 c1ca408:	e3a02000 	mov	r2, #0
 c1ca40c:	e1c320b4 	strh	r2, [r3, #4]
}
 c1ca410:	e24bd00c 	sub	sp, fp, #12
 c1ca414:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca418:	e12fff1e 	bx	lr
 c1ca41c:	0c1c7120 	.word	0x0c1c7120

0c1ca420 <fifo_enqueue>:

void fifo_enqueue( pf_t pf )
{
 c1ca420:	e1a0c00d 	mov	ip, sp
 c1ca424:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca428:	e24cb004 	sub	fp, ip, #4
 c1ca42c:	e24dd008 	sub	sp, sp, #8
 c1ca430:	e50b0010 	str	r0, [fp, #-16]
    fifo.buffer[fifo.tail++] = pf;
 c1ca434:	e59f309c 	ldr	r3, [pc, #156]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca438:	e1d330b2 	ldrh	r3, [r3, #2]
 c1ca43c:	e1a03803 	lsl	r3, r3, #16
 c1ca440:	e1a03823 	lsr	r3, r3, #16
 c1ca444:	e1a01003 	mov	r1, r3
 c1ca448:	e59f2088 	ldr	r2, [pc, #136]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca44c:	e2811002 	add	r1, r1, #2
 c1ca450:	e51b0010 	ldr	r0, [fp, #-16]
 c1ca454:	e7820101 	str	r0, [r2, r1, lsl #2]
 c1ca458:	e2833001 	add	r3, r3, #1
 c1ca45c:	e1a03803 	lsl	r3, r3, #16
 c1ca460:	e1a02823 	lsr	r2, r3, #16
 c1ca464:	e59f306c 	ldr	r3, [pc, #108]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca468:	e1c320b2 	strh	r2, [r3, #2]
    if( fifo.tail == BUFFER_LEN )
 c1ca46c:	e59f3064 	ldr	r3, [pc, #100]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca470:	e1d330b2 	ldrh	r3, [r3, #2]
 c1ca474:	e1a03803 	lsl	r3, r3, #16
 c1ca478:	e1a03823 	lsr	r3, r3, #16
 c1ca47c:	e3530c02 	cmp	r3, #512	; 0x200
 c1ca480:	1a000002 	bne	c1ca490 <fifo_enqueue+0x70>
        fifo.tail = 0;
 c1ca484:	e59f304c 	ldr	r3, [pc, #76]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca488:	e3a02000 	mov	r2, #0
 c1ca48c:	e1c320b2 	strh	r2, [r3, #2]
    INT_DISABLE;
 c1ca490:	e10f0000 	mrs	r0, CPSR
 c1ca494:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c1ca498:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c1ca49c:	e121f000 	msr	CPSR_c, r0
    fifo.size++;
 c1ca4a0:	e59f3030 	ldr	r3, [pc, #48]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca4a4:	e1d330b4 	ldrh	r3, [r3, #4]
 c1ca4a8:	e1a03803 	lsl	r3, r3, #16
 c1ca4ac:	e1a03823 	lsr	r3, r3, #16
 c1ca4b0:	e2833001 	add	r3, r3, #1
 c1ca4b4:	e1a03803 	lsl	r3, r3, #16
 c1ca4b8:	e1a02823 	lsr	r2, r3, #16
 c1ca4bc:	e59f3014 	ldr	r3, [pc, #20]	; c1ca4d8 <fifo_enqueue+0xb8>
 c1ca4c0:	e1c320b4 	strh	r2, [r3, #4]
    INT_ENABLE;
 c1ca4c4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c1ca4c8:	e121f000 	msr	CPSR_c, r0
}
 c1ca4cc:	e24bd00c 	sub	sp, fp, #12
 c1ca4d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca4d4:	e12fff1e 	bx	lr
 c1ca4d8:	0c1c7120 	.word	0x0c1c7120

0c1ca4dc <fifo_dequeue>:

pf_t fifo_dequeue( void )
{
 c1ca4dc:	e1a0c00d 	mov	ip, sp
 c1ca4e0:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca4e4:	e24cb004 	sub	fp, ip, #4
 c1ca4e8:	e24dd008 	sub	sp, sp, #8
    pf_t pf;

    pf = fifo.buffer[fifo.head++];
 c1ca4ec:	e59f30a4 	ldr	r3, [pc, #164]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca4f0:	e1d330b0 	ldrh	r3, [r3]
 c1ca4f4:	e1a03803 	lsl	r3, r3, #16
 c1ca4f8:	e1a03823 	lsr	r3, r3, #16
 c1ca4fc:	e1a01003 	mov	r1, r3
 c1ca500:	e59f2090 	ldr	r2, [pc, #144]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca504:	e2811002 	add	r1, r1, #2
 c1ca508:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c1ca50c:	e50b2010 	str	r2, [fp, #-16]
 c1ca510:	e2833001 	add	r3, r3, #1
 c1ca514:	e1a03803 	lsl	r3, r3, #16
 c1ca518:	e1a02823 	lsr	r2, r3, #16
 c1ca51c:	e59f3074 	ldr	r3, [pc, #116]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca520:	e1c320b0 	strh	r2, [r3]
    if( fifo.head == BUFFER_LEN )
 c1ca524:	e59f306c 	ldr	r3, [pc, #108]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca528:	e1d330b0 	ldrh	r3, [r3]
 c1ca52c:	e1a03803 	lsl	r3, r3, #16
 c1ca530:	e1a03823 	lsr	r3, r3, #16
 c1ca534:	e3530c02 	cmp	r3, #512	; 0x200
 c1ca538:	1a000002 	bne	c1ca548 <fifo_dequeue+0x6c>
        fifo.head = 0;
 c1ca53c:	e59f3054 	ldr	r3, [pc, #84]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca540:	e3a02000 	mov	r2, #0
 c1ca544:	e1c320b0 	strh	r2, [r3]
    INT_DISABLE;
 c1ca548:	e10f0000 	mrs	r0, CPSR
 c1ca54c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 c1ca550:	e38000c0 	orr	r0, r0, #192	; 0xc0
 c1ca554:	e121f000 	msr	CPSR_c, r0
    fifo.size--;
 c1ca558:	e59f3038 	ldr	r3, [pc, #56]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca55c:	e1d330b4 	ldrh	r3, [r3, #4]
 c1ca560:	e1a03803 	lsl	r3, r3, #16
 c1ca564:	e1a03823 	lsr	r3, r3, #16
 c1ca568:	e2433001 	sub	r3, r3, #1
 c1ca56c:	e1a03803 	lsl	r3, r3, #16
 c1ca570:	e1a02823 	lsr	r2, r3, #16
 c1ca574:	e59f301c 	ldr	r3, [pc, #28]	; c1ca598 <fifo_dequeue+0xbc>
 c1ca578:	e1c320b4 	strh	r2, [r3, #4]
    INT_ENABLE;
 c1ca57c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 c1ca580:	e121f000 	msr	CPSR_c, r0
    return pf;
 c1ca584:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1ca588:	e1a00003 	mov	r0, r3
 c1ca58c:	e24bd00c 	sub	sp, fp, #12
 c1ca590:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca594:	e12fff1e 	bx	lr
 c1ca598:	0c1c7120 	.word	0x0c1c7120

0c1ca59c <fifo_is_empty>:

boolean fifo_is_empty( void )
{
 c1ca59c:	e1a0c00d 	mov	ip, sp
 c1ca5a0:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca5a4:	e24cb004 	sub	fp, ip, #4
    return (fifo.size == 0);
 c1ca5a8:	e59f3028 	ldr	r3, [pc, #40]	; c1ca5d8 <fifo_is_empty+0x3c>
 c1ca5ac:	e1d330b4 	ldrh	r3, [r3, #4]
 c1ca5b0:	e1a03803 	lsl	r3, r3, #16
 c1ca5b4:	e1a03823 	lsr	r3, r3, #16
 c1ca5b8:	e3530000 	cmp	r3, #0
 c1ca5bc:	13a03000 	movne	r3, #0
 c1ca5c0:	03a03001 	moveq	r3, #1
 c1ca5c4:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1ca5c8:	e1a00003 	mov	r0, r3
 c1ca5cc:	e24bd00c 	sub	sp, fp, #12
 c1ca5d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca5d4:	e12fff1e 	bx	lr
 c1ca5d8:	0c1c7120 	.word	0x0c1c7120

0c1ca5dc <fifo_is_full>:

boolean fifo_is_full( void )
{
 c1ca5dc:	e1a0c00d 	mov	ip, sp
 c1ca5e0:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca5e4:	e24cb004 	sub	fp, ip, #4
    return (fifo.size == BUFFER_LEN-1);
 c1ca5e8:	e59f302c 	ldr	r3, [pc, #44]	; c1ca61c <fifo_is_full+0x40>
 c1ca5ec:	e1d330b4 	ldrh	r3, [r3, #4]
 c1ca5f0:	e1a03803 	lsl	r3, r3, #16
 c1ca5f4:	e1a02823 	lsr	r2, r3, #16
 c1ca5f8:	e59f3020 	ldr	r3, [pc, #32]	; c1ca620 <fifo_is_full+0x44>
 c1ca5fc:	e1520003 	cmp	r2, r3
 c1ca600:	13a03000 	movne	r3, #0
 c1ca604:	03a03001 	moveq	r3, #1
 c1ca608:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1ca60c:	e1a00003 	mov	r0, r3
 c1ca610:	e24bd00c 	sub	sp, fp, #12
 c1ca614:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca618:	e12fff1e 	bx	lr
 c1ca61c:	0c1c7120 	.word	0x0c1c7120
 c1ca620:	000001ff 	.word	0x000001ff

0c1ca624 <D8Led_init>:
	 							 DIGIT_4, DIGIT_5, DIGIT_6, DIGIT_7, 
								 DIGIT_8, DIGIT_9, DIGIT_A, DIGIT_B,
								 DIGIT_C, DIGIT_D, DIGIT_E, DIGIT_F };
			  					  
void D8Led_init(void)
{
 c1ca624:	e1a0c00d 	mov	ip, sp
 c1ca628:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca62c:	e24cb004 	sub	fp, ip, #4
    LED8ADDR = ~0;
 c1ca630:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c1ca634:	e3e02000 	mvn	r2, #0
 c1ca638:	e5c32000 	strb	r2, [r3]
}
 c1ca63c:	e24bd00c 	sub	sp, fp, #12
 c1ca640:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca644:	e12fff1e 	bx	lr

0c1ca648 <D8Led_off>:

void D8Led_off(void)
{
 c1ca648:	e1a0c00d 	mov	ip, sp
 c1ca64c:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca650:	e24cb004 	sub	fp, ip, #4
    LED8ADDR = ~0;
 c1ca654:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c1ca658:	e3e02000 	mvn	r2, #0
 c1ca65c:	e5c32000 	strb	r2, [r3]
}
 c1ca660:	e24bd00c 	sub	sp, fp, #12
 c1ca664:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca668:	e12fff1e 	bx	lr

0c1ca66c <D8Led_segment>:

void D8Led_segment(int value)
{
 c1ca66c:	e1a0c00d 	mov	ip, sp
 c1ca670:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca674:	e24cb004 	sub	fp, ip, #4
 c1ca678:	e24dd008 	sub	sp, sp, #8
 c1ca67c:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 8) )
 c1ca680:	e51b3010 	ldr	r3, [fp, #-16]
 c1ca684:	e3530000 	cmp	r3, #0
 c1ca688:	ba00000a 	blt	c1ca6b8 <D8Led_segment+0x4c>
 c1ca68c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ca690:	e3530007 	cmp	r3, #7
 c1ca694:	ca000007 	bgt	c1ca6b8 <D8Led_segment+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el segmento que está en la posición
		// value del array Segmentes. Hay que tener en cuente que el display
		// usa lógica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Segments[value];
 c1ca698:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c1ca69c:	e59f2020 	ldr	r2, [pc, #32]	; c1ca6c4 <D8Led_segment+0x58>
 c1ca6a0:	e51b1010 	ldr	r1, [fp, #-16]
 c1ca6a4:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c1ca6a8:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ca6ac:	e1e02002 	mvn	r2, r2
 c1ca6b0:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ca6b4:	e5c32000 	strb	r2, [r3]
}
 c1ca6b8:	e24bd00c 	sub	sp, fp, #12
 c1ca6bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca6c0:	e12fff1e 	bx	lr
 c1ca6c4:	0c1000e8 	.word	0x0c1000e8

0c1ca6c8 <D8Led_digit>:

void D8Led_digit(int value)
{
 c1ca6c8:	e1a0c00d 	mov	ip, sp
 c1ca6cc:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca6d0:	e24cb004 	sub	fp, ip, #4
 c1ca6d4:	e24dd008 	sub	sp, sp, #8
 c1ca6d8:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 16) )
 c1ca6dc:	e51b3010 	ldr	r3, [fp, #-16]
 c1ca6e0:	e3530000 	cmp	r3, #0
 c1ca6e4:	ba00000a 	blt	c1ca714 <D8Led_digit+0x4c>
 c1ca6e8:	e51b3010 	ldr	r3, [fp, #-16]
 c1ca6ec:	e353000f 	cmp	r3, #15
 c1ca6f0:	ca000007 	bgt	c1ca714 <D8Led_digit+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el dígito que está en la posición
		// value del array Digits. Hay que tener en cuente que el display
		// usa lógica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Digits[value];
 c1ca6f4:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c1ca6f8:	e59f2020 	ldr	r2, [pc, #32]	; c1ca720 <D8Led_digit+0x58>
 c1ca6fc:	e51b1010 	ldr	r1, [fp, #-16]
 c1ca700:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c1ca704:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ca708:	e1e02002 	mvn	r2, r2
 c1ca70c:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ca710:	e5c32000 	strb	r2, [r3]
}
 c1ca714:	e24bd00c 	sub	sp, fp, #12
 c1ca718:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca71c:	e12fff1e 	bx	lr
 c1ca720:	0c100108 	.word	0x0c100108

0c1ca724 <L3_init>:
#include "gpio.h"

#define SHORT_DELAY { volatile int8 j; for( j=0; j<4; j++ ); }

void L3_init( void )
{
 c1ca724:	e1a0c00d 	mov	ip, sp
 c1ca728:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca72c:	e24cb004 	sub	fp, ip, #4
 c1ca730:	e24dd008 	sub	sp, sp, #8
    //L3CLOCK = 1
	//L3MODE = 1
    uint8 rled, lled;

    rled = !led2_status();
 c1ca734:	eb000bc7 	bl	c1cd658 <led2_status>
 c1ca738:	e1a03000 	mov	r3, r0
 c1ca73c:	e3530000 	cmp	r3, #0
 c1ca740:	13a03000 	movne	r3, #0
 c1ca744:	03a03001 	moveq	r3, #1
 c1ca748:	e54b300d 	strb	r3, [fp, #-13]
    lled = !led1_status();
 c1ca74c:	eb000bb4 	bl	c1cd624 <led1_status>
 c1ca750:	e1a03000 	mov	r3, r0
 c1ca754:	e3530000 	cmp	r3, #0
 c1ca758:	13a03000 	movne	r3, #0
 c1ca75c:	03a03001 	moveq	r3, #1
 c1ca760:	e54b300e 	strb	r3, [fp, #-14]

    portB_conf(5, OUTPUT);
 c1ca764:	e3a00005 	mov	r0, #5
 c1ca768:	e3a01001 	mov	r1, #1
 c1ca76c:	eb00028e 	bl	c1cb1ac <portB_conf>
    portB_conf(4, OUTPUT);
 c1ca770:	e3a00004 	mov	r0, #4
 c1ca774:	e3a01001 	mov	r1, #1
 c1ca778:	eb00028b 	bl	c1cb1ac <portB_conf>
    rPCONA &= ~(1 << 9);
 c1ca77c:	e59f3038 	ldr	r3, [pc, #56]	; c1ca7bc <L3_init+0x98>
 c1ca780:	e59f2034 	ldr	r2, [pc, #52]	; c1ca7bc <L3_init+0x98>
 c1ca784:	e5922000 	ldr	r2, [r2]
 c1ca788:	e3c22c02 	bic	r2, r2, #512	; 0x200
 c1ca78c:	e5832000 	str	r2, [r3]

    //L3CLOCK = PDATB[5]
    //L3MODE = PDATB[4]

    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (1 << 4);
 c1ca790:	e59f3028 	ldr	r3, [pc, #40]	; c1ca7c0 <L3_init+0x9c>
 c1ca794:	e55b200d 	ldrb	r2, [fp, #-13]
 c1ca798:	e1a01502 	lsl	r1, r2, #10
 c1ca79c:	e55b200e 	ldrb	r2, [fp, #-14]
 c1ca7a0:	e1a02482 	lsl	r2, r2, #9
 c1ca7a4:	e1812002 	orr	r2, r1, r2
 c1ca7a8:	e3822030 	orr	r2, r2, #48	; 0x30
 c1ca7ac:	e5832000 	str	r2, [r3]
}
 c1ca7b0:	e24bd00c 	sub	sp, fp, #12
 c1ca7b4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca7b8:	e12fff1e 	bx	lr
 c1ca7bc:	01d20000 	.word	0x01d20000
 c1ca7c0:	01d2000c 	.word	0x01d2000c

0c1ca7c4 <L3_putByte>:

void L3_putByte( uint8 byte, enum L3_mode_t mode )
{
 c1ca7c4:	e1a0c00d 	mov	ip, sp
 c1ca7c8:	e92dd800 	push	{fp, ip, lr, pc}
 c1ca7cc:	e24cb004 	sub	fp, ip, #4
 c1ca7d0:	e24dd010 	sub	sp, sp, #16
 c1ca7d4:	e1a02000 	mov	r2, r0
 c1ca7d8:	e1a03001 	mov	r3, r1
 c1ca7dc:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c1ca7e0:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
    uint8 i;
    uint8 rled, lled;

    rled = !led2_status();
 c1ca7e4:	eb000b9b 	bl	c1cd658 <led2_status>
 c1ca7e8:	e1a03000 	mov	r3, r0
 c1ca7ec:	e3530000 	cmp	r3, #0
 c1ca7f0:	13a03000 	movne	r3, #0
 c1ca7f4:	03a03001 	moveq	r3, #1
 c1ca7f8:	e54b300e 	strb	r3, [fp, #-14]
    lled = !led1_status();
 c1ca7fc:	eb000b88 	bl	c1cd624 <led1_status>
 c1ca800:	e1a03000 	mov	r3, r0
 c1ca804:	e3530000 	cmp	r3, #0
 c1ca808:	13a03000 	movne	r3, #0
 c1ca80c:	03a03001 	moveq	r3, #1
 c1ca810:	e54b300f 	strb	r3, [fp, #-15]

    //L3CLOCK = PDATB[5]
    //L3MODE = PDATB[4]

    //L3CLOCK=1, L3MODE=mode
    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
 c1ca814:	e59f31b0 	ldr	r3, [pc, #432]	; c1ca9cc <L3_putByte+0x208>
 c1ca818:	e55b200e 	ldrb	r2, [fp, #-14]
 c1ca81c:	e1a01502 	lsl	r1, r2, #10
 c1ca820:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ca824:	e1a02482 	lsl	r2, r2, #9
 c1ca828:	e1812002 	orr	r2, r1, r2
 c1ca82c:	e3821020 	orr	r1, r2, #32
 c1ca830:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c1ca834:	e1a02202 	lsl	r2, r2, #4
 c1ca838:	e1812002 	orr	r2, r1, r2
 c1ca83c:	e5832000 	str	r2, [r3]
    SHORT_DELAY;
 c1ca840:	e3a03000 	mov	r3, #0
 c1ca844:	e54b3010 	strb	r3, [fp, #-16]
 c1ca848:	ea000004 	b	c1ca860 <L3_putByte+0x9c>
 c1ca84c:	e55b3010 	ldrb	r3, [fp, #-16]
 c1ca850:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca854:	e2833001 	add	r3, r3, #1
 c1ca858:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca85c:	e54b3010 	strb	r3, [fp, #-16]
 c1ca860:	e55b3010 	ldrb	r3, [fp, #-16]
 c1ca864:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca868:	e1a03c03 	lsl	r3, r3, #24
 c1ca86c:	e1a03c43 	asr	r3, r3, #24
 c1ca870:	e3530003 	cmp	r3, #3
 c1ca874:	dafffff4 	ble	c1ca84c <L3_putByte+0x88>

    for( i=0; i<8; i++ )
 c1ca878:	e3a03000 	mov	r3, #0
 c1ca87c:	e54b300d 	strb	r3, [fp, #-13]
 c1ca880:	ea000043 	b	c1ca994 <L3_putByte+0x1d0>
    {
    	//L3CLOCK = 0, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (0 << 5) | (mode << 4);
 c1ca884:	e59f3140 	ldr	r3, [pc, #320]	; c1ca9cc <L3_putByte+0x208>
 c1ca888:	e55b200e 	ldrb	r2, [fp, #-14]
 c1ca88c:	e1a01502 	lsl	r1, r2, #10
 c1ca890:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ca894:	e1a02482 	lsl	r2, r2, #9
 c1ca898:	e1811002 	orr	r1, r1, r2
 c1ca89c:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c1ca8a0:	e1a02202 	lsl	r2, r2, #4
 c1ca8a4:	e1812002 	orr	r2, r1, r2
 c1ca8a8:	e5832000 	str	r2, [r3]

        //L3DATA = byte[i]
        //L3DATA = PDATA[9]
        rPDATA &= ~(1 << 9);
 c1ca8ac:	e59f311c 	ldr	r3, [pc, #284]	; c1ca9d0 <L3_putByte+0x20c>
 c1ca8b0:	e59f2118 	ldr	r2, [pc, #280]	; c1ca9d0 <L3_putByte+0x20c>
 c1ca8b4:	e5922000 	ldr	r2, [r2]
 c1ca8b8:	e3c22c02 	bic	r2, r2, #512	; 0x200
 c1ca8bc:	e5832000 	str	r2, [r3]
        rPDATA |= (byte & 1) << 9;
 c1ca8c0:	e59f3108 	ldr	r3, [pc, #264]	; c1ca9d0 <L3_putByte+0x20c>
 c1ca8c4:	e59f2104 	ldr	r2, [pc, #260]	; c1ca9d0 <L3_putByte+0x20c>
 c1ca8c8:	e5921000 	ldr	r1, [r2]
 c1ca8cc:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c1ca8d0:	e2022001 	and	r2, r2, #1
 c1ca8d4:	e1a02482 	lsl	r2, r2, #9
 c1ca8d8:	e1812002 	orr	r2, r1, r2
 c1ca8dc:	e5832000 	str	r2, [r3]
        byte >>= 1;
 c1ca8e0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1ca8e4:	e1a030a3 	lsr	r3, r3, #1
 c1ca8e8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb

        SHORT_DELAY;
 c1ca8ec:	e3a03000 	mov	r3, #0
 c1ca8f0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c1ca8f4:	ea000004 	b	c1ca90c <L3_putByte+0x148>
 c1ca8f8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1ca8fc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca900:	e2833001 	add	r3, r3, #1
 c1ca904:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca908:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c1ca90c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1ca910:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca914:	e1a03c03 	lsl	r3, r3, #24
 c1ca918:	e1a03c43 	asr	r3, r3, #24
 c1ca91c:	e3530003 	cmp	r3, #3
 c1ca920:	dafffff4 	ble	c1ca8f8 <L3_putByte+0x134>

        //L3CLOCK = 1, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
 c1ca924:	e59f30a0 	ldr	r3, [pc, #160]	; c1ca9cc <L3_putByte+0x208>
 c1ca928:	e55b200e 	ldrb	r2, [fp, #-14]
 c1ca92c:	e1a01502 	lsl	r1, r2, #10
 c1ca930:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ca934:	e1a02482 	lsl	r2, r2, #9
 c1ca938:	e1812002 	orr	r2, r1, r2
 c1ca93c:	e3821020 	orr	r1, r2, #32
 c1ca940:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
 c1ca944:	e1a02202 	lsl	r2, r2, #4
 c1ca948:	e1812002 	orr	r2, r1, r2
 c1ca94c:	e5832000 	str	r2, [r3]
        SHORT_DELAY;
 c1ca950:	e3a03000 	mov	r3, #0
 c1ca954:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
 c1ca958:	ea000004 	b	c1ca970 <L3_putByte+0x1ac>
 c1ca95c:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c1ca960:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca964:	e2833001 	add	r3, r3, #1
 c1ca968:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca96c:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
 c1ca970:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
 c1ca974:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ca978:	e1a03c03 	lsl	r3, r3, #24
 c1ca97c:	e1a03c43 	asr	r3, r3, #24
 c1ca980:	e3530003 	cmp	r3, #3
 c1ca984:	dafffff4 	ble	c1ca95c <L3_putByte+0x198>

    //L3CLOCK=1, L3MODE=mode
    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
    SHORT_DELAY;

    for( i=0; i<8; i++ )
 c1ca988:	e55b300d 	ldrb	r3, [fp, #-13]
 c1ca98c:	e2833001 	add	r3, r3, #1
 c1ca990:	e54b300d 	strb	r3, [fp, #-13]
 c1ca994:	e55b300d 	ldrb	r3, [fp, #-13]
 c1ca998:	e3530007 	cmp	r3, #7
 c1ca99c:	9affffb8 	bls	c1ca884 <L3_putByte+0xc0>
        //L3CLOCK = 1, L3MODE = mode
        rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (mode << 4);
        SHORT_DELAY;
    }

    rPDATB = (rled << 10) | (lled << 9) | (1 << 5) | (1 << 4);
 c1ca9a0:	e59f3024 	ldr	r3, [pc, #36]	; c1ca9cc <L3_putByte+0x208>
 c1ca9a4:	e55b200e 	ldrb	r2, [fp, #-14]
 c1ca9a8:	e1a01502 	lsl	r1, r2, #10
 c1ca9ac:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ca9b0:	e1a02482 	lsl	r2, r2, #9
 c1ca9b4:	e1812002 	orr	r2, r1, r2
 c1ca9b8:	e3822030 	orr	r2, r2, #48	; 0x30
 c1ca9bc:	e5832000 	str	r2, [r3]
}
 c1ca9c0:	e24bd00c 	sub	sp, fp, #12
 c1ca9c4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ca9c8:	e12fff1e 	bx	lr
 c1ca9cc:	01d2000c 	.word	0x01d2000c
 c1ca9d0:	01d20004 	.word	0x01d20004

0c1ca9d4 <isr_ADC_dummy>:
static uint8 state;

void isr_ADC_dummy( void ) __attribute__ ((interrupt ("IRQ")));

void isr_ADC_dummy(void)
{
 c1ca9d4:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1ca9d8:	e1a0c00d 	mov	ip, sp
 c1ca9dc:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1ca9e0:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_ADC);
 c1ca9e4:	e3a00000 	mov	r0, #0
 c1ca9e8:	eb00074a 	bl	c1cc718 <ic_cleanflag>
}
 c1ca9ec:	e24bd01c 	sub	sp, fp, #28
 c1ca9f0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1ca9f4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1ca9f8:	e25ef004 	subs	pc, lr, #4

0c1ca9fc <adc_init>:

void adc_init( void )
{
 c1ca9fc:	e1a0c00d 	mov	ip, sp
 c1caa00:	e92dd800 	push	{fp, ip, lr, pc}
 c1caa04:	e24cb004 	sub	fp, ip, #4
	//Tasa de conversiÃ³n: mÃ¡xima (100 KSPS, tiempo de conversiÃ³n 10 us)
	//100KHz = 64 MHz / 2(n+1)Ã16 => n = 19
	rADCPSR = 19;
 c1caa08:	e59f3014 	ldr	r3, [pc, #20]	; c1caa24 <adc_init+0x28>
 c1caa0c:	e3a02013 	mov	r2, #19
 c1caa10:	e5832000 	str	r2, [r3]
    adc_off();
 c1caa14:	eb000014 	bl	c1caa6c <adc_off>
}
 c1caa18:	e24bd00c 	sub	sp, fp, #12
 c1caa1c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1caa20:	e12fff1e 	bx	lr
 c1caa24:	01d40004 	.word	0x01d40004

0c1caa28 <adc_on>:

void adc_on( void )
{
 c1caa28:	e1a0c00d 	mov	ip, sp
 c1caa2c:	e92dd800 	push	{fp, ip, lr, pc}
 c1caa30:	e24cb004 	sub	fp, ip, #4
	//	ADCCON[5] = 0 Normal mode
	rADCCON &= ~(1 << 5);
 c1caa34:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1caa38:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1caa3c:	e5922000 	ldr	r2, [r2]
 c1caa40:	e3c22020 	bic	r2, r2, #32
 c1caa44:	e5832000 	str	r2, [r3]

	//Esperar 10 ms antes de arrancar la conversiÃ³n
	Delay(10);
 c1caa48:	e3a0000a 	mov	r0, #10
 c1caa4c:	eb001581 	bl	c1d0058 <Delay>
    state = ON;
 c1caa50:	e59f3010 	ldr	r3, [pc, #16]	; c1caa68 <adc_on+0x40>
 c1caa54:	e3a02001 	mov	r2, #1
 c1caa58:	e5c32000 	strb	r2, [r3]
}
 c1caa5c:	e24bd00c 	sub	sp, fp, #12
 c1caa60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1caa64:	e12fff1e 	bx	lr
 c1caa68:	0c1022e4 	.word	0x0c1022e4

0c1caa6c <adc_off>:

void adc_off( void )
{
 c1caa6c:	e1a0c00d 	mov	ip, sp
 c1caa70:	e92dd800 	push	{fp, ip, lr, pc}
 c1caa74:	e24cb004 	sub	fp, ip, #4
	//ADCCON[5] = 1  Sleep mode
	rADCCON |= 1 << 5;
 c1caa78:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1caa7c:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1caa80:	e5922000 	ldr	r2, [r2]
 c1caa84:	e3822020 	orr	r2, r2, #32
 c1caa88:	e5832000 	str	r2, [r3]
	state = OFF;
 c1caa8c:	e59f3010 	ldr	r3, [pc, #16]	; c1caaa4 <adc_off+0x38>
 c1caa90:	e3a02000 	mov	r2, #0
 c1caa94:	e5c32000 	strb	r2, [r3]
}
 c1caa98:	e24bd00c 	sub	sp, fp, #12
 c1caa9c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1caaa0:	e12fff1e 	bx	lr
 c1caaa4:	0c1022e4 	.word	0x0c1022e4

0c1caaa8 <adc_status>:

uint8 adc_status( void )
{
 c1caaa8:	e1a0c00d 	mov	ip, sp
 c1caaac:	e92dd800 	push	{fp, ip, lr, pc}
 c1caab0:	e24cb004 	sub	fp, ip, #4
    return state;
 c1caab4:	e59f3010 	ldr	r3, [pc, #16]	; c1caacc <adc_status+0x24>
 c1caab8:	e5d33000 	ldrb	r3, [r3]
}
 c1caabc:	e1a00003 	mov	r0, r3
 c1caac0:	e24bd00c 	sub	sp, fp, #12
 c1caac4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1caac8:	e12fff1e 	bx	lr
 c1caacc:	0c1022e4 	.word	0x0c1022e4

0c1caad0 <adc_getSample>:

uint16 adc_getSample( enum ADC_channel_t ch )
{
 c1caad0:	e1a0c00d 	mov	ip, sp
 c1caad4:	e92dd800 	push	{fp, ip, lr, pc}
 c1caad8:	e24cb004 	sub	fp, ip, #4
 c1caadc:	e24dd010 	sub	sp, sp, #16
 c1caae0:	e1a03000 	mov	r3, r0
 c1caae4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    uint32 sample;
    uint8 i;

    //Seleccionar el canal
    rADCCON &= ~(0b111 << 2);
 c1caae8:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1caaec:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1caaf0:	e5922000 	ldr	r2, [r2]
 c1caaf4:	e3c2201c 	bic	r2, r2, #28
 c1caaf8:	e5832000 	str	r2, [r3]
    rADCCON |= ch << 2;
 c1caafc:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1cab00:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1cab04:	e5921000 	ldr	r1, [r2]
 c1cab08:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
 c1cab0c:	e1a02102 	lsl	r2, r2, #2
 c1cab10:	e1812002 	orr	r2, r1, r2
 c1cab14:	e5832000 	str	r2, [r3]

    Delay(10);
 c1cab18:	e3a0000a 	mov	r0, #10
 c1cab1c:	eb00154d 	bl	c1d0058 <Delay>

    // Hacer la media de 5 samples para estabilizar
    for( i=0, sample=0; i<5; i++ )
 c1cab20:	e3a03000 	mov	r3, #0
 c1cab24:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c1cab28:	e3a03000 	mov	r3, #0
 c1cab2c:	e50b3010 	str	r3, [fp, #-16]
 c1cab30:	ea000020 	b	c1cabb8 <adc_getSample+0xe8>
    {
    	//ADCCON[1] = 0 deshabilita arranque por lectura
    	//ADCCON[0] = 1 arranca manualmente la conversiÃ³n

    	rADCCON &= ~2;
 c1cab34:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1cab38:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1cab3c:	e5922000 	ldr	r2, [r2]
 c1cab40:	e3c22002 	bic	r2, r2, #2
 c1cab44:	e5832000 	str	r2, [r3]
        rADCCON |= 1;
 c1cab48:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1cab4c:	e3a02775 	mov	r2, #30670848	; 0x1d40000
 c1cab50:	e5922000 	ldr	r2, [r2]
 c1cab54:	e3822001 	orr	r2, r2, #1
 c1cab58:	e5832000 	str	r2, [r3]

    	//Espera hasta que la conversion comience (mientras ADCCON[0] == 1)
        while( rADCCON & 1 );
 c1cab5c:	e1a00000 	nop			; (mov r0, r0)
 c1cab60:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1cab64:	e5933000 	ldr	r3, [r3]
 c1cab68:	e2033001 	and	r3, r3, #1
 c1cab6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cab70:	e3530000 	cmp	r3, #0
 c1cab74:	1afffff9 	bne	c1cab60 <adc_getSample+0x90>

    	//Espera hasta que la conversion finalice (mientras ADCCON[6] == 0)
        while( !(rADCCON & (1 << 6)) );
 c1cab78:	e1a00000 	nop			; (mov r0, r0)
 c1cab7c:	e3a03775 	mov	r3, #30670848	; 0x1d40000
 c1cab80:	e5933000 	ldr	r3, [r3]
 c1cab84:	e2033040 	and	r3, r3, #64	; 0x40
 c1cab88:	e3530000 	cmp	r3, #0
 c1cab8c:	0afffffa 	beq	c1cab7c <adc_getSample+0xac>

        sample += rADCDAT & 0x3ff;
 c1cab90:	e59f3054 	ldr	r3, [pc, #84]	; c1cabec <adc_getSample+0x11c>
 c1cab94:	e5933000 	ldr	r3, [r3]
 c1cab98:	e1a03b03 	lsl	r3, r3, #22
 c1cab9c:	e1a03b23 	lsr	r3, r3, #22
 c1caba0:	e51b2010 	ldr	r2, [fp, #-16]
 c1caba4:	e0823003 	add	r3, r2, r3
 c1caba8:	e50b3010 	str	r3, [fp, #-16]
    rADCCON |= ch << 2;

    Delay(10);

    // Hacer la media de 5 samples para estabilizar
    for( i=0, sample=0; i<5; i++ )
 c1cabac:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cabb0:	e2833001 	add	r3, r3, #1
 c1cabb4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
 c1cabb8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cabbc:	e3530004 	cmp	r3, #4
 c1cabc0:	9affffdb 	bls	c1cab34 <adc_getSample+0x64>
    	//Espera hasta que la conversion finalice (mientras ADCCON[6] == 0)
        while( !(rADCCON & (1 << 6)) );

        sample += rADCDAT & 0x3ff;
    }
    return sample / 5;
 c1cabc4:	e51b2010 	ldr	r2, [fp, #-16]
 c1cabc8:	e59f3020 	ldr	r3, [pc, #32]	; c1cabf0 <adc_getSample+0x120>
 c1cabcc:	e0831392 	umull	r1, r3, r2, r3
 c1cabd0:	e1a03123 	lsr	r3, r3, #2
 c1cabd4:	e1a03803 	lsl	r3, r3, #16
 c1cabd8:	e1a03823 	lsr	r3, r3, #16
}
 c1cabdc:	e1a00003 	mov	r0, r3
 c1cabe0:	e24bd00c 	sub	sp, fp, #12
 c1cabe4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cabe8:	e12fff1e 	bx	lr
 c1cabec:	01d40008 	.word	0x01d40008
 c1cabf0:	cccccccd 	.word	0xcccccccd

0c1cabf4 <adc_open>:

void adc_open( void (*isr)(void) )
{
 c1cabf4:	e1a0c00d 	mov	ip, sp
 c1cabf8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cabfc:	e24cb004 	sub	fp, ip, #4
 c1cac00:	e24dd008 	sub	sp, sp, #8
 c1cac04:	e50b0010 	str	r0, [fp, #-16]
	pISR_ADC = (unsigned) isr;
 c1cac08:	e59f3018 	ldr	r3, [pc, #24]	; c1cac28 <adc_open+0x34>
 c1cac0c:	e51b2010 	ldr	r2, [fp, #-16]
 c1cac10:	e5832000 	str	r2, [r3]
    ic_enable(INT_ADC);
 c1cac14:	e3a00000 	mov	r0, #0
 c1cac18:	eb00068b 	bl	c1cc64c <ic_enable>
}
 c1cac1c:	e24bd00c 	sub	sp, fp, #12
 c1cac20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cac24:	e12fff1e 	bx	lr
 c1cac28:	0c7fff20 	.word	0x0c7fff20

0c1cac2c <adc_close>:

void adc_close( void )
{
 c1cac2c:	e1a0c00d 	mov	ip, sp
 c1cac30:	e92dd800 	push	{fp, ip, lr, pc}
 c1cac34:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_ADC);
 c1cac38:	e3a00000 	mov	r0, #0
 c1cac3c:	eb00069c 	bl	c1cc6b4 <ic_disable>
    pISR_ADC = (unsigned) isr_ADC_dummy;
 c1cac40:	e59f3010 	ldr	r3, [pc, #16]	; c1cac58 <adc_close+0x2c>
 c1cac44:	e59f2010 	ldr	r2, [pc, #16]	; c1cac5c <adc_close+0x30>
 c1cac48:	e5832000 	str	r2, [r3]
}
 c1cac4c:	e24bd00c 	sub	sp, fp, #12
 c1cac50:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cac54:	e12fff1e 	bx	lr
 c1cac58:	0c7fff20 	.word	0x0c7fff20
 c1cac5c:	0c1ca9d4 	.word	0x0c1ca9d4

0c1cac60 <at24c04_clear>:

#define READ  (1)
#define WRITE (0)

void at24c04_clear( void )
{
 c1cac60:	e1a0c00d 	mov	ip, sp
 c1cac64:	e92dd800 	push	{fp, ip, lr, pc}
 c1cac68:	e24cb004 	sub	fp, ip, #4
 c1cac6c:	e24dd010 	sub	sp, sp, #16
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
 c1cac70:	e3a03000 	mov	r3, #0
 c1cac74:	e50b3010 	str	r3, [fp, #-16]
 c1cac78:	e3a03000 	mov	r3, #0
 c1cac7c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c1cac80:	e3a03000 	mov	r3, #0
 c1cac84:	e50b3010 	str	r3, [fp, #-16]
 c1cac88:	ea000025 	b	c1cad24 <at24c04_clear+0xc4>
		//Store page
		int addr = page_count * 16;
 c1cac8c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cac90:	e1a03203 	lsl	r3, r3, #4
 c1cac94:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		bit = (addr & 0x100) >> 8;
 c1cac98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cac9c:	e2033c01 	and	r3, r3, #256	; 0x100
 c1caca0:	e1a03443 	asr	r3, r3, #8
 c1caca4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

		//Se envÃ­a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
		//-el bit 8 de la direcciÃ³n del dato
		//-un 0 para indicar la operaciÃ³n de escritura
		iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c1caca8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cacac:	e1a03083 	lsl	r3, r3, #1
 c1cacb0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cacb4:	e1e03003 	mvn	r3, r3
 c1cacb8:	e203305f 	and	r3, r3, #95	; 0x5f
 c1cacbc:	e1e03003 	mvn	r3, r3
 c1cacc0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cacc4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cacc8:	e3a00003 	mov	r0, #3
 c1caccc:	e1a01003 	mov	r1, r3
 c1cacd0:	eb00036d 	bl	c1cba8c <iic_start>

		//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
		iic_putByte(addr & 0xff);
 c1cacd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cacd8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cacdc:	e1a00003 	mov	r0, r3
 c1cace0:	eb00038a 	bl	c1cbb10 <iic_putByte>

		//Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c1cace4:	e3a03000 	mov	r3, #0
 c1cace8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cacec:	ea000004 	b	c1cad04 <at24c04_clear+0xa4>
			iic_putByte(0);
 c1cacf0:	e3a00000 	mov	r0, #0
 c1cacf4:	eb000385 	bl	c1cbb10 <iic_putByte>

		//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
		iic_putByte(addr & 0xff);

		//Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c1cacf8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cacfc:	e2833001 	add	r3, r3, #1
 c1cad00:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cad04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cad08:	e353000f 	cmp	r3, #15
 c1cad0c:	dafffff7 	ble	c1cacf0 <at24c04_clear+0x90>
			iic_putByte(0);
		}

		//Se envÃ­a la stop condition
		iic_stop(5);
 c1cad10:	e3a00005 	mov	r0, #5
 c1cad14:	eb0003be 	bl	c1cbc14 <iic_stop>
{
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c1cad18:	e51b3010 	ldr	r3, [fp, #-16]
 c1cad1c:	e2833001 	add	r3, r3, #1
 c1cad20:	e50b3010 	str	r3, [fp, #-16]
 c1cad24:	e51b3010 	ldr	r3, [fp, #-16]
 c1cad28:	e353001f 	cmp	r3, #31
 c1cad2c:	daffffd6 	ble	c1cac8c <at24c04_clear+0x2c>
		}

		//Se envÃ­a la stop condition
		iic_stop(5);
	}
}
 c1cad30:	e24bd00c 	sub	sp, fp, #12
 c1cad34:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cad38:	e12fff1e 	bx	lr

0c1cad3c <at24c04_bytewrite>:

void at24c04_bytewrite( uint16 addr, uint8 data )
{
 c1cad3c:	e1a0c00d 	mov	ip, sp
 c1cad40:	e92dd800 	push	{fp, ip, lr, pc}
 c1cad44:	e24cb004 	sub	fp, ip, #4
 c1cad48:	e24dd010 	sub	sp, sp, #16
 c1cad4c:	e1a02000 	mov	r2, r0
 c1cad50:	e1a03001 	mov	r3, r1
 c1cad54:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c1cad58:	e54b3017 	strb	r3, [fp, #-23]	; 0xffffffe9
    uint8 page;

    page = (addr & 0x100) >> 8;
 c1cad5c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cad60:	e2033c01 	and	r3, r3, #256	; 0x100
 c1cad64:	e1a03443 	asr	r3, r3, #8
 c1cad68:	e54b300d 	strb	r3, [fp, #-13]

    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c1cad6c:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cad70:	e1a03083 	lsl	r3, r3, #1
 c1cad74:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cad78:	e1e03003 	mvn	r3, r3
 c1cad7c:	e203305f 	and	r3, r3, #95	; 0x5f
 c1cad80:	e1e03003 	mvn	r3, r3
 c1cad84:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cad88:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cad8c:	e3a00003 	mov	r0, #3
 c1cad90:	e1a01003 	mov	r1, r3
 c1cad94:	eb00033c 	bl	c1cba8c <iic_start>
    iic_putByte( addr & 0xFF );
 c1cad98:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cad9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cada0:	e1a00003 	mov	r0, r3
 c1cada4:	eb000359 	bl	c1cbb10 <iic_putByte>
    iic_putByte( data );
 c1cada8:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c1cadac:	e1a00003 	mov	r0, r3
 c1cadb0:	eb000356 	bl	c1cbb10 <iic_putByte>
    iic_stop( 5 );
 c1cadb4:	e3a00005 	mov	r0, #5
 c1cadb8:	eb000395 	bl	c1cbc14 <iic_stop>
}
 c1cadbc:	e24bd00c 	sub	sp, fp, #12
 c1cadc0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cadc4:	e12fff1e 	bx	lr

0c1cadc8 <at24c04_byteread>:

void at24c04_byteread( uint16 addr, uint8 *data )
{
 c1cadc8:	e1a0c00d 	mov	ip, sp
 c1cadcc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cadd0:	e24cb004 	sub	fp, ip, #4
 c1cadd4:	e24dd010 	sub	sp, sp, #16
 c1cadd8:	e1a03000 	mov	r3, r0
 c1caddc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c1cade0:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
	//Read random byte
	uint8 page;
    page = (addr & 0x100) >> 8;
 c1cade4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cade8:	e2033c01 	and	r3, r3, #256	; 0x100
 c1cadec:	e1a03443 	asr	r3, r3, #8
 c1cadf0:	e54b300d 	strb	r3, [fp, #-13]
	//Steps:
	//Se envÃ­a la start condition seguida del 1er. byte que incluye:
	//- los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
	//- el bit 8 de la direcciÃ³n del dato
	//- un 0 para indicar la operaciÃ³n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c1cadf4:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cadf8:	e1a03083 	lsl	r3, r3, #1
 c1cadfc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae00:	e1e03003 	mvn	r3, r3
 c1cae04:	e203305f 	and	r3, r3, #95	; 0x5f
 c1cae08:	e1e03003 	mvn	r3, r3
 c1cae0c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae10:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae14:	e3a00003 	mov	r0, #3
 c1cae18:	e1a01003 	mov	r1, r3
 c1cae1c:	eb00031a 	bl	c1cba8c <iic_start>

	//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
    iic_putByte( addr & 0xFF );
 c1cae20:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cae24:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae28:	e1a00003 	mov	r0, r3
 c1cae2c:	eb000337 	bl	c1cbb10 <iic_putByte>

	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	//- La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (page << 1) | READ);
 c1cae30:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cae34:	e1a03083 	lsl	r3, r3, #1
 c1cae38:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae3c:	e1e03003 	mvn	r3, r3
 c1cae40:	e203305e 	and	r3, r3, #94	; 0x5e
 c1cae44:	e1e03003 	mvn	r3, r3
 c1cae48:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae4c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cae50:	e3a00002 	mov	r0, #2
 c1cae54:	e1a01003 	mov	r1, r3
 c1cae58:	eb00030b 	bl	c1cba8c <iic_start>

	//Se recibe el byte que incluye el dato (sin enviar ACK).
    *data = iic_getByte(NO_RxACK);
 c1cae5c:	e3a00000 	mov	r0, #0
 c1cae60:	eb000343 	bl	c1cbb74 <iic_getByte>
 c1cae64:	e1a03000 	mov	r3, r0
 c1cae68:	e1a02003 	mov	r2, r3
 c1cae6c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cae70:	e5c32000 	strb	r2, [r3]

	//Se envÃ­a la stop condition
    iic_stop( 5 );
 c1cae74:	e3a00005 	mov	r0, #5
 c1cae78:	eb000365 	bl	c1cbc14 <iic_stop>
}
 c1cae7c:	e24bd00c 	sub	sp, fp, #12
 c1cae80:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cae84:	e12fff1e 	bx	lr

0c1cae88 <at24c04_load>:

void at24c04_load( uint8 *buffer )
{
 c1cae88:	e1a0c00d 	mov	ip, sp
 c1cae8c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cae90:	e24cb004 	sub	fp, ip, #4
 c1cae94:	e24dd010 	sub	sp, sp, #16
 c1cae98:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    //Load sequentially all 512 bytes from 0x0
	int i = 0;
 c1cae9c:	e3a03000 	mov	r3, #0
 c1caea0:	e50b3010 	str	r3, [fp, #-16]

	//Se envÃ­a la start condition seguida del 1er. byte que incluye:
	// - los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
	// - el bit 8 de la direcciÃ³n del dato
	// -un 0 para indicar la operaciÃ³n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (0 << 1) | WRITE );
 c1caea4:	e3a00003 	mov	r0, #3
 c1caea8:	e3a010a0 	mov	r1, #160	; 0xa0
 c1caeac:	eb0002f6 	bl	c1cba8c <iic_start>

	//Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
    iic_putByte(00);
 c1caeb0:	e3a00000 	mov	r0, #0
 c1caeb4:	eb000315 	bl	c1cbb10 <iic_putByte>

	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	// - La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );
 c1caeb8:	e3a00002 	mov	r0, #2
 c1caebc:	e3a010a1 	mov	r1, #161	; 0xa1
 c1caec0:	eb0002f1 	bl	c1cba8c <iic_start>

	//Se reciben nâ1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c1caec4:	e3a03000 	mov	r3, #0
 c1caec8:	e50b3010 	str	r3, [fp, #-16]
 c1caecc:	ea00000b 	b	c1caf00 <at24c04_load+0x78>
    	*buffer = iic_getByte(RxACK);
 c1caed0:	e3a00001 	mov	r0, #1
 c1caed4:	eb000326 	bl	c1cbb74 <iic_getByte>
 c1caed8:	e1a03000 	mov	r3, r0
 c1caedc:	e1a02003 	mov	r2, r3
 c1caee0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1caee4:	e5c32000 	strb	r2, [r3]
    	buffer++;
 c1caee8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1caeec:	e2833001 	add	r3, r3, #1
 c1caef0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	//Se envÃ­a la start condition seguida del 3er. byte que incluye:
	// - La misma informaciÃ³n que el 1er. byte pero con un 1 final para indicar la operaciÃ³n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );

	//Se reciben nâ1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c1caef4:	e51b3010 	ldr	r3, [fp, #-16]
 c1caef8:	e2833001 	add	r3, r3, #1
 c1caefc:	e50b3010 	str	r3, [fp, #-16]
 c1caf00:	e51b2010 	ldr	r2, [fp, #-16]
 c1caf04:	e59f3030 	ldr	r3, [pc, #48]	; c1caf3c <at24c04_load+0xb4>
 c1caf08:	e1520003 	cmp	r2, r3
 c1caf0c:	daffffef 	ble	c1caed0 <at24c04_load+0x48>
    	*buffer = iic_getByte(RxACK);
    	buffer++;
    }

	//Se recibe el Ãºltimo byte que incluye datos (sin enviar ACK).
	*buffer = iic_getByte(NO_RxACK);
 c1caf10:	e3a00000 	mov	r0, #0
 c1caf14:	eb000316 	bl	c1cbb74 <iic_getByte>
 c1caf18:	e1a03000 	mov	r3, r0
 c1caf1c:	e1a02003 	mov	r2, r3
 c1caf20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1caf24:	e5c32000 	strb	r2, [r3]

	//Se envÃ­a la stop condition.
    iic_stop( 5 );
 c1caf28:	e3a00005 	mov	r0, #5
 c1caf2c:	eb000338 	bl	c1cbc14 <iic_stop>
}
 c1caf30:	e24bd00c 	sub	sp, fp, #12
 c1caf34:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1caf38:	e12fff1e 	bx	lr
 c1caf3c:	000001fe 	.word	0x000001fe

0c1caf40 <at24c04_store>:

void at24c04_store( uint8 *buffer )
{
 c1caf40:	e1a0c00d 	mov	ip, sp
 c1caf44:	e92dd800 	push	{fp, ip, lr, pc}
 c1caf48:	e24cb004 	sub	fp, ip, #4
 c1caf4c:	e24dd018 	sub	sp, sp, #24
 c1caf50:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
 c1caf54:	e3a03000 	mov	r3, #0
 c1caf58:	e50b3010 	str	r3, [fp, #-16]
 c1caf5c:	e3a03000 	mov	r3, #0
 c1caf60:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c1caf64:	e3a03000 	mov	r3, #0
 c1caf68:	e50b3010 	str	r3, [fp, #-16]
 c1caf6c:	ea00002a 	b	c1cb01c <at24c04_store+0xdc>
		//Store page
		int addr = page_count * 16;
 c1caf70:	e51b3010 	ldr	r3, [fp, #-16]
 c1caf74:	e1a03203 	lsl	r3, r3, #4
 c1caf78:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	    bit = (addr & 0x100) >> 8;
 c1caf7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1caf80:	e2033c01 	and	r3, r3, #256	; 0x100
 c1caf84:	e1a03443 	asr	r3, r3, #8
 c1caf88:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

	    //Se envÃ­a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits mÃ¡s significativos de la direcciÃ³n del dispositivo IIC (101000)
		//-el bit 8 de la direcciÃ³n del dato
		//-un 0 para indicar la operaciÃ³n de escritura
	    iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c1caf8c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1caf90:	e1a03083 	lsl	r3, r3, #1
 c1caf94:	e20330ff 	and	r3, r3, #255	; 0xff
 c1caf98:	e1e03003 	mvn	r3, r3
 c1caf9c:	e203305f 	and	r3, r3, #95	; 0x5f
 c1cafa0:	e1e03003 	mvn	r3, r3
 c1cafa4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cafa8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cafac:	e3a00003 	mov	r0, #3
 c1cafb0:	e1a01003 	mov	r1, r3
 c1cafb4:	eb0002b4 	bl	c1cba8c <iic_start>

	    //Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
	    iic_putByte(addr & 0xff);
 c1cafb8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cafbc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cafc0:	e1a00003 	mov	r0, r3
 c1cafc4:	eb0002d1 	bl	c1cbb10 <iic_putByte>

	    //Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c1cafc8:	e3a03000 	mov	r3, #0
 c1cafcc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cafd0:	ea000009 	b	c1caffc <at24c04_store+0xbc>
	    	iic_putByte(*buffer);
 c1cafd4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cafd8:	e5d33000 	ldrb	r3, [r3]
 c1cafdc:	e1a00003 	mov	r0, r3
 c1cafe0:	eb0002ca 	bl	c1cbb10 <iic_putByte>
	    	++buffer;
 c1cafe4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cafe8:	e2833001 	add	r3, r3, #1
 c1cafec:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	    //Se envÃ­a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcciÃ³n del dato.
	    iic_putByte(addr & 0xff);

	    //Se envÃ­an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c1caff0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1caff4:	e2833001 	add	r3, r3, #1
 c1caff8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1caffc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cb000:	e353000f 	cmp	r3, #15
 c1cb004:	dafffff2 	ble	c1cafd4 <at24c04_store+0x94>
	    	iic_putByte(*buffer);
	    	++buffer;
	    }

	    //Se envÃ­a la stop condition
	    iic_stop(5);
 c1cb008:	e3a00005 	mov	r0, #5
 c1cb00c:	eb000300 	bl	c1cbc14 <iic_stop>
{
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c1cb010:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb014:	e2833001 	add	r3, r3, #1
 c1cb018:	e50b3010 	str	r3, [fp, #-16]
 c1cb01c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb020:	e353001f 	cmp	r3, #31
 c1cb024:	daffffd1 	ble	c1caf70 <at24c04_store+0x30>
	    }

	    //Se envÃ­a la stop condition
	    iic_stop(5);
	}
}
 c1cb028:	e24bd00c 	sub	sp, fp, #12
 c1cb02c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb030:	e12fff1e 	bx	lr

0c1cb034 <read_button>:
#include "button.h"
#include "leds.h"
#include "gpio.h"

unsigned int read_button(void)
{
 c1cb034:	e1a0c00d 	mov	ip, sp
 c1cb038:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb03c:	e24cb004 	sub	fp, ip, #4
 c1cb040:	e24dd008 	sub	sp, sp, #8
	unsigned int buttons = 0;
 c1cb044:	e3a03000 	mov	r3, #0
 c1cb048:	e50b3010 	str	r3, [fp, #-16]
	//pines 6 y 7 del puerto G (portG_read) debemos devolver un valor (buttons)
	//en el que el bit 0 (el menos significativo) representa el estado del botÃ³n
	//del pin 6 y el bit 1 representa el estado del botÃ³n del pin 7 (a 1 si
	//estÃ¡n pulsados a 0 si no lo estÃ¡n).

	portG_read(6, &val);
 c1cb04c:	e24b3011 	sub	r3, fp, #17
 c1cb050:	e3a00006 	mov	r0, #6
 c1cb054:	e1a01003 	mov	r1, r3
 c1cb058:	eb000216 	bl	c1cb8b8 <portG_read>
	if(!val)
 c1cb05c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb060:	e3530000 	cmp	r3, #0
 c1cb064:	1a000002 	bne	c1cb074 <read_button+0x40>
		buttons |= BUT1;
 c1cb068:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb06c:	e3833001 	orr	r3, r3, #1
 c1cb070:	e50b3010 	str	r3, [fp, #-16]

	portG_read(7, &val);
 c1cb074:	e24b3011 	sub	r3, fp, #17
 c1cb078:	e3a00007 	mov	r0, #7
 c1cb07c:	e1a01003 	mov	r1, r3
 c1cb080:	eb00020c 	bl	c1cb8b8 <portG_read>
	if(!val)
 c1cb084:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb088:	e3530000 	cmp	r3, #0
 c1cb08c:	1a000002 	bne	c1cb09c <read_button+0x68>
		buttons |= BUT2;
 c1cb090:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb094:	e3833002 	orr	r3, r3, #2
 c1cb098:	e50b3010 	str	r3, [fp, #-16]

	return buttons;
 c1cb09c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1cb0a0:	e1a00003 	mov	r0, r3
 c1cb0a4:	e24bd00c 	sub	sp, fp, #12
 c1cb0a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb0ac:	e12fff1e 	bx	lr

0c1cb0b0 <isr_BDMA0_dummy>:
#include "dma.h"
#include "intcontroller.h"

void isr_BDMA0_dummy( void )  __attribute__ ((interrupt ("IRQ")));

void isr_BDMA0_dummy( void ) {
 c1cb0b0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cb0b4:	e1a0c00d 	mov	ip, sp
 c1cb0b8:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cb0bc:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_BDMA0);
 c1cb0c0:	e3a00011 	mov	r0, #17
 c1cb0c4:	eb000593 	bl	c1cc718 <ic_cleanflag>
}
 c1cb0c8:	e24bd01c 	sub	sp, fp, #28
 c1cb0cc:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cb0d0:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cb0d4:	e25ef004 	subs	pc, lr, #4

0c1cb0d8 <bdma0_init>:

void bdma0_init( void )
{
 c1cb0d8:	e1a0c00d 	mov	ip, sp
 c1cb0dc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb0e0:	e24cb004 	sub	fp, ip, #4
    rBDCON0  = 0;
 c1cb0e4:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c1cb0e8:	e3a02000 	mov	r2, #0
 c1cb0ec:	e5832000 	str	r2, [r3]
    rBDISRC0 = 0;
 c1cb0f0:	e59f3034 	ldr	r3, [pc, #52]	; c1cb12c <bdma0_init+0x54>
 c1cb0f4:	e3a02000 	mov	r2, #0
 c1cb0f8:	e5832000 	str	r2, [r3]
    rBDIDES0 = 0;
 c1cb0fc:	e59f302c 	ldr	r3, [pc, #44]	; c1cb130 <bdma0_init+0x58>
 c1cb100:	e3a02000 	mov	r2, #0
 c1cb104:	e5832000 	str	r2, [r3]
    rBDICNT0 = 0;
 c1cb108:	e59f3024 	ldr	r3, [pc, #36]	; c1cb134 <bdma0_init+0x5c>
 c1cb10c:	e3a02000 	mov	r2, #0
 c1cb110:	e5832000 	str	r2, [r3]

    ic_conf_line(INT_BDMA0, IRQ);
 c1cb114:	e3a00011 	mov	r0, #17
 c1cb118:	e3a01000 	mov	r1, #0
 c1cb11c:	eb00051a 	bl	c1cc58c <ic_conf_line>
}
 c1cb120:	e24bd00c 	sub	sp, fp, #12
 c1cb124:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb128:	e12fff1e 	bx	lr
 c1cb12c:	01f80004 	.word	0x01f80004
 c1cb130:	01f80008 	.word	0x01f80008
 c1cb134:	01f8000c 	.word	0x01f8000c

0c1cb138 <bdma0_open>:

void bdma0_open( void (*isr)(void) )
{
 c1cb138:	e1a0c00d 	mov	ip, sp
 c1cb13c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb140:	e24cb004 	sub	fp, ip, #4
 c1cb144:	e24dd008 	sub	sp, sp, #8
 c1cb148:	e50b0010 	str	r0, [fp, #-16]
    pISR_BDMA0 = (unsigned) isr;
 c1cb14c:	e59f3020 	ldr	r3, [pc, #32]	; c1cb174 <bdma0_open+0x3c>
 c1cb150:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb154:	e5832000 	str	r2, [r3]
    ic_cleanflag(INT_BDMA0);
 c1cb158:	e3a00011 	mov	r0, #17
 c1cb15c:	eb00056d 	bl	c1cc718 <ic_cleanflag>
    ic_enable(INT_BDMA0);
 c1cb160:	e3a00011 	mov	r0, #17
 c1cb164:	eb000538 	bl	c1cc64c <ic_enable>
}
 c1cb168:	e24bd00c 	sub	sp, fp, #12
 c1cb16c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb170:	e12fff1e 	bx	lr
 c1cb174:	0c7fff64 	.word	0x0c7fff64

0c1cb178 <bdma0_close>:

void bdma0_close( void )
{
 c1cb178:	e1a0c00d 	mov	ip, sp
 c1cb17c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb180:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_BDMA0);
 c1cb184:	e3a00011 	mov	r0, #17
 c1cb188:	eb000549 	bl	c1cc6b4 <ic_disable>
    pISR_BDMA0 = (unsigned) isr_BDMA0_dummy;
 c1cb18c:	e59f3010 	ldr	r3, [pc, #16]	; c1cb1a4 <bdma0_close+0x2c>
 c1cb190:	e59f2010 	ldr	r2, [pc, #16]	; c1cb1a8 <bdma0_close+0x30>
 c1cb194:	e5832000 	str	r2, [r3]
}
 c1cb198:	e24bd00c 	sub	sp, fp, #12
 c1cb19c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb1a0:	e12fff1e 	bx	lr
 c1cb1a4:	0c7fff64 	.word	0x0c7fff64
 c1cb1a8:	0c1cb0b0 	.word	0x0c1cb0b0

0c1cb1ac <portB_conf>:
#include "gpio.h"

/* Port B interface implementation */

int portB_conf(int pin, enum port_mode mode)
{
 c1cb1ac:	e1a0c00d 	mov	ip, sp
 c1cb1b0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb1b4:	e24cb004 	sub	fp, ip, #4
 c1cb1b8:	e24dd010 	sub	sp, sp, #16
 c1cb1bc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cb1c0:	e1a03001 	mov	r3, r1
 c1cb1c4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int ret = 0;
 c1cb1c8:	e3a03000 	mov	r3, #0
 c1cb1cc:	e50b3010 	str	r3, [fp, #-16]
	if (pin < 0 || pin > 10)
 c1cb1d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb1d4:	e3530000 	cmp	r3, #0
 c1cb1d8:	ba000002 	blt	c1cb1e8 <portB_conf+0x3c>
 c1cb1dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb1e0:	e353000a 	cmp	r3, #10
 c1cb1e4:	da000001 	ble	c1cb1f0 <portB_conf+0x44>
		return -1; // indica error
 c1cb1e8:	e3e03000 	mvn	r3, #0
 c1cb1ec:	ea00001b 	b	c1cb260 <portB_conf+0xb4>

	if (mode == SIGOUT)
 c1cb1f0:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb1f4:	e3530002 	cmp	r3, #2
 c1cb1f8:	1a000008 	bne	c1cb220 <portB_conf+0x74>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 1 para que por
		// dicho pin en el puerto B salga la seÃ±al correspondiente del
		// controlador de memoria
		rPCONB |= 1 << pin;
 c1cb1fc:	e59f306c 	ldr	r3, [pc, #108]	; c1cb270 <portB_conf+0xc4>
 c1cb200:	e59f2068 	ldr	r2, [pc, #104]	; c1cb270 <portB_conf+0xc4>
 c1cb204:	e5921000 	ldr	r1, [r2]
 c1cb208:	e3a00001 	mov	r0, #1
 c1cb20c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cb210:	e1a02210 	lsl	r2, r0, r2
 c1cb214:	e1812002 	orr	r2, r1, r2
 c1cb218:	e5832000 	str	r2, [r3]
 c1cb21c:	ea00000e 	b	c1cb25c <portB_conf+0xb0>
	else if (mode == OUTPUT)
 c1cb220:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb224:	e3530001 	cmp	r3, #1
 c1cb228:	1a000009 	bne	c1cb254 <portB_conf+0xa8>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 0 para que dicho
		// pin sea un pin de salida
		rPCONB &= ~(1 << pin);
 c1cb22c:	e59f303c 	ldr	r3, [pc, #60]	; c1cb270 <portB_conf+0xc4>
 c1cb230:	e59f2038 	ldr	r2, [pc, #56]	; c1cb270 <portB_conf+0xc4>
 c1cb234:	e5921000 	ldr	r1, [r2]
 c1cb238:	e3a00001 	mov	r0, #1
 c1cb23c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cb240:	e1a02210 	lsl	r2, r0, r2
 c1cb244:	e1e02002 	mvn	r2, r2
 c1cb248:	e0012002 	and	r2, r1, r2
 c1cb24c:	e5832000 	str	r2, [r3]
 c1cb250:	ea000001 	b	c1cb25c <portB_conf+0xb0>
	else
		ret = -1; // indica error
 c1cb254:	e3e03000 	mvn	r3, #0
 c1cb258:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c1cb25c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1cb260:	e1a00003 	mov	r0, r3
 c1cb264:	e24bd00c 	sub	sp, fp, #12
 c1cb268:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb26c:	e12fff1e 	bx	lr
 c1cb270:	01d20008 	.word	0x01d20008

0c1cb274 <portB_write>:

int portB_write(int pin, enum digital val)
{
 c1cb274:	e1a0c00d 	mov	ip, sp
 c1cb278:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb27c:	e24cb004 	sub	fp, ip, #4
 c1cb280:	e24dd008 	sub	sp, sp, #8
 c1cb284:	e50b0010 	str	r0, [fp, #-16]
 c1cb288:	e1a03001 	mov	r3, r1
 c1cb28c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 10)
 c1cb290:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb294:	e3530000 	cmp	r3, #0
 c1cb298:	ba000002 	blt	c1cb2a8 <portB_write+0x34>
 c1cb29c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb2a0:	e353000a 	cmp	r3, #10
 c1cb2a4:	da000001 	ble	c1cb2b0 <portB_write+0x3c>
		return -1; // indica error
 c1cb2a8:	e3e03000 	mvn	r3, #0
 c1cb2ac:	ea00001a 	b	c1cb31c <portB_write+0xa8>

	if (val < 0 || val > 1)
 c1cb2b0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb2b4:	e3530001 	cmp	r3, #1
 c1cb2b8:	9a000001 	bls	c1cb2c4 <portB_write+0x50>
		return -1; // indica error
 c1cb2bc:	e3e03000 	mvn	r3, #0
 c1cb2c0:	ea000015 	b	c1cb31c <portB_write+0xa8>

	if (val)
 c1cb2c4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb2c8:	e3530000 	cmp	r3, #0
 c1cb2cc:	0a000008 	beq	c1cb2f4 <portB_write+0x80>
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 1
		rPDATB |= 1 << pin;
 c1cb2d0:	e59f3054 	ldr	r3, [pc, #84]	; c1cb32c <portB_write+0xb8>
 c1cb2d4:	e59f2050 	ldr	r2, [pc, #80]	; c1cb32c <portB_write+0xb8>
 c1cb2d8:	e5921000 	ldr	r1, [r2]
 c1cb2dc:	e3a00001 	mov	r0, #1
 c1cb2e0:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb2e4:	e1a02210 	lsl	r2, r0, r2
 c1cb2e8:	e1812002 	orr	r2, r1, r2
 c1cb2ec:	e5832000 	str	r2, [r3]
 c1cb2f0:	ea000008 	b	c1cb318 <portB_write+0xa4>
	else
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 0
		rPDATB &= ~(1 << pin);
 c1cb2f4:	e59f3030 	ldr	r3, [pc, #48]	; c1cb32c <portB_write+0xb8>
 c1cb2f8:	e59f202c 	ldr	r2, [pc, #44]	; c1cb32c <portB_write+0xb8>
 c1cb2fc:	e5921000 	ldr	r1, [r2]
 c1cb300:	e3a00001 	mov	r0, #1
 c1cb304:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb308:	e1a02210 	lsl	r2, r0, r2
 c1cb30c:	e1e02002 	mvn	r2, r2
 c1cb310:	e0012002 	and	r2, r1, r2
 c1cb314:	e5832000 	str	r2, [r3]

	return 0;
 c1cb318:	e3a03000 	mov	r3, #0
}
 c1cb31c:	e1a00003 	mov	r0, r3
 c1cb320:	e24bd00c 	sub	sp, fp, #12
 c1cb324:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb328:	e12fff1e 	bx	lr
 c1cb32c:	01d2000c 	.word	0x01d2000c

0c1cb330 <portG_conf>:

/* Port G interface implementation */

int portG_conf(int pin, enum port_mode mode)
{
 c1cb330:	e1a0c00d 	mov	ip, sp
 c1cb334:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb338:	e24cb004 	sub	fp, ip, #4
 c1cb33c:	e24dd010 	sub	sp, sp, #16
 c1cb340:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cb344:	e1a03001 	mov	r3, r1
 c1cb348:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos  = pin*2;
 c1cb34c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb350:	e1a03083 	lsl	r3, r3, #1
 c1cb354:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c1cb358:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb35c:	e3530000 	cmp	r3, #0
 c1cb360:	ba000002 	blt	c1cb370 <portG_conf+0x40>
 c1cb364:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb368:	e3530007 	cmp	r3, #7
 c1cb36c:	da000001 	ble	c1cb378 <portG_conf+0x48>
		return -1; // indica error
 c1cb370:	e3e03000 	mvn	r3, #0
 c1cb374:	ea000056 	b	c1cb4d4 <portG_conf+0x1a4>

	switch (mode) {
 c1cb378:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb37c:	e3530003 	cmp	r3, #3
 c1cb380:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c1cb384:	ea00004f 	b	c1cb4c8 <portG_conf+0x198>
 c1cb388:	0c1cb398 	.word	0x0c1cb398
 c1cb38c:	0c1cb3e8 	.word	0x0c1cb3e8
 c1cb390:	0c1cb434 	.word	0x0c1cb434
 c1cb394:	0c1cb480 	.word	0x0c1cb480
		case INPUT:
			// COMPLETAR: poner en rPCONG 00 a partir de la posiciÃ³n pos para
			// configurar como pin de entrada el pin indicado por el parÃ¡metro pin
			rPCONG &= ~(1 << pos);  	 // 0
 c1cb398:	e59f3144 	ldr	r3, [pc, #324]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb39c:	e59f2140 	ldr	r2, [pc, #320]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb3a0:	e5921000 	ldr	r1, [r2]
 c1cb3a4:	e3a00001 	mov	r0, #1
 c1cb3a8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb3ac:	e1a02210 	lsl	r2, r0, r2
 c1cb3b0:	e1e02002 	mvn	r2, r2
 c1cb3b4:	e0012002 	and	r2, r1, r2
 c1cb3b8:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c1cb3bc:	e59f3120 	ldr	r3, [pc, #288]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb3c0:	e59f211c 	ldr	r2, [pc, #284]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb3c4:	e5921000 	ldr	r1, [r2]
 c1cb3c8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb3cc:	e2822001 	add	r2, r2, #1
 c1cb3d0:	e3a00001 	mov	r0, #1
 c1cb3d4:	e1a02210 	lsl	r2, r0, r2
 c1cb3d8:	e1e02002 	mvn	r2, r2
 c1cb3dc:	e0012002 	and	r2, r1, r2
 c1cb3e0:	e5832000 	str	r2, [r3]
			break;
 c1cb3e4:	ea000039 	b	c1cb4d0 <portG_conf+0x1a0>
		case OUTPUT:
			// COMPLETAR: poner en rPCONG 01 a partir de la posiciÃ³n pos para
			// configurar como pin de salida el pin indicado por el parÃ¡metro pin
			rPCONG |= 1 << pos;			 // 1
 c1cb3e8:	e59f30f4 	ldr	r3, [pc, #244]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb3ec:	e59f20f0 	ldr	r2, [pc, #240]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb3f0:	e5921000 	ldr	r1, [r2]
 c1cb3f4:	e3a00001 	mov	r0, #1
 c1cb3f8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb3fc:	e1a02210 	lsl	r2, r0, r2
 c1cb400:	e1812002 	orr	r2, r1, r2
 c1cb404:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c1cb408:	e59f30d4 	ldr	r3, [pc, #212]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb40c:	e59f20d0 	ldr	r2, [pc, #208]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb410:	e5921000 	ldr	r1, [r2]
 c1cb414:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb418:	e2822001 	add	r2, r2, #1
 c1cb41c:	e3a00001 	mov	r0, #1
 c1cb420:	e1a02210 	lsl	r2, r0, r2
 c1cb424:	e1e02002 	mvn	r2, r2
 c1cb428:	e0012002 	and	r2, r1, r2
 c1cb42c:	e5832000 	str	r2, [r3]
			break;
 c1cb430:	ea000026 	b	c1cb4d0 <portG_conf+0x1a0>
		case SIGOUT:
			// COMPLETAR: poner en rPCONG 10 a partir de la posiciÃ³n pos para
			// que salga la seÃ±al interna correspondiente por el pin indicado
			// por el parÃ¡metro pin
			rPCONG &= ~(1 << pos); 		// 0
 c1cb434:	e59f30a8 	ldr	r3, [pc, #168]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb438:	e59f20a4 	ldr	r2, [pc, #164]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb43c:	e5921000 	ldr	r1, [r2]
 c1cb440:	e3a00001 	mov	r0, #1
 c1cb444:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb448:	e1a02210 	lsl	r2, r0, r2
 c1cb44c:	e1e02002 	mvn	r2, r2
 c1cb450:	e0012002 	and	r2, r1, r2
 c1cb454:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c1cb458:	e59f3084 	ldr	r3, [pc, #132]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb45c:	e59f2080 	ldr	r2, [pc, #128]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb460:	e5921000 	ldr	r1, [r2]
 c1cb464:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb468:	e2822001 	add	r2, r2, #1
 c1cb46c:	e3a00001 	mov	r0, #1
 c1cb470:	e1a02210 	lsl	r2, r0, r2
 c1cb474:	e1812002 	orr	r2, r1, r2
 c1cb478:	e5832000 	str	r2, [r3]
			break;
 c1cb47c:	ea000013 	b	c1cb4d0 <portG_conf+0x1a0>
		case EINT:
			// COMPLETAR: poner en rPCONG 11 a partir de la posiciÃ³n pos para
			// habilitar la generaciÃ³n de interrupciones externas por el pin
			// indicado por el parÃ¡metro pin
			rPCONG |= 1 << pos;			// 1
 c1cb480:	e59f305c 	ldr	r3, [pc, #92]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb484:	e59f2058 	ldr	r2, [pc, #88]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb488:	e5921000 	ldr	r1, [r2]
 c1cb48c:	e3a00001 	mov	r0, #1
 c1cb490:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb494:	e1a02210 	lsl	r2, r0, r2
 c1cb498:	e1812002 	orr	r2, r1, r2
 c1cb49c:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c1cb4a0:	e59f303c 	ldr	r3, [pc, #60]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb4a4:	e59f2038 	ldr	r2, [pc, #56]	; c1cb4e4 <portG_conf+0x1b4>
 c1cb4a8:	e5921000 	ldr	r1, [r2]
 c1cb4ac:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb4b0:	e2822001 	add	r2, r2, #1
 c1cb4b4:	e3a00001 	mov	r0, #1
 c1cb4b8:	e1a02210 	lsl	r2, r0, r2
 c1cb4bc:	e1812002 	orr	r2, r1, r2
 c1cb4c0:	e5832000 	str	r2, [r3]
			break;
 c1cb4c4:	ea000001 	b	c1cb4d0 <portG_conf+0x1a0>
		default:
			return -1;
 c1cb4c8:	e3e03000 	mvn	r3, #0
 c1cb4cc:	ea000000 	b	c1cb4d4 <portG_conf+0x1a4>
	}

	return 0;
 c1cb4d0:	e3a03000 	mov	r3, #0
}
 c1cb4d4:	e1a00003 	mov	r0, r3
 c1cb4d8:	e24bd00c 	sub	sp, fp, #12
 c1cb4dc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb4e0:	e12fff1e 	bx	lr
 c1cb4e4:	01d20040 	.word	0x01d20040

0c1cb4e8 <portG_eint_trig>:

int portG_eint_trig(int pin, enum trigger trig)
{
 c1cb4e8:	e1a0c00d 	mov	ip, sp
 c1cb4ec:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb4f0:	e24cb004 	sub	fp, ip, #4
 c1cb4f4:	e24dd010 	sub	sp, sp, #16
 c1cb4f8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cb4fc:	e1a03001 	mov	r3, r1
 c1cb500:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*4;
 c1cb504:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb508:	e1a03103 	lsl	r3, r3, #2
 c1cb50c:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c1cb510:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb514:	e3530000 	cmp	r3, #0
 c1cb518:	ba000002 	blt	c1cb528 <portG_eint_trig+0x40>
 c1cb51c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb520:	e3530007 	cmp	r3, #7
 c1cb524:	da000001 	ble	c1cb530 <portG_eint_trig+0x48>
		return -1;
 c1cb528:	e3e03000 	mvn	r3, #0
 c1cb52c:	ea00009c 	b	c1cb7a4 <portG_eint_trig+0x2bc>

switch (trig) {
 c1cb530:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb534:	e3530004 	cmp	r3, #4
 c1cb538:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c1cb53c:	ea000095 	b	c1cb798 <portG_eint_trig+0x2b0>
 c1cb540:	0c1cb554 	.word	0x0c1cb554
 c1cb544:	0c1cb5cc 	.word	0x0c1cb5cc
 c1cb548:	0c1cb640 	.word	0x0c1cb640
 c1cb54c:	0c1cb6b4 	.word	0x0c1cb6b4
 c1cb550:	0c1cb728 	.word	0x0c1cb728
		case LLOW:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 000, para configurar interrupciones externas por nivel bajo
			rEXTINT &= ~(1 << pos);	 		// 0
 c1cb554:	e59f3258 	ldr	r3, [pc, #600]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb558:	e59f2254 	ldr	r2, [pc, #596]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb55c:	e5921000 	ldr	r1, [r2]
 c1cb560:	e3a00001 	mov	r0, #1
 c1cb564:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb568:	e1a02210 	lsl	r2, r0, r2
 c1cb56c:	e1e02002 	mvn	r2, r2
 c1cb570:	e0012002 	and	r2, r1, r2
 c1cb574:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c1cb578:	e59f3234 	ldr	r3, [pc, #564]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb57c:	e59f2230 	ldr	r2, [pc, #560]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb580:	e5921000 	ldr	r1, [r2]
 c1cb584:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb588:	e2822001 	add	r2, r2, #1
 c1cb58c:	e3a00001 	mov	r0, #1
 c1cb590:	e1a02210 	lsl	r2, r0, r2
 c1cb594:	e1e02002 	mvn	r2, r2
 c1cb598:	e0012002 	and	r2, r1, r2
 c1cb59c:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c1cb5a0:	e59f320c 	ldr	r3, [pc, #524]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5a4:	e59f2208 	ldr	r2, [pc, #520]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5a8:	e5921000 	ldr	r1, [r2]
 c1cb5ac:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb5b0:	e2822002 	add	r2, r2, #2
 c1cb5b4:	e3a00001 	mov	r0, #1
 c1cb5b8:	e1a02210 	lsl	r2, r0, r2
 c1cb5bc:	e1e02002 	mvn	r2, r2
 c1cb5c0:	e0012002 	and	r2, r1, r2
 c1cb5c4:	e5832000 	str	r2, [r3]
			break;
 c1cb5c8:	ea000074 	b	c1cb7a0 <portG_eint_trig+0x2b8>
		case LHIGH:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 001, para configurar interrupciones externas por nivel alto
			rEXTINT |= 1 << pos;	 		// 1
 c1cb5cc:	e59f31e0 	ldr	r3, [pc, #480]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5d0:	e59f21dc 	ldr	r2, [pc, #476]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5d4:	e5921000 	ldr	r1, [r2]
 c1cb5d8:	e3a00001 	mov	r0, #1
 c1cb5dc:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb5e0:	e1a02210 	lsl	r2, r0, r2
 c1cb5e4:	e1812002 	orr	r2, r1, r2
 c1cb5e8:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c1cb5ec:	e59f31c0 	ldr	r3, [pc, #448]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5f0:	e59f21bc 	ldr	r2, [pc, #444]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb5f4:	e5921000 	ldr	r1, [r2]
 c1cb5f8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb5fc:	e2822001 	add	r2, r2, #1
 c1cb600:	e3a00001 	mov	r0, #1
 c1cb604:	e1a02210 	lsl	r2, r0, r2
 c1cb608:	e1e02002 	mvn	r2, r2
 c1cb60c:	e0012002 	and	r2, r1, r2
 c1cb610:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c1cb614:	e59f3198 	ldr	r3, [pc, #408]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb618:	e59f2194 	ldr	r2, [pc, #404]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb61c:	e5921000 	ldr	r1, [r2]
 c1cb620:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb624:	e2822002 	add	r2, r2, #2
 c1cb628:	e3a00001 	mov	r0, #1
 c1cb62c:	e1a02210 	lsl	r2, r0, r2
 c1cb630:	e1e02002 	mvn	r2, r2
 c1cb634:	e0012002 	and	r2, r1, r2
 c1cb638:	e5832000 	str	r2, [r3]
			break;
 c1cb63c:	ea000057 	b	c1cb7a0 <portG_eint_trig+0x2b8>
		case FALLING:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 010, para configurar interrupciones externas por flanco de
			// bajada
			rEXTINT &= ~(1 << pos);	 		// 0
 c1cb640:	e59f316c 	ldr	r3, [pc, #364]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb644:	e59f2168 	ldr	r2, [pc, #360]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb648:	e5921000 	ldr	r1, [r2]
 c1cb64c:	e3a00001 	mov	r0, #1
 c1cb650:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb654:	e1a02210 	lsl	r2, r0, r2
 c1cb658:	e1e02002 	mvn	r2, r2
 c1cb65c:	e0012002 	and	r2, r1, r2
 c1cb660:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c1cb664:	e59f3148 	ldr	r3, [pc, #328]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb668:	e59f2144 	ldr	r2, [pc, #324]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb66c:	e5921000 	ldr	r1, [r2]
 c1cb670:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb674:	e2822001 	add	r2, r2, #1
 c1cb678:	e3a00001 	mov	r0, #1
 c1cb67c:	e1a02210 	lsl	r2, r0, r2
 c1cb680:	e1812002 	orr	r2, r1, r2
 c1cb684:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c1cb688:	e59f3124 	ldr	r3, [pc, #292]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb68c:	e59f2120 	ldr	r2, [pc, #288]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb690:	e5921000 	ldr	r1, [r2]
 c1cb694:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb698:	e2822002 	add	r2, r2, #2
 c1cb69c:	e3a00001 	mov	r0, #1
 c1cb6a0:	e1a02210 	lsl	r2, r0, r2
 c1cb6a4:	e1e02002 	mvn	r2, r2
 c1cb6a8:	e0012002 	and	r2, r1, r2
 c1cb6ac:	e5832000 	str	r2, [r3]
			break;
 c1cb6b0:	ea00003a 	b	c1cb7a0 <portG_eint_trig+0x2b8>
		case RISING:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 100, para configurar interrupciones externas por flanco de
			// subida
			rEXTINT &= ~(1 << pos);	 		// 0
 c1cb6b4:	e59f30f8 	ldr	r3, [pc, #248]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb6b8:	e59f20f4 	ldr	r2, [pc, #244]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb6bc:	e5921000 	ldr	r1, [r2]
 c1cb6c0:	e3a00001 	mov	r0, #1
 c1cb6c4:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb6c8:	e1a02210 	lsl	r2, r0, r2
 c1cb6cc:	e1e02002 	mvn	r2, r2
 c1cb6d0:	e0012002 	and	r2, r1, r2
 c1cb6d4:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c1cb6d8:	e59f30d4 	ldr	r3, [pc, #212]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb6dc:	e59f20d0 	ldr	r2, [pc, #208]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb6e0:	e5921000 	ldr	r1, [r2]
 c1cb6e4:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb6e8:	e2822001 	add	r2, r2, #1
 c1cb6ec:	e3a00001 	mov	r0, #1
 c1cb6f0:	e1a02210 	lsl	r2, r0, r2
 c1cb6f4:	e1e02002 	mvn	r2, r2
 c1cb6f8:	e0012002 	and	r2, r1, r2
 c1cb6fc:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c1cb700:	e59f30ac 	ldr	r3, [pc, #172]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb704:	e59f20a8 	ldr	r2, [pc, #168]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb708:	e5921000 	ldr	r1, [r2]
 c1cb70c:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb710:	e2822002 	add	r2, r2, #2
 c1cb714:	e3a00001 	mov	r0, #1
 c1cb718:	e1a02210 	lsl	r2, r0, r2
 c1cb71c:	e1812002 	orr	r2, r1, r2
 c1cb720:	e5832000 	str	r2, [r3]
			break;
 c1cb724:	ea00001d 	b	c1cb7a0 <portG_eint_trig+0x2b8>
		case EDGE:
			// COMPLETAR: poner en rEXTINT a partir de la posiciÃ³n pos tres bits
			// a 110, para configurar interrupciones externas por cualquier
			// flanco
			rEXTINT &= ~(1 << pos);	 		// 0
 c1cb728:	e59f3084 	ldr	r3, [pc, #132]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb72c:	e59f2080 	ldr	r2, [pc, #128]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb730:	e5921000 	ldr	r1, [r2]
 c1cb734:	e3a00001 	mov	r0, #1
 c1cb738:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb73c:	e1a02210 	lsl	r2, r0, r2
 c1cb740:	e1e02002 	mvn	r2, r2
 c1cb744:	e0012002 	and	r2, r1, r2
 c1cb748:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c1cb74c:	e59f3060 	ldr	r3, [pc, #96]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb750:	e59f205c 	ldr	r2, [pc, #92]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb754:	e5921000 	ldr	r1, [r2]
 c1cb758:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb75c:	e2822001 	add	r2, r2, #1
 c1cb760:	e3a00001 	mov	r0, #1
 c1cb764:	e1a02210 	lsl	r2, r0, r2
 c1cb768:	e1812002 	orr	r2, r1, r2
 c1cb76c:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c1cb770:	e59f303c 	ldr	r3, [pc, #60]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb774:	e59f2038 	ldr	r2, [pc, #56]	; c1cb7b4 <portG_eint_trig+0x2cc>
 c1cb778:	e5921000 	ldr	r1, [r2]
 c1cb77c:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb780:	e2822002 	add	r2, r2, #2
 c1cb784:	e3a00001 	mov	r0, #1
 c1cb788:	e1a02210 	lsl	r2, r0, r2
 c1cb78c:	e1812002 	orr	r2, r1, r2
 c1cb790:	e5832000 	str	r2, [r3]
			break;
 c1cb794:	ea000001 	b	c1cb7a0 <portG_eint_trig+0x2b8>
		default:
			return -1;
 c1cb798:	e3e03000 	mvn	r3, #0
 c1cb79c:	ea000000 	b	c1cb7a4 <portG_eint_trig+0x2bc>
	}
	return 0;
 c1cb7a0:	e3a03000 	mov	r3, #0
}
 c1cb7a4:	e1a00003 	mov	r0, r3
 c1cb7a8:	e24bd00c 	sub	sp, fp, #12
 c1cb7ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb7b0:	e12fff1e 	bx	lr
 c1cb7b4:	01d20050 	.word	0x01d20050

0c1cb7b8 <portG_write>:

int portG_write(int pin, enum digital val)
{
 c1cb7b8:	e1a0c00d 	mov	ip, sp
 c1cb7bc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb7c0:	e24cb004 	sub	fp, ip, #4
 c1cb7c4:	e24dd010 	sub	sp, sp, #16
 c1cb7c8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cb7cc:	e1a03001 	mov	r3, r1
 c1cb7d0:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*2;
 c1cb7d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb7d8:	e1a03083 	lsl	r3, r3, #1
 c1cb7dc:	e50b3010 	str	r3, [fp, #-16]

		if (pin < 0 || pin > 7)
 c1cb7e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb7e4:	e3530000 	cmp	r3, #0
 c1cb7e8:	ba000002 	blt	c1cb7f8 <portG_write+0x40>
 c1cb7ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb7f0:	e3530007 	cmp	r3, #7
 c1cb7f4:	da000001 	ble	c1cb800 <portG_write+0x48>
			return -1; // indica error
 c1cb7f8:	e3e03000 	mvn	r3, #0
 c1cb7fc:	ea000027 	b	c1cb8a0 <portG_write+0xe8>

		if (val < 0 || val > 1)
 c1cb800:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb804:	e3530001 	cmp	r3, #1
 c1cb808:	9a000001 	bls	c1cb814 <portG_write+0x5c>
			return -1; // indica error
 c1cb80c:	e3e03000 	mvn	r3, #0
 c1cb810:	ea000022 	b	c1cb8a0 <portG_write+0xe8>

		if ((rPCONG & (0x3 << pos)) != (0x1 << pos))
 c1cb814:	e59f3094 	ldr	r3, [pc, #148]	; c1cb8b0 <portG_write+0xf8>
 c1cb818:	e5932000 	ldr	r2, [r3]
 c1cb81c:	e3a01003 	mov	r1, #3
 c1cb820:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb824:	e1a03311 	lsl	r3, r1, r3
 c1cb828:	e0022003 	and	r2, r2, r3
 c1cb82c:	e3a01001 	mov	r1, #1
 c1cb830:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb834:	e1a03311 	lsl	r3, r1, r3
 c1cb838:	e1520003 	cmp	r2, r3
 c1cb83c:	0a000001 	beq	c1cb848 <portG_write+0x90>
			return -1; // indica error
 c1cb840:	e3e03000 	mvn	r3, #0
 c1cb844:	ea000015 	b	c1cb8a0 <portG_write+0xe8>

		if (val)
 c1cb848:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cb84c:	e3530000 	cmp	r3, #0
 c1cb850:	0a000008 	beq	c1cb878 <portG_write+0xc0>
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 1
			rPDATG |= 1 << pin;
 c1cb854:	e59f3058 	ldr	r3, [pc, #88]	; c1cb8b4 <portG_write+0xfc>
 c1cb858:	e59f2054 	ldr	r2, [pc, #84]	; c1cb8b4 <portG_write+0xfc>
 c1cb85c:	e5921000 	ldr	r1, [r2]
 c1cb860:	e3a00001 	mov	r0, #1
 c1cb864:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cb868:	e1a02210 	lsl	r2, r0, r2
 c1cb86c:	e1812002 	orr	r2, r1, r2
 c1cb870:	e5832000 	str	r2, [r3]
 c1cb874:	ea000008 	b	c1cb89c <portG_write+0xe4>
		else
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 0
			rPDATG &= ~(1 << pin);
 c1cb878:	e59f3034 	ldr	r3, [pc, #52]	; c1cb8b4 <portG_write+0xfc>
 c1cb87c:	e59f2030 	ldr	r2, [pc, #48]	; c1cb8b4 <portG_write+0xfc>
 c1cb880:	e5921000 	ldr	r1, [r2]
 c1cb884:	e3a00001 	mov	r0, #1
 c1cb888:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cb88c:	e1a02210 	lsl	r2, r0, r2
 c1cb890:	e1e02002 	mvn	r2, r2
 c1cb894:	e0012002 	and	r2, r1, r2
 c1cb898:	e5832000 	str	r2, [r3]

		return 0;
 c1cb89c:	e3a03000 	mov	r3, #0
}
 c1cb8a0:	e1a00003 	mov	r0, r3
 c1cb8a4:	e24bd00c 	sub	sp, fp, #12
 c1cb8a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb8ac:	e12fff1e 	bx	lr
 c1cb8b0:	01d20040 	.word	0x01d20040
 c1cb8b4:	01d20044 	.word	0x01d20044

0c1cb8b8 <portG_read>:

int portG_read(int pin, enum digital* val)
{
 c1cb8b8:	e1a0c00d 	mov	ip, sp
 c1cb8bc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb8c0:	e24cb004 	sub	fp, ip, #4
 c1cb8c4:	e24dd010 	sub	sp, sp, #16
 c1cb8c8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cb8cc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
	int pos = pin*2;
 c1cb8d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb8d4:	e1a03083 	lsl	r3, r3, #1
 c1cb8d8:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c1cb8dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb8e0:	e3530000 	cmp	r3, #0
 c1cb8e4:	ba000002 	blt	c1cb8f4 <portG_read+0x3c>
 c1cb8e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb8ec:	e3530007 	cmp	r3, #7
 c1cb8f0:	da000001 	ble	c1cb8fc <portG_read+0x44>
		return -1; // indica error
 c1cb8f4:	e3e03000 	mvn	r3, #0
 c1cb8f8:	ea000019 	b	c1cb964 <portG_read+0xac>

	if (rPCONG & (0x3 << pos))
 c1cb8fc:	e59f3070 	ldr	r3, [pc, #112]	; c1cb974 <portG_read+0xbc>
 c1cb900:	e5932000 	ldr	r2, [r3]
 c1cb904:	e3a01003 	mov	r1, #3
 c1cb908:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb90c:	e1a03311 	lsl	r3, r1, r3
 c1cb910:	e0023003 	and	r3, r2, r3
 c1cb914:	e3530000 	cmp	r3, #0
 c1cb918:	0a000001 	beq	c1cb924 <portG_read+0x6c>
		return -1; // indica error
 c1cb91c:	e3e03000 	mvn	r3, #0
 c1cb920:	ea00000f 	b	c1cb964 <portG_read+0xac>

	/*COMPLETAR: true si estÃ¡ a 1 en rPDATG el pin indicado por el parÃ¡metro pin*/
	if (rPDATG & (1 << pin))
 c1cb924:	e59f304c 	ldr	r3, [pc, #76]	; c1cb978 <portG_read+0xc0>
 c1cb928:	e5932000 	ldr	r2, [r3]
 c1cb92c:	e3a01001 	mov	r1, #1
 c1cb930:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cb934:	e1a03311 	lsl	r3, r1, r3
 c1cb938:	e0023003 	and	r3, r2, r3
 c1cb93c:	e3530000 	cmp	r3, #0
 c1cb940:	0a000003 	beq	c1cb954 <portG_read+0x9c>
		*val = HIGH;
 c1cb944:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cb948:	e3a02001 	mov	r2, #1
 c1cb94c:	e5c32000 	strb	r2, [r3]
 c1cb950:	ea000002 	b	c1cb960 <portG_read+0xa8>
	else
		*val = LOW;
 c1cb954:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cb958:	e3a02000 	mov	r2, #0
 c1cb95c:	e5c32000 	strb	r2, [r3]

	return 0;
 c1cb960:	e3a03000 	mov	r3, #0
}
 c1cb964:	e1a00003 	mov	r0, r3
 c1cb968:	e24bd00c 	sub	sp, fp, #12
 c1cb96c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cb970:	e12fff1e 	bx	lr
 c1cb974:	01d20040 	.word	0x01d20040
 c1cb978:	01d20044 	.word	0x01d20044

0c1cb97c <portG_conf_pup>:

int portG_conf_pup(int pin, enum enable st)
{
 c1cb97c:	e1a0c00d 	mov	ip, sp
 c1cb980:	e92dd800 	push	{fp, ip, lr, pc}
 c1cb984:	e24cb004 	sub	fp, ip, #4
 c1cb988:	e24dd008 	sub	sp, sp, #8
 c1cb98c:	e50b0010 	str	r0, [fp, #-16]
 c1cb990:	e1a03001 	mov	r3, r1
 c1cb994:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 7)
 c1cb998:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb99c:	e3530000 	cmp	r3, #0
 c1cb9a0:	ba000002 	blt	c1cb9b0 <portG_conf_pup+0x34>
 c1cb9a4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cb9a8:	e3530007 	cmp	r3, #7
 c1cb9ac:	da000001 	ble	c1cb9b8 <portG_conf_pup+0x3c>
		return -1; // indica error
 c1cb9b0:	e3e03000 	mvn	r3, #0
 c1cb9b4:	ea00001d 	b	c1cba30 <portG_conf_pup+0xb4>

	if (st != ENABLE && st != DISABLE)
 c1cb9b8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb9bc:	e3530001 	cmp	r3, #1
 c1cb9c0:	0a000004 	beq	c1cb9d8 <portG_conf_pup+0x5c>
 c1cb9c4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb9c8:	e3530000 	cmp	r3, #0
 c1cb9cc:	0a000001 	beq	c1cb9d8 <portG_conf_pup+0x5c>
		return -1; // indica error
 c1cb9d0:	e3e03000 	mvn	r3, #0
 c1cb9d4:	ea000015 	b	c1cba30 <portG_conf_pup+0xb4>

	if (st == ENABLE)
 c1cb9d8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cb9dc:	e3530001 	cmp	r3, #1
 c1cb9e0:	1a000009 	bne	c1cba0c <portG_conf_pup+0x90>
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para activar la resistencia de pull-up
		rPUPG &= ~(1 << pin);
 c1cb9e4:	e59f3054 	ldr	r3, [pc, #84]	; c1cba40 <portG_conf_pup+0xc4>
 c1cb9e8:	e59f2050 	ldr	r2, [pc, #80]	; c1cba40 <portG_conf_pup+0xc4>
 c1cb9ec:	e5921000 	ldr	r1, [r2]
 c1cb9f0:	e3a00001 	mov	r0, #1
 c1cb9f4:	e51b2010 	ldr	r2, [fp, #-16]
 c1cb9f8:	e1a02210 	lsl	r2, r0, r2
 c1cb9fc:	e1e02002 	mvn	r2, r2
 c1cba00:	e0012002 	and	r2, r1, r2
 c1cba04:	e5832000 	str	r2, [r3]
 c1cba08:	ea000007 	b	c1cba2c <portG_conf_pup+0xb0>
	else
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para desactivar la resistencia de pull-up
		rPUPG |= 1 << pin;
 c1cba0c:	e59f302c 	ldr	r3, [pc, #44]	; c1cba40 <portG_conf_pup+0xc4>
 c1cba10:	e59f2028 	ldr	r2, [pc, #40]	; c1cba40 <portG_conf_pup+0xc4>
 c1cba14:	e5921000 	ldr	r1, [r2]
 c1cba18:	e3a00001 	mov	r0, #1
 c1cba1c:	e51b2010 	ldr	r2, [fp, #-16]
 c1cba20:	e1a02210 	lsl	r2, r0, r2
 c1cba24:	e1812002 	orr	r2, r1, r2
 c1cba28:	e5832000 	str	r2, [r3]

	return 0;
 c1cba2c:	e3a03000 	mov	r3, #0
}
 c1cba30:	e1a00003 	mov	r0, r3
 c1cba34:	e24bd00c 	sub	sp, fp, #12
 c1cba38:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cba3c:	e12fff1e 	bx	lr
 c1cba40:	01d20048 	.word	0x01d20048

0c1cba44 <iic_init>:
#include "44b.h"
#include "iic.h"
#include "utils.h"

void iic_init( void )
{
 c1cba44:	e1a0c00d 	mov	ip, sp
 c1cba48:	e92dd800 	push	{fp, ip, lr, pc}
 c1cba4c:	e24cb004 	sub	fp, ip, #4
	//Slave Address: Undefined, always going to be master
	rIICADD = 0;
 c1cba50:	e59f3028 	ldr	r3, [pc, #40]	; c1cba80 <iic_init+0x3c>
 c1cba54:	e3a02000 	mov	r2, #0
 c1cba58:	e5832000 	str	r2, [r3]
	//*250kHz
	//IICCON[7]	  = 1   Generate ACK
	//IICCON[6]   = 0   IICCLK = MCLK / 16
	//IICCON[5]   = 1	Enable RX/TX Interrupts
	//IICCON[3:0] = 15  TxCLK = IICCLK / (15+1) = 64 MHz / 256
	rIICCON = 0xAF;
 c1cba5c:	e59f3020 	ldr	r3, [pc, #32]	; c1cba84 <iic_init+0x40>
 c1cba60:	e3a020af 	mov	r2, #175	; 0xaf
 c1cba64:	e5832000 	str	r2, [r3]

	//*Transfer mode: set per transfer
	//ICCSTAT[4] = 1 read/write enable
	rIICSTAT = 0x10;
 c1cba68:	e59f3018 	ldr	r3, [pc, #24]	; c1cba88 <iic_init+0x44>
 c1cba6c:	e3a02010 	mov	r2, #16
 c1cba70:	e5832000 	str	r2, [r3]
}
 c1cba74:	e24bd00c 	sub	sp, fp, #12
 c1cba78:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cba7c:	e12fff1e 	bx	lr
 c1cba80:	01d60008 	.word	0x01d60008
 c1cba84:	01d60000 	.word	0x01d60000
 c1cba88:	01d60004 	.word	0x01d60004

0c1cba8c <iic_start>:

void iic_start(enum IIC_Mode_t mode, uint8 addr)
{
 c1cba8c:	e1a0c00d 	mov	ip, sp
 c1cba90:	e92dd800 	push	{fp, ip, lr, pc}
 c1cba94:	e24cb004 	sub	fp, ip, #4
 c1cba98:	e24dd008 	sub	sp, sp, #8
 c1cba9c:	e1a02000 	mov	r2, r0
 c1cbaa0:	e1a03001 	mov	r3, r1
 c1cbaa4:	e54b200d 	strb	r2, [fp, #-13]
 c1cbaa8:	e54b300e 	strb	r3, [fp, #-14]
	//Address
    rIICDS = addr;
 c1cbaac:	e59f3050 	ldr	r3, [pc, #80]	; c1cbb04 <iic_start+0x78>
 c1cbab0:	e55b200e 	ldrb	r2, [fp, #-14]
 c1cbab4:	e5832000 	str	r2, [r3]

    //Set mode, send START signal, Serial Output enable
    rIICSTAT = mode << 6 | 0b11 << 4;
 c1cbab8:	e59f3048 	ldr	r3, [pc, #72]	; c1cbb08 <iic_start+0x7c>
 c1cbabc:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cbac0:	e1a02302 	lsl	r2, r2, #6
 c1cbac4:	e3822030 	orr	r2, r2, #48	; 0x30
 c1cbac8:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c1cbacc:	e59f3038 	ldr	r3, [pc, #56]	; c1cbb0c <iic_start+0x80>
 c1cbad0:	e59f2034 	ldr	r2, [pc, #52]	; c1cbb0c <iic_start+0x80>
 c1cbad4:	e5922000 	ldr	r2, [r2]
 c1cbad8:	e3c22010 	bic	r2, r2, #16
 c1cbadc:	e5832000 	str	r2, [r3]

    while(!( rIICCON & (1 << 4)));
 c1cbae0:	e1a00000 	nop			; (mov r0, r0)
 c1cbae4:	e59f3020 	ldr	r3, [pc, #32]	; c1cbb0c <iic_start+0x80>
 c1cbae8:	e5933000 	ldr	r3, [r3]
 c1cbaec:	e2033010 	and	r3, r3, #16
 c1cbaf0:	e3530000 	cmp	r3, #0
 c1cbaf4:	0afffffa 	beq	c1cbae4 <iic_start+0x58>
}
 c1cbaf8:	e24bd00c 	sub	sp, fp, #12
 c1cbafc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbb00:	e12fff1e 	bx	lr
 c1cbb04:	01d6000c 	.word	0x01d6000c
 c1cbb08:	01d60004 	.word	0x01d60004
 c1cbb0c:	01d60000 	.word	0x01d60000

0c1cbb10 <iic_putByte>:


void iic_putByte( uint8 byte )
{
 c1cbb10:	e1a0c00d 	mov	ip, sp
 c1cbb14:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbb18:	e24cb004 	sub	fp, ip, #4
 c1cbb1c:	e24dd008 	sub	sp, sp, #8
 c1cbb20:	e1a03000 	mov	r3, r0
 c1cbb24:	e54b300d 	strb	r3, [fp, #-13]
    rIICDS   = byte;
 c1cbb28:	e59f303c 	ldr	r3, [pc, #60]	; c1cbb6c <iic_putByte+0x5c>
 c1cbb2c:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cbb30:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c1cbb34:	e59f3034 	ldr	r3, [pc, #52]	; c1cbb70 <iic_putByte+0x60>
 c1cbb38:	e59f2030 	ldr	r2, [pc, #48]	; c1cbb70 <iic_putByte+0x60>
 c1cbb3c:	e5922000 	ldr	r2, [r2]
 c1cbb40:	e3c22010 	bic	r2, r2, #16
 c1cbb44:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c1cbb48:	e1a00000 	nop			; (mov r0, r0)
 c1cbb4c:	e59f301c 	ldr	r3, [pc, #28]	; c1cbb70 <iic_putByte+0x60>
 c1cbb50:	e5933000 	ldr	r3, [r3]
 c1cbb54:	e2033010 	and	r3, r3, #16
 c1cbb58:	e3530000 	cmp	r3, #0
 c1cbb5c:	0afffffa 	beq	c1cbb4c <iic_putByte+0x3c>
}
 c1cbb60:	e24bd00c 	sub	sp, fp, #12
 c1cbb64:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbb68:	e12fff1e 	bx	lr
 c1cbb6c:	01d6000c 	.word	0x01d6000c
 c1cbb70:	01d60000 	.word	0x01d60000

0c1cbb74 <iic_getByte>:

uint8 iic_getByte(enum IIC_ACK_t ack)
{
 c1cbb74:	e1a0c00d 	mov	ip, sp
 c1cbb78:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbb7c:	e24cb004 	sub	fp, ip, #4
 c1cbb80:	e24dd008 	sub	sp, sp, #8
 c1cbb84:	e1a03000 	mov	r3, r0
 c1cbb88:	e54b300d 	strb	r3, [fp, #-13]
	// Setup ACK or not
	if(ack == RxACK) {
 c1cbb8c:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cbb90:	e3530001 	cmp	r3, #1
 c1cbb94:	1a000005 	bne	c1cbbb0 <iic_getByte+0x3c>
		//IICCON[7] = 1   Generate ACK
	    rIICCON |= 1 << 7;
 c1cbb98:	e59f306c 	ldr	r3, [pc, #108]	; c1cbc0c <iic_getByte+0x98>
 c1cbb9c:	e59f2068 	ldr	r2, [pc, #104]	; c1cbc0c <iic_getByte+0x98>
 c1cbba0:	e5922000 	ldr	r2, [r2]
 c1cbba4:	e3822080 	orr	r2, r2, #128	; 0x80
 c1cbba8:	e5832000 	str	r2, [r3]
 c1cbbac:	ea000004 	b	c1cbbc4 <iic_getByte+0x50>
	} else {
		//IICCON[7] = 0   Don't generate ACK
	    rIICCON &= ~(1 << 7);
 c1cbbb0:	e59f3054 	ldr	r3, [pc, #84]	; c1cbc0c <iic_getByte+0x98>
 c1cbbb4:	e59f2050 	ldr	r2, [pc, #80]	; c1cbc0c <iic_getByte+0x98>
 c1cbbb8:	e5922000 	ldr	r2, [r2]
 c1cbbbc:	e3c22080 	bic	r2, r2, #128	; 0x80
 c1cbbc0:	e5832000 	str	r2, [r3]
	}

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c1cbbc4:	e59f3040 	ldr	r3, [pc, #64]	; c1cbc0c <iic_getByte+0x98>
 c1cbbc8:	e59f203c 	ldr	r2, [pc, #60]	; c1cbc0c <iic_getByte+0x98>
 c1cbbcc:	e5922000 	ldr	r2, [r2]
 c1cbbd0:	e3c22010 	bic	r2, r2, #16
 c1cbbd4:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c1cbbd8:	e1a00000 	nop			; (mov r0, r0)
 c1cbbdc:	e59f3028 	ldr	r3, [pc, #40]	; c1cbc0c <iic_getByte+0x98>
 c1cbbe0:	e5933000 	ldr	r3, [r3]
 c1cbbe4:	e2033010 	and	r3, r3, #16
 c1cbbe8:	e3530000 	cmp	r3, #0
 c1cbbec:	0afffffa 	beq	c1cbbdc <iic_getByte+0x68>

    return rIICDS;
 c1cbbf0:	e59f3018 	ldr	r3, [pc, #24]	; c1cbc10 <iic_getByte+0x9c>
 c1cbbf4:	e5933000 	ldr	r3, [r3]
 c1cbbf8:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cbbfc:	e1a00003 	mov	r0, r3
 c1cbc00:	e24bd00c 	sub	sp, fp, #12
 c1cbc04:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbc08:	e12fff1e 	bx	lr
 c1cbc0c:	01d60000 	.word	0x01d60000
 c1cbc10:	01d6000c 	.word	0x01d6000c

0c1cbc14 <iic_stop>:

void iic_stop( uint16 ms )
{
 c1cbc14:	e1a0c00d 	mov	ip, sp
 c1cbc18:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbc1c:	e24cb004 	sub	fp, ip, #4
 c1cbc20:	e24dd008 	sub	sp, sp, #8
 c1cbc24:	e1a03000 	mov	r3, r0
 c1cbc28:	e14b30be 	strh	r3, [fp, #-14]
	//Generate STOP signal (ICCSTAT[5]=0)
    rIICSTAT &= ~(1 << 5);
 c1cbc2c:	e59f3038 	ldr	r3, [pc, #56]	; c1cbc6c <iic_stop+0x58>
 c1cbc30:	e59f2034 	ldr	r2, [pc, #52]	; c1cbc6c <iic_stop+0x58>
 c1cbc34:	e5922000 	ldr	r2, [r2]
 c1cbc38:	e3c22020 	bic	r2, r2, #32
 c1cbc3c:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission of STOP signal
    rIICCON &= ~(1 << 4);
 c1cbc40:	e59f3028 	ldr	r3, [pc, #40]	; c1cbc70 <iic_stop+0x5c>
 c1cbc44:	e59f2024 	ldr	r2, [pc, #36]	; c1cbc70 <iic_stop+0x5c>
 c1cbc48:	e5922000 	ldr	r2, [r2]
 c1cbc4c:	e3c22010 	bic	r2, r2, #16
 c1cbc50:	e5832000 	str	r2, [r3]

    Delay(ms);
 c1cbc54:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cbc58:	e1a00003 	mov	r0, r3
 c1cbc5c:	eb0010fd 	bl	c1d0058 <Delay>
}
 c1cbc60:	e24bd00c 	sub	sp, fp, #12
 c1cbc64:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbc68:	e12fff1e 	bx	lr
 c1cbc6c:	01d60004 	.word	0x01d60004
 c1cbc70:	01d60000 	.word	0x01d60000

0c1cbc74 <iis_init>:
static void isr_bdma0( void ) __attribute__ ((interrupt ("IRQ")));

static enum IIS_mode_t iomode;

void iis_init(enum IIS_mode_t mode )
{
 c1cbc74:	e1a0c00d 	mov	ip, sp
 c1cbc78:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbc7c:	e24cb004 	sub	fp, ip, #4
 c1cbc80:	e24dd008 	sub	sp, sp, #8
 c1cbc84:	e1a03000 	mov	r3, r0
 c1cbc88:	e54b300d 	strb	r3, [fp, #-13]
    iomode = mode;
 c1cbc8c:	e59f30a0 	ldr	r3, [pc, #160]	; c1cbd34 <iis_init+0xc0>
 c1cbc90:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cbc94:	e5c32000 	strb	r2, [r3]
    //IISPSR[3:0] = 7 division factor = 16

    //IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
    //IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n

    if( iomode == IIS_POLLING ) {
 c1cbc98:	e59f3094 	ldr	r3, [pc, #148]	; c1cbd34 <iis_init+0xc0>
 c1cbc9c:	e5d33000 	ldrb	r3, [r3]
 c1cbca0:	e3530002 	cmp	r3, #2
 c1cbca4:	1a00000c 	bne	c1cbcdc <iis_init+0x68>

    	//IISPSR[7:4] = 7 Frecuencia de muestreo: fs = 16 KHz (calidad Voz IP)
    	//IISPSR[3:0] = 7 division factor = 16

    	rIISPSR  = 0x7 | (0x7 << 4);
 c1cbca8:	e59f3088 	ldr	r3, [pc, #136]	; c1cbd38 <iis_init+0xc4>
 c1cbcac:	e3a02077 	mov	r2, #119	; 0x77
 c1cbcb0:	e5832000 	str	r2, [r3]
		//IISMOD[4] = 0  IIS compatible
		//IISMOD[3] = 1  16b Transfer
		//IISMOD[2] = 0 Frecuencia de CODECLK: 256fs
		//IISMOD[1:0] = 1 Frecuencia de SCLK: 32fs

    	rIISMOD  = 0b011001001;
 c1cbcb4:	e59f3080 	ldr	r3, [pc, #128]	; c1cbd3c <iis_init+0xc8>
 c1cbcb8:	e3a020c9 	mov	r2, #201	; 0xc9
 c1cbcbc:	e5832000 	str	r2, [r3]
    	//IISFCON[11] = 0 normal access mode (no DMA)
		//IISFCON[10] = 0 normal access mode (no DMA)
		//IISFCON[9] = 1 Tx FIFO enable
		//IISFCON[8] = 1 Rx FIFO enable

        rIISFCON = 0b0011 << 8;
 c1cbcc0:	e59f3078 	ldr	r3, [pc, #120]	; c1cbd40 <iis_init+0xcc>
 c1cbcc4:	e3a02c03 	mov	r2, #768	; 0x300
 c1cbcc8:	e5832000 	str	r2, [r3]
		//IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
		//IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n
		//IISCON[1] = 1 prescaler habilitado
		//IISCON[0] = 1 interfaz IIS habilitado

        rIISCON  = 0b000011;
 c1cbccc:	e59f3070 	ldr	r3, [pc, #112]	; c1cbd44 <iis_init+0xd0>
 c1cbcd0:	e3a02003 	mov	r2, #3
 c1cbcd4:	e5832000 	str	r2, [r3]
 c1cbcd8:	ea000012 	b	c1cbd28 <iis_init+0xb4>

    } else if( iomode == IIS_DMA ) {
 c1cbcdc:	e59f3050 	ldr	r3, [pc, #80]	; c1cbd34 <iis_init+0xc0>
 c1cbce0:	e5d33000 	ldrb	r3, [r3]
 c1cbce4:	e3530001 	cmp	r3, #1
 c1cbce8:	1a00000e 	bne	c1cbd28 <iis_init+0xb4>

        //IISPSR[7:4] = 7 Frecuencia de muestreo: fs = 16 KHz (calidad Voz IP)
        //IISPSR[3:0] = 7 division factor = 16

        rIISPSR  = 0x7 | (0x7 << 4);
 c1cbcec:	e59f3044 	ldr	r3, [pc, #68]	; c1cbd38 <iis_init+0xc4>
 c1cbcf0:	e3a02077 	mov	r2, #119	; 0x77
 c1cbcf4:	e5832000 	str	r2, [r3]
        //IISMOD[4] = 0  IIS compatible
        //IISMOD[3] = 1  16b Transfer
        //IISMOD[2] = 0 Frecuencia de CODECLK: 256fs
        //IISMOD[1:0] = 1 Frecuencia de SCLK: 32fs

        rIISMOD  = 0b000001001;
 c1cbcf8:	e59f303c 	ldr	r3, [pc, #60]	; c1cbd3c <iis_init+0xc8>
 c1cbcfc:	e3a02009 	mov	r2, #9
 c1cbd00:	e5832000 	str	r2, [r3]
    	//IISFCON[11] = 1 DMA access mode
    	//IISFCON[10] = 1 DMA access mode
    	//IISFCON[9] = 1 Tx FIFO habilitada
    	//IISFCON[8] = 1 Rx FIFO habilitada

        rIISFCON = 0b1111 << 8;
 c1cbd04:	e59f3034 	ldr	r3, [pc, #52]	; c1cbd40 <iis_init+0xcc>
 c1cbd08:	e3a02c0f 	mov	r2, #3840	; 0xf00
 c1cbd0c:	e5832000 	str	r2, [r3]
        //IISCON[3] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en transmisiÃ³n
        //IISCON[2] = 0 GeneraciÃ³n de LRCLK en inactividad: sÃ­ en recepciÃ³n
    	//IISCON[1] = 1  prescaler habilitado
    	//IISCON[0] = 0 interfaz IIS deshabilitado

        rIISCON  = 0b110010;
 c1cbd10:	e59f302c 	ldr	r3, [pc, #44]	; c1cbd44 <iis_init+0xd0>
 c1cbd14:	e3a02032 	mov	r2, #50	; 0x32
 c1cbd18:	e5832000 	str	r2, [r3]

        bdma0_init();
 c1cbd1c:	ebfffced 	bl	c1cb0d8 <bdma0_init>
        bdma0_open( isr_bdma0 );
 c1cbd20:	e59f0020 	ldr	r0, [pc, #32]	; c1cbd48 <iis_init+0xd4>
 c1cbd24:	ebfffd03 	bl	c1cb138 <bdma0_open>
    }
}
 c1cbd28:	e24bd00c 	sub	sp, fp, #12
 c1cbd2c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbd30:	e12fff1e 	bx	lr
 c1cbd34:	0c1022e5 	.word	0x0c1022e5
 c1cbd38:	01d18008 	.word	0x01d18008
 c1cbd3c:	01d18004 	.word	0x01d18004
 c1cbd40:	01d1800c 	.word	0x01d1800c
 c1cbd44:	01d18000 	.word	0x01d18000
 c1cbd48:	0c1cbd4c 	.word	0x0c1cbd4c

0c1cbd4c <isr_bdma0>:

static void isr_bdma0( void )
{
 c1cbd4c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cbd50:	e1a0c00d 	mov	ip, sp
 c1cbd54:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cbd58:	e24cb004 	sub	fp, ip, #4
	//Disable IIS Controller
    rIISCON &= ~1;
 c1cbd5c:	e59f3024 	ldr	r3, [pc, #36]	; c1cbd88 <isr_bdma0+0x3c>
 c1cbd60:	e59f2020 	ldr	r2, [pc, #32]	; c1cbd88 <isr_bdma0+0x3c>
 c1cbd64:	e5922000 	ldr	r2, [r2]
 c1cbd68:	e3c22001 	bic	r2, r2, #1
 c1cbd6c:	e5832000 	str	r2, [r3]

    //Clean flag
    ic_cleanflag(INT_BDMA0);
 c1cbd70:	e3a00011 	mov	r0, #17
 c1cbd74:	eb000267 	bl	c1cc718 <ic_cleanflag>
}
 c1cbd78:	e24bd01c 	sub	sp, fp, #28
 c1cbd7c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cbd80:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cbd84:	e25ef004 	subs	pc, lr, #4
 c1cbd88:	01d18000 	.word	0x01d18000

0c1cbd8c <iis_putSample>:

inline void iis_putSample( int16 ch0, int16 ch1 )
{
 c1cbd8c:	e1a0c00d 	mov	ip, sp
 c1cbd90:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbd94:	e24cb004 	sub	fp, ip, #4
 c1cbd98:	e24dd008 	sub	sp, sp, #8
 c1cbd9c:	e1a02000 	mov	r2, r0
 c1cbda0:	e1a03001 	mov	r3, r1
 c1cbda4:	e14b20be 	strh	r2, [fp, #-14]
 c1cbda8:	e14b31b0 	strh	r3, [fp, #-16]
	//Polling only

	//Wait until there are two empty spots in FIFO
    while(((rIISFCON >> 4) & 0b1111) > 6);
 c1cbdac:	e1a00000 	nop			; (mov r0, r0)
 c1cbdb0:	e59f3034 	ldr	r3, [pc, #52]	; c1cbdec <iis_putSample+0x60>
 c1cbdb4:	e5933000 	ldr	r3, [r3]
 c1cbdb8:	e1a03223 	lsr	r3, r3, #4
 c1cbdbc:	e203300f 	and	r3, r3, #15
 c1cbdc0:	e3530006 	cmp	r3, #6
 c1cbdc4:	8afffff9 	bhi	c1cbdb0 <iis_putSample+0x24>

    //Send data
    IISFIF = ch0;
 c1cbdc8:	e59f3020 	ldr	r3, [pc, #32]	; c1cbdf0 <iis_putSample+0x64>
 c1cbdcc:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cbdd0:	e1c320b0 	strh	r2, [r3]
    IISFIF = ch1;
 c1cbdd4:	e59f3014 	ldr	r3, [pc, #20]	; c1cbdf0 <iis_putSample+0x64>
 c1cbdd8:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1cbddc:	e1c320b0 	strh	r2, [r3]
}
 c1cbde0:	e24bd00c 	sub	sp, fp, #12
 c1cbde4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbde8:	e12fff1e 	bx	lr
 c1cbdec:	01d1800c 	.word	0x01d1800c
 c1cbdf0:	01d18010 	.word	0x01d18010

0c1cbdf4 <iis_getSample>:

inline void iis_getSample( int16 *ch0, int16 *ch1 )
{
 c1cbdf4:	e1a0c00d 	mov	ip, sp
 c1cbdf8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbdfc:	e24cb004 	sub	fp, ip, #4
 c1cbe00:	e24dd008 	sub	sp, sp, #8
 c1cbe04:	e50b0010 	str	r0, [fp, #-16]
 c1cbe08:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	//Polling only

	//Wait until there are two samples in FIFO
    while((rIISFCON & 0b1111) < 2);
 c1cbe0c:	e1a00000 	nop			; (mov r0, r0)
 c1cbe10:	e59f3058 	ldr	r3, [pc, #88]	; c1cbe70 <iis_getSample+0x7c>
 c1cbe14:	e5933000 	ldr	r3, [r3]
 c1cbe18:	e203300f 	and	r3, r3, #15
 c1cbe1c:	e3530001 	cmp	r3, #1
 c1cbe20:	9afffffa 	bls	c1cbe10 <iis_getSample+0x1c>

    *ch0 = IISFIF;
 c1cbe24:	e59f3048 	ldr	r3, [pc, #72]	; c1cbe74 <iis_getSample+0x80>
 c1cbe28:	e1d330b0 	ldrh	r3, [r3]
 c1cbe2c:	e1a03803 	lsl	r3, r3, #16
 c1cbe30:	e1a03823 	lsr	r3, r3, #16
 c1cbe34:	e1a03803 	lsl	r3, r3, #16
 c1cbe38:	e1a02823 	lsr	r2, r3, #16
 c1cbe3c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbe40:	e1c320b0 	strh	r2, [r3]
    *ch1 = IISFIF;
 c1cbe44:	e59f3028 	ldr	r3, [pc, #40]	; c1cbe74 <iis_getSample+0x80>
 c1cbe48:	e1d330b0 	ldrh	r3, [r3]
 c1cbe4c:	e1a03803 	lsl	r3, r3, #16
 c1cbe50:	e1a03823 	lsr	r3, r3, #16
 c1cbe54:	e1a03803 	lsl	r3, r3, #16
 c1cbe58:	e1a02823 	lsr	r2, r3, #16
 c1cbe5c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cbe60:	e1c320b0 	strh	r2, [r3]
}
 c1cbe64:	e24bd00c 	sub	sp, fp, #12
 c1cbe68:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cbe6c:	e12fff1e 	bx	lr
 c1cbe70:	01d1800c 	.word	0x01d1800c
 c1cbe74:	01d18010 	.word	0x01d18010

0c1cbe78 <iis_play>:

void iis_play( int16 *buffer, uint32 length, uint8 loop )
{
 c1cbe78:	e1a0c00d 	mov	ip, sp
 c1cbe7c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cbe80:	e24cb004 	sub	fp, ip, #4
 c1cbe84:	e24dd020 	sub	sp, sp, #32
 c1cbe88:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c1cbe8c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
 c1cbe90:	e1a03002 	mov	r3, r2
 c1cbe94:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    uint32 i;
    int16 ch1, ch2;
    uint8 loop_23_22, loop_21;

    if( iomode == IIS_POLLING )
 c1cbe98:	e59f316c 	ldr	r3, [pc, #364]	; c1cc00c <iis_play+0x194>
 c1cbe9c:	e5d33000 	ldrb	r3, [r3]
 c1cbea0:	e3530002 	cmp	r3, #2
 c1cbea4:	1a00001e 	bne	c1cbf24 <iis_play+0xac>
        for( i=0; i<length/2; )
 c1cbea8:	e3a03000 	mov	r3, #0
 c1cbeac:	e50b3010 	str	r3, [fp, #-16]
 c1cbeb0:	ea000016 	b	c1cbf10 <iis_play+0x98>
        {
            ch1 = buffer[i++];
 c1cbeb4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbeb8:	e1a03083 	lsl	r3, r3, #1
 c1cbebc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cbec0:	e0823003 	add	r3, r2, r3
 c1cbec4:	e1d330b0 	ldrh	r3, [r3]
 c1cbec8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c1cbecc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbed0:	e2833001 	add	r3, r3, #1
 c1cbed4:	e50b3010 	str	r3, [fp, #-16]
            ch2 = buffer[i++];
 c1cbed8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbedc:	e1a03083 	lsl	r3, r3, #1
 c1cbee0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cbee4:	e0823003 	add	r3, r2, r3
 c1cbee8:	e1d330b0 	ldrh	r3, [r3]
 c1cbeec:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
 c1cbef0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbef4:	e2833001 	add	r3, r3, #1
 c1cbef8:	e50b3010 	str	r3, [fp, #-16]
            iis_putSample( ch1, ch2 );
 c1cbefc:	e15b21f2 	ldrsh	r2, [fp, #-18]	; 0xffffffee
 c1cbf00:	e15b31f4 	ldrsh	r3, [fp, #-20]	; 0xffffffec
 c1cbf04:	e1a00002 	mov	r0, r2
 c1cbf08:	e1a01003 	mov	r1, r3
 c1cbf0c:	ebffff9e 	bl	c1cbd8c <iis_putSample>
    uint32 i;
    int16 ch1, ch2;
    uint8 loop_23_22, loop_21;

    if( iomode == IIS_POLLING )
        for( i=0; i<length/2; )
 c1cbf10:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cbf14:	e1a020a3 	lsr	r2, r3, #1
 c1cbf18:	e51b3010 	ldr	r3, [fp, #-16]
 c1cbf1c:	e1520003 	cmp	r2, r3
 c1cbf20:	8affffe3 	bhi	c1cbeb4 <iis_play+0x3c>
        {
            ch1 = buffer[i++];
            ch2 = buffer[i++];
            iis_putSample( ch1, ch2 );
        }
    if( iomode == IIS_DMA ){
 c1cbf24:	e59f30e0 	ldr	r3, [pc, #224]	; c1cc00c <iis_play+0x194>
 c1cbf28:	e5d33000 	ldrb	r3, [r3]
 c1cbf2c:	e3530001 	cmp	r3, #1
 c1cbf30:	1a000032 	bne	c1cc000 <iis_play+0x188>

    	//BDISRC0[31:30] = 1 half word (16b)
    	//BDISRC0[29:28] = 1 postâincrementada source address
    	//BDISRC0[27:0] = ... direcciÃ³n del buffer source address

    	rBDISRC0  = (1 << 30) | (1 << 28) | (uint32) buffer;
 c1cbf34:	e59f30d4 	ldr	r3, [pc, #212]	; c1cc010 <iis_play+0x198>
 c1cbf38:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cbf3c:	e3822205 	orr	r2, r2, #1342177280	; 0x50000000
 c1cbf40:	e5832000 	str	r2, [r3]

    	//BDIDES0[31:30] = 1 from external memory to internal peripheral transfer direction
    	//BDIDES0[29:28] = 3 fija (dest address)
    	//BDIDES0[27:0] = ... direcciÃ³n de IISFIF (dest address)

		rBDIDES0  = (1 << 30) | (3 << 28) | (uint32) &IISFIF;
 c1cbf44:	e59f30c8 	ldr	r3, [pc, #200]	; c1cc014 <iis_play+0x19c>
 c1cbf48:	e59f20c8 	ldr	r2, [pc, #200]	; c1cc018 <iis_play+0x1a0>
 c1cbf4c:	e5832000 	str	r2, [r3]

    	//BDCON0[3:2] = 0 DMA request enable
    	//BDCON0[1:0] = 0 no command
		rBDCON0  = 0;
 c1cbf50:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c1cbf54:	e3a02000 	mov	r2, #0
 c1cbf58:	e5832000 	str	r2, [r3]
    	//BDICNT0[23:22] = 0 (no) si loop = TRUE; 3 (sÃ­, al terminar la transferencia DMA) en otro caso
    	//BDICNT0[21] = 1 (activado) si loop = TRUE; 0 (desactivado) en otro caso
    	//BDICNT0[20] = 1 DMA enable
    	//BDICNT0[19:0] = ... tamaÃ±o del buffer a transferur

		loop_23_22 = loop ? 0 : 3;
 c1cbf5c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
 c1cbf60:	e3530000 	cmp	r3, #0
 c1cbf64:	0a000001 	beq	c1cbf70 <iis_play+0xf8>
 c1cbf68:	e3a03000 	mov	r3, #0
 c1cbf6c:	ea000000 	b	c1cbf74 <iis_play+0xfc>
 c1cbf70:	e3a03003 	mov	r3, #3
 c1cbf74:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
		loop_21 = loop ? 1 : 0;
 c1cbf78:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
 c1cbf7c:	e3530000 	cmp	r3, #0
 c1cbf80:	03a03000 	moveq	r3, #0
 c1cbf84:	13a03001 	movne	r3, #1
 c1cbf88:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea

		rBDICNT0  = (1 << 30) | (1 << 26) | (loop_23_22 << 22) | (loop_21 << 21) | (0xfffff & length);
 c1cbf8c:	e59f2088 	ldr	r2, [pc, #136]	; c1cc01c <iis_play+0x1a4>
 c1cbf90:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cbf94:	e1a03b03 	lsl	r3, r3, #22
 c1cbf98:	e3831311 	orr	r1, r3, #1140850688	; 0x44000000
 c1cbf9c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cbfa0:	e1a03a83 	lsl	r3, r3, #21
 c1cbfa4:	e1813003 	orr	r3, r1, r3
 c1cbfa8:	e1a01003 	mov	r1, r3
 c1cbfac:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cbfb0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c1cbfb4:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
 c1cbfb8:	e1813003 	orr	r3, r1, r3
 c1cbfbc:	e5823000 	str	r3, [r2]
		rBDICNT0 |= (1 << 20);
 c1cbfc0:	e59f3054 	ldr	r3, [pc, #84]	; c1cc01c <iis_play+0x1a4>
 c1cbfc4:	e59f2050 	ldr	r2, [pc, #80]	; c1cc01c <iis_play+0x1a4>
 c1cbfc8:	e5922000 	ldr	r2, [r2]
 c1cbfcc:	e3822601 	orr	r2, r2, #1048576	; 0x100000
 c1cbfd0:	e5832000 	str	r2, [r3]

    	//*IIS Controller

    	//IISMOD[7:6] = 2 modo transmisiÃ³n
    	//IISCON[0] = 1 interfaz IIS habilitado
        rIISMOD   = (rIISMOD & ~(3 << 6)) | (2 << 6);
 c1cbfd4:	e59f3044 	ldr	r3, [pc, #68]	; c1cc020 <iis_play+0x1a8>
 c1cbfd8:	e59f2040 	ldr	r2, [pc, #64]	; c1cc020 <iis_play+0x1a8>
 c1cbfdc:	e5922000 	ldr	r2, [r2]
 c1cbfe0:	e3c220c0 	bic	r2, r2, #192	; 0xc0
 c1cbfe4:	e3822080 	orr	r2, r2, #128	; 0x80
 c1cbfe8:	e5832000 	str	r2, [r3]
        rIISCON  |= 1;
 c1cbfec:	e59f3030 	ldr	r3, [pc, #48]	; c1cc024 <iis_play+0x1ac>
 c1cbff0:	e59f202c 	ldr	r2, [pc, #44]	; c1cc024 <iis_play+0x1ac>
 c1cbff4:	e5922000 	ldr	r2, [r2]
 c1cbff8:	e3822001 	orr	r2, r2, #1
 c1cbffc:	e5832000 	str	r2, [r3]
    }
}
 c1cc000:	e24bd00c 	sub	sp, fp, #12
 c1cc004:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc008:	e12fff1e 	bx	lr
 c1cc00c:	0c1022e5 	.word	0x0c1022e5
 c1cc010:	01f80004 	.word	0x01f80004
 c1cc014:	01f80008 	.word	0x01f80008
 c1cc018:	71d18010 	.word	0x71d18010
 c1cc01c:	01f8000c 	.word	0x01f8000c
 c1cc020:	01d18004 	.word	0x01d18004
 c1cc024:	01d18000 	.word	0x01d18000

0c1cc028 <iis_rec>:

void iis_rec( int16 *buffer, uint32 length )
{
 c1cc028:	e1a0c00d 	mov	ip, sp
 c1cc02c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc030:	e24cb004 	sub	fp, ip, #4
 c1cc034:	e24dd010 	sub	sp, sp, #16
 c1cc038:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cc03c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    uint32 i;
    int16 ch1, ch2;

    if( iomode == IIS_POLLING ) {
 c1cc040:	e59f3108 	ldr	r3, [pc, #264]	; c1cc150 <iis_rec+0x128>
 c1cc044:	e5d33000 	ldrb	r3, [r3]
 c1cc048:	e3530002 	cmp	r3, #2
 c1cc04c:	1a000010 	bne	c1cc094 <iis_rec+0x6c>
    	//Repeated polling
    	for( i=0; i<length/2; ) {
 c1cc050:	e3a03000 	mov	r3, #0
 c1cc054:	e50b3010 	str	r3, [fp, #-16]
 c1cc058:	ea000007 	b	c1cc07c <iis_rec+0x54>
			iis_getSample( buffer, buffer + 1);
 c1cc05c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cc060:	e2833002 	add	r3, r3, #2
 c1cc064:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c1cc068:	e1a01003 	mov	r1, r3
 c1cc06c:	ebffff60 	bl	c1cbdf4 <iis_getSample>
			buffer += 2;
 c1cc070:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cc074:	e2833004 	add	r3, r3, #4
 c1cc078:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    uint32 i;
    int16 ch1, ch2;

    if( iomode == IIS_POLLING ) {
    	//Repeated polling
    	for( i=0; i<length/2; ) {
 c1cc07c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cc080:	e1a020a3 	lsr	r2, r3, #1
 c1cc084:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc088:	e1520003 	cmp	r2, r3
 c1cc08c:	8afffff2 	bhi	c1cc05c <iis_rec+0x34>
 c1cc090:	ea00002b 	b	c1cc144 <iis_rec+0x11c>
			iis_getSample( buffer, buffer + 1);
			buffer += 2;
		}
    } else if( iomode == IIS_DMA ) {
 c1cc094:	e59f30b4 	ldr	r3, [pc, #180]	; c1cc150 <iis_rec+0x128>
 c1cc098:	e5d33000 	ldrb	r3, [r3]
 c1cc09c:	e3530001 	cmp	r3, #1
 c1cc0a0:	1a000027 	bne	c1cc144 <iis_rec+0x11c>

    	//Wait while DMA transfer is ongoing
        while( rIISCON & 1  );
 c1cc0a4:	e1a00000 	nop			; (mov r0, r0)
 c1cc0a8:	e59f30a4 	ldr	r3, [pc, #164]	; c1cc154 <iis_rec+0x12c>
 c1cc0ac:	e5933000 	ldr	r3, [r3]
 c1cc0b0:	e2033001 	and	r3, r3, #1
 c1cc0b4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cc0b8:	e3530000 	cmp	r3, #0
 c1cc0bc:	1afffff9 	bne	c1cc0a8 <iis_rec+0x80>

        //Set up DMA Receive
        rBDISRC0  = (1 << 30) | (3 << 28) | (uint32)&IISFIF;
 c1cc0c0:	e59f3090 	ldr	r3, [pc, #144]	; c1cc158 <iis_rec+0x130>
 c1cc0c4:	e59f2090 	ldr	r2, [pc, #144]	; c1cc15c <iis_rec+0x134>
 c1cc0c8:	e5832000 	str	r2, [r3]
        rBDIDES0  = (2 << 30) | (1 << 28) | (uint32) buffer;
 c1cc0cc:	e59f308c 	ldr	r3, [pc, #140]	; c1cc160 <iis_rec+0x138>
 c1cc0d0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cc0d4:	e3822209 	orr	r2, r2, #-1879048192	; 0x90000000
 c1cc0d8:	e5832000 	str	r2, [r3]
        rBDCON0   = 0;
 c1cc0dc:	e3a0377e 	mov	r3, #33030144	; 0x1f80000
 c1cc0e0:	e3a02000 	mov	r2, #0
 c1cc0e4:	e5832000 	str	r2, [r3]
        rBDICNT0  = (1 << 30) | (1 << 26) | (3 << 22) | (0xfffff & length);
 c1cc0e8:	e59f2074 	ldr	r2, [pc, #116]	; c1cc164 <iis_rec+0x13c>
 c1cc0ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cc0f0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c1cc0f4:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
 c1cc0f8:	e3833311 	orr	r3, r3, #1140850688	; 0x44000000
 c1cc0fc:	e3833503 	orr	r3, r3, #12582912	; 0xc00000
 c1cc100:	e5823000 	str	r3, [r2]
        rBDICNT0 |= (1 << 20);
 c1cc104:	e59f3058 	ldr	r3, [pc, #88]	; c1cc164 <iis_rec+0x13c>
 c1cc108:	e59f2054 	ldr	r2, [pc, #84]	; c1cc164 <iis_rec+0x13c>
 c1cc10c:	e5922000 	ldr	r2, [r2]
 c1cc110:	e3822601 	orr	r2, r2, #1048576	; 0x100000
 c1cc114:	e5832000 	str	r2, [r3]
        //*Set up IIS

        //IISMOD[7:6] = 1 modo recepciÃ³n
        //IISCON[0] = 1 interfaz IIS habilitado

        rIISMOD   = (rIISMOD & ~(3 << 6)) | (1 << 6);
 c1cc118:	e59f3048 	ldr	r3, [pc, #72]	; c1cc168 <iis_rec+0x140>
 c1cc11c:	e59f2044 	ldr	r2, [pc, #68]	; c1cc168 <iis_rec+0x140>
 c1cc120:	e5922000 	ldr	r2, [r2]
 c1cc124:	e3c220c0 	bic	r2, r2, #192	; 0xc0
 c1cc128:	e3822040 	orr	r2, r2, #64	; 0x40
 c1cc12c:	e5832000 	str	r2, [r3]
        rIISCON  |= 1;
 c1cc130:	e59f301c 	ldr	r3, [pc, #28]	; c1cc154 <iis_rec+0x12c>
 c1cc134:	e59f2018 	ldr	r2, [pc, #24]	; c1cc154 <iis_rec+0x12c>
 c1cc138:	e5922000 	ldr	r2, [r2]
 c1cc13c:	e3822001 	orr	r2, r2, #1
 c1cc140:	e5832000 	str	r2, [r3]
    }
}
 c1cc144:	e24bd00c 	sub	sp, fp, #12
 c1cc148:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc14c:	e12fff1e 	bx	lr
 c1cc150:	0c1022e5 	.word	0x0c1022e5
 c1cc154:	01d18000 	.word	0x01d18000
 c1cc158:	01f80004 	.word	0x01f80004
 c1cc15c:	71d18010 	.word	0x71d18010
 c1cc160:	01f80008 	.word	0x01f80008
 c1cc164:	01f8000c 	.word	0x01f8000c
 c1cc168:	01d18004 	.word	0x01d18004

0c1cc16c <iis_pause>:

void iis_pause( void )
{
 c1cc16c:	e1a0c00d 	mov	ip, sp
 c1cc170:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc174:	e24cb004 	sub	fp, ip, #4
	//Pause DMA transfer

	//Desabilita IIS
	rIISCON &= ~1;
 c1cc178:	e59f3018 	ldr	r3, [pc, #24]	; c1cc198 <iis_pause+0x2c>
 c1cc17c:	e59f2014 	ldr	r2, [pc, #20]	; c1cc198 <iis_pause+0x2c>
 c1cc180:	e5922000 	ldr	r2, [r2]
 c1cc184:	e3c22001 	bic	r2, r2, #1
 c1cc188:	e5832000 	str	r2, [r3]
}
 c1cc18c:	e24bd00c 	sub	sp, fp, #12
 c1cc190:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc194:	e12fff1e 	bx	lr
 c1cc198:	01d18000 	.word	0x01d18000

0c1cc19c <iis_continue>:

void iis_continue( void )
{
 c1cc19c:	e1a0c00d 	mov	ip, sp
 c1cc1a0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc1a4:	e24cb004 	sub	fp, ip, #4
	//Continue DMA transfer

	//Habilita IIS
	rIISCON |= 1;
 c1cc1a8:	e59f3018 	ldr	r3, [pc, #24]	; c1cc1c8 <iis_continue+0x2c>
 c1cc1ac:	e59f2014 	ldr	r2, [pc, #20]	; c1cc1c8 <iis_continue+0x2c>
 c1cc1b0:	e5922000 	ldr	r2, [r2]
 c1cc1b4:	e3822001 	orr	r2, r2, #1
 c1cc1b8:	e5832000 	str	r2, [r3]
}
 c1cc1bc:	e24bd00c 	sub	sp, fp, #12
 c1cc1c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc1c4:	e12fff1e 	bx	lr
 c1cc1c8:	01d18000 	.word	0x01d18000

0c1cc1cc <iis_status>:

uint8 iis_status( void )
{
 c1cc1cc:	e1a0c00d 	mov	ip, sp
 c1cc1d0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc1d4:	e24cb004 	sub	fp, ip, #4
	//Return if DMA is currently playing / recording
    return rIISCON & 1;
 c1cc1d8:	e59f301c 	ldr	r3, [pc, #28]	; c1cc1fc <iis_status+0x30>
 c1cc1dc:	e5933000 	ldr	r3, [r3]
 c1cc1e0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cc1e4:	e2033001 	and	r3, r3, #1
 c1cc1e8:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cc1ec:	e1a00003 	mov	r0, r3
 c1cc1f0:	e24bd00c 	sub	sp, fp, #12
 c1cc1f4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc1f8:	e12fff1e 	bx	lr
 c1cc1fc:	01d18000 	.word	0x01d18000

0c1cc200 <iis_playWawFile>:

void iis_playWawFile( int16 *wav, uint8 loop )
{
 c1cc200:	e1a0c00d 	mov	ip, sp
 c1cc204:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc208:	e24cb004 	sub	fp, ip, #4
 c1cc20c:	e24dd010 	sub	sp, sp, #16
 c1cc210:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cc214:	e1a03001 	mov	r3, r1
 c1cc218:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    uint32 size;
    char *p;

    p = (char *) wav;
 c1cc21c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cc220:	e50b3010 	str	r3, [fp, #-16]
    while ( !(p[0] == 'd' && p[1] == 'a' && p[2] == 't' && p[3] == 'a') ) // busca el chunck data
 c1cc224:	ea000002 	b	c1cc234 <iis_playWawFile+0x34>
        p++;
 c1cc228:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc22c:	e2833001 	add	r3, r3, #1
 c1cc230:	e50b3010 	str	r3, [fp, #-16]
{
    uint32 size;
    char *p;

    p = (char *) wav;
    while ( !(p[0] == 'd' && p[1] == 'a' && p[2] == 't' && p[3] == 'a') ) // busca el chunck data
 c1cc234:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc238:	e5d33000 	ldrb	r3, [r3]
 c1cc23c:	e3530064 	cmp	r3, #100	; 0x64
 c1cc240:	1afffff8 	bne	c1cc228 <iis_playWawFile+0x28>
 c1cc244:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc248:	e2833001 	add	r3, r3, #1
 c1cc24c:	e5d33000 	ldrb	r3, [r3]
 c1cc250:	e3530061 	cmp	r3, #97	; 0x61
 c1cc254:	1afffff3 	bne	c1cc228 <iis_playWawFile+0x28>
 c1cc258:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc25c:	e2833002 	add	r3, r3, #2
 c1cc260:	e5d33000 	ldrb	r3, [r3]
 c1cc264:	e3530074 	cmp	r3, #116	; 0x74
 c1cc268:	1affffee 	bne	c1cc228 <iis_playWawFile+0x28>
 c1cc26c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc270:	e2833003 	add	r3, r3, #3
 c1cc274:	e5d33000 	ldrb	r3, [r3]
 c1cc278:	e3530061 	cmp	r3, #97	; 0x61
 c1cc27c:	1affffe9 	bne	c1cc228 <iis_playWawFile+0x28>
        p++;
    p += 4;
 c1cc280:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc284:	e2833004 	add	r3, r3, #4
 c1cc288:	e50b3010 	str	r3, [fp, #-16]

    size = p[0] + (p[1] << 8) + (p[2] << 16) + (p[3] << 24); // los datos de cabecera estÃ¡n en little-endian
 c1cc28c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc290:	e5d33000 	ldrb	r3, [r3]
 c1cc294:	e1a02003 	mov	r2, r3
 c1cc298:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc29c:	e2833001 	add	r3, r3, #1
 c1cc2a0:	e5d33000 	ldrb	r3, [r3]
 c1cc2a4:	e1a03403 	lsl	r3, r3, #8
 c1cc2a8:	e0822003 	add	r2, r2, r3
 c1cc2ac:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc2b0:	e2833002 	add	r3, r3, #2
 c1cc2b4:	e5d33000 	ldrb	r3, [r3]
 c1cc2b8:	e1a03803 	lsl	r3, r3, #16
 c1cc2bc:	e0822003 	add	r2, r2, r3
 c1cc2c0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc2c4:	e2833003 	add	r3, r3, #3
 c1cc2c8:	e5d33000 	ldrb	r3, [r3]
 c1cc2cc:	e1a03c03 	lsl	r3, r3, #24
 c1cc2d0:	e0823003 	add	r3, r2, r3
 c1cc2d4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    p += 4;
 c1cc2d8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc2dc:	e2833004 	add	r3, r3, #4
 c1cc2e0:	e50b3010 	str	r3, [fp, #-16]

    iis_play( (int16 *)p, size, loop );
 c1cc2e4:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc2e8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cc2ec:	e1a00002 	mov	r0, r2
 c1cc2f0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c1cc2f4:	e1a02003 	mov	r2, r3
 c1cc2f8:	ebfffede 	bl	c1cbe78 <iis_play>
}
 c1cc2fc:	e24bd00c 	sub	sp, fp, #12
 c1cc300:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc304:	e12fff1e 	bx	lr

0c1cc308 <start>:
	.equ rEXTINTPND, 0x1d20054

start:

	/* Pasa a modo supervisor */
    mrs	r0, cpsr
 c1cc308:	e10f0000 	mrs	r0, CPSR
    bic	r0, r0, #MODEMASK
 c1cc30c:	e3c0001f 	bic	r0, r0, #31
    orr	r1, r0, #SVCMODE
 c1cc310:	e3801013 	orr	r1, r0, #19
    msr	cpsr_c, r1 
 c1cc314:	e121f001 	msr	CPSR_c, r1

	/* InicializaciÃ³n de la secciÃ³n bss a 0, estÃ¡ndar C */
    ldr	    r3, =Image_ZI_Base
 c1cc318:	e59f30b8 	ldr	r3, [pc, #184]	; c1cc3d8 <InitStacks+0x48>
	ldr	    r1, =Image_ZI_Limit	/* Top of zero init segment */
 c1cc31c:	e59f10b8 	ldr	r1, [pc, #184]	; c1cc3dc <InitStacks+0x4c>
    mov	    r2, #0
 c1cc320:	e3a02000 	mov	r2, #0

0c1cc324 <L0>:
L0:
    cmp	    r3, r1	    		/* Zero init */
 c1cc324:	e1530001 	cmp	r3, r1
    strcc   r2, [r3], #4
 c1cc328:	34832004 	strcc	r2, [r3], #4
    bcc	    L0
 c1cc32c:	3afffffc 	bcc	c1cc324 <L0>
	/****************************************************/

	/* Desde modo SVC inicializa los SP de todos los modos de ejecuciï¿½n privilegiados */
    bl InitStacks
 c1cc330:	eb000016 	bl	c1cc390 <InitStacks>

	ldr r0, =rEXTINTPND
 c1cc334:	e59f00a4 	ldr	r0, [pc, #164]	; c1cc3e0 <InitStacks+0x50>
	ldr r1, =0xff
 c1cc338:	e3a010ff 	mov	r1, #255	; 0xff
	str r1, [r0]
 c1cc33c:	e5801000 	str	r1, [r0]
	ldr r0, =rI_ISPC
 c1cc340:	e59f009c 	ldr	r0, [pc, #156]	; c1cc3e4 <InitStacks+0x54>
	ldr r1, =0x1fffffff
 c1cc344:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c1cc348:	e5801000 	str	r1, [r0]
	ldr r0, =rF_ISPC
 c1cc34c:	e59f0094 	ldr	r0, [pc, #148]	; c1cc3e8 <InitStacks+0x58>
	ldr r1, =0x1fffffff
 c1cc350:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c1cc354:	e5801000 	str	r1, [r0]

	/* Enmascara interrupciones */
	ldr r0, =rINTMSK
 c1cc358:	e59f008c 	ldr	r0, [pc, #140]	; c1cc3ec <InitStacks+0x5c>
	ldr r1, =0x1fffffff
 c1cc35c:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
    str r1, [r0]
 c1cc360:	e5801000 	str	r1, [r0]

	/* Habilita linea IRQ y FIQ del CPSR */
	mrs r0, cpsr
 c1cc364:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #0xC0
 c1cc368:	e3c000c0 	bic	r0, r0, #192	; 0xc0
	msr cpsr_c, r0
 c1cc36c:	e121f000 	msr	CPSR_c, r0
	
	/* Desde modo SVC cambia a modo USR e inicializa el SP_usr */
	mrs r0, cpsr
 c1cc370:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c1cc374:	e3c0001f 	bic	r0, r0, #31
	orr r1, r0, #USRMODE  
 c1cc378:	e3801010 	orr	r1, r0, #16
	msr cpsr_c, r1
 c1cc37c:	e121f001 	msr	CPSR_c, r1
	ldr sp, =USRSTACK
 c1cc380:	e59fd068 	ldr	sp, [pc, #104]	; c1cc3f0 <InitStacks+0x60>

    mov fp, #0
 c1cc384:	e3a0b000 	mov	fp, #0

    bl main
 c1cc388:	eb000618 	bl	c1cdbf0 <main>

0c1cc38c <End>:
End:
    B End
 c1cc38c:	eafffffe 	b	c1cc38c <End>

0c1cc390 <InitStacks>:

InitStacks:
	mrs r0, cpsr
 c1cc390:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c1cc394:	e3c0001f 	bic	r0, r0, #31

	orr r1, r0, #UNDMODE  /* desde modo SVC cambia a modo UND e inicializa el SP_und */
 c1cc398:	e380101b 	orr	r1, r0, #27
	msr cpsr_c, r1    
 c1cc39c:	e121f001 	msr	CPSR_c, r1
	ldr sp, =UNDSTACK
 c1cc3a0:	e59fd04c 	ldr	sp, [pc, #76]	; c1cc3f4 <InitStacks+0x64>

	orr r1, r0, #ABTMODE  /* desde modo UND cambia a modo ABT e inicializa el SP_abt */
 c1cc3a4:	e3801017 	orr	r1, r0, #23
	msr cpsr_c, r1 
 c1cc3a8:	e121f001 	msr	CPSR_c, r1
	ldr sp, =ABTSTACK
 c1cc3ac:	e59fd044 	ldr	sp, [pc, #68]	; c1cc3f8 <InitStacks+0x68>

	orr r1, r0, #IRQMODE  /* desde modo ABT cambia a modo IRQ e inicializa el SP_abt */
 c1cc3b0:	e3801012 	orr	r1, r0, #18
	msr cpsr_c, r1
 c1cc3b4:	e121f001 	msr	CPSR_c, r1
	ldr sp, =IRQSTACK
 c1cc3b8:	e59fd03c 	ldr	sp, [pc, #60]	; c1cc3fc <InitStacks+0x6c>

	orr r1, r0, #FIQMODE  /* desde modo IRQ cambia a modo FIQ e inicializa el SP_fiq */
 c1cc3bc:	e3801011 	orr	r1, r0, #17
	msr cpsr_c, r1
 c1cc3c0:	e121f001 	msr	CPSR_c, r1
	ldr sp, =FIQSTACK
 c1cc3c4:	e59fd034 	ldr	sp, [pc, #52]	; c1cc400 <InitStacks+0x70>

	orr r1, r0, #SVCMODE  /* desde modo FIQ cambia a modo SVC e inicializa el SP_svc */
 c1cc3c8:	e3801013 	orr	r1, r0, #19
	msr cpsr_c, r1
 c1cc3cc:	e121f001 	msr	CPSR_c, r1
	ldr sp, =SVCSTACK
 c1cc3d0:	e59fd02c 	ldr	sp, [pc, #44]	; c1cc404 <InitStacks+0x74>
	
    mov pc, lr
 c1cc3d4:	e1a0f00e 	mov	pc, lr
 c1cc3d8:	0c10223c 	.word	0x0c10223c
 c1cc3dc:	0c1c7928 	.word	0x0c1c7928
 c1cc3e0:	01d20054 	.word	0x01d20054
 c1cc3e4:	01e00024 	.word	0x01e00024
 c1cc3e8:	01e0003c 	.word	0x01e0003c
 c1cc3ec:	01e0000c 	.word	0x01e0000c
 c1cc3f0:	0c7ff000 	.word	0x0c7ff000
 c1cc3f4:	0c7ff200 	.word	0x0c7ff200
 c1cc3f8:	0c7ff300 	.word	0x0c7ff300
 c1cc3fc:	0c7ff400 	.word	0x0c7ff400
 c1cc400:	0c7ff500 	.word	0x0c7ff500
 c1cc404:	0c7ff100 	.word	0x0c7ff100

0c1cc408 <ic_init>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "intcontroller.h"

void ic_init(void)
{
 c1cc408:	e1a0c00d 	mov	ip, sp
 c1cc40c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc410:	e24cb004 	sub	fp, ip, #4
	 *    Lineas IRQ y FIQ no habilitadas
	 *    Linea IRQ en modo no vectorizado
	 *    Todo por la lÃ­nea IRQ
	 *    Todas las interrupciones enmascaradas
	 **/
	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 c1cc414:	e59f3028 	ldr	r3, [pc, #40]	; c1cc444 <ic_init+0x3c>
 c1cc418:	e3a02000 	mov	r2, #0
 c1cc41c:	e5832000 	str	r2, [r3]
	rINTCON = 0x7; // IRQ y FIQ enmascaradas, IRQ en modo no vectorizado
 c1cc420:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c1cc424:	e3a02007 	mov	r2, #7
 c1cc428:	e5832000 	str	r2, [r3]
	rINTMSK = ~(0x0); // Enmascara todas las lineas
 c1cc42c:	e59f3014 	ldr	r3, [pc, #20]	; c1cc448 <ic_init+0x40>
 c1cc430:	e3e02000 	mvn	r2, #0
 c1cc434:	e5832000 	str	r2, [r3]
}
 c1cc438:	e24bd00c 	sub	sp, fp, #12
 c1cc43c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc440:	e12fff1e 	bx	lr
 c1cc444:	01e00008 	.word	0x01e00008
 c1cc448:	01e0000c 	.word	0x01e0000c

0c1cc44c <ic_conf_irq>:

int ic_conf_irq(enum enable st, enum int_vec vec)
{
 c1cc44c:	e1a0c00d 	mov	ip, sp
 c1cc450:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc454:	e24cb004 	sub	fp, ip, #4
 c1cc458:	e24dd010 	sub	sp, sp, #16
 c1cc45c:	e1a02000 	mov	r2, r0
 c1cc460:	e1a03001 	mov	r3, r1
 c1cc464:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c1cc468:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int conf = rINTCON;
 c1cc46c:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c1cc470:	e5933000 	ldr	r3, [r3]
 c1cc474:	e50b3010 	str	r3, [fp, #-16]

	if (st != ENABLE && st != DISABLE)
 c1cc478:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc47c:	e3530001 	cmp	r3, #1
 c1cc480:	0a000004 	beq	c1cc498 <ic_conf_irq+0x4c>
 c1cc484:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc488:	e3530000 	cmp	r3, #0
 c1cc48c:	0a000001 	beq	c1cc498 <ic_conf_irq+0x4c>
		return -1;
 c1cc490:	e3e03000 	mvn	r3, #0
 c1cc494:	ea000017 	b	c1cc4f8 <ic_conf_irq+0xac>

	if (vec == VEC)
 c1cc498:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cc49c:	e3530000 	cmp	r3, #0
 c1cc4a0:	1a000003 	bne	c1cc4b4 <ic_conf_irq+0x68>
		//COMPLETAR: poner la linea IRQ en modo vectorizado
		conf &= ~(1 << 2);
 c1cc4a4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc4a8:	e3c33004 	bic	r3, r3, #4
 c1cc4ac:	e50b3010 	str	r3, [fp, #-16]
 c1cc4b0:	ea000002 	b	c1cc4c0 <ic_conf_irq+0x74>
	else
		//COMPLETAR: poner la linea IRQ en modo no vectorizado
		conf |= 1 << 2;
 c1cc4b4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc4b8:	e3833004 	orr	r3, r3, #4
 c1cc4bc:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c1cc4c0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc4c4:	e3530001 	cmp	r3, #1
 c1cc4c8:	1a000003 	bne	c1cc4dc <ic_conf_irq+0x90>
		//COMPLETAR: habilitar la linea IRQ
		conf &= ~(1 << 1);
 c1cc4cc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc4d0:	e3c33002 	bic	r3, r3, #2
 c1cc4d4:	e50b3010 	str	r3, [fp, #-16]
 c1cc4d8:	ea000002 	b	c1cc4e8 <ic_conf_irq+0x9c>
	else
		//COMPLETAR: deshabilitar la linea IRQ
		conf |= 1 << 1;
 c1cc4dc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc4e0:	e3833002 	orr	r3, r3, #2
 c1cc4e4:	e50b3010 	str	r3, [fp, #-16]

	rINTCON = conf;
 c1cc4e8:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c1cc4ec:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc4f0:	e5832000 	str	r2, [r3]
	return 0;
 c1cc4f4:	e3a03000 	mov	r3, #0
}
 c1cc4f8:	e1a00003 	mov	r0, r3
 c1cc4fc:	e24bd00c 	sub	sp, fp, #12
 c1cc500:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc504:	e12fff1e 	bx	lr

0c1cc508 <ic_conf_fiq>:

int ic_conf_fiq(enum enable st)
{
 c1cc508:	e1a0c00d 	mov	ip, sp
 c1cc50c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc510:	e24cb004 	sub	fp, ip, #4
 c1cc514:	e24dd010 	sub	sp, sp, #16
 c1cc518:	e1a03000 	mov	r3, r0
 c1cc51c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c1cc520:	e3a03000 	mov	r3, #0
 c1cc524:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c1cc528:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc52c:	e3530001 	cmp	r3, #1
 c1cc530:	1a000005 	bne	c1cc54c <ic_conf_fiq+0x44>
		//COMPLETAR: habilitar la linea FIQ
		rINTCON &= ~(1 << 0);
 c1cc534:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c1cc538:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c1cc53c:	e5922000 	ldr	r2, [r2]
 c1cc540:	e3c22001 	bic	r2, r2, #1
 c1cc544:	e5832000 	str	r2, [r3]
 c1cc548:	ea00000a 	b	c1cc578 <ic_conf_fiq+0x70>
	else if (st == DISABLE)
 c1cc54c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc550:	e3530000 	cmp	r3, #0
 c1cc554:	1a000005 	bne	c1cc570 <ic_conf_fiq+0x68>
		//COMPLETAR: deshabilitar la linea FIQ
		rINTCON |= 1 << 0;
 c1cc558:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c1cc55c:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c1cc560:	e5922000 	ldr	r2, [r2]
 c1cc564:	e3822001 	orr	r2, r2, #1
 c1cc568:	e5832000 	str	r2, [r3]
 c1cc56c:	ea000001 	b	c1cc578 <ic_conf_fiq+0x70>
	else
		ret = -1;
 c1cc570:	e3e03000 	mvn	r3, #0
 c1cc574:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c1cc578:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1cc57c:	e1a00003 	mov	r0, r3
 c1cc580:	e24bd00c 	sub	sp, fp, #12
 c1cc584:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc588:	e12fff1e 	bx	lr

0c1cc58c <ic_conf_line>:

int ic_conf_line(enum int_line line, enum int_mode mode)
{
 c1cc58c:	e1a0c00d 	mov	ip, sp
 c1cc590:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc594:	e24cb004 	sub	fp, ip, #4
 c1cc598:	e24dd010 	sub	sp, sp, #16
 c1cc59c:	e1a02000 	mov	r2, r0
 c1cc5a0:	e1a03001 	mov	r3, r1
 c1cc5a4:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c1cc5a8:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	unsigned int bit = INT_BIT(line);
 c1cc5ac:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc5b0:	e3a02001 	mov	r2, #1
 c1cc5b4:	e1a03312 	lsl	r3, r2, r3
 c1cc5b8:	e50b3010 	str	r3, [fp, #-16]

	if (line < 0 || line > 26)
 c1cc5bc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc5c0:	e353001a 	cmp	r3, #26
 c1cc5c4:	9a000001 	bls	c1cc5d0 <ic_conf_line+0x44>
		return -1;
 c1cc5c8:	e3e03000 	mvn	r3, #0
 c1cc5cc:	ea000019 	b	c1cc638 <ic_conf_line+0xac>

	if (mode != IRQ && mode != FIQ)
 c1cc5d0:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cc5d4:	e3530000 	cmp	r3, #0
 c1cc5d8:	0a000004 	beq	c1cc5f0 <ic_conf_line+0x64>
 c1cc5dc:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cc5e0:	e3530001 	cmp	r3, #1
 c1cc5e4:	0a000001 	beq	c1cc5f0 <ic_conf_line+0x64>
		return -1;
 c1cc5e8:	e3e03000 	mvn	r3, #0
 c1cc5ec:	ea000011 	b	c1cc638 <ic_conf_line+0xac>

	if (mode == IRQ)
 c1cc5f0:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cc5f4:	e3530000 	cmp	r3, #0
 c1cc5f8:	1a000007 	bne	c1cc61c <ic_conf_line+0x90>
		//COMPLETAR: poner la linea line en modo IRQ
		rINTMOD &= ~bit;
 c1cc5fc:	e59f3044 	ldr	r3, [pc, #68]	; c1cc648 <ic_conf_line+0xbc>
 c1cc600:	e59f2040 	ldr	r2, [pc, #64]	; c1cc648 <ic_conf_line+0xbc>
 c1cc604:	e5921000 	ldr	r1, [r2]
 c1cc608:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc60c:	e1e02002 	mvn	r2, r2
 c1cc610:	e0012002 	and	r2, r1, r2
 c1cc614:	e5832000 	str	r2, [r3]
 c1cc618:	ea000005 	b	c1cc634 <ic_conf_line+0xa8>
	else
		//COMPLETAR: poner la linea line en modo FIQ
		rINTMOD |= bit;
 c1cc61c:	e59f3024 	ldr	r3, [pc, #36]	; c1cc648 <ic_conf_line+0xbc>
 c1cc620:	e59f2020 	ldr	r2, [pc, #32]	; c1cc648 <ic_conf_line+0xbc>
 c1cc624:	e5921000 	ldr	r1, [r2]
 c1cc628:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc62c:	e1812002 	orr	r2, r1, r2
 c1cc630:	e5832000 	str	r2, [r3]
	return 0;
 c1cc634:	e3a03000 	mov	r3, #0
}
 c1cc638:	e1a00003 	mov	r0, r3
 c1cc63c:	e24bd00c 	sub	sp, fp, #12
 c1cc640:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc644:	e12fff1e 	bx	lr
 c1cc648:	01e00008 	.word	0x01e00008

0c1cc64c <ic_enable>:

int ic_enable(enum int_line line)
{
 c1cc64c:	e1a0c00d 	mov	ip, sp
 c1cc650:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc654:	e24cb004 	sub	fp, ip, #4
 c1cc658:	e24dd008 	sub	sp, sp, #8
 c1cc65c:	e1a03000 	mov	r3, r0
 c1cc660:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c1cc664:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cc668:	e353001a 	cmp	r3, #26
 c1cc66c:	9a000001 	bls	c1cc678 <ic_enable+0x2c>
		return -1;
 c1cc670:	e3e03000 	mvn	r3, #0
 c1cc674:	ea000009 	b	c1cc6a0 <ic_enable+0x54>

	//COMPLETAR: habilitar las interrupciones por la linea line
	rINTMSK &= ~(1 << line);
 c1cc678:	e59f3030 	ldr	r3, [pc, #48]	; c1cc6b0 <ic_enable+0x64>
 c1cc67c:	e59f202c 	ldr	r2, [pc, #44]	; c1cc6b0 <ic_enable+0x64>
 c1cc680:	e5921000 	ldr	r1, [r2]
 c1cc684:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cc688:	e3a00001 	mov	r0, #1
 c1cc68c:	e1a02210 	lsl	r2, r0, r2
 c1cc690:	e1e02002 	mvn	r2, r2
 c1cc694:	e0012002 	and	r2, r1, r2
 c1cc698:	e5832000 	str	r2, [r3]
	return 0;
 c1cc69c:	e3a03000 	mov	r3, #0
}
 c1cc6a0:	e1a00003 	mov	r0, r3
 c1cc6a4:	e24bd00c 	sub	sp, fp, #12
 c1cc6a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc6ac:	e12fff1e 	bx	lr
 c1cc6b0:	01e0000c 	.word	0x01e0000c

0c1cc6b4 <ic_disable>:

int ic_disable(enum int_line line)
{
 c1cc6b4:	e1a0c00d 	mov	ip, sp
 c1cc6b8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc6bc:	e24cb004 	sub	fp, ip, #4
 c1cc6c0:	e24dd008 	sub	sp, sp, #8
 c1cc6c4:	e1a03000 	mov	r3, r0
 c1cc6c8:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c1cc6cc:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cc6d0:	e353001a 	cmp	r3, #26
 c1cc6d4:	9a000001 	bls	c1cc6e0 <ic_disable+0x2c>
		return -1;
 c1cc6d8:	e3e03000 	mvn	r3, #0
 c1cc6dc:	ea000008 	b	c1cc704 <ic_disable+0x50>

	//COMPLETAR: enmascarar las interrupciones por la linea line
	rINTMSK |= 1 << line;
 c1cc6e0:	e59f302c 	ldr	r3, [pc, #44]	; c1cc714 <ic_disable+0x60>
 c1cc6e4:	e59f2028 	ldr	r2, [pc, #40]	; c1cc714 <ic_disable+0x60>
 c1cc6e8:	e5921000 	ldr	r1, [r2]
 c1cc6ec:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cc6f0:	e3a00001 	mov	r0, #1
 c1cc6f4:	e1a02210 	lsl	r2, r0, r2
 c1cc6f8:	e1812002 	orr	r2, r1, r2
 c1cc6fc:	e5832000 	str	r2, [r3]
	return 0;
 c1cc700:	e3a03000 	mov	r3, #0
}
 c1cc704:	e1a00003 	mov	r0, r3
 c1cc708:	e24bd00c 	sub	sp, fp, #12
 c1cc70c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc710:	e12fff1e 	bx	lr
 c1cc714:	01e0000c 	.word	0x01e0000c

0c1cc718 <ic_cleanflag>:

int ic_cleanflag(enum int_line line)
{
 c1cc718:	e1a0c00d 	mov	ip, sp
 c1cc71c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc720:	e24cb004 	sub	fp, ip, #4
 c1cc724:	e24dd010 	sub	sp, sp, #16
 c1cc728:	e1a03000 	mov	r3, r0
 c1cc72c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int bit;

	if (line < 0 || line > 26)
 c1cc730:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc734:	e353001a 	cmp	r3, #26
 c1cc738:	9a000001 	bls	c1cc744 <ic_cleanflag+0x2c>
		return -1;
 c1cc73c:	e3e03000 	mvn	r3, #0
 c1cc740:	ea000017 	b	c1cc7a4 <ic_cleanflag+0x8c>

	bit = INT_BIT(line);
 c1cc744:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cc748:	e3a02001 	mov	r2, #1
 c1cc74c:	e1a03312 	lsl	r3, r2, r3
 c1cc750:	e50b3010 	str	r3, [fp, #-16]

	if (rINTMOD & bit)
 c1cc754:	e59f3058 	ldr	r3, [pc, #88]	; c1cc7b4 <ic_cleanflag+0x9c>
 c1cc758:	e5932000 	ldr	r2, [r3]
 c1cc75c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cc760:	e0023003 	and	r3, r2, r3
 c1cc764:	e3530000 	cmp	r3, #0
 c1cc768:	0a000006 	beq	c1cc788 <ic_cleanflag+0x70>
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por FIQ
		rF_ISPC |= bit;
 c1cc76c:	e59f3044 	ldr	r3, [pc, #68]	; c1cc7b8 <ic_cleanflag+0xa0>
 c1cc770:	e59f2040 	ldr	r2, [pc, #64]	; c1cc7b8 <ic_cleanflag+0xa0>
 c1cc774:	e5921000 	ldr	r1, [r2]
 c1cc778:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc77c:	e1812002 	orr	r2, r1, r2
 c1cc780:	e5832000 	str	r2, [r3]
 c1cc784:	ea000005 	b	c1cc7a0 <ic_cleanflag+0x88>
	else
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por IRQ
		rI_ISPC |= bit;
 c1cc788:	e59f302c 	ldr	r3, [pc, #44]	; c1cc7bc <ic_cleanflag+0xa4>
 c1cc78c:	e59f2028 	ldr	r2, [pc, #40]	; c1cc7bc <ic_cleanflag+0xa4>
 c1cc790:	e5921000 	ldr	r1, [r2]
 c1cc794:	e51b2010 	ldr	r2, [fp, #-16]
 c1cc798:	e1812002 	orr	r2, r1, r2
 c1cc79c:	e5832000 	str	r2, [r3]
	return 0;
 c1cc7a0:	e3a03000 	mov	r3, #0
}
 c1cc7a4:	e1a00003 	mov	r0, r3
 c1cc7a8:	e24bd00c 	sub	sp, fp, #12
 c1cc7ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cc7b0:	e12fff1e 	bx	lr
 c1cc7b4:	01e00008 	.word	0x01e00008
 c1cc7b8:	01e0003c 	.word	0x01e0003c
 c1cc7bc:	01e00024 	.word	0x01e00024

0c1cc7c0 <kb_scan>:
/*--- Variables globales ---*/
volatile static unsigned char *keyboard_base = (unsigned char *)0x06000000;


int kb_scan(void)
{
 c1cc7c0:	e1a0c00d 	mov	ip, sp
 c1cc7c4:	e92dd810 	push	{r4, fp, ip, lr, pc}
 c1cc7c8:	e24cb004 	sub	fp, ip, #4
 c1cc7cc:	e24dd064 	sub	sp, sp, #100	; 0x64
	int value = -1;
 c1cc7d0:	e3e03000 	mvn	r3, #0
 c1cc7d4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	int i;
	char temp;
	int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};
 c1cc7d8:	e59f3178 	ldr	r3, [pc, #376]	; c1cc958 <kb_scan+0x198>
 c1cc7dc:	e24bc030 	sub	ip, fp, #48	; 0x30
 c1cc7e0:	e893000f 	ldm	r3, {r0, r1, r2, r3}
 c1cc7e4:	e88c000f 	stm	ip, {r0, r1, r2, r3}
	int map[4][4] = {{0, 1, 2, 3},
 c1cc7e8:	e59f316c 	ldr	r3, [pc, #364]	; c1cc95c <kb_scan+0x19c>
 c1cc7ec:	e24bc070 	sub	ip, fp, #112	; 0x70
 c1cc7f0:	e1a04003 	mov	r4, r3
 c1cc7f4:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c1cc7f8:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c1cc7fc:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c1cc800:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c1cc804:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c1cc808:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c1cc80c:	e894000f 	ldm	r4, {r0, r1, r2, r3}
 c1cc810:	e88c000f 	stm	ip, {r0, r1, r2, r3}
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c1cc814:	e3a03000 	mov	r3, #0
 c1cc818:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1cc81c:	ea000042 	b	c1cc92c <kb_scan+0x16c>
		temp = *(keyboard_base+lines[i]);
 c1cc820:	e59f3138 	ldr	r3, [pc, #312]	; c1cc960 <kb_scan+0x1a0>
 c1cc824:	e5932000 	ldr	r2, [r3]
 c1cc828:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c1cc82c:	e3e0301b 	mvn	r3, #27
 c1cc830:	e1a01101 	lsl	r1, r1, #2
 c1cc834:	e24b0014 	sub	r0, fp, #20
 c1cc838:	e0801001 	add	r1, r0, r1
 c1cc83c:	e0813003 	add	r3, r1, r3
 c1cc840:	e5933000 	ldr	r3, [r3]
 c1cc844:	e0823003 	add	r3, r2, r3
 c1cc848:	e5d33000 	ldrb	r3, [r3]
 c1cc84c:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3

		if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {
 c1cc850:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c1cc854:	e203300f 	and	r3, r3, #15
 c1cc858:	e353000f 	cmp	r3, #15
 c1cc85c:	0a00002f 	beq	c1cc920 <kb_scan+0x160>
			//COMPLETAR: 
			//      si estÃ¡ el bit 1 a 0 la tecla es la map[i][3]
			//      si estÃ¡ el bit 2 a 0 la tecla es la map[i][2]
			//      si estÃ¡ el bit 3 a 0 la tecla es la map[i][1]
			//      si estÃ¡ el bit 4 a 0 la tecla es la map[i][0]
			if(!(temp & 1 << 0)) {
 c1cc860:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c1cc864:	e2033001 	and	r3, r3, #1
 c1cc868:	e3530000 	cmp	r3, #0
 c1cc86c:	1a000007 	bne	c1cc890 <kb_scan+0xd0>
				return map[i][3];
 c1cc870:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cc874:	e3e0304f 	mvn	r3, #79	; 0x4f
 c1cc878:	e1a02202 	lsl	r2, r2, #4
 c1cc87c:	e24b1014 	sub	r1, fp, #20
 c1cc880:	e0812002 	add	r2, r1, r2
 c1cc884:	e0823003 	add	r3, r2, r3
 c1cc888:	e5933000 	ldr	r3, [r3]
 c1cc88c:	ea00002d 	b	c1cc948 <kb_scan+0x188>
			}

			if(!(temp & 1 << 1)) {
 c1cc890:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c1cc894:	e2033002 	and	r3, r3, #2
 c1cc898:	e3530000 	cmp	r3, #0
 c1cc89c:	1a000007 	bne	c1cc8c0 <kb_scan+0x100>
				return map[i][2];
 c1cc8a0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cc8a4:	e3e03053 	mvn	r3, #83	; 0x53
 c1cc8a8:	e1a02202 	lsl	r2, r2, #4
 c1cc8ac:	e24b0014 	sub	r0, fp, #20
 c1cc8b0:	e0802002 	add	r2, r0, r2
 c1cc8b4:	e0823003 	add	r3, r2, r3
 c1cc8b8:	e5933000 	ldr	r3, [r3]
 c1cc8bc:	ea000021 	b	c1cc948 <kb_scan+0x188>
			}

			if(!(temp & 1 << 2)) {
 c1cc8c0:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c1cc8c4:	e2033004 	and	r3, r3, #4
 c1cc8c8:	e3530000 	cmp	r3, #0
 c1cc8cc:	1a000007 	bne	c1cc8f0 <kb_scan+0x130>
				return map[i][1];
 c1cc8d0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cc8d4:	e3e03057 	mvn	r3, #87	; 0x57
 c1cc8d8:	e1a02202 	lsl	r2, r2, #4
 c1cc8dc:	e24b1014 	sub	r1, fp, #20
 c1cc8e0:	e0812002 	add	r2, r1, r2
 c1cc8e4:	e0823003 	add	r3, r2, r3
 c1cc8e8:	e5933000 	ldr	r3, [r3]
 c1cc8ec:	ea000015 	b	c1cc948 <kb_scan+0x188>
			}

			if(!(temp & 1 << 3)) {
 c1cc8f0:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c1cc8f4:	e2033008 	and	r3, r3, #8
 c1cc8f8:	e3530000 	cmp	r3, #0
 c1cc8fc:	1a000007 	bne	c1cc920 <kb_scan+0x160>
				return map[i][0];
 c1cc900:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cc904:	e3e0305b 	mvn	r3, #91	; 0x5b
 c1cc908:	e1a02202 	lsl	r2, r2, #4
 c1cc90c:	e24b0014 	sub	r0, fp, #20
 c1cc910:	e0802002 	add	r2, r0, r2
 c1cc914:	e0823003 	add	r3, r2, r3
 c1cc918:	e5933000 	ldr	r3, [r3]
 c1cc91c:	ea000009 	b	c1cc948 <kb_scan+0x188>
	int map[4][4] = {{0, 1, 2, 3},
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c1cc920:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cc924:	e2833001 	add	r3, r3, #1
 c1cc928:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1cc92c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cc930:	e3530003 	cmp	r3, #3
 c1cc934:	ca000002 	bgt	c1cc944 <kb_scan+0x184>
 c1cc938:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cc93c:	e3730001 	cmn	r3, #1
 c1cc940:	0affffb6 	beq	c1cc820 <kb_scan+0x60>
			}

	}
	}

	return value;
 c1cc944:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
 c1cc948:	e1a00003 	mov	r0, r3
 c1cc94c:	e24bd010 	sub	sp, fp, #16
 c1cc950:	e89d6810 	ldm	sp, {r4, fp, sp, lr}
 c1cc954:	e12fff1e 	bx	lr
 c1cc958:	0c102094 	.word	0x0c102094
 c1cc95c:	0c1020a4 	.word	0x0c1020a4
 c1cc960:	0c100148 	.word	0x0c100148

0c1cc964 <lcd_init>:
static uint8 lcd_buffer[LCD_BUFFER_SIZE];

static uint8 state;

void lcd_init( void )
{
 c1cc964:	e1a0c00d 	mov	ip, sp
 c1cc968:	e92dd800 	push	{fp, ip, lr, pc}
 c1cc96c:	e24cb004 	sub	fp, ip, #4
	//Initialize dithering patterns to recommended patterns
	rDITHMODE = 0x12210;
 c1cc970:	e59f30fc 	ldr	r3, [pc, #252]	; c1cca74 <lcd_init+0x110>
 c1cc974:	e59f20fc 	ldr	r2, [pc, #252]	; c1cca78 <lcd_init+0x114>
 c1cc978:	e5832000 	str	r2, [r3]
	rDP1_2 = 0xA5A5;
 c1cc97c:	e59f30f8 	ldr	r3, [pc, #248]	; c1cca7c <lcd_init+0x118>
 c1cc980:	e59f20f8 	ldr	r2, [pc, #248]	; c1cca80 <lcd_init+0x11c>
 c1cc984:	e5832000 	str	r2, [r3]
	rDP4_7 = 0xBA5DA65;
 c1cc988:	e59f30f4 	ldr	r3, [pc, #244]	; c1cca84 <lcd_init+0x120>
 c1cc98c:	e59f20f4 	ldr	r2, [pc, #244]	; c1cca88 <lcd_init+0x124>
 c1cc990:	e5832000 	str	r2, [r3]
	rDP3_5 = 0xA5A5F;
 c1cc994:	e59f30f0 	ldr	r3, [pc, #240]	; c1cca8c <lcd_init+0x128>
 c1cc998:	e59f20f0 	ldr	r2, [pc, #240]	; c1cca90 <lcd_init+0x12c>
 c1cc99c:	e5832000 	str	r2, [r3]
	rDP2_3 = 0xD6B;
 c1cc9a0:	e59f30ec 	ldr	r3, [pc, #236]	; c1cca94 <lcd_init+0x130>
 c1cc9a4:	e59f20ec 	ldr	r2, [pc, #236]	; c1cca98 <lcd_init+0x134>
 c1cc9a8:	e5832000 	str	r2, [r3]
	rDP5_7 = 0xEB7B5ED;
 c1cc9ac:	e59f30e8 	ldr	r3, [pc, #232]	; c1cca9c <lcd_init+0x138>
 c1cc9b0:	e59f20e8 	ldr	r2, [pc, #232]	; c1ccaa0 <lcd_init+0x13c>
 c1cc9b4:	e5832000 	str	r2, [r3]
	rDP3_4 = 0x7DBE;
 c1cc9b8:	e59f30e4 	ldr	r3, [pc, #228]	; c1ccaa4 <lcd_init+0x140>
 c1cc9bc:	e59f20e4 	ldr	r2, [pc, #228]	; c1ccaa8 <lcd_init+0x144>
 c1cc9c0:	e5832000 	str	r2, [r3]
	rDP4_5 = 0x7EBDF;
 c1cc9c4:	e59f30e0 	ldr	r3, [pc, #224]	; c1ccaac <lcd_init+0x148>
 c1cc9c8:	e59f20e0 	ldr	r2, [pc, #224]	; c1ccab0 <lcd_init+0x14c>
 c1cc9cc:	e5832000 	str	r2, [r3]
	rDP6_7 = 0x7FDFBFE;
 c1cc9d0:	e59f30dc 	ldr	r3, [pc, #220]	; c1ccab4 <lcd_init+0x150>
 c1cc9d4:	e59f20dc 	ldr	r2, [pc, #220]	; c1ccab8 <lcd_init+0x154>
 c1cc9d8:	e5832000 	str	r2, [r3]

	//Zero, black and white LCD
    rREDLUT   = 0;
 c1cc9dc:	e59f30d8 	ldr	r3, [pc, #216]	; c1ccabc <lcd_init+0x158>
 c1cc9e0:	e3a02000 	mov	r2, #0
 c1cc9e4:	e5832000 	str	r2, [r3]
    rGREENLUT = 0;
 c1cc9e8:	e59f30d0 	ldr	r3, [pc, #208]	; c1ccac0 <lcd_init+0x15c>
 c1cc9ec:	e3a02000 	mov	r2, #0
 c1cc9f0:	e5832000 	str	r2, [r3]
    rBLUELUT  = 0;
 c1cc9f4:	e59f30c8 	ldr	r3, [pc, #200]	; c1ccac4 <lcd_init+0x160>
 c1cc9f8:	e3a02000 	mov	r2, #0
 c1cc9fc:	e5832000 	str	r2, [r3]
    //LCDCON1[3]     = 0   no invierte la señal VLINE
    //LCDCON1[4]     = 0   las señales de vídeo se muestrean a flanco de bajada
    //LCDCON1[9:8]   = 0   WDLY = 4 ciclos (minimum blanking)
    //LCDCON1[11:10] = 0   WLH = 4 ciclos  (minimum blanking)
    //LCDCON1[21:12] = 28  CLKVAL = 28 => tFRAME = 59,4 Hz
    rLCDCON1  = 0x1C020;
 c1cca00:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c1cca04:	e59f20bc 	ldr	r2, [pc, #188]	; c1ccac8 <lcd_init+0x164>
 c1cca08:	e5832000 	str	r2, [r3]

    //LCDCON2[31:21] =  0 LINEBLANK = 0 ciclos (minimum horizontal blanking
    //LCDCON2[20:10] = 79   HOZVAL = (320 / 4)  1 (Horizontal resolution)
    //LCDCON2[9:0]   = 239  LINEVAL = 240  1 (Vertical resolution)
    rLCDCON2  = 0x13CEF;
 c1cca0c:	e59f30b8 	ldr	r3, [pc, #184]	; c1ccacc <lcd_init+0x168>
 c1cca10:	e59f20b8 	ldr	r2, [pc, #184]	; c1ccad0 <lcd_init+0x16c>
 c1cca14:	e5832000 	str	r2, [r3]

    //LCDCON3[0] = 0  Disable self refresh
    rLCDCON3  = 0;
 c1cca18:	e59f30b4 	ldr	r3, [pc, #180]	; c1ccad4 <lcd_init+0x170>
 c1cca1c:	e3a02000 	mov	r2, #0
 c1cca20:	e5832000 	str	r2, [r3]

    //Start of lcd_buffer
    rLCDSADDR1 = (2 << 27) | ((uint32)lcd_buffer >> 1);
 c1cca24:	e59f30ac 	ldr	r3, [pc, #172]	; c1ccad8 <lcd_init+0x174>
 c1cca28:	e59f20ac 	ldr	r2, [pc, #172]	; c1ccadc <lcd_init+0x178>
 c1cca2c:	e1a020a2 	lsr	r2, r2, #1
 c1cca30:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
 c1cca34:	e5832000 	str	r2, [r3]

    //End of lcd_buffer
    rLCDSADDR2 = (1 << 29) | (((uint32)lcd_buffer + LCD_BUFFER_SIZE) & 0x3FFFFF) >> 1;
 c1cca38:	e59f20a0 	ldr	r2, [pc, #160]	; c1ccae0 <lcd_init+0x17c>
 c1cca3c:	e59f3098 	ldr	r3, [pc, #152]	; c1ccadc <lcd_init+0x178>
 c1cca40:	e2833c96 	add	r3, r3, #38400	; 0x9600
 c1cca44:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c1cca48:	e3c33503 	bic	r3, r3, #12582912	; 0xc00000
 c1cca4c:	e1a030a3 	lsr	r3, r3, #1
 c1cca50:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
 c1cca54:	e5823000 	str	r3, [r2]

    //No virtual screen
    //LCDSADDR3[19:9] = 0 OFFSIZE = 0
    //LCDSADDR3[8:0] = 80 PAGEWIDTH = HOZVAL + 1 = 320 / 4
    rLCDSADDR3 = 0x50;
 c1cca58:	e59f3084 	ldr	r3, [pc, #132]	; c1ccae4 <lcd_init+0x180>
 c1cca5c:	e3a02050 	mov	r2, #80	; 0x50
 c1cca60:	e5832000 	str	r2, [r3]

    lcd_off();
 c1cca64:	eb00002e 	bl	c1ccb24 <lcd_off>
}
 c1cca68:	e24bd00c 	sub	sp, fp, #12
 c1cca6c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cca70:	e12fff1e 	bx	lr
 c1cca74:	01f00044 	.word	0x01f00044
 c1cca78:	00012210 	.word	0x00012210
 c1cca7c:	01f00020 	.word	0x01f00020
 c1cca80:	0000a5a5 	.word	0x0000a5a5
 c1cca84:	01f00024 	.word	0x01f00024
 c1cca88:	0ba5da65 	.word	0x0ba5da65
 c1cca8c:	01f00028 	.word	0x01f00028
 c1cca90:	000a5a5f 	.word	0x000a5a5f
 c1cca94:	01f0002c 	.word	0x01f0002c
 c1cca98:	00000d6b 	.word	0x00000d6b
 c1cca9c:	01f00030 	.word	0x01f00030
 c1ccaa0:	0eb7b5ed 	.word	0x0eb7b5ed
 c1ccaa4:	01f00034 	.word	0x01f00034
 c1ccaa8:	00007dbe 	.word	0x00007dbe
 c1ccaac:	01f00038 	.word	0x01f00038
 c1ccab0:	0007ebdf 	.word	0x0007ebdf
 c1ccab4:	01f0003c 	.word	0x01f0003c
 c1ccab8:	07fdfbfe 	.word	0x07fdfbfe
 c1ccabc:	01f00014 	.word	0x01f00014
 c1ccac0:	01f00018 	.word	0x01f00018
 c1ccac4:	01f0001c 	.word	0x01f0001c
 c1ccac8:	0001c020 	.word	0x0001c020
 c1ccacc:	01f00004 	.word	0x01f00004
 c1ccad0:	00013cef 	.word	0x00013cef
 c1ccad4:	01f00040 	.word	0x01f00040
 c1ccad8:	01f00008 	.word	0x01f00008
 c1ccadc:	0c1022e8 	.word	0x0c1022e8
 c1ccae0:	01f0000c 	.word	0x01f0000c
 c1ccae4:	01f00010 	.word	0x01f00010

0c1ccae8 <lcd_on>:

void lcd_on( void )
{
 c1ccae8:	e1a0c00d 	mov	ip, sp
 c1ccaec:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccaf0:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 |= 1;
 c1ccaf4:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c1ccaf8:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c1ccafc:	e5922000 	ldr	r2, [r2]
 c1ccb00:	e3822001 	orr	r2, r2, #1
 c1ccb04:	e5832000 	str	r2, [r3]
	state = 1;
 c1ccb08:	e59f3010 	ldr	r3, [pc, #16]	; c1ccb20 <lcd_on+0x38>
 c1ccb0c:	e3a02001 	mov	r2, #1
 c1ccb10:	e5c32000 	strb	r2, [r3]
}
 c1ccb14:	e24bd00c 	sub	sp, fp, #12
 c1ccb18:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccb1c:	e12fff1e 	bx	lr
 c1ccb20:	0c10b8e8 	.word	0x0c10b8e8

0c1ccb24 <lcd_off>:

void lcd_off( void )
{
 c1ccb24:	e1a0c00d 	mov	ip, sp
 c1ccb28:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccb2c:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 &= ~1;
 c1ccb30:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c1ccb34:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c1ccb38:	e5922000 	ldr	r2, [r2]
 c1ccb3c:	e3c22001 	bic	r2, r2, #1
 c1ccb40:	e5832000 	str	r2, [r3]
	state = 0;
 c1ccb44:	e59f3010 	ldr	r3, [pc, #16]	; c1ccb5c <lcd_off+0x38>
 c1ccb48:	e3a02000 	mov	r2, #0
 c1ccb4c:	e5c32000 	strb	r2, [r3]
}
 c1ccb50:	e24bd00c 	sub	sp, fp, #12
 c1ccb54:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccb58:	e12fff1e 	bx	lr
 c1ccb5c:	0c10b8e8 	.word	0x0c10b8e8

0c1ccb60 <lcd_status>:

uint8 lcd_status( void )
{
 c1ccb60:	e1a0c00d 	mov	ip, sp
 c1ccb64:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccb68:	e24cb004 	sub	fp, ip, #4
	return state;
 c1ccb6c:	e59f3010 	ldr	r3, [pc, #16]	; c1ccb84 <lcd_status+0x24>
 c1ccb70:	e5d33000 	ldrb	r3, [r3]
}
 c1ccb74:	e1a00003 	mov	r0, r3
 c1ccb78:	e24bd00c 	sub	sp, fp, #12
 c1ccb7c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccb80:	e12fff1e 	bx	lr
 c1ccb84:	0c10b8e8 	.word	0x0c10b8e8

0c1ccb88 <lcd_clear>:

void lcd_clear( void )
{
 c1ccb88:	e1a0c00d 	mov	ip, sp
 c1ccb8c:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccb90:	e24cb004 	sub	fp, ip, #4
 c1ccb94:	e24dd008 	sub	sp, sp, #8
	uint16 i = 0;
 c1ccb98:	e3a03000 	mov	r3, #0
 c1ccb9c:	e14b30be 	strh	r3, [fp, #-14]
    while(i < LCD_BUFFER_SIZE) {
 c1ccba0:	ea000006 	b	c1ccbc0 <lcd_clear+0x38>
    	lcd_buffer[i] = 0x0;
 c1ccba4:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccba8:	e59f202c 	ldr	r2, [pc, #44]	; c1ccbdc <lcd_clear+0x54>
 c1ccbac:	e3a01000 	mov	r1, #0
 c1ccbb0:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c1ccbb4:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccbb8:	e2833001 	add	r3, r3, #1
 c1ccbbc:	e14b30be 	strh	r3, [fp, #-14]
}

void lcd_clear( void )
{
	uint16 i = 0;
    while(i < LCD_BUFFER_SIZE) {
 c1ccbc0:	e15b20be 	ldrh	r2, [fp, #-14]
 c1ccbc4:	e59f3014 	ldr	r3, [pc, #20]	; c1ccbe0 <lcd_clear+0x58>
 c1ccbc8:	e1520003 	cmp	r2, r3
 c1ccbcc:	9afffff4 	bls	c1ccba4 <lcd_clear+0x1c>
    	lcd_buffer[i] = 0x0;
    	i++;
    }
}
 c1ccbd0:	e24bd00c 	sub	sp, fp, #12
 c1ccbd4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccbd8:	e12fff1e 	bx	lr
 c1ccbdc:	0c1022e8 	.word	0x0c1022e8
 c1ccbe0:	000095ff 	.word	0x000095ff

0c1ccbe4 <lcd_clear_color>:

void lcd_clear_color( uint8 color )
{
 c1ccbe4:	e1a0c00d 	mov	ip, sp
 c1ccbe8:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccbec:	e24cb004 	sub	fp, ip, #4
 c1ccbf0:	e24dd010 	sub	sp, sp, #16
 c1ccbf4:	e1a03000 	mov	r3, r0
 c1ccbf8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	uint16 i = 0;
 c1ccbfc:	e3a03000 	mov	r3, #0
 c1ccc00:	e14b30be 	strh	r3, [fp, #-14]
	uint8 c = color & 0xf;
 c1ccc04:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1ccc08:	e203300f 	and	r3, r3, #15
 c1ccc0c:	e54b300f 	strb	r3, [fp, #-15]

    while(i < LCD_BUFFER_SIZE) {
 c1ccc10:	ea00000c 	b	c1ccc48 <lcd_clear_color+0x64>
    	lcd_buffer[i] = (c << 4) | c;
 c1ccc14:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccc18:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ccc1c:	e1a02202 	lsl	r2, r2, #4
 c1ccc20:	e20210ff 	and	r1, r2, #255	; 0xff
 c1ccc24:	e55b200f 	ldrb	r2, [fp, #-15]
 c1ccc28:	e1812002 	orr	r2, r1, r2
 c1ccc2c:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ccc30:	e20210ff 	and	r1, r2, #255	; 0xff
 c1ccc34:	e59f2028 	ldr	r2, [pc, #40]	; c1ccc64 <lcd_clear_color+0x80>
 c1ccc38:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c1ccc3c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccc40:	e2833001 	add	r3, r3, #1
 c1ccc44:	e14b30be 	strh	r3, [fp, #-14]
void lcd_clear_color( uint8 color )
{
	uint16 i = 0;
	uint8 c = color & 0xf;

    while(i < LCD_BUFFER_SIZE) {
 c1ccc48:	e15b20be 	ldrh	r2, [fp, #-14]
 c1ccc4c:	e59f3014 	ldr	r3, [pc, #20]	; c1ccc68 <lcd_clear_color+0x84>
 c1ccc50:	e1520003 	cmp	r2, r3
 c1ccc54:	9affffee 	bls	c1ccc14 <lcd_clear_color+0x30>
    	lcd_buffer[i] = (c << 4) | c;
    	i++;
    }
}
 c1ccc58:	e24bd00c 	sub	sp, fp, #12
 c1ccc5c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccc60:	e12fff1e 	bx	lr
 c1ccc64:	0c1022e8 	.word	0x0c1022e8
 c1ccc68:	000095ff 	.word	0x000095ff

0c1ccc6c <lcd_putpixel>:


void lcd_putpixel( uint16 x, uint16 y, uint8 c)
{
 c1ccc6c:	e1a0c00d 	mov	ip, sp
 c1ccc70:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccc74:	e24cb004 	sub	fp, ip, #4
 c1ccc78:	e24dd010 	sub	sp, sp, #16
 c1ccc7c:	e1a03002 	mov	r3, r2
 c1ccc80:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c1ccc84:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c1ccc88:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    uint8 byte, bit;
    uint16 i;

    i = x/2 + y*(LCD_WIDTH/2);
 c1ccc8c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1ccc90:	e1a030a3 	lsr	r3, r3, #1
 c1ccc94:	e1a03803 	lsl	r3, r3, #16
 c1ccc98:	e1a02823 	lsr	r2, r3, #16
 c1ccc9c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1ccca0:	e1a01003 	mov	r1, r3
 c1ccca4:	e1a01101 	lsl	r1, r1, #2
 c1ccca8:	e0813003 	add	r3, r1, r3
 c1cccac:	e1a03283 	lsl	r3, r3, #5
 c1cccb0:	e1a03803 	lsl	r3, r3, #16
 c1cccb4:	e1a03823 	lsr	r3, r3, #16
 c1cccb8:	e0823003 	add	r3, r2, r3
 c1cccbc:	e14b30be 	strh	r3, [fp, #-14]
    bit = (1-x%2)*4;
 c1cccc0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cccc4:	e2033001 	and	r3, r3, #1
 c1cccc8:	e3530000 	cmp	r3, #0
 c1ccccc:	1a000001 	bne	c1cccd8 <lcd_putpixel+0x6c>
 c1cccd0:	e3a03004 	mov	r3, #4
 c1cccd4:	ea000000 	b	c1cccdc <lcd_putpixel+0x70>
 c1cccd8:	e3a03000 	mov	r3, #0
 c1cccdc:	e54b300f 	strb	r3, [fp, #-15]

    byte = lcd_buffer[i];
 c1ccce0:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccce4:	e59f2068 	ldr	r2, [pc, #104]	; c1ccd54 <lcd_putpixel+0xe8>
 c1ccce8:	e7d23003 	ldrb	r3, [r2, r3]
 c1cccec:	e54b3010 	strb	r3, [fp, #-16]
    byte &= ~(0xF << bit);
 c1cccf0:	e55b300f 	ldrb	r3, [fp, #-15]
 c1cccf4:	e3a0200f 	mov	r2, #15
 c1cccf8:	e1a03312 	lsl	r3, r2, r3
 c1cccfc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ccd00:	e1e03003 	mvn	r3, r3
 c1ccd04:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ccd08:	e55b3010 	ldrb	r3, [fp, #-16]
 c1ccd0c:	e0023003 	and	r3, r2, r3
 c1ccd10:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ccd14:	e54b3010 	strb	r3, [fp, #-16]
    byte |= c << bit;
 c1ccd18:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
 c1ccd1c:	e55b300f 	ldrb	r3, [fp, #-15]
 c1ccd20:	e1a03312 	lsl	r3, r2, r3
 c1ccd24:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ccd28:	e55b3010 	ldrb	r3, [fp, #-16]
 c1ccd2c:	e1823003 	orr	r3, r2, r3
 c1ccd30:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ccd34:	e54b3010 	strb	r3, [fp, #-16]
    lcd_buffer[i] = byte;
 c1ccd38:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccd3c:	e59f2010 	ldr	r2, [pc, #16]	; c1ccd54 <lcd_putpixel+0xe8>
 c1ccd40:	e55b1010 	ldrb	r1, [fp, #-16]
 c1ccd44:	e7c21003 	strb	r1, [r2, r3]
}
 c1ccd48:	e24bd00c 	sub	sp, fp, #12
 c1ccd4c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccd50:	e12fff1e 	bx	lr
 c1ccd54:	0c1022e8 	.word	0x0c1022e8

0c1ccd58 <lcd_getpixel>:

uint8 lcd_getpixel( uint16 x, uint16 y )
{
 c1ccd58:	e1a0c00d 	mov	ip, sp
 c1ccd5c:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccd60:	e24cb004 	sub	fp, ip, #4
 c1ccd64:	e24dd010 	sub	sp, sp, #16
 c1ccd68:	e1a02000 	mov	r2, r0
 c1ccd6c:	e1a03001 	mov	r3, r1
 c1ccd70:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c1ccd74:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
	uint8 byte, bit;
	uint16 i = x/2 + y*(LCD_WIDTH/2);
 c1ccd78:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1ccd7c:	e1a030a3 	lsr	r3, r3, #1
 c1ccd80:	e1a03803 	lsl	r3, r3, #16
 c1ccd84:	e1a02823 	lsr	r2, r3, #16
 c1ccd88:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1ccd8c:	e1a01003 	mov	r1, r3
 c1ccd90:	e1a01101 	lsl	r1, r1, #2
 c1ccd94:	e0813003 	add	r3, r1, r3
 c1ccd98:	e1a03283 	lsl	r3, r3, #5
 c1ccd9c:	e1a03803 	lsl	r3, r3, #16
 c1ccda0:	e1a03823 	lsr	r3, r3, #16
 c1ccda4:	e0823003 	add	r3, r2, r3
 c1ccda8:	e14b30be 	strh	r3, [fp, #-14]

	bit = (1-x%2)*4;
 c1ccdac:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1ccdb0:	e2033001 	and	r3, r3, #1
 c1ccdb4:	e3530000 	cmp	r3, #0
 c1ccdb8:	1a000001 	bne	c1ccdc4 <lcd_getpixel+0x6c>
 c1ccdbc:	e3a03004 	mov	r3, #4
 c1ccdc0:	ea000000 	b	c1ccdc8 <lcd_getpixel+0x70>
 c1ccdc4:	e3a03000 	mov	r3, #0
 c1ccdc8:	e54b300f 	strb	r3, [fp, #-15]
	byte = lcd_buffer[i];
 c1ccdcc:	e15b30be 	ldrh	r3, [fp, #-14]
 c1ccdd0:	e59f202c 	ldr	r2, [pc, #44]	; c1cce04 <lcd_getpixel+0xac>
 c1ccdd4:	e7d23003 	ldrb	r3, [r2, r3]
 c1ccdd8:	e54b3010 	strb	r3, [fp, #-16]

	return (byte >> bit ) & 0xf;
 c1ccddc:	e55b2010 	ldrb	r2, [fp, #-16]
 c1ccde0:	e55b300f 	ldrb	r3, [fp, #-15]
 c1ccde4:	e1a03352 	asr	r3, r2, r3
 c1ccde8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ccdec:	e203300f 	and	r3, r3, #15
 c1ccdf0:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1ccdf4:	e1a00003 	mov	r0, r3
 c1ccdf8:	e24bd00c 	sub	sp, fp, #12
 c1ccdfc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cce00:	e12fff1e 	bx	lr
 c1cce04:	0c1022e8 	.word	0x0c1022e8

0c1cce08 <lcd_draw_hline>:

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
 c1cce08:	e1a0c00d 	mov	ip, sp
 c1cce0c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cce10:	e24cb004 	sub	fp, ip, #4
 c1cce14:	e24dd010 	sub	sp, sp, #16
 c1cce18:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c1cce1c:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c1cce20:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c1cce24:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c1cce28:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cce2c:	e50b3010 	str	r3, [fp, #-16]
 c1cce30:	ea000019 	b	c1cce9c <lcd_draw_hline+0x94>
		for(y_i = y; y_i < y + width; ++y_i)
 c1cce34:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c1cce38:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cce3c:	ea00000d 	b	c1cce78 <lcd_draw_hline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c1cce40:	e51b3010 	ldr	r3, [fp, #-16]
 c1cce44:	e1a03803 	lsl	r3, r3, #16
 c1cce48:	e1a01823 	lsr	r1, r3, #16
 c1cce4c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cce50:	e1a03803 	lsl	r3, r3, #16
 c1cce54:	e1a02823 	lsr	r2, r3, #16
 c1cce58:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c1cce5c:	e1a00001 	mov	r0, r1
 c1cce60:	e1a01002 	mov	r1, r2
 c1cce64:	e1a02003 	mov	r2, r3
 c1cce68:	ebffff7f 	bl	c1ccc6c <lcd_putpixel>

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
		for(y_i = y; y_i < y + width; ++y_i)
 c1cce6c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cce70:	e2833001 	add	r3, r3, #1
 c1cce74:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cce78:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c1cce7c:	e1db30b4 	ldrh	r3, [fp, #4]
 c1cce80:	e0822003 	add	r2, r2, r3
 c1cce84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cce88:	e1520003 	cmp	r2, r3
 c1cce8c:	caffffeb 	bgt	c1cce40 <lcd_draw_hline+0x38>
}

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c1cce90:	e51b3010 	ldr	r3, [fp, #-16]
 c1cce94:	e2833001 	add	r3, r3, #1
 c1cce98:	e50b3010 	str	r3, [fp, #-16]
 c1cce9c:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c1ccea0:	e51b3010 	ldr	r3, [fp, #-16]
 c1ccea4:	e1520003 	cmp	r2, r3
 c1ccea8:	aaffffe1 	bge	c1cce34 <lcd_draw_hline+0x2c>
		for(y_i = y; y_i < y + width; ++y_i)
			lcd_putpixel(x_i, y_i, color);
}
 c1cceac:	e24bd00c 	sub	sp, fp, #12
 c1cceb0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cceb4:	e12fff1e 	bx	lr

0c1cceb8 <lcd_draw_vline>:

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
 c1cceb8:	e1a0c00d 	mov	ip, sp
 c1ccebc:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccec0:	e24cb004 	sub	fp, ip, #4
 c1ccec4:	e24dd010 	sub	sp, sp, #16
 c1ccec8:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c1ccecc:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c1cced0:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c1cced4:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c1cced8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1ccedc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1ccee0:	ea000019 	b	c1ccf4c <lcd_draw_vline+0x94>
		for(x_i = x; x_i < x + width; ++x_i)
 c1ccee4:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c1ccee8:	e50b3010 	str	r3, [fp, #-16]
 c1cceec:	ea00000d 	b	c1ccf28 <lcd_draw_vline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c1ccef0:	e51b3010 	ldr	r3, [fp, #-16]
 c1ccef4:	e1a03803 	lsl	r3, r3, #16
 c1ccef8:	e1a01823 	lsr	r1, r3, #16
 c1ccefc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ccf00:	e1a03803 	lsl	r3, r3, #16
 c1ccf04:	e1a02823 	lsr	r2, r3, #16
 c1ccf08:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c1ccf0c:	e1a00001 	mov	r0, r1
 c1ccf10:	e1a01002 	mov	r1, r2
 c1ccf14:	e1a02003 	mov	r2, r3
 c1ccf18:	ebffff53 	bl	c1ccc6c <lcd_putpixel>

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
		for(x_i = x; x_i < x + width; ++x_i)
 c1ccf1c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ccf20:	e2833001 	add	r3, r3, #1
 c1ccf24:	e50b3010 	str	r3, [fp, #-16]
 c1ccf28:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c1ccf2c:	e1db30b4 	ldrh	r3, [fp, #4]
 c1ccf30:	e0822003 	add	r2, r2, r3
 c1ccf34:	e51b3010 	ldr	r3, [fp, #-16]
 c1ccf38:	e1520003 	cmp	r2, r3
 c1ccf3c:	caffffeb 	bgt	c1ccef0 <lcd_draw_vline+0x38>
}

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c1ccf40:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ccf44:	e2833001 	add	r3, r3, #1
 c1ccf48:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1ccf4c:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c1ccf50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ccf54:	e1520003 	cmp	r2, r3
 c1ccf58:	aaffffe1 	bge	c1ccee4 <lcd_draw_vline+0x2c>
		for(x_i = x; x_i < x + width; ++x_i)
			lcd_putpixel(x_i, y_i, color);
}
 c1ccf5c:	e24bd00c 	sub	sp, fp, #12
 c1ccf60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ccf64:	e12fff1e 	bx	lr

0c1ccf68 <lcd_draw_box>:

void lcd_draw_box( uint16 xleft, uint16 yup, uint16 xright, uint16 ydown, uint8 color, uint16 width )
{
 c1ccf68:	e1a0c00d 	mov	ip, sp
 c1ccf6c:	e92dd800 	push	{fp, ip, lr, pc}
 c1ccf70:	e24cb004 	sub	fp, ip, #4
 c1ccf74:	e24dd010 	sub	sp, sp, #16
 c1ccf78:	e14b00be 	strh	r0, [fp, #-14]
 c1ccf7c:	e14b11b0 	strh	r1, [fp, #-16]
 c1ccf80:	e14b21b2 	strh	r2, [fp, #-18]	; 0xffffffee
 c1ccf84:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
	lcd_draw_hline(xleft, xright, yup, color, width);
 c1ccf88:	e15b00be 	ldrh	r0, [fp, #-14]
 c1ccf8c:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c1ccf90:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1ccf94:	e5db3004 	ldrb	r3, [fp, #4]
 c1ccf98:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c1ccf9c:	e58dc000 	str	ip, [sp]
 c1ccfa0:	ebffff98 	bl	c1cce08 <lcd_draw_hline>
	lcd_draw_vline(yup, ydown, xleft, color, width);
 c1ccfa4:	e15b01b0 	ldrh	r0, [fp, #-16]
 c1ccfa8:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c1ccfac:	e15b20be 	ldrh	r2, [fp, #-14]
 c1ccfb0:	e5db3004 	ldrb	r3, [fp, #4]
 c1ccfb4:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c1ccfb8:	e58dc000 	str	ip, [sp]
 c1ccfbc:	ebffffbd 	bl	c1cceb8 <lcd_draw_vline>
	lcd_draw_vline(yup, ydown, xright - width + 1, color, width);
 c1ccfc0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1ccfc4:	e1db30b8 	ldrh	r3, [fp, #8]
 c1ccfc8:	e0633002 	rsb	r3, r3, r2
 c1ccfcc:	e1a03803 	lsl	r3, r3, #16
 c1ccfd0:	e1a03823 	lsr	r3, r3, #16
 c1ccfd4:	e2833001 	add	r3, r3, #1
 c1ccfd8:	e1a03803 	lsl	r3, r3, #16
 c1ccfdc:	e1a02823 	lsr	r2, r3, #16
 c1ccfe0:	e15b01b0 	ldrh	r0, [fp, #-16]
 c1ccfe4:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c1ccfe8:	e5db3004 	ldrb	r3, [fp, #4]
 c1ccfec:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c1ccff0:	e58dc000 	str	ip, [sp]
 c1ccff4:	ebffffaf 	bl	c1cceb8 <lcd_draw_vline>
	lcd_draw_hline(xleft, xright, ydown - width + 1, color, width);
 c1ccff8:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c1ccffc:	e1db30b8 	ldrh	r3, [fp, #8]
 c1cd000:	e0633002 	rsb	r3, r3, r2
 c1cd004:	e1a03803 	lsl	r3, r3, #16
 c1cd008:	e1a03823 	lsr	r3, r3, #16
 c1cd00c:	e2833001 	add	r3, r3, #1
 c1cd010:	e1a03803 	lsl	r3, r3, #16
 c1cd014:	e1a02823 	lsr	r2, r3, #16
 c1cd018:	e15b00be 	ldrh	r0, [fp, #-14]
 c1cd01c:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c1cd020:	e5db3004 	ldrb	r3, [fp, #4]
 c1cd024:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c1cd028:	e58dc000 	str	ip, [sp]
 c1cd02c:	ebffff75 	bl	c1cce08 <lcd_draw_hline>
}
 c1cd030:	e24bd00c 	sub	sp, fp, #12
 c1cd034:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd038:	e12fff1e 	bx	lr

0c1cd03c <lcd_putchar>:

void lcd_putchar( uint16 x, uint16 y, uint8 color, char ch )
{
 c1cd03c:	e1a0c00d 	mov	ip, sp
 c1cd040:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd044:	e24cb004 	sub	fp, ip, #4
 c1cd048:	e24dd010 	sub	sp, sp, #16
 c1cd04c:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c1cd050:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c1cd054:	e54b2019 	strb	r2, [fp, #-25]	; 0xffffffe7
 c1cd058:	e54b301a 	strb	r3, [fp, #-26]	; 0xffffffe6
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
 c1cd05c:	e55b301a 	ldrb	r3, [fp, #-26]	; 0xffffffe6
 c1cd060:	e1a03203 	lsl	r3, r3, #4
 c1cd064:	e1a02003 	mov	r2, r3
 c1cd068:	e59f311c 	ldr	r3, [pc, #284]	; c1cd18c <lcd_putchar+0x150>
 c1cd06c:	e0823003 	add	r3, r2, r3
 c1cd070:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for( line=0; line<16; line++ )
 c1cd074:	e3a03000 	mov	r3, #0
 c1cd078:	e54b300d 	strb	r3, [fp, #-13]
 c1cd07c:	ea00003c 	b	c1cd174 <lcd_putchar+0x138>
        for( row=0; row<8; row++ )
 c1cd080:	e3a03000 	mov	r3, #0
 c1cd084:	e54b300e 	strb	r3, [fp, #-14]
 c1cd088:	ea000033 	b	c1cd15c <lcd_putchar+0x120>
            if( bitmap[line] & (0x80 >> row) )
 c1cd08c:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cd090:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cd094:	e0823003 	add	r3, r2, r3
 c1cd098:	e5d33000 	ldrb	r3, [r3]
 c1cd09c:	e1a02003 	mov	r2, r3
 c1cd0a0:	e55b300e 	ldrb	r3, [fp, #-14]
 c1cd0a4:	e3a01080 	mov	r1, #128	; 0x80
 c1cd0a8:	e1a03351 	asr	r3, r1, r3
 c1cd0ac:	e0023003 	and	r3, r2, r3
 c1cd0b0:	e3530000 	cmp	r3, #0
 c1cd0b4:	0a000013 	beq	c1cd108 <lcd_putchar+0xcc>
                lcd_putpixel( x+row, y+line, color );
 c1cd0b8:	e55b300e 	ldrb	r3, [fp, #-14]
 c1cd0bc:	e1a03803 	lsl	r3, r3, #16
 c1cd0c0:	e1a02823 	lsr	r2, r3, #16
 c1cd0c4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cd0c8:	e0823003 	add	r3, r2, r3
 c1cd0cc:	e1a03803 	lsl	r3, r3, #16
 c1cd0d0:	e1a01823 	lsr	r1, r3, #16
 c1cd0d4:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cd0d8:	e1a03803 	lsl	r3, r3, #16
 c1cd0dc:	e1a02823 	lsr	r2, r3, #16
 c1cd0e0:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1cd0e4:	e0823003 	add	r3, r2, r3
 c1cd0e8:	e1a03803 	lsl	r3, r3, #16
 c1cd0ec:	e1a02823 	lsr	r2, r3, #16
 c1cd0f0:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c1cd0f4:	e1a00001 	mov	r0, r1
 c1cd0f8:	e1a01002 	mov	r1, r2
 c1cd0fc:	e1a02003 	mov	r2, r3
 c1cd100:	ebfffed9 	bl	c1ccc6c <lcd_putpixel>
 c1cd104:	ea000011 	b	c1cd150 <lcd_putchar+0x114>
            else
                lcd_putpixel( x+row, y+line, WHITE );
 c1cd108:	e55b300e 	ldrb	r3, [fp, #-14]
 c1cd10c:	e1a03803 	lsl	r3, r3, #16
 c1cd110:	e1a02823 	lsr	r2, r3, #16
 c1cd114:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c1cd118:	e0823003 	add	r3, r2, r3
 c1cd11c:	e1a03803 	lsl	r3, r3, #16
 c1cd120:	e1a02823 	lsr	r2, r3, #16
 c1cd124:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cd128:	e1a03803 	lsl	r3, r3, #16
 c1cd12c:	e1a01823 	lsr	r1, r3, #16
 c1cd130:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c1cd134:	e0813003 	add	r3, r1, r3
 c1cd138:	e1a03803 	lsl	r3, r3, #16
 c1cd13c:	e1a03823 	lsr	r3, r3, #16
 c1cd140:	e1a00002 	mov	r0, r2
 c1cd144:	e1a01003 	mov	r1, r3
 c1cd148:	e3a02000 	mov	r2, #0
 c1cd14c:	ebfffec6 	bl	c1ccc6c <lcd_putpixel>
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
        for( row=0; row<8; row++ )
 c1cd150:	e55b300e 	ldrb	r3, [fp, #-14]
 c1cd154:	e2833001 	add	r3, r3, #1
 c1cd158:	e54b300e 	strb	r3, [fp, #-14]
 c1cd15c:	e55b300e 	ldrb	r3, [fp, #-14]
 c1cd160:	e3530007 	cmp	r3, #7
 c1cd164:	9affffc8 	bls	c1cd08c <lcd_putchar+0x50>
{
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
 c1cd168:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cd16c:	e2833001 	add	r3, r3, #1
 c1cd170:	e54b300d 	strb	r3, [fp, #-13]
 c1cd174:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cd178:	e353000f 	cmp	r3, #15
 c1cd17c:	9affffbf 	bls	c1cd080 <lcd_putchar+0x44>
        for( row=0; row<8; row++ )
            if( bitmap[line] & (0x80 >> row) )
                lcd_putpixel( x+row, y+line, color );
            else
                lcd_putpixel( x+row, y+line, WHITE );
}
 c1cd180:	e24bd00c 	sub	sp, fp, #12
 c1cd184:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd188:	e12fff1e 	bx	lr
 c1cd18c:	0c101094 	.word	0x0c101094

0c1cd190 <lcd_puts>:

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
 c1cd190:	e1a0c00d 	mov	ip, sp
 c1cd194:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd198:	e24cb004 	sub	fp, ip, #4
 c1cd19c:	e24dd010 	sub	sp, sp, #16
 c1cd1a0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1cd1a4:	e14b00be 	strh	r0, [fp, #-14]
 c1cd1a8:	e14b11b0 	strh	r1, [fp, #-16]
 c1cd1ac:	e1a03002 	mov	r3, r2
 c1cd1b0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	while(*s) {
 c1cd1b4:	ea000015 	b	c1cd210 <lcd_puts+0x80>
		lcd_putchar(x, y, color, *s);
 c1cd1b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cd1bc:	e5d33000 	ldrb	r3, [r3]
 c1cd1c0:	e15b00be 	ldrh	r0, [fp, #-14]
 c1cd1c4:	e15b11b0 	ldrh	r1, [fp, #-16]
 c1cd1c8:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c1cd1cc:	ebffff9a 	bl	c1cd03c <lcd_putchar>

		x += 8;
 c1cd1d0:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cd1d4:	e2833008 	add	r3, r3, #8
 c1cd1d8:	e14b30be 	strh	r3, [fp, #-14]
		if(x + 8 >= LCD_WIDTH) {
 c1cd1dc:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cd1e0:	e2832008 	add	r2, r3, #8
 c1cd1e4:	e59f3040 	ldr	r3, [pc, #64]	; c1cd22c <lcd_puts+0x9c>
 c1cd1e8:	e1520003 	cmp	r2, r3
 c1cd1ec:	da000004 	ble	c1cd204 <lcd_puts+0x74>
			x = 0;
 c1cd1f0:	e3a03000 	mov	r3, #0
 c1cd1f4:	e14b30be 	strh	r3, [fp, #-14]
			y += 16;
 c1cd1f8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cd1fc:	e2833010 	add	r3, r3, #16
 c1cd200:	e14b31b0 	strh	r3, [fp, #-16]
		}
		s++;
 c1cd204:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cd208:	e2833001 	add	r3, r3, #1
 c1cd20c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
                lcd_putpixel( x+row, y+line, WHITE );
}

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
	while(*s) {
 c1cd210:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cd214:	e5d33000 	ldrb	r3, [r3]
 c1cd218:	e3530000 	cmp	r3, #0
 c1cd21c:	1affffe5 	bne	c1cd1b8 <lcd_puts+0x28>
			x = 0;
			y += 16;
		}
		s++;
	}
}
 c1cd220:	e24bd00c 	sub	sp, fp, #12
 c1cd224:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd228:	e12fff1e 	bx	lr
 c1cd22c:	0000013f 	.word	0x0000013f

0c1cd230 <lcd_putWallpaper>:

void lcd_putWallpaper( uint8 *bmp )
{
 c1cd230:	e1a0c00d 	mov	ip, sp
 c1cd234:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd238:	e24cb004 	sub	fp, ip, #4
 c1cd23c:	e24dd018 	sub	sp, sp, #24
 c1cd240:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    uint32 headerSize;

    uint16 x, ySrc, yDst;
    uint16 offsetSrc, offsetDst;

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);
 c1cd244:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd248:	e283300a 	add	r3, r3, #10
 c1cd24c:	e5d33000 	ldrb	r3, [r3]
 c1cd250:	e1a02003 	mov	r2, r3
 c1cd254:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd258:	e283300b 	add	r3, r3, #11
 c1cd25c:	e5d33000 	ldrb	r3, [r3]
 c1cd260:	e1a03403 	lsl	r3, r3, #8
 c1cd264:	e0822003 	add	r2, r2, r3
 c1cd268:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd26c:	e283300c 	add	r3, r3, #12
 c1cd270:	e5d33000 	ldrb	r3, [r3]
 c1cd274:	e1a03803 	lsl	r3, r3, #16
 c1cd278:	e0822003 	add	r2, r2, r3
 c1cd27c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd280:	e283300d 	add	r3, r3, #13
 c1cd284:	e5d33000 	ldrb	r3, [r3]
 c1cd288:	e1a03c03 	lsl	r3, r3, #24
 c1cd28c:	e0823003 	add	r3, r2, r3
 c1cd290:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    bmp = bmp + headerSize;
 c1cd294:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cd298:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cd29c:	e0823003 	add	r3, r2, r3
 c1cd2a0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c1cd2a4:	e3a03000 	mov	r3, #0
 c1cd2a8:	e14b31b0 	strh	r3, [fp, #-16]
 c1cd2ac:	e3a030ef 	mov	r3, #239	; 0xef
 c1cd2b0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c1cd2b4:	ea00002d 	b	c1cd370 <lcd_putWallpaper+0x140>
    {
        offsetDst = yDst*LCD_WIDTH/2;
 c1cd2b8:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c1cd2bc:	e1a03002 	mov	r3, r2
 c1cd2c0:	e1a03103 	lsl	r3, r3, #2
 c1cd2c4:	e0833002 	add	r3, r3, r2
 c1cd2c8:	e1a03303 	lsl	r3, r3, #6
 c1cd2cc:	e1a02fa3 	lsr	r2, r3, #31
 c1cd2d0:	e0823003 	add	r3, r2, r3
 c1cd2d4:	e1a030c3 	asr	r3, r3, #1
 c1cd2d8:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
        offsetSrc = ySrc*LCD_WIDTH/2;
 c1cd2dc:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1cd2e0:	e1a03002 	mov	r3, r2
 c1cd2e4:	e1a03103 	lsl	r3, r3, #2
 c1cd2e8:	e0833002 	add	r3, r3, r2
 c1cd2ec:	e1a03303 	lsl	r3, r3, #6
 c1cd2f0:	e1a02fa3 	lsr	r2, r3, #31
 c1cd2f4:	e0823003 	add	r3, r2, r3
 c1cd2f8:	e1a030c3 	asr	r3, r3, #1
 c1cd2fc:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
        for( x=0; x<LCD_WIDTH/2; x++ )
 c1cd300:	e3a03000 	mov	r3, #0
 c1cd304:	e14b30be 	strh	r3, [fp, #-14]
 c1cd308:	ea00000f 	b	c1cd34c <lcd_putWallpaper+0x11c>
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
 c1cd30c:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c1cd310:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cd314:	e0823003 	add	r3, r2, r3
 c1cd318:	e15b11bc 	ldrh	r1, [fp, #-28]	; 0xffffffe4
 c1cd31c:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cd320:	e0812002 	add	r2, r1, r2
 c1cd324:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c1cd328:	e0812002 	add	r2, r1, r2
 c1cd32c:	e5d22000 	ldrb	r2, [r2]
 c1cd330:	e1e02002 	mvn	r2, r2
 c1cd334:	e20210ff 	and	r1, r2, #255	; 0xff
 c1cd338:	e59f2048 	ldr	r2, [pc, #72]	; c1cd388 <lcd_putWallpaper+0x158>
 c1cd33c:	e7c21003 	strb	r1, [r2, r3]

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
    {
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
 c1cd340:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cd344:	e2833001 	add	r3, r3, #1
 c1cd348:	e14b30be 	strh	r3, [fp, #-14]
 c1cd34c:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cd350:	e353009f 	cmp	r3, #159	; 0x9f
 c1cd354:	9affffec 	bls	c1cd30c <lcd_putWallpaper+0xdc>

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);

    bmp = bmp + headerSize;

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c1cd358:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cd35c:	e2833001 	add	r3, r3, #1
 c1cd360:	e14b31b0 	strh	r3, [fp, #-16]
 c1cd364:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c1cd368:	e2433001 	sub	r3, r3, #1
 c1cd36c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c1cd370:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cd374:	e35300ef 	cmp	r3, #239	; 0xef
 c1cd378:	9affffce 	bls	c1cd2b8 <lcd_putWallpaper+0x88>
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
    }
}
 c1cd37c:	e24bd00c 	sub	sp, fp, #12
 c1cd380:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd384:	e12fff1e 	bx	lr
 c1cd388:	0c1022e8 	.word	0x0c1022e8

0c1cd38c <leds_init>:
// significativos, cada uno para un led
// 1 encendido y 0 apagado
static unsigned int status = 0;

void leds_init( void )
{
 c1cd38c:	e1a0c00d 	mov	ip, sp
 c1cd390:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd394:	e24cb004 	sub	fp, ip, #4
	//COMPLETAR usando el interfaz del puerto B definido en gpio.h
	// hay que configurar los pines 9 y 10 como pines de salida
	portB_conf(BIT_LED1, OUTPUT);
 c1cd398:	e3a00009 	mov	r0, #9
 c1cd39c:	e3a01001 	mov	r1, #1
 c1cd3a0:	ebfff781 	bl	c1cb1ac <portB_conf>
	portB_conf(BIT_LED2, OUTPUT);
 c1cd3a4:	e3a0000a 	mov	r0, #10
 c1cd3a8:	e3a01001 	mov	r1, #1
 c1cd3ac:	ebfff77e 	bl	c1cb1ac <portB_conf>
	leds_display( status );
 c1cd3b0:	e59f3014 	ldr	r3, [pc, #20]	; c1cd3cc <leds_init+0x40>
 c1cd3b4:	e5933000 	ldr	r3, [r3]
 c1cd3b8:	e1a00003 	mov	r0, r3
 c1cd3bc:	eb000073 	bl	c1cd590 <leds_display>
}
 c1cd3c0:	e24bd00c 	sub	sp, fp, #12
 c1cd3c4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd3c8:	e12fff1e 	bx	lr
 c1cd3cc:	0c10b8ec 	.word	0x0c10b8ec

0c1cd3d0 <led1_on>:

void led1_on( void )
{
 c1cd3d0:	e1a0c00d 	mov	ip, sp
 c1cd3d4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd3d8:	e24cb004 	sub	fp, ip, #4
	status |=  LED1;
 c1cd3dc:	e59f3028 	ldr	r3, [pc, #40]	; c1cd40c <led1_on+0x3c>
 c1cd3e0:	e5933000 	ldr	r3, [r3]
 c1cd3e4:	e3832001 	orr	r2, r3, #1
 c1cd3e8:	e59f301c 	ldr	r3, [pc, #28]	; c1cd40c <led1_on+0x3c>
 c1cd3ec:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd3f0:	e59f3014 	ldr	r3, [pc, #20]	; c1cd40c <led1_on+0x3c>
 c1cd3f4:	e5933000 	ldr	r3, [r3]
 c1cd3f8:	e1a00003 	mov	r0, r3
 c1cd3fc:	eb000063 	bl	c1cd590 <leds_display>
}
 c1cd400:	e24bd00c 	sub	sp, fp, #12
 c1cd404:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd408:	e12fff1e 	bx	lr
 c1cd40c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd410 <led1_off>:

void led1_off( void )
{
 c1cd410:	e1a0c00d 	mov	ip, sp
 c1cd414:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd418:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED1;
 c1cd41c:	e59f3028 	ldr	r3, [pc, #40]	; c1cd44c <led1_off+0x3c>
 c1cd420:	e5933000 	ldr	r3, [r3]
 c1cd424:	e3c32001 	bic	r2, r3, #1
 c1cd428:	e59f301c 	ldr	r3, [pc, #28]	; c1cd44c <led1_off+0x3c>
 c1cd42c:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd430:	e59f3014 	ldr	r3, [pc, #20]	; c1cd44c <led1_off+0x3c>
 c1cd434:	e5933000 	ldr	r3, [r3]
 c1cd438:	e1a00003 	mov	r0, r3
 c1cd43c:	eb000053 	bl	c1cd590 <leds_display>
}
 c1cd440:	e24bd00c 	sub	sp, fp, #12
 c1cd444:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd448:	e12fff1e 	bx	lr
 c1cd44c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd450 <led2_on>:

void led2_on( void )
{
 c1cd450:	e1a0c00d 	mov	ip, sp
 c1cd454:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd458:	e24cb004 	sub	fp, ip, #4
	status |=  LED2;
 c1cd45c:	e59f3028 	ldr	r3, [pc, #40]	; c1cd48c <led2_on+0x3c>
 c1cd460:	e5933000 	ldr	r3, [r3]
 c1cd464:	e3832002 	orr	r2, r3, #2
 c1cd468:	e59f301c 	ldr	r3, [pc, #28]	; c1cd48c <led2_on+0x3c>
 c1cd46c:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd470:	e59f3014 	ldr	r3, [pc, #20]	; c1cd48c <led2_on+0x3c>
 c1cd474:	e5933000 	ldr	r3, [r3]
 c1cd478:	e1a00003 	mov	r0, r3
 c1cd47c:	eb000043 	bl	c1cd590 <leds_display>
}
 c1cd480:	e24bd00c 	sub	sp, fp, #12
 c1cd484:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd488:	e12fff1e 	bx	lr
 c1cd48c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd490 <led2_off>:

void led2_off( void )
{
 c1cd490:	e1a0c00d 	mov	ip, sp
 c1cd494:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd498:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED2;
 c1cd49c:	e59f3028 	ldr	r3, [pc, #40]	; c1cd4cc <led2_off+0x3c>
 c1cd4a0:	e5933000 	ldr	r3, [r3]
 c1cd4a4:	e3c32002 	bic	r2, r3, #2
 c1cd4a8:	e59f301c 	ldr	r3, [pc, #28]	; c1cd4cc <led2_off+0x3c>
 c1cd4ac:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd4b0:	e59f3014 	ldr	r3, [pc, #20]	; c1cd4cc <led2_off+0x3c>
 c1cd4b4:	e5933000 	ldr	r3, [r3]
 c1cd4b8:	e1a00003 	mov	r0, r3
 c1cd4bc:	eb000033 	bl	c1cd590 <leds_display>
}
 c1cd4c0:	e24bd00c 	sub	sp, fp, #12
 c1cd4c4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd4c8:	e12fff1e 	bx	lr
 c1cd4cc:	0c10b8ec 	.word	0x0c10b8ec

0c1cd4d0 <led1_switch>:

void led1_switch( void )
{
 c1cd4d0:	e1a0c00d 	mov	ip, sp
 c1cd4d4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd4d8:	e24cb004 	sub	fp, ip, #4
	status ^= LED1;
 c1cd4dc:	e59f3028 	ldr	r3, [pc, #40]	; c1cd50c <led1_switch+0x3c>
 c1cd4e0:	e5933000 	ldr	r3, [r3]
 c1cd4e4:	e2232001 	eor	r2, r3, #1
 c1cd4e8:	e59f301c 	ldr	r3, [pc, #28]	; c1cd50c <led1_switch+0x3c>
 c1cd4ec:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd4f0:	e59f3014 	ldr	r3, [pc, #20]	; c1cd50c <led1_switch+0x3c>
 c1cd4f4:	e5933000 	ldr	r3, [r3]
 c1cd4f8:	e1a00003 	mov	r0, r3
 c1cd4fc:	eb000023 	bl	c1cd590 <leds_display>
}
 c1cd500:	e24bd00c 	sub	sp, fp, #12
 c1cd504:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd508:	e12fff1e 	bx	lr
 c1cd50c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd510 <led2_switch>:

void led2_switch( void )
{
 c1cd510:	e1a0c00d 	mov	ip, sp
 c1cd514:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd518:	e24cb004 	sub	fp, ip, #4
	status ^= LED2;
 c1cd51c:	e59f3028 	ldr	r3, [pc, #40]	; c1cd54c <led2_switch+0x3c>
 c1cd520:	e5933000 	ldr	r3, [r3]
 c1cd524:	e2232002 	eor	r2, r3, #2
 c1cd528:	e59f301c 	ldr	r3, [pc, #28]	; c1cd54c <led2_switch+0x3c>
 c1cd52c:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd530:	e59f3014 	ldr	r3, [pc, #20]	; c1cd54c <led2_switch+0x3c>
 c1cd534:	e5933000 	ldr	r3, [r3]
 c1cd538:	e1a00003 	mov	r0, r3
 c1cd53c:	eb000013 	bl	c1cd590 <leds_display>
}
 c1cd540:	e24bd00c 	sub	sp, fp, #12
 c1cd544:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd548:	e12fff1e 	bx	lr
 c1cd54c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd550 <leds_switch>:

void leds_switch( void ){
 c1cd550:	e1a0c00d 	mov	ip, sp
 c1cd554:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd558:	e24cb004 	sub	fp, ip, #4
	status ^= (LED1 | LED2);
 c1cd55c:	e59f3028 	ldr	r3, [pc, #40]	; c1cd58c <leds_switch+0x3c>
 c1cd560:	e5933000 	ldr	r3, [r3]
 c1cd564:	e2232003 	eor	r2, r3, #3
 c1cd568:	e59f301c 	ldr	r3, [pc, #28]	; c1cd58c <leds_switch+0x3c>
 c1cd56c:	e5832000 	str	r2, [r3]
	leds_display( status );
 c1cd570:	e59f3014 	ldr	r3, [pc, #20]	; c1cd58c <leds_switch+0x3c>
 c1cd574:	e5933000 	ldr	r3, [r3]
 c1cd578:	e1a00003 	mov	r0, r3
 c1cd57c:	eb000003 	bl	c1cd590 <leds_display>
}
 c1cd580:	e24bd00c 	sub	sp, fp, #12
 c1cd584:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd588:	e12fff1e 	bx	lr
 c1cd58c:	0c10b8ec 	.word	0x0c10b8ec

0c1cd590 <leds_display>:

void leds_display( unsigned int leds_status )
{
 c1cd590:	e1a0c00d 	mov	ip, sp
 c1cd594:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd598:	e24cb004 	sub	fp, ip, #4
 c1cd59c:	e24dd008 	sub	sp, sp, #8
 c1cd5a0:	e50b0010 	str	r0, [fp, #-16]
	status = leds_status;
 c1cd5a4:	e59f3074 	ldr	r3, [pc, #116]	; c1cd620 <leds_display+0x90>
 c1cd5a8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cd5ac:	e5832000 	str	r2, [r3]
	
	// LED 1
	if( status & LED1 )
 c1cd5b0:	e59f3068 	ldr	r3, [pc, #104]	; c1cd620 <leds_display+0x90>
 c1cd5b4:	e5933000 	ldr	r3, [r3]
 c1cd5b8:	e2033001 	and	r3, r3, #1
 c1cd5bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cd5c0:	e3530000 	cmp	r3, #0
 c1cd5c4:	0a000003 	beq	c1cd5d8 <leds_display+0x48>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 1
		portB_write(BIT_LED1, DISABLE);
 c1cd5c8:	e3a00009 	mov	r0, #9
 c1cd5cc:	e3a01000 	mov	r1, #0
 c1cd5d0:	ebfff727 	bl	c1cb274 <portB_write>
 c1cd5d4:	ea000002 	b	c1cd5e4 <leds_display+0x54>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 1
		portB_write(BIT_LED1, ENABLE);
 c1cd5d8:	e3a00009 	mov	r0, #9
 c1cd5dc:	e3a01001 	mov	r1, #1
 c1cd5e0:	ebfff723 	bl	c1cb274 <portB_write>

	// LED 2
	if( status & LED2 )
 c1cd5e4:	e59f3034 	ldr	r3, [pc, #52]	; c1cd620 <leds_display+0x90>
 c1cd5e8:	e5933000 	ldr	r3, [r3]
 c1cd5ec:	e2033002 	and	r3, r3, #2
 c1cd5f0:	e3530000 	cmp	r3, #0
 c1cd5f4:	0a000003 	beq	c1cd608 <leds_display+0x78>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 2
		portB_write(BIT_LED2, DISABLE);
 c1cd5f8:	e3a0000a 	mov	r0, #10
 c1cd5fc:	e3a01000 	mov	r1, #0
 c1cd600:	ebfff71b 	bl	c1cb274 <portB_write>
 c1cd604:	ea000002 	b	c1cd614 <leds_display+0x84>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 2
		portB_write(BIT_LED2, ENABLE);
 c1cd608:	e3a0000a 	mov	r0, #10
 c1cd60c:	e3a01001 	mov	r1, #1
 c1cd610:	ebfff717 	bl	c1cb274 <portB_write>
}
 c1cd614:	e24bd00c 	sub	sp, fp, #12
 c1cd618:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd61c:	e12fff1e 	bx	lr
 c1cd620:	0c10b8ec 	.word	0x0c10b8ec

0c1cd624 <led1_status>:

inline uint8 led1_status(void)
{
 c1cd624:	e1a0c00d 	mov	ip, sp
 c1cd628:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd62c:	e24cb004 	sub	fp, ip, #4
	return status & LED1;
 c1cd630:	e59f301c 	ldr	r3, [pc, #28]	; c1cd654 <led1_status+0x30>
 c1cd634:	e5933000 	ldr	r3, [r3]
 c1cd638:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cd63c:	e2033001 	and	r3, r3, #1
 c1cd640:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cd644:	e1a00003 	mov	r0, r3
 c1cd648:	e24bd00c 	sub	sp, fp, #12
 c1cd64c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd650:	e12fff1e 	bx	lr
 c1cd654:	0c10b8ec 	.word	0x0c10b8ec

0c1cd658 <led2_status>:

inline uint8 led2_status(void) {
 c1cd658:	e1a0c00d 	mov	ip, sp
 c1cd65c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd660:	e24cb004 	sub	fp, ip, #4
	return status & LED2;
 c1cd664:	e59f301c 	ldr	r3, [pc, #28]	; c1cd688 <led2_status+0x30>
 c1cd668:	e5933000 	ldr	r3, [r3]
 c1cd66c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cd670:	e2033002 	and	r3, r3, #2
 c1cd674:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cd678:	e1a00003 	mov	r0, r3
 c1cd67c:	e24bd00c 	sub	sp, fp, #12
 c1cd680:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd684:	e12fff1e 	bx	lr
 c1cd688:	0c10b8ec 	.word	0x0c10b8ec

0c1cd68c <timer_ISR>:
void keyboard_ISR(void) __attribute__ ((interrupt ("IRQ")));
void rtc_ISR(void)  __attribute__ ((interrupt ("IRQ")));
void rtc_alarm_ISR(void)  __attribute__ ((interrupt ("IRQ")));

void timer_ISR(void)
{
 c1cd68c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cd690:	e1a0c00d 	mov	ip, sp
 c1cd694:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cd698:	e24cb004 	sub	fp, ip, #4
	//Timer ISR Implementation
	led1_switch();
 c1cd69c:	ebffff8b 	bl	c1cd4d0 <led1_switch>
	led2_switch();
 c1cd6a0:	ebffff9a 	bl	c1cd510 <led2_switch>

	ic_cleanflag(INT_TIMER0);
 c1cd6a4:	e3a0000d 	mov	r0, #13
 c1cd6a8:	ebfffc1a 	bl	c1cc718 <ic_cleanflag>
}
 c1cd6ac:	e24bd01c 	sub	sp, fp, #28
 c1cd6b0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cd6b4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cd6b8:	e25ef004 	subs	pc, lr, #4

0c1cd6bc <button_ISR>:

void button_ISR(void)
{
 c1cd6bc:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cd6c0:	e1a0c00d 	mov	ip, sp
 c1cd6c4:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cd6c8:	e24cb004 	sub	fp, ip, #4
 c1cd6cc:	e24dd008 	sub	sp, sp, #8
	unsigned int whicheint = rEXTINTPND;
 c1cd6d0:	e59f3080 	ldr	r3, [pc, #128]	; c1cd758 <button_ISR+0x9c>
 c1cd6d4:	e5933000 	ldr	r3, [r3]
 c1cd6d8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
	unsigned int buttons = (whicheint >> 2) & 0x3;
 c1cd6dc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd6e0:	e1a03123 	lsr	r3, r3, #2
 c1cd6e4:	e2033003 	and	r3, r3, #3
 c1cd6e8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
	if (buttons & BUT2) {
		//BUT2 pressed
	}

	// eliminamos rebotes
	Delay(2000);
 c1cd6ec:	e3a00e7d 	mov	r0, #2000	; 0x7d0
 c1cd6f0:	eb000a58 	bl	c1d0058 <Delay>
	// borramos el flag en extintpnd
	//COMPLETAR: debemos borrar las peticiones de interrupciÃ³n en
	//EXTINTPND escribiendo un 1 en los flags que queremos borrar (los
	//correspondientes a los pulsadores pulsados)

	if(buttons & BUT1)
 c1cd6f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cd6f8:	e2033001 	and	r3, r3, #1
 c1cd6fc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cd700:	e3530000 	cmp	r3, #0
 c1cd704:	0a000004 	beq	c1cd71c <button_ISR+0x60>
		//Borrar bit 2
		rEXTINTPND |= 1 << 2;
 c1cd708:	e59f3048 	ldr	r3, [pc, #72]	; c1cd758 <button_ISR+0x9c>
 c1cd70c:	e59f2044 	ldr	r2, [pc, #68]	; c1cd758 <button_ISR+0x9c>
 c1cd710:	e5922000 	ldr	r2, [r2]
 c1cd714:	e3822004 	orr	r2, r2, #4
 c1cd718:	e5832000 	str	r2, [r3]

	if(buttons & BUT2)
 c1cd71c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cd720:	e2033002 	and	r3, r3, #2
 c1cd724:	e3530000 	cmp	r3, #0
 c1cd728:	0a000004 	beq	c1cd740 <button_ISR+0x84>
		//Borrar bit 3
		rEXTINTPND |= 1 << 3;
 c1cd72c:	e59f3024 	ldr	r3, [pc, #36]	; c1cd758 <button_ISR+0x9c>
 c1cd730:	e59f2020 	ldr	r2, [pc, #32]	; c1cd758 <button_ISR+0x9c>
 c1cd734:	e5922000 	ldr	r2, [r2]
 c1cd738:	e3822008 	orr	r2, r2, #8
 c1cd73c:	e5832000 	str	r2, [r3]

	ic_cleanflag(INT_EINT4567);
 c1cd740:	e3a00015 	mov	r0, #21
 c1cd744:	ebfffbf3 	bl	c1cc718 <ic_cleanflag>
}
 c1cd748:	e24bd01c 	sub	sp, fp, #28
 c1cd74c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cd750:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cd754:	e25ef004 	subs	pc, lr, #4
 c1cd758:	01d20054 	.word	0x01d20054

0c1cd75c <keyboard_ISR>:

void keyboard_ISR(void)
{
 c1cd75c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cd760:	e1a0c00d 	mov	ip, sp
 c1cd764:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cd768:	e24cb004 	sub	fp, ip, #4
 c1cd76c:	e24dd008 	sub	sp, sp, #8
	static unsigned n = 0;
	int key = -1;
 c1cd770:	e3e03000 	mvn	r3, #0
 c1cd774:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	/* Eliminar rebotes de presiÃ³n */
	Delay(200);
 c1cd778:	e3a000c8 	mov	r0, #200	; 0xc8
 c1cd77c:	eb000a35 	bl	c1d0058 <Delay>
	
	/* Escaneo de tecla */
	key = kb_scan();
 c1cd780:	ebfffc0e 	bl	c1cc7c0 <kb_scan>
 c1cd784:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0

	n = (n+1) & 0xf;
 c1cd788:	e59f3044 	ldr	r3, [pc, #68]	; c1cd7d4 <keyboard_ISR+0x78>
 c1cd78c:	e5933000 	ldr	r3, [r3]
 c1cd790:	e2833001 	add	r3, r3, #1
 c1cd794:	e203200f 	and	r2, r3, #15
 c1cd798:	e59f3034 	ldr	r3, [pc, #52]	; c1cd7d4 <keyboard_ISR+0x78>
 c1cd79c:	e5832000 	str	r2, [r3]

	if (key != -1) {
 c1cd7a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cd7a4:	e3730001 	cmn	r3, #1
 c1cd7a8:	0a000001 	beq	c1cd7b4 <keyboard_ISR+0x58>
		/* Visualizacion en el display */
		//COMPLETAR: mostrar la tecla en el display utilizando el interfaz
		//definido en D8Led.h

		D8Led_digit(key);
 c1cd7ac:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c1cd7b0:	ebfff3c4 	bl	c1ca6c8 <D8Led_digit>
		/* Esperar a que la tecla se suelte, consultando el registro de datos */		
		//while (/*COMPLETAR: true si estÃ¡ pulsada la tecla (leer del registro rPDATG)*/);
	}

    /* Eliminar rebotes de depresiÃ³n */
    Delay(200);
 c1cd7b4:	e3a000c8 	mov	r0, #200	; 0xc8
 c1cd7b8:	eb000a26 	bl	c1d0058 <Delay>
     
    /* Borrar interrupciones pendientes */
	//COMPLETAR
	//borrar la interrupciÃ³n por la lÃ­nea EINT1 en el registro rI_ISPC
    ic_cleanflag(INT_EINT1);
 c1cd7bc:	e3a00018 	mov	r0, #24
 c1cd7c0:	ebfffbd4 	bl	c1cc718 <ic_cleanflag>
}
 c1cd7c4:	e24bd01c 	sub	sp, fp, #28
 c1cd7c8:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cd7cc:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cd7d0:	e25ef004 	subs	pc, lr, #4
 c1cd7d4:	0c10b900 	.word	0x0c10b900

0c1cd7d8 <setup>:

int setup(void)
{
 c1cd7d8:	e1a0c00d 	mov	ip, sp
 c1cd7dc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd7e0:	e24cb004 	sub	fp, ip, #4
	leds_init();
 c1cd7e4:	ebfffee8 	bl	c1cd38c <leds_init>
	D8Led_init();
 c1cd7e8:	ebfff38d 	bl	c1ca624 <D8Led_init>
	D8Led_segment(0x02); // "-" Symbol
 c1cd7ec:	e3a00002 	mov	r0, #2
 c1cd7f0:	ebfff39d 	bl	c1ca66c <D8Led_segment>
	led1_on();
 c1cd7f4:	ebfffef5 	bl	c1cd3d0 <led1_on>
	//COMPLETAR: utilizando el interfaz para el puerto G definido en gpio.h
	//configurar los pines 1, 6 y 7 del puerto G para poder generar interrupciones
	//externas por flanco de bajada por ellos y activar las correspondientes
	//resistencias de pull-up.

	portG_conf(6, EINT);
 c1cd7f8:	e3a00006 	mov	r0, #6
 c1cd7fc:	e3a01003 	mov	r1, #3
 c1cd800:	ebfff6ca 	bl	c1cb330 <portG_conf>
	portG_eint_trig(6, FALLING);
 c1cd804:	e3a00006 	mov	r0, #6
 c1cd808:	e3a01002 	mov	r1, #2
 c1cd80c:	ebfff735 	bl	c1cb4e8 <portG_eint_trig>
	portG_conf_pup(6, ENABLE);
 c1cd810:	e3a00006 	mov	r0, #6
 c1cd814:	e3a01001 	mov	r1, #1
 c1cd818:	ebfff857 	bl	c1cb97c <portG_conf_pup>

	portG_conf(7, EINT);
 c1cd81c:	e3a00007 	mov	r0, #7
 c1cd820:	e3a01003 	mov	r1, #3
 c1cd824:	ebfff6c1 	bl	c1cb330 <portG_conf>
	portG_eint_trig(7, FALLING);
 c1cd828:	e3a00007 	mov	r0, #7
 c1cd82c:	e3a01002 	mov	r1, #2
 c1cd830:	ebfff72c 	bl	c1cb4e8 <portG_eint_trig>
	portG_conf_pup(7, ENABLE);
 c1cd834:	e3a00007 	mov	r0, #7
 c1cd838:	e3a01001 	mov	r1, #1
 c1cd83c:	ebfff84e 	bl	c1cb97c <portG_conf_pup>
	//if (RL.moving)
	//
	/***************************/

	// Registramos las ISRs
	pISR_TIMER0 = (unsigned)timer_ISR;//COMPLETAR: registrar la RTI del timer
 c1cd840:	e59f3090 	ldr	r3, [pc, #144]	; c1cd8d8 <setup+0x100>
 c1cd844:	e59f2090 	ldr	r2, [pc, #144]	; c1cd8dc <setup+0x104>
 c1cd848:	e5832000 	str	r2, [r3]
	pISR_EINT4567 = (unsigned)button_ISR; //COMPLETAR: registrar la RTI de los botones
 c1cd84c:	e59f308c 	ldr	r3, [pc, #140]	; c1cd8e0 <setup+0x108>
 c1cd850:	e59f208c 	ldr	r2, [pc, #140]	; c1cd8e4 <setup+0x10c>
 c1cd854:	e5832000 	str	r2, [r3]
	pISR_EINT1    = (unsigned)keyboard_ISR; //COMPLETAR: registrar la RTI del teclado
 c1cd858:	e59f3088 	ldr	r3, [pc, #136]	; c1cd8e8 <setup+0x110>
 c1cd85c:	e59f2088 	ldr	r2, [pc, #136]	; c1cd8ec <setup+0x114>
 c1cd860:	e5832000 	str	r2, [r3]
	 * Configuramos el timer 0 en modo IRQ y habilitamos esta lÃ­nea
	 * Configuramos la lÃ­nea EINT4567 en modo IRQ y la habilitamos
	 * Configuramos la lÃ­nea EINT1 en modo IRQ y la habilitamos
	 */

	uart0_init();
 c1cd864:	eb0007dd 	bl	c1cf7e0 <uart0_init>
	iic_init();
 c1cd868:	ebfff875 	bl	c1cba44 <iic_init>
	rtc_init();
 c1cd86c:	eb0000fa 	bl	c1cdc5c <rtc_init>
	ic_init();
 c1cd870:	ebfffae4 	bl	c1cc408 <ic_init>
	//		habilitar la lÃ­nea INT_EINT4567
	//		habilitar la lÃ­nea INT_EINT1

	/***************************************************/

	ic_conf_irq(ENABLE, VEC);
 c1cd874:	e3a00001 	mov	r0, #1
 c1cd878:	e3a01000 	mov	r1, #0
 c1cd87c:	ebfffaf2 	bl	c1cc44c <ic_conf_irq>
	ic_conf_fiq(DISABLE);
 c1cd880:	e3a00000 	mov	r0, #0
 c1cd884:	ebfffb1f 	bl	c1cc508 <ic_conf_fiq>

	ic_conf_line(INT_TIMER0, IRQ);
 c1cd888:	e3a0000d 	mov	r0, #13
 c1cd88c:	e3a01000 	mov	r1, #0
 c1cd890:	ebfffb3d 	bl	c1cc58c <ic_conf_line>
	ic_conf_line(INT_EINT4567, IRQ);
 c1cd894:	e3a00015 	mov	r0, #21
 c1cd898:	e3a01000 	mov	r1, #0
 c1cd89c:	ebfffb3a 	bl	c1cc58c <ic_conf_line>
	ic_conf_line(INT_EINT1, IRQ);
 c1cd8a0:	e3a00018 	mov	r0, #24
 c1cd8a4:	e3a01000 	mov	r1, #0
 c1cd8a8:	ebfffb37 	bl	c1cc58c <ic_conf_line>

	//ic_enable(INT_TIMER0);
	//ic_enable(INT_EINT4567);
	//ic_enable(INT_EINT1);

	ic_enable(INT_GLOBAL);
 c1cd8ac:	e3a0001a 	mov	r0, #26
 c1cd8b0:	ebfffb65 	bl	c1cc64c <ic_enable>

	lcd_init();
 c1cd8b4:	ebfffc2a 	bl	c1cc964 <lcd_init>
	//ts_init();
	ts_on();
 c1cd8b8:	eb00062c 	bl	c1cf170 <ts_on>

	Delay(0);
 c1cd8bc:	e3a00000 	mov	r0, #0
 c1cd8c0:	eb0009e4 	bl	c1d0058 <Delay>
	return 0;
 c1cd8c4:	e3a03000 	mov	r3, #0
}
 c1cd8c8:	e1a00003 	mov	r0, r3
 c1cd8cc:	e24bd00c 	sub	sp, fp, #12
 c1cd8d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd8d4:	e12fff1e 	bx	lr
 c1cd8d8:	0c7fff54 	.word	0x0c7fff54
 c1cd8dc:	0c1cd68c 	.word	0x0c1cd68c
 c1cd8e0:	0c7fff74 	.word	0x0c7fff74
 c1cd8e4:	0c1cd6bc 	.word	0x0c1cd6bc
 c1cd8e8:	0c7fff80 	.word	0x0c7fff80
 c1cd8ec:	0c1cd75c 	.word	0x0c1cd75c

0c1cd8f0 <read_date>:

void read_date(rtc_time_t* rtc_time)
{
 c1cd8f0:	e1a0c00d 	mov	ip, sp
 c1cd8f4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cd8f8:	e24cb004 	sub	fp, ip, #4
 c1cd8fc:	e24dd008 	sub	sp, sp, #8
 c1cd900:	e50b0010 	str	r0, [fp, #-16]
	uart0_puts( "\nDia: " );
 c1cd904:	e59f00c8 	ldr	r0, [pc, #200]	; c1cd9d4 <read_date+0xe4>
 c1cd908:	eb0007f3 	bl	c1cf8dc <uart0_puts>
	rtc_time->mday = uart0_getint();
 c1cd90c:	eb00088f 	bl	c1cfb50 <uart0_getint>
 c1cd910:	e1a03000 	mov	r3, r0
 c1cd914:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd918:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd91c:	e5c32003 	strb	r2, [r3, #3]
	uart0_puts( "\nMes: " );
 c1cd920:	e59f00b0 	ldr	r0, [pc, #176]	; c1cd9d8 <read_date+0xe8>
 c1cd924:	eb0007ec 	bl	c1cf8dc <uart0_puts>
	rtc_time->mon = uart0_getint();
 c1cd928:	eb000888 	bl	c1cfb50 <uart0_getint>
 c1cd92c:	e1a03000 	mov	r3, r0
 c1cd930:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd934:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd938:	e5c32005 	strb	r2, [r3, #5]
	uart0_puts( "\nAño: " );
 c1cd93c:	e59f0098 	ldr	r0, [pc, #152]	; c1cd9dc <read_date+0xec>
 c1cd940:	eb0007e5 	bl	c1cf8dc <uart0_puts>
	rtc_time->year = uart0_getint();
 c1cd944:	eb000881 	bl	c1cfb50 <uart0_getint>
 c1cd948:	e1a03000 	mov	r3, r0
 c1cd94c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd950:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd954:	e5c32006 	strb	r2, [r3, #6]
	uart0_puts( "\nDia de la semana: " );
 c1cd958:	e59f0080 	ldr	r0, [pc, #128]	; c1cd9e0 <read_date+0xf0>
 c1cd95c:	eb0007de 	bl	c1cf8dc <uart0_puts>
	rtc_time->wday = uart0_getint();
 c1cd960:	eb00087a 	bl	c1cfb50 <uart0_getint>
 c1cd964:	e1a03000 	mov	r3, r0
 c1cd968:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd96c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd970:	e5c32004 	strb	r2, [r3, #4]

	uart0_puts( "\nHora: " );
 c1cd974:	e59f0068 	ldr	r0, [pc, #104]	; c1cd9e4 <read_date+0xf4>
 c1cd978:	eb0007d7 	bl	c1cf8dc <uart0_puts>
	rtc_time->hour = uart0_getint();
 c1cd97c:	eb000873 	bl	c1cfb50 <uart0_getint>
 c1cd980:	e1a03000 	mov	r3, r0
 c1cd984:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd988:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd98c:	e5c32002 	strb	r2, [r3, #2]
	uart0_puts( "\nMinutos: " );
 c1cd990:	e59f0050 	ldr	r0, [pc, #80]	; c1cd9e8 <read_date+0xf8>
 c1cd994:	eb0007d0 	bl	c1cf8dc <uart0_puts>
	rtc_time->min = uart0_getint();
 c1cd998:	eb00086c 	bl	c1cfb50 <uart0_getint>
 c1cd99c:	e1a03000 	mov	r3, r0
 c1cd9a0:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd9a4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd9a8:	e5c32001 	strb	r2, [r3, #1]
	uart0_puts( "\nSegundos: " );
 c1cd9ac:	e59f0038 	ldr	r0, [pc, #56]	; c1cd9ec <read_date+0xfc>
 c1cd9b0:	eb0007c9 	bl	c1cf8dc <uart0_puts>
	rtc_time->sec = uart0_getint();
 c1cd9b4:	eb000865 	bl	c1cfb50 <uart0_getint>
 c1cd9b8:	e1a03000 	mov	r3, r0
 c1cd9bc:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cd9c0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cd9c4:	e5c32000 	strb	r2, [r3]
}
 c1cd9c8:	e24bd00c 	sub	sp, fp, #12
 c1cd9cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cd9d0:	e12fff1e 	bx	lr
 c1cd9d4:	0c1020e4 	.word	0x0c1020e4
 c1cd9d8:	0c1020ec 	.word	0x0c1020ec
 c1cd9dc:	0c1020f4 	.word	0x0c1020f4
 c1cd9e0:	0c1020fc 	.word	0x0c1020fc
 c1cd9e4:	0c102110 	.word	0x0c102110
 c1cd9e8:	0c102118 	.word	0x0c102118
 c1cd9ec:	0c102124 	.word	0x0c102124

0c1cd9f0 <rtc_ISR>:

void rtc_ISR() {
 c1cd9f0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cd9f4:	e1a0c00d 	mov	ip, sp
 c1cd9f8:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cd9fc:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;

	rtc_gettime(&rtc_time);
 c1cda00:	e59f0028 	ldr	r0, [pc, #40]	; c1cda30 <rtc_ISR+0x40>
 c1cda04:	eb0001be 	bl	c1ce104 <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c1cda08:	e59f0020 	ldr	r0, [pc, #32]	; c1cda30 <rtc_ISR+0x40>
 c1cda0c:	eb0008c6 	bl	c1cfd2c <uart0_put_rtc_time>
	uart0_putchar('\n');
 c1cda10:	e3a0000a 	mov	r0, #10
 c1cda14:	eb00078a 	bl	c1cf844 <uart0_putchar>

	ic_cleanflag(INT_TICK);
 c1cda18:	e3a00014 	mov	r0, #20
 c1cda1c:	ebfffb3d 	bl	c1cc718 <ic_cleanflag>
}
 c1cda20:	e24bd01c 	sub	sp, fp, #28
 c1cda24:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cda28:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cda2c:	e25ef004 	subs	pc, lr, #4
 c1cda30:	0c10b8f8 	.word	0x0c10b8f8

0c1cda34 <rtc_alarm_ISR>:

void rtc_alarm_ISR(void) {
 c1cda34:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cda38:	e1a0c00d 	mov	ip, sp
 c1cda3c:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cda40:	e24cb004 	sub	fp, ip, #4
	uart0_puts("\nALARM GOES OFF!\n");
 c1cda44:	e59f0018 	ldr	r0, [pc, #24]	; c1cda64 <rtc_alarm_ISR+0x30>
 c1cda48:	eb0007a3 	bl	c1cf8dc <uart0_puts>
	ic_cleanflag(INT_RTC);
 c1cda4c:	e3a00001 	mov	r0, #1
 c1cda50:	ebfffb30 	bl	c1cc718 <ic_cleanflag>
}
 c1cda54:	e24bd01c 	sub	sp, fp, #28
 c1cda58:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cda5c:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cda60:	e25ef004 	subs	pc, lr, #4
 c1cda64:	0c102130 	.word	0x0c102130

0c1cda68 <clock_setup>:

void clock_setup() {
 c1cda68:	e1a0c00d 	mov	ip, sp
 c1cda6c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cda70:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;
	uart0_puts("Initial time: \n");
 c1cda74:	e59f0128 	ldr	r0, [pc, #296]	; c1cdba4 <clock_setup+0x13c>
 c1cda78:	eb000797 	bl	c1cf8dc <uart0_puts>
	rtc_gettime(&rtc_time);
 c1cda7c:	e59f0124 	ldr	r0, [pc, #292]	; c1cdba8 <clock_setup+0x140>
 c1cda80:	eb00019f 	bl	c1ce104 <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c1cda84:	e59f011c 	ldr	r0, [pc, #284]	; c1cdba8 <clock_setup+0x140>
 c1cda88:	eb0008a7 	bl	c1cfd2c <uart0_put_rtc_time>

	//Ask for time first time
	read_date(&rtc_time);
 c1cda8c:	e59f0114 	ldr	r0, [pc, #276]	; c1cdba8 <clock_setup+0x140>
 c1cda90:	ebffff96 	bl	c1cd8f0 <read_date>
	rtc_puttime(&rtc_time);
 c1cda94:	e59f010c 	ldr	r0, [pc, #268]	; c1cdba8 <clock_setup+0x140>
 c1cda98:	eb0000a4 	bl	c1cdd30 <rtc_puttime>

	//Set alarm 10 seconds from now (imperfect but enough)

	rtc_time.sec += 10;
 c1cda9c:	e59f3104 	ldr	r3, [pc, #260]	; c1cdba8 <clock_setup+0x140>
 c1cdaa0:	e5d33000 	ldrb	r3, [r3]
 c1cdaa4:	e283300a 	add	r3, r3, #10
 c1cdaa8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdaac:	e59f30f4 	ldr	r3, [pc, #244]	; c1cdba8 <clock_setup+0x140>
 c1cdab0:	e5c32000 	strb	r2, [r3]
	if(rtc_time.sec >= 60) {
 c1cdab4:	e59f30ec 	ldr	r3, [pc, #236]	; c1cdba8 <clock_setup+0x140>
 c1cdab8:	e5d33000 	ldrb	r3, [r3]
 c1cdabc:	e353003b 	cmp	r3, #59	; 0x3b
 c1cdac0:	9a00000b 	bls	c1cdaf4 <clock_setup+0x8c>
		rtc_time.sec -= 60;
 c1cdac4:	e59f30dc 	ldr	r3, [pc, #220]	; c1cdba8 <clock_setup+0x140>
 c1cdac8:	e5d33000 	ldrb	r3, [r3]
 c1cdacc:	e243303c 	sub	r3, r3, #60	; 0x3c
 c1cdad0:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdad4:	e59f30cc 	ldr	r3, [pc, #204]	; c1cdba8 <clock_setup+0x140>
 c1cdad8:	e5c32000 	strb	r2, [r3]
		rtc_time.min++;
 c1cdadc:	e59f30c4 	ldr	r3, [pc, #196]	; c1cdba8 <clock_setup+0x140>
 c1cdae0:	e5d33001 	ldrb	r3, [r3, #1]
 c1cdae4:	e2833001 	add	r3, r3, #1
 c1cdae8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdaec:	e59f30b4 	ldr	r3, [pc, #180]	; c1cdba8 <clock_setup+0x140>
 c1cdaf0:	e5c32001 	strb	r2, [r3, #1]
	}

	if(rtc_time.min >= 60) {
 c1cdaf4:	e59f30ac 	ldr	r3, [pc, #172]	; c1cdba8 <clock_setup+0x140>
 c1cdaf8:	e5d33001 	ldrb	r3, [r3, #1]
 c1cdafc:	e353003b 	cmp	r3, #59	; 0x3b
 c1cdb00:	9a00000b 	bls	c1cdb34 <clock_setup+0xcc>
		rtc_time.min -= 60;
 c1cdb04:	e59f309c 	ldr	r3, [pc, #156]	; c1cdba8 <clock_setup+0x140>
 c1cdb08:	e5d33001 	ldrb	r3, [r3, #1]
 c1cdb0c:	e243303c 	sub	r3, r3, #60	; 0x3c
 c1cdb10:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdb14:	e59f308c 	ldr	r3, [pc, #140]	; c1cdba8 <clock_setup+0x140>
 c1cdb18:	e5c32001 	strb	r2, [r3, #1]
		rtc_time.hour++;
 c1cdb1c:	e59f3084 	ldr	r3, [pc, #132]	; c1cdba8 <clock_setup+0x140>
 c1cdb20:	e5d33002 	ldrb	r3, [r3, #2]
 c1cdb24:	e2833001 	add	r3, r3, #1
 c1cdb28:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdb2c:	e59f3074 	ldr	r3, [pc, #116]	; c1cdba8 <clock_setup+0x140>
 c1cdb30:	e5c32002 	strb	r2, [r3, #2]
	}

	if(rtc_time.hour >= 24) {
 c1cdb34:	e59f306c 	ldr	r3, [pc, #108]	; c1cdba8 <clock_setup+0x140>
 c1cdb38:	e5d33002 	ldrb	r3, [r3, #2]
 c1cdb3c:	e3530017 	cmp	r3, #23
 c1cdb40:	9a00000b 	bls	c1cdb74 <clock_setup+0x10c>
		rtc_time.hour--;
 c1cdb44:	e59f305c 	ldr	r3, [pc, #92]	; c1cdba8 <clock_setup+0x140>
 c1cdb48:	e5d33002 	ldrb	r3, [r3, #2]
 c1cdb4c:	e2433001 	sub	r3, r3, #1
 c1cdb50:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdb54:	e59f304c 	ldr	r3, [pc, #76]	; c1cdba8 <clock_setup+0x140>
 c1cdb58:	e5c32002 	strb	r2, [r3, #2]
		rtc_time.mday++;
 c1cdb5c:	e59f3044 	ldr	r3, [pc, #68]	; c1cdba8 <clock_setup+0x140>
 c1cdb60:	e5d33003 	ldrb	r3, [r3, #3]
 c1cdb64:	e2833001 	add	r3, r3, #1
 c1cdb68:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdb6c:	e59f3034 	ldr	r3, [pc, #52]	; c1cdba8 <clock_setup+0x140>
 c1cdb70:	e5c32003 	strb	r2, [r3, #3]
	}

	uart0_puts("Alarm time: ");
 c1cdb74:	e59f0030 	ldr	r0, [pc, #48]	; c1cdbac <clock_setup+0x144>
 c1cdb78:	eb000757 	bl	c1cf8dc <uart0_puts>
	uart0_put_rtc_time(&rtc_time);
 c1cdb7c:	e59f0024 	ldr	r0, [pc, #36]	; c1cdba8 <clock_setup+0x140>
 c1cdb80:	eb000869 	bl	c1cfd2c <uart0_put_rtc_time>
	uart0_putchar('\n');
 c1cdb84:	e3a0000a 	mov	r0, #10
 c1cdb88:	eb00072d 	bl	c1cf844 <uart0_putchar>

	rtc_set_alarm(rtc_alarm_ISR, &rtc_time);
 c1cdb8c:	e59f001c 	ldr	r0, [pc, #28]	; c1cdbb0 <clock_setup+0x148>
 c1cdb90:	e59f1010 	ldr	r1, [pc, #16]	; c1cdba8 <clock_setup+0x140>
 c1cdb94:	eb00026a 	bl	c1ce544 <rtc_set_alarm>
}
 c1cdb98:	e24bd00c 	sub	sp, fp, #12
 c1cdb9c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cdba0:	e12fff1e 	bx	lr
 c1cdba4:	0c102144 	.word	0x0c102144
 c1cdba8:	0c10b8f0 	.word	0x0c10b8f0
 c1cdbac:	0c102154 	.word	0x0c102154
 c1cdbb0:	0c1cda34 	.word	0x0c1cda34

0c1cdbb4 <startup>:

void startup() {
 c1cdbb4:	e1a0c00d 	mov	ip, sp
 c1cdbb8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cdbbc:	e24cb004 	sub	fp, ip, #4
	non_expropiative_kernel();
 c1cdbc0:	ebfff006 	bl	c1c9be0 <non_expropiative_kernel>
}
 c1cdbc4:	e24bd00c 	sub	sp, fp, #12
 c1cdbc8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cdbcc:	e12fff1e 	bx	lr

0c1cdbd0 <loop>:

int loop(void) {
 c1cdbd0:	e1a0c00d 	mov	ip, sp
 c1cdbd4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cdbd8:	e24cb004 	sub	fp, ip, #4
	return 0;
 c1cdbdc:	e3a03000 	mov	r3, #0
}
 c1cdbe0:	e1a00003 	mov	r0, r3
 c1cdbe4:	e24bd00c 	sub	sp, fp, #12
 c1cdbe8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cdbec:	e12fff1e 	bx	lr

0c1cdbf0 <main>:

int main(void) {
 c1cdbf0:	e1a0c00d 	mov	ip, sp
 c1cdbf4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cdbf8:	e24cb004 	sub	fp, ip, #4

	setup();
 c1cdbfc:	ebfffef5 	bl	c1cd7d8 <setup>
	startup();
 c1cdc00:	ebffffeb 	bl	c1cdbb4 <startup>

	while (1) {
		loop();
 c1cdc04:	ebfffff1 	bl	c1cdbd0 <loop>
	}
 c1cdc08:	eafffffd 	b	c1cdc04 <main+0x14>

0c1cdc0c <isr_TICK_dummy>:
#include "intcontroller.h"

void isr_TICK_dummy(void)  __attribute__ ((interrupt ("IRQ")));
void isr_ALARM_dummy(void) __attribute__ ((interrupt ("IRQ")));

void isr_TICK_dummy(void){
 c1cdc0c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cdc10:	e1a0c00d 	mov	ip, sp
 c1cdc14:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cdc18:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_TICK);
 c1cdc1c:	e3a00014 	mov	r0, #20
 c1cdc20:	ebfffabc 	bl	c1cc718 <ic_cleanflag>
}
 c1cdc24:	e24bd01c 	sub	sp, fp, #28
 c1cdc28:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cdc2c:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cdc30:	e25ef004 	subs	pc, lr, #4

0c1cdc34 <isr_ALARM_dummy>:

void isr_ALARM_dummy(void){
 c1cdc34:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cdc38:	e1a0c00d 	mov	ip, sp
 c1cdc3c:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cdc40:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_RTC);
 c1cdc44:	e3a00001 	mov	r0, #1
 c1cdc48:	ebfffab2 	bl	c1cc718 <ic_cleanflag>
}
 c1cdc4c:	e24bd01c 	sub	sp, fp, #28
 c1cdc50:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cdc54:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cdc58:	e25ef004 	subs	pc, lr, #4

0c1cdc5c <rtc_init>:

void rtc_init( void )
{
 c1cdc5c:	e1a0c00d 	mov	ip, sp
 c1cdc60:	e92dd800 	push	{fp, ip, lr, pc}
 c1cdc64:	e24cb004 	sub	fp, ip, #4
	//Disable Tick interrupt
    rTICINT   = 0x0;
 c1cdc68:	e59f3098 	ldr	r3, [pc, #152]	; c1cdd08 <rtc_init+0xac>
 c1cdc6c:	e3a02000 	mov	r2, #0
 c1cdc70:	e5c32000 	strb	r2, [r3]

    //Disable alarm
    rRTCALM  = 0x0;
 c1cdc74:	e59f3090 	ldr	r3, [pc, #144]	; c1cdd0c <rtc_init+0xb0>
 c1cdc78:	e3a02000 	mov	r2, #0
 c1cdc7c:	e5c32000 	strb	r2, [r3]

    //Disable Rounding
    rRTCRST  = 0x0;
 c1cdc80:	e59f3088 	ldr	r3, [pc, #136]	; c1cdd10 <rtc_init+0xb4>
 c1cdc84:	e3a02000 	mov	r2, #0
 c1cdc88:	e5c32000 	strb	r2, [r3]


    // RTCCON[2] = 0 merged BCD registers: única opción posible
    // RTCCON[1] = 0 Fuente de reloj primaria: única opción posible: XTAL
    // RTCCON[0] = 1 Enabled register read/write
    rRTCCON  = 0x1;
 c1cdc8c:	e59f3080 	ldr	r3, [pc, #128]	; c1cdd14 <rtc_init+0xb8>
 c1cdc90:	e3a02001 	mov	r2, #1
 c1cdc94:	e5c32000 	strb	r2, [r3]
    rBCDMIN  = 0x0;
    rBCDSEC  = 0x0;
    */

    //Init to 0
    rALMYEAR = 0;
 c1cdc98:	e59f3078 	ldr	r3, [pc, #120]	; c1cdd18 <rtc_init+0xbc>
 c1cdc9c:	e3a02000 	mov	r2, #0
 c1cdca0:	e5c32000 	strb	r2, [r3]
    rALMMON  = 0;
 c1cdca4:	e59f3070 	ldr	r3, [pc, #112]	; c1cdd1c <rtc_init+0xc0>
 c1cdca8:	e3a02000 	mov	r2, #0
 c1cdcac:	e5c32000 	strb	r2, [r3]
    rALMDAY  = 0;
 c1cdcb0:	e59f3068 	ldr	r3, [pc, #104]	; c1cdd20 <rtc_init+0xc4>
 c1cdcb4:	e3a02000 	mov	r2, #0
 c1cdcb8:	e5c32000 	strb	r2, [r3]
    rALMHOUR = 0;
 c1cdcbc:	e59f3060 	ldr	r3, [pc, #96]	; c1cdd24 <rtc_init+0xc8>
 c1cdcc0:	e3a02000 	mov	r2, #0
 c1cdcc4:	e5c32000 	strb	r2, [r3]
    rALMMIN  = 0;
 c1cdcc8:	e59f3058 	ldr	r3, [pc, #88]	; c1cdd28 <rtc_init+0xcc>
 c1cdccc:	e3a02000 	mov	r2, #0
 c1cdcd0:	e5c32000 	strb	r2, [r3]
    rALMSEC  = 0;
 c1cdcd4:	e59f3050 	ldr	r3, [pc, #80]	; c1cdd2c <rtc_init+0xd0>
 c1cdcd8:	e3a02000 	mov	r2, #0
 c1cdcdc:	e5c32000 	strb	r2, [r3]

    rRTCCON &= ~1;
 c1cdce0:	e59f302c 	ldr	r3, [pc, #44]	; c1cdd14 <rtc_init+0xb8>
 c1cdce4:	e59f2028 	ldr	r2, [pc, #40]	; c1cdd14 <rtc_init+0xb8>
 c1cdce8:	e5d22000 	ldrb	r2, [r2]
 c1cdcec:	e20220ff 	and	r2, r2, #255	; 0xff
 c1cdcf0:	e3c22001 	bic	r2, r2, #1
 c1cdcf4:	e20220ff 	and	r2, r2, #255	; 0xff
 c1cdcf8:	e5c32000 	strb	r2, [r3]
}
 c1cdcfc:	e24bd00c 	sub	sp, fp, #12
 c1cdd00:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cdd04:	e12fff1e 	bx	lr
 c1cdd08:	01d7008c 	.word	0x01d7008c
 c1cdd0c:	01d70050 	.word	0x01d70050
 c1cdd10:	01d7006c 	.word	0x01d7006c
 c1cdd14:	01d70040 	.word	0x01d70040
 c1cdd18:	01d70068 	.word	0x01d70068
 c1cdd1c:	01d70064 	.word	0x01d70064
 c1cdd20:	01d70060 	.word	0x01d70060
 c1cdd24:	01d7005c 	.word	0x01d7005c
 c1cdd28:	01d70058 	.word	0x01d70058
 c1cdd2c:	01d70054 	.word	0x01d70054

0c1cdd30 <rtc_puttime>:

void rtc_puttime( rtc_time_t *rtc_time )
{
 c1cdd30:	e1a0c00d 	mov	ip, sp
 c1cdd34:	e92dd800 	push	{fp, ip, lr, pc}
 c1cdd38:	e24cb004 	sub	fp, ip, #4
 c1cdd3c:	e24dd008 	sub	sp, sp, #8
 c1cdd40:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c1cdd44:	e59f3394 	ldr	r3, [pc, #916]	; c1ce0e0 <rtc_puttime+0x3b0>
 c1cdd48:	e59f2390 	ldr	r2, [pc, #912]	; c1ce0e0 <rtc_puttime+0x3b0>
 c1cdd4c:	e5d22000 	ldrb	r2, [r2]
 c1cdd50:	e20220ff 	and	r2, r2, #255	; 0xff
 c1cdd54:	e3822001 	orr	r2, r2, #1
 c1cdd58:	e20220ff 	and	r2, r2, #255	; 0xff
 c1cdd5c:	e5c32000 	strb	r2, [r3]

    rBCDYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c1cdd60:	e59f037c 	ldr	r0, [pc, #892]	; c1ce0e4 <rtc_puttime+0x3b4>
 c1cdd64:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdd68:	e5d32006 	ldrb	r2, [r3, #6]
 c1cdd6c:	e59f3374 	ldr	r3, [pc, #884]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdd70:	e0831392 	umull	r1, r3, r2, r3
 c1cdd74:	e1a031a3 	lsr	r3, r3, #3
 c1cdd78:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdd7c:	e59f3364 	ldr	r3, [pc, #868]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdd80:	e0831392 	umull	r1, r3, r2, r3
 c1cdd84:	e1a011a3 	lsr	r1, r3, #3
 c1cdd88:	e1a03001 	mov	r3, r1
 c1cdd8c:	e1a03103 	lsl	r3, r3, #2
 c1cdd90:	e0833001 	add	r3, r3, r1
 c1cdd94:	e1a03083 	lsl	r3, r3, #1
 c1cdd98:	e0633002 	rsb	r3, r3, r2
 c1cdd9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdda0:	e1a03203 	lsl	r3, r3, #4
 c1cdda4:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1cdda8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cddac:	e5d32006 	ldrb	r2, [r3, #6]
 c1cddb0:	e59f3330 	ldr	r3, [pc, #816]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cddb4:	e0831392 	umull	r1, r3, r2, r3
 c1cddb8:	e1a011a3 	lsr	r1, r3, #3
 c1cddbc:	e1a03001 	mov	r3, r1
 c1cddc0:	e1a03103 	lsl	r3, r3, #2
 c1cddc4:	e0833001 	add	r3, r3, r1
 c1cddc8:	e1a03083 	lsl	r3, r3, #1
 c1cddcc:	e0633002 	rsb	r3, r3, r2
 c1cddd0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cddd4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cddd8:	e1a0200c 	mov	r2, ip
 c1cdddc:	e1823003 	orr	r3, r2, r3
 c1cdde0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdde4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdde8:	e5c03000 	strb	r3, [r0]
    rBCDMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c1cddec:	e59f02f8 	ldr	r0, [pc, #760]	; c1ce0ec <rtc_puttime+0x3bc>
 c1cddf0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cddf4:	e5d32005 	ldrb	r2, [r3, #5]
 c1cddf8:	e59f32e8 	ldr	r3, [pc, #744]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cddfc:	e0831392 	umull	r1, r3, r2, r3
 c1cde00:	e1a031a3 	lsr	r3, r3, #3
 c1cde04:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cde08:	e59f32d8 	ldr	r3, [pc, #728]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cde0c:	e0831392 	umull	r1, r3, r2, r3
 c1cde10:	e1a011a3 	lsr	r1, r3, #3
 c1cde14:	e1a03001 	mov	r3, r1
 c1cde18:	e1a03103 	lsl	r3, r3, #2
 c1cde1c:	e0833001 	add	r3, r3, r1
 c1cde20:	e1a03083 	lsl	r3, r3, #1
 c1cde24:	e0633002 	rsb	r3, r3, r2
 c1cde28:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cde2c:	e1a03203 	lsl	r3, r3, #4
 c1cde30:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1cde34:	e51b3010 	ldr	r3, [fp, #-16]
 c1cde38:	e5d32005 	ldrb	r2, [r3, #5]
 c1cde3c:	e59f32a4 	ldr	r3, [pc, #676]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cde40:	e0831392 	umull	r1, r3, r2, r3
 c1cde44:	e1a011a3 	lsr	r1, r3, #3
 c1cde48:	e1a03001 	mov	r3, r1
 c1cde4c:	e1a03103 	lsl	r3, r3, #2
 c1cde50:	e0833001 	add	r3, r3, r1
 c1cde54:	e1a03083 	lsl	r3, r3, #1
 c1cde58:	e0633002 	rsb	r3, r3, r2
 c1cde5c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cde60:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cde64:	e1a0200c 	mov	r2, ip
 c1cde68:	e1823003 	orr	r3, r2, r3
 c1cde6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cde70:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cde74:	e5c03000 	strb	r3, [r0]
    rBCDDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c1cde78:	e59f0270 	ldr	r0, [pc, #624]	; c1ce0f0 <rtc_puttime+0x3c0>
 c1cde7c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cde80:	e5d32003 	ldrb	r2, [r3, #3]
 c1cde84:	e59f325c 	ldr	r3, [pc, #604]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cde88:	e0831392 	umull	r1, r3, r2, r3
 c1cde8c:	e1a031a3 	lsr	r3, r3, #3
 c1cde90:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cde94:	e59f324c 	ldr	r3, [pc, #588]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cde98:	e0831392 	umull	r1, r3, r2, r3
 c1cde9c:	e1a011a3 	lsr	r1, r3, #3
 c1cdea0:	e1a03001 	mov	r3, r1
 c1cdea4:	e1a03103 	lsl	r3, r3, #2
 c1cdea8:	e0833001 	add	r3, r3, r1
 c1cdeac:	e1a03083 	lsl	r3, r3, #1
 c1cdeb0:	e0633002 	rsb	r3, r3, r2
 c1cdeb4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdeb8:	e1a03203 	lsl	r3, r3, #4
 c1cdebc:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1cdec0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdec4:	e5d32003 	ldrb	r2, [r3, #3]
 c1cdec8:	e59f3218 	ldr	r3, [pc, #536]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdecc:	e0831392 	umull	r1, r3, r2, r3
 c1cded0:	e1a011a3 	lsr	r1, r3, #3
 c1cded4:	e1a03001 	mov	r3, r1
 c1cded8:	e1a03103 	lsl	r3, r3, #2
 c1cdedc:	e0833001 	add	r3, r3, r1
 c1cdee0:	e1a03083 	lsl	r3, r3, #1
 c1cdee4:	e0633002 	rsb	r3, r3, r2
 c1cdee8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdeec:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdef0:	e1a0200c 	mov	r2, ip
 c1cdef4:	e1823003 	orr	r3, r2, r3
 c1cdef8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdefc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf00:	e5c03000 	strb	r3, [r0]
    rBCDDATE = rtc_time->wday;
 c1cdf04:	e59f31e8 	ldr	r3, [pc, #488]	; c1ce0f4 <rtc_puttime+0x3c4>
 c1cdf08:	e51b2010 	ldr	r2, [fp, #-16]
 c1cdf0c:	e5d22004 	ldrb	r2, [r2, #4]
 c1cdf10:	e5c32000 	strb	r2, [r3]
    rBCDHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c1cdf14:	e59f01dc 	ldr	r0, [pc, #476]	; c1ce0f8 <rtc_puttime+0x3c8>
 c1cdf18:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdf1c:	e5d32002 	ldrb	r2, [r3, #2]
 c1cdf20:	e59f31c0 	ldr	r3, [pc, #448]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdf24:	e0831392 	umull	r1, r3, r2, r3
 c1cdf28:	e1a031a3 	lsr	r3, r3, #3
 c1cdf2c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdf30:	e59f31b0 	ldr	r3, [pc, #432]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdf34:	e0831392 	umull	r1, r3, r2, r3
 c1cdf38:	e1a011a3 	lsr	r1, r3, #3
 c1cdf3c:	e1a03001 	mov	r3, r1
 c1cdf40:	e1a03103 	lsl	r3, r3, #2
 c1cdf44:	e0833001 	add	r3, r3, r1
 c1cdf48:	e1a03083 	lsl	r3, r3, #1
 c1cdf4c:	e0633002 	rsb	r3, r3, r2
 c1cdf50:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf54:	e1a03203 	lsl	r3, r3, #4
 c1cdf58:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1cdf5c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdf60:	e5d32002 	ldrb	r2, [r3, #2]
 c1cdf64:	e59f317c 	ldr	r3, [pc, #380]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdf68:	e0831392 	umull	r1, r3, r2, r3
 c1cdf6c:	e1a011a3 	lsr	r1, r3, #3
 c1cdf70:	e1a03001 	mov	r3, r1
 c1cdf74:	e1a03103 	lsl	r3, r3, #2
 c1cdf78:	e0833001 	add	r3, r3, r1
 c1cdf7c:	e1a03083 	lsl	r3, r3, #1
 c1cdf80:	e0633002 	rsb	r3, r3, r2
 c1cdf84:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf88:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf8c:	e1a0200c 	mov	r2, ip
 c1cdf90:	e1823003 	orr	r3, r2, r3
 c1cdf94:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf98:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdf9c:	e5c03000 	strb	r3, [r0]
    rBCDMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c1cdfa0:	e59f0154 	ldr	r0, [pc, #340]	; c1ce0fc <rtc_puttime+0x3cc>
 c1cdfa4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdfa8:	e5d32001 	ldrb	r2, [r3, #1]
 c1cdfac:	e59f3134 	ldr	r3, [pc, #308]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdfb0:	e0831392 	umull	r1, r3, r2, r3
 c1cdfb4:	e1a031a3 	lsr	r3, r3, #3
 c1cdfb8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cdfbc:	e59f3124 	ldr	r3, [pc, #292]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdfc0:	e0831392 	umull	r1, r3, r2, r3
 c1cdfc4:	e1a011a3 	lsr	r1, r3, #3
 c1cdfc8:	e1a03001 	mov	r3, r1
 c1cdfcc:	e1a03103 	lsl	r3, r3, #2
 c1cdfd0:	e0833001 	add	r3, r3, r1
 c1cdfd4:	e1a03083 	lsl	r3, r3, #1
 c1cdfd8:	e0633002 	rsb	r3, r3, r2
 c1cdfdc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cdfe0:	e1a03203 	lsl	r3, r3, #4
 c1cdfe4:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1cdfe8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cdfec:	e5d32001 	ldrb	r2, [r3, #1]
 c1cdff0:	e59f30f0 	ldr	r3, [pc, #240]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1cdff4:	e0831392 	umull	r1, r3, r2, r3
 c1cdff8:	e1a011a3 	lsr	r1, r3, #3
 c1cdffc:	e1a03001 	mov	r3, r1
 c1ce000:	e1a03103 	lsl	r3, r3, #2
 c1ce004:	e0833001 	add	r3, r3, r1
 c1ce008:	e1a03083 	lsl	r3, r3, #1
 c1ce00c:	e0633002 	rsb	r3, r3, r2
 c1ce010:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce014:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce018:	e1a0200c 	mov	r2, ip
 c1ce01c:	e1823003 	orr	r3, r2, r3
 c1ce020:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce024:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce028:	e5c03000 	strb	r3, [r0]
    rBCDSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c1ce02c:	e59f00cc 	ldr	r0, [pc, #204]	; c1ce100 <rtc_puttime+0x3d0>
 c1ce030:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce034:	e5d32000 	ldrb	r2, [r3]
 c1ce038:	e59f30a8 	ldr	r3, [pc, #168]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1ce03c:	e0831392 	umull	r1, r3, r2, r3
 c1ce040:	e1a031a3 	lsr	r3, r3, #3
 c1ce044:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce048:	e59f3098 	ldr	r3, [pc, #152]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1ce04c:	e0831392 	umull	r1, r3, r2, r3
 c1ce050:	e1a011a3 	lsr	r1, r3, #3
 c1ce054:	e1a03001 	mov	r3, r1
 c1ce058:	e1a03103 	lsl	r3, r3, #2
 c1ce05c:	e0833001 	add	r3, r3, r1
 c1ce060:	e1a03083 	lsl	r3, r3, #1
 c1ce064:	e0633002 	rsb	r3, r3, r2
 c1ce068:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce06c:	e1a03203 	lsl	r3, r3, #4
 c1ce070:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce074:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce078:	e5d32000 	ldrb	r2, [r3]
 c1ce07c:	e59f3064 	ldr	r3, [pc, #100]	; c1ce0e8 <rtc_puttime+0x3b8>
 c1ce080:	e0831392 	umull	r1, r3, r2, r3
 c1ce084:	e1a011a3 	lsr	r1, r3, #3
 c1ce088:	e1a03001 	mov	r3, r1
 c1ce08c:	e1a03103 	lsl	r3, r3, #2
 c1ce090:	e0833001 	add	r3, r3, r1
 c1ce094:	e1a03083 	lsl	r3, r3, #1
 c1ce098:	e0633002 	rsb	r3, r3, r2
 c1ce09c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce0a0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce0a4:	e1a0200c 	mov	r2, ip
 c1ce0a8:	e1823003 	orr	r3, r2, r3
 c1ce0ac:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce0b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce0b4:	e5c03000 	strb	r3, [r0]

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c1ce0b8:	e59f3020 	ldr	r3, [pc, #32]	; c1ce0e0 <rtc_puttime+0x3b0>
 c1ce0bc:	e59f201c 	ldr	r2, [pc, #28]	; c1ce0e0 <rtc_puttime+0x3b0>
 c1ce0c0:	e5d22000 	ldrb	r2, [r2]
 c1ce0c4:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce0c8:	e3c22001 	bic	r2, r2, #1
 c1ce0cc:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce0d0:	e5c32000 	strb	r2, [r3]
}
 c1ce0d4:	e24bd00c 	sub	sp, fp, #12
 c1ce0d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce0dc:	e12fff1e 	bx	lr
 c1ce0e0:	01d70040 	.word	0x01d70040
 c1ce0e4:	01d70088 	.word	0x01d70088
 c1ce0e8:	cccccccd 	.word	0xcccccccd
 c1ce0ec:	01d70084 	.word	0x01d70084
 c1ce0f0:	01d7007c 	.word	0x01d7007c
 c1ce0f4:	01d70080 	.word	0x01d70080
 c1ce0f8:	01d70078 	.word	0x01d70078
 c1ce0fc:	01d70074 	.word	0x01d70074
 c1ce100:	01d70070 	.word	0x01d70070

0c1ce104 <rtc_gettime>:

void rtc_gettime( rtc_time_t *rtc_time )
{
 c1ce104:	e1a0c00d 	mov	ip, sp
 c1ce108:	e92dd800 	push	{fp, ip, lr, pc}
 c1ce10c:	e24cb004 	sub	fp, ip, #4
 c1ce110:	e24dd008 	sub	sp, sp, #8
 c1ce114:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c1ce118:	e59f3404 	ldr	r3, [pc, #1028]	; c1ce524 <rtc_gettime+0x420>
 c1ce11c:	e59f2400 	ldr	r2, [pc, #1024]	; c1ce524 <rtc_gettime+0x420>
 c1ce120:	e5d22000 	ldrb	r2, [r2]
 c1ce124:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce128:	e3822001 	orr	r2, r2, #1
 c1ce12c:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce130:	e5c32000 	strb	r2, [r3]

    rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c1ce134:	e59f33ec 	ldr	r3, [pc, #1004]	; c1ce528 <rtc_gettime+0x424>
 c1ce138:	e5d33000 	ldrb	r3, [r3]
 c1ce13c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce140:	e203300f 	and	r3, r3, #15
 c1ce144:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce148:	e59f33d8 	ldr	r3, [pc, #984]	; c1ce528 <rtc_gettime+0x424>
 c1ce14c:	e5d33000 	ldrb	r3, [r3]
 c1ce150:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce154:	e1a03223 	lsr	r3, r3, #4
 c1ce158:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce15c:	e1a01003 	mov	r1, r3
 c1ce160:	e1a01101 	lsl	r1, r1, #2
 c1ce164:	e0813003 	add	r3, r1, r3
 c1ce168:	e1a03083 	lsl	r3, r3, #1
 c1ce16c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce170:	e0823003 	add	r3, r2, r3
 c1ce174:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce178:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce17c:	e5c32006 	strb	r2, [r3, #6]
    rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c1ce180:	e59f33a4 	ldr	r3, [pc, #932]	; c1ce52c <rtc_gettime+0x428>
 c1ce184:	e5d33000 	ldrb	r3, [r3]
 c1ce188:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce18c:	e203300f 	and	r3, r3, #15
 c1ce190:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce194:	e59f3390 	ldr	r3, [pc, #912]	; c1ce52c <rtc_gettime+0x428>
 c1ce198:	e5d33000 	ldrb	r3, [r3]
 c1ce19c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1a0:	e1a03223 	lsr	r3, r3, #4
 c1ce1a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1a8:	e1a01003 	mov	r1, r3
 c1ce1ac:	e1a01101 	lsl	r1, r1, #2
 c1ce1b0:	e0813003 	add	r3, r1, r3
 c1ce1b4:	e1a03083 	lsl	r3, r3, #1
 c1ce1b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1bc:	e0823003 	add	r3, r2, r3
 c1ce1c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce1c4:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce1c8:	e5c32005 	strb	r2, [r3, #5]
    rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c1ce1cc:	e59f335c 	ldr	r3, [pc, #860]	; c1ce530 <rtc_gettime+0x42c>
 c1ce1d0:	e5d33000 	ldrb	r3, [r3]
 c1ce1d4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1d8:	e203300f 	and	r3, r3, #15
 c1ce1dc:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce1e0:	e59f3348 	ldr	r3, [pc, #840]	; c1ce530 <rtc_gettime+0x42c>
 c1ce1e4:	e5d33000 	ldrb	r3, [r3]
 c1ce1e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1ec:	e1a03223 	lsr	r3, r3, #4
 c1ce1f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce1f4:	e1a01003 	mov	r1, r3
 c1ce1f8:	e1a01101 	lsl	r1, r1, #2
 c1ce1fc:	e0813003 	add	r3, r1, r3
 c1ce200:	e1a03083 	lsl	r3, r3, #1
 c1ce204:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce208:	e0823003 	add	r3, r2, r3
 c1ce20c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce210:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce214:	e5c32003 	strb	r2, [r3, #3]
    rtc_time->wday = rBCDDATE;
 c1ce218:	e59f3314 	ldr	r3, [pc, #788]	; c1ce534 <rtc_gettime+0x430>
 c1ce21c:	e5d33000 	ldrb	r3, [r3]
 c1ce220:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce224:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce228:	e5c32004 	strb	r2, [r3, #4]
    rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c1ce22c:	e59f3304 	ldr	r3, [pc, #772]	; c1ce538 <rtc_gettime+0x434>
 c1ce230:	e5d33000 	ldrb	r3, [r3]
 c1ce234:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce238:	e203300f 	and	r3, r3, #15
 c1ce23c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce240:	e59f32f0 	ldr	r3, [pc, #752]	; c1ce538 <rtc_gettime+0x434>
 c1ce244:	e5d33000 	ldrb	r3, [r3]
 c1ce248:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce24c:	e1a03223 	lsr	r3, r3, #4
 c1ce250:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce254:	e1a01003 	mov	r1, r3
 c1ce258:	e1a01101 	lsl	r1, r1, #2
 c1ce25c:	e0813003 	add	r3, r1, r3
 c1ce260:	e1a03083 	lsl	r3, r3, #1
 c1ce264:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce268:	e0823003 	add	r3, r2, r3
 c1ce26c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce270:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce274:	e5c32002 	strb	r2, [r3, #2]
    rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c1ce278:	e59f32bc 	ldr	r3, [pc, #700]	; c1ce53c <rtc_gettime+0x438>
 c1ce27c:	e5d33000 	ldrb	r3, [r3]
 c1ce280:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce284:	e203300f 	and	r3, r3, #15
 c1ce288:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce28c:	e59f32a8 	ldr	r3, [pc, #680]	; c1ce53c <rtc_gettime+0x438>
 c1ce290:	e5d33000 	ldrb	r3, [r3]
 c1ce294:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce298:	e1a03223 	lsr	r3, r3, #4
 c1ce29c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce2a0:	e1a01003 	mov	r1, r3
 c1ce2a4:	e1a01101 	lsl	r1, r1, #2
 c1ce2a8:	e0813003 	add	r3, r1, r3
 c1ce2ac:	e1a03083 	lsl	r3, r3, #1
 c1ce2b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce2b4:	e0823003 	add	r3, r2, r3
 c1ce2b8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce2bc:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce2c0:	e5c32001 	strb	r2, [r3, #1]
    rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c1ce2c4:	e59f3274 	ldr	r3, [pc, #628]	; c1ce540 <rtc_gettime+0x43c>
 c1ce2c8:	e5d33000 	ldrb	r3, [r3]
 c1ce2cc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce2d0:	e203300f 	and	r3, r3, #15
 c1ce2d4:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce2d8:	e59f3260 	ldr	r3, [pc, #608]	; c1ce540 <rtc_gettime+0x43c>
 c1ce2dc:	e5d33000 	ldrb	r3, [r3]
 c1ce2e0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce2e4:	e1a03223 	lsr	r3, r3, #4
 c1ce2e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce2ec:	e1a01003 	mov	r1, r3
 c1ce2f0:	e1a01101 	lsl	r1, r1, #2
 c1ce2f4:	e0813003 	add	r3, r1, r3
 c1ce2f8:	e1a03083 	lsl	r3, r3, #1
 c1ce2fc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce300:	e0823003 	add	r3, r2, r3
 c1ce304:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce308:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce30c:	e5c32000 	strb	r2, [r3]
    if( ! rtc_time->sec ){
 c1ce310:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce314:	e5d33000 	ldrb	r3, [r3]
 c1ce318:	e3530000 	cmp	r3, #0
 c1ce31c:	1a000076 	bne	c1ce4fc <rtc_gettime+0x3f8>
    	//Reread, a second may have elapsed so date is invalid
        rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c1ce320:	e59f3200 	ldr	r3, [pc, #512]	; c1ce528 <rtc_gettime+0x424>
 c1ce324:	e5d33000 	ldrb	r3, [r3]
 c1ce328:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce32c:	e203300f 	and	r3, r3, #15
 c1ce330:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce334:	e59f31ec 	ldr	r3, [pc, #492]	; c1ce528 <rtc_gettime+0x424>
 c1ce338:	e5d33000 	ldrb	r3, [r3]
 c1ce33c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce340:	e1a03223 	lsr	r3, r3, #4
 c1ce344:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce348:	e1a01003 	mov	r1, r3
 c1ce34c:	e1a01101 	lsl	r1, r1, #2
 c1ce350:	e0813003 	add	r3, r1, r3
 c1ce354:	e1a03083 	lsl	r3, r3, #1
 c1ce358:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce35c:	e0823003 	add	r3, r2, r3
 c1ce360:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce364:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce368:	e5c32006 	strb	r2, [r3, #6]
        rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c1ce36c:	e59f31b8 	ldr	r3, [pc, #440]	; c1ce52c <rtc_gettime+0x428>
 c1ce370:	e5d33000 	ldrb	r3, [r3]
 c1ce374:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce378:	e203300f 	and	r3, r3, #15
 c1ce37c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce380:	e59f31a4 	ldr	r3, [pc, #420]	; c1ce52c <rtc_gettime+0x428>
 c1ce384:	e5d33000 	ldrb	r3, [r3]
 c1ce388:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce38c:	e1a03223 	lsr	r3, r3, #4
 c1ce390:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce394:	e1a01003 	mov	r1, r3
 c1ce398:	e1a01101 	lsl	r1, r1, #2
 c1ce39c:	e0813003 	add	r3, r1, r3
 c1ce3a0:	e1a03083 	lsl	r3, r3, #1
 c1ce3a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce3a8:	e0823003 	add	r3, r2, r3
 c1ce3ac:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce3b0:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce3b4:	e5c32005 	strb	r2, [r3, #5]
        rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c1ce3b8:	e59f3170 	ldr	r3, [pc, #368]	; c1ce530 <rtc_gettime+0x42c>
 c1ce3bc:	e5d33000 	ldrb	r3, [r3]
 c1ce3c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce3c4:	e203300f 	and	r3, r3, #15
 c1ce3c8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce3cc:	e59f315c 	ldr	r3, [pc, #348]	; c1ce530 <rtc_gettime+0x42c>
 c1ce3d0:	e5d33000 	ldrb	r3, [r3]
 c1ce3d4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce3d8:	e1a03223 	lsr	r3, r3, #4
 c1ce3dc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce3e0:	e1a01003 	mov	r1, r3
 c1ce3e4:	e1a01101 	lsl	r1, r1, #2
 c1ce3e8:	e0813003 	add	r3, r1, r3
 c1ce3ec:	e1a03083 	lsl	r3, r3, #1
 c1ce3f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce3f4:	e0823003 	add	r3, r2, r3
 c1ce3f8:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce3fc:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce400:	e5c32003 	strb	r2, [r3, #3]
        rtc_time->wday = rBCDDATE;
 c1ce404:	e59f3128 	ldr	r3, [pc, #296]	; c1ce534 <rtc_gettime+0x430>
 c1ce408:	e5d33000 	ldrb	r3, [r3]
 c1ce40c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce410:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce414:	e5c32004 	strb	r2, [r3, #4]
        rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c1ce418:	e59f3118 	ldr	r3, [pc, #280]	; c1ce538 <rtc_gettime+0x434>
 c1ce41c:	e5d33000 	ldrb	r3, [r3]
 c1ce420:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce424:	e203300f 	and	r3, r3, #15
 c1ce428:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce42c:	e59f3104 	ldr	r3, [pc, #260]	; c1ce538 <rtc_gettime+0x434>
 c1ce430:	e5d33000 	ldrb	r3, [r3]
 c1ce434:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce438:	e1a03223 	lsr	r3, r3, #4
 c1ce43c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce440:	e1a01003 	mov	r1, r3
 c1ce444:	e1a01101 	lsl	r1, r1, #2
 c1ce448:	e0813003 	add	r3, r1, r3
 c1ce44c:	e1a03083 	lsl	r3, r3, #1
 c1ce450:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce454:	e0823003 	add	r3, r2, r3
 c1ce458:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce45c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce460:	e5c32002 	strb	r2, [r3, #2]
        rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c1ce464:	e59f30d0 	ldr	r3, [pc, #208]	; c1ce53c <rtc_gettime+0x438>
 c1ce468:	e5d33000 	ldrb	r3, [r3]
 c1ce46c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce470:	e203300f 	and	r3, r3, #15
 c1ce474:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce478:	e59f30bc 	ldr	r3, [pc, #188]	; c1ce53c <rtc_gettime+0x438>
 c1ce47c:	e5d33000 	ldrb	r3, [r3]
 c1ce480:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce484:	e1a03223 	lsr	r3, r3, #4
 c1ce488:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce48c:	e1a01003 	mov	r1, r3
 c1ce490:	e1a01101 	lsl	r1, r1, #2
 c1ce494:	e0813003 	add	r3, r1, r3
 c1ce498:	e1a03083 	lsl	r3, r3, #1
 c1ce49c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce4a0:	e0823003 	add	r3, r2, r3
 c1ce4a4:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce4a8:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce4ac:	e5c32001 	strb	r2, [r3, #1]
        rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c1ce4b0:	e59f3088 	ldr	r3, [pc, #136]	; c1ce540 <rtc_gettime+0x43c>
 c1ce4b4:	e5d33000 	ldrb	r3, [r3]
 c1ce4b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce4bc:	e203300f 	and	r3, r3, #15
 c1ce4c0:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce4c4:	e59f3074 	ldr	r3, [pc, #116]	; c1ce540 <rtc_gettime+0x43c>
 c1ce4c8:	e5d33000 	ldrb	r3, [r3]
 c1ce4cc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce4d0:	e1a03223 	lsr	r3, r3, #4
 c1ce4d4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce4d8:	e1a01003 	mov	r1, r3
 c1ce4dc:	e1a01101 	lsl	r1, r1, #2
 c1ce4e0:	e0813003 	add	r3, r1, r3
 c1ce4e4:	e1a03083 	lsl	r3, r3, #1
 c1ce4e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce4ec:	e0823003 	add	r3, r2, r3
 c1ce4f0:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce4f4:	e51b3010 	ldr	r3, [fp, #-16]
 c1ce4f8:	e5c32000 	strb	r2, [r3]
    }

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c1ce4fc:	e59f3020 	ldr	r3, [pc, #32]	; c1ce524 <rtc_gettime+0x420>
 c1ce500:	e59f201c 	ldr	r2, [pc, #28]	; c1ce524 <rtc_gettime+0x420>
 c1ce504:	e5d22000 	ldrb	r2, [r2]
 c1ce508:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce50c:	e3c22001 	bic	r2, r2, #1
 c1ce510:	e20220ff 	and	r2, r2, #255	; 0xff
 c1ce514:	e5c32000 	strb	r2, [r3]
}
 c1ce518:	e24bd00c 	sub	sp, fp, #12
 c1ce51c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce520:	e12fff1e 	bx	lr
 c1ce524:	01d70040 	.word	0x01d70040
 c1ce528:	01d70088 	.word	0x01d70088
 c1ce52c:	01d70084 	.word	0x01d70084
 c1ce530:	01d7007c 	.word	0x01d7007c
 c1ce534:	01d70080 	.word	0x01d70080
 c1ce538:	01d70078 	.word	0x01d70078
 c1ce53c:	01d70074 	.word	0x01d70074
 c1ce540:	01d70070 	.word	0x01d70070

0c1ce544 <rtc_set_alarm>:

void rtc_set_alarm( void(*isr)(void), rtc_time_t* rtc_time ) {
 c1ce544:	e1a0c00d 	mov	ip, sp
 c1ce548:	e92dd800 	push	{fp, ip, lr, pc}
 c1ce54c:	e24cb004 	sub	fp, ip, #4
 c1ce550:	e24dd008 	sub	sp, sp, #8
 c1ce554:	e50b0010 	str	r0, [fp, #-16]
 c1ce558:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec


    //Set alarm date
    rALMYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c1ce55c:	e59f0380 	ldr	r0, [pc, #896]	; c1ce8e4 <rtc_set_alarm+0x3a0>
 c1ce560:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce564:	e5d32006 	ldrb	r2, [r3, #6]
 c1ce568:	e59f3378 	ldr	r3, [pc, #888]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce56c:	e0831392 	umull	r1, r3, r2, r3
 c1ce570:	e1a031a3 	lsr	r3, r3, #3
 c1ce574:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce578:	e59f3368 	ldr	r3, [pc, #872]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce57c:	e0831392 	umull	r1, r3, r2, r3
 c1ce580:	e1a011a3 	lsr	r1, r3, #3
 c1ce584:	e1a03001 	mov	r3, r1
 c1ce588:	e1a03103 	lsl	r3, r3, #2
 c1ce58c:	e0833001 	add	r3, r3, r1
 c1ce590:	e1a03083 	lsl	r3, r3, #1
 c1ce594:	e0633002 	rsb	r3, r3, r2
 c1ce598:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce59c:	e1a03203 	lsl	r3, r3, #4
 c1ce5a0:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce5a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce5a8:	e5d32006 	ldrb	r2, [r3, #6]
 c1ce5ac:	e59f3334 	ldr	r3, [pc, #820]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce5b0:	e0831392 	umull	r1, r3, r2, r3
 c1ce5b4:	e1a011a3 	lsr	r1, r3, #3
 c1ce5b8:	e1a03001 	mov	r3, r1
 c1ce5bc:	e1a03103 	lsl	r3, r3, #2
 c1ce5c0:	e0833001 	add	r3, r3, r1
 c1ce5c4:	e1a03083 	lsl	r3, r3, #1
 c1ce5c8:	e0633002 	rsb	r3, r3, r2
 c1ce5cc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce5d0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce5d4:	e1a0200c 	mov	r2, ip
 c1ce5d8:	e1823003 	orr	r3, r2, r3
 c1ce5dc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce5e0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce5e4:	e5c03000 	strb	r3, [r0]
    rALMMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c1ce5e8:	e59f02fc 	ldr	r0, [pc, #764]	; c1ce8ec <rtc_set_alarm+0x3a8>
 c1ce5ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce5f0:	e5d32005 	ldrb	r2, [r3, #5]
 c1ce5f4:	e59f32ec 	ldr	r3, [pc, #748]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce5f8:	e0831392 	umull	r1, r3, r2, r3
 c1ce5fc:	e1a031a3 	lsr	r3, r3, #3
 c1ce600:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce604:	e59f32dc 	ldr	r3, [pc, #732]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce608:	e0831392 	umull	r1, r3, r2, r3
 c1ce60c:	e1a011a3 	lsr	r1, r3, #3
 c1ce610:	e1a03001 	mov	r3, r1
 c1ce614:	e1a03103 	lsl	r3, r3, #2
 c1ce618:	e0833001 	add	r3, r3, r1
 c1ce61c:	e1a03083 	lsl	r3, r3, #1
 c1ce620:	e0633002 	rsb	r3, r3, r2
 c1ce624:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce628:	e1a03203 	lsl	r3, r3, #4
 c1ce62c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce630:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce634:	e5d32005 	ldrb	r2, [r3, #5]
 c1ce638:	e59f32a8 	ldr	r3, [pc, #680]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce63c:	e0831392 	umull	r1, r3, r2, r3
 c1ce640:	e1a011a3 	lsr	r1, r3, #3
 c1ce644:	e1a03001 	mov	r3, r1
 c1ce648:	e1a03103 	lsl	r3, r3, #2
 c1ce64c:	e0833001 	add	r3, r3, r1
 c1ce650:	e1a03083 	lsl	r3, r3, #1
 c1ce654:	e0633002 	rsb	r3, r3, r2
 c1ce658:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce65c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce660:	e1a0200c 	mov	r2, ip
 c1ce664:	e1823003 	orr	r3, r2, r3
 c1ce668:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce66c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce670:	e5c03000 	strb	r3, [r0]
    rALMDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c1ce674:	e59f0274 	ldr	r0, [pc, #628]	; c1ce8f0 <rtc_set_alarm+0x3ac>
 c1ce678:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce67c:	e5d32003 	ldrb	r2, [r3, #3]
 c1ce680:	e59f3260 	ldr	r3, [pc, #608]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce684:	e0831392 	umull	r1, r3, r2, r3
 c1ce688:	e1a031a3 	lsr	r3, r3, #3
 c1ce68c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce690:	e59f3250 	ldr	r3, [pc, #592]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce694:	e0831392 	umull	r1, r3, r2, r3
 c1ce698:	e1a011a3 	lsr	r1, r3, #3
 c1ce69c:	e1a03001 	mov	r3, r1
 c1ce6a0:	e1a03103 	lsl	r3, r3, #2
 c1ce6a4:	e0833001 	add	r3, r3, r1
 c1ce6a8:	e1a03083 	lsl	r3, r3, #1
 c1ce6ac:	e0633002 	rsb	r3, r3, r2
 c1ce6b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce6b4:	e1a03203 	lsl	r3, r3, #4
 c1ce6b8:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce6bc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce6c0:	e5d32003 	ldrb	r2, [r3, #3]
 c1ce6c4:	e59f321c 	ldr	r3, [pc, #540]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce6c8:	e0831392 	umull	r1, r3, r2, r3
 c1ce6cc:	e1a011a3 	lsr	r1, r3, #3
 c1ce6d0:	e1a03001 	mov	r3, r1
 c1ce6d4:	e1a03103 	lsl	r3, r3, #2
 c1ce6d8:	e0833001 	add	r3, r3, r1
 c1ce6dc:	e1a03083 	lsl	r3, r3, #1
 c1ce6e0:	e0633002 	rsb	r3, r3, r2
 c1ce6e4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce6e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce6ec:	e1a0200c 	mov	r2, ip
 c1ce6f0:	e1823003 	orr	r3, r2, r3
 c1ce6f4:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce6f8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce6fc:	e5c03000 	strb	r3, [r0]
    rALMHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c1ce700:	e59f01ec 	ldr	r0, [pc, #492]	; c1ce8f4 <rtc_set_alarm+0x3b0>
 c1ce704:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce708:	e5d32002 	ldrb	r2, [r3, #2]
 c1ce70c:	e59f31d4 	ldr	r3, [pc, #468]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce710:	e0831392 	umull	r1, r3, r2, r3
 c1ce714:	e1a031a3 	lsr	r3, r3, #3
 c1ce718:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce71c:	e59f31c4 	ldr	r3, [pc, #452]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce720:	e0831392 	umull	r1, r3, r2, r3
 c1ce724:	e1a011a3 	lsr	r1, r3, #3
 c1ce728:	e1a03001 	mov	r3, r1
 c1ce72c:	e1a03103 	lsl	r3, r3, #2
 c1ce730:	e0833001 	add	r3, r3, r1
 c1ce734:	e1a03083 	lsl	r3, r3, #1
 c1ce738:	e0633002 	rsb	r3, r3, r2
 c1ce73c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce740:	e1a03203 	lsl	r3, r3, #4
 c1ce744:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce748:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce74c:	e5d32002 	ldrb	r2, [r3, #2]
 c1ce750:	e59f3190 	ldr	r3, [pc, #400]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce754:	e0831392 	umull	r1, r3, r2, r3
 c1ce758:	e1a011a3 	lsr	r1, r3, #3
 c1ce75c:	e1a03001 	mov	r3, r1
 c1ce760:	e1a03103 	lsl	r3, r3, #2
 c1ce764:	e0833001 	add	r3, r3, r1
 c1ce768:	e1a03083 	lsl	r3, r3, #1
 c1ce76c:	e0633002 	rsb	r3, r3, r2
 c1ce770:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce774:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce778:	e1a0200c 	mov	r2, ip
 c1ce77c:	e1823003 	orr	r3, r2, r3
 c1ce780:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce784:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce788:	e5c03000 	strb	r3, [r0]
    rALMMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c1ce78c:	e59f0164 	ldr	r0, [pc, #356]	; c1ce8f8 <rtc_set_alarm+0x3b4>
 c1ce790:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce794:	e5d32001 	ldrb	r2, [r3, #1]
 c1ce798:	e59f3148 	ldr	r3, [pc, #328]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce79c:	e0831392 	umull	r1, r3, r2, r3
 c1ce7a0:	e1a031a3 	lsr	r3, r3, #3
 c1ce7a4:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce7a8:	e59f3138 	ldr	r3, [pc, #312]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce7ac:	e0831392 	umull	r1, r3, r2, r3
 c1ce7b0:	e1a011a3 	lsr	r1, r3, #3
 c1ce7b4:	e1a03001 	mov	r3, r1
 c1ce7b8:	e1a03103 	lsl	r3, r3, #2
 c1ce7bc:	e0833001 	add	r3, r3, r1
 c1ce7c0:	e1a03083 	lsl	r3, r3, #1
 c1ce7c4:	e0633002 	rsb	r3, r3, r2
 c1ce7c8:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce7cc:	e1a03203 	lsl	r3, r3, #4
 c1ce7d0:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce7d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce7d8:	e5d32001 	ldrb	r2, [r3, #1]
 c1ce7dc:	e59f3104 	ldr	r3, [pc, #260]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce7e0:	e0831392 	umull	r1, r3, r2, r3
 c1ce7e4:	e1a011a3 	lsr	r1, r3, #3
 c1ce7e8:	e1a03001 	mov	r3, r1
 c1ce7ec:	e1a03103 	lsl	r3, r3, #2
 c1ce7f0:	e0833001 	add	r3, r3, r1
 c1ce7f4:	e1a03083 	lsl	r3, r3, #1
 c1ce7f8:	e0633002 	rsb	r3, r3, r2
 c1ce7fc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce800:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce804:	e1a0200c 	mov	r2, ip
 c1ce808:	e1823003 	orr	r3, r2, r3
 c1ce80c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce810:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce814:	e5c03000 	strb	r3, [r0]
    rALMSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c1ce818:	e59f00dc 	ldr	r0, [pc, #220]	; c1ce8fc <rtc_set_alarm+0x3b8>
 c1ce81c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce820:	e5d32000 	ldrb	r2, [r3]
 c1ce824:	e59f30bc 	ldr	r3, [pc, #188]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce828:	e0831392 	umull	r1, r3, r2, r3
 c1ce82c:	e1a031a3 	lsr	r3, r3, #3
 c1ce830:	e20320ff 	and	r2, r3, #255	; 0xff
 c1ce834:	e59f30ac 	ldr	r3, [pc, #172]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce838:	e0831392 	umull	r1, r3, r2, r3
 c1ce83c:	e1a011a3 	lsr	r1, r3, #3
 c1ce840:	e1a03001 	mov	r3, r1
 c1ce844:	e1a03103 	lsl	r3, r3, #2
 c1ce848:	e0833001 	add	r3, r3, r1
 c1ce84c:	e1a03083 	lsl	r3, r3, #1
 c1ce850:	e0633002 	rsb	r3, r3, r2
 c1ce854:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce858:	e1a03203 	lsl	r3, r3, #4
 c1ce85c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c1ce860:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ce864:	e5d32000 	ldrb	r2, [r3]
 c1ce868:	e59f3078 	ldr	r3, [pc, #120]	; c1ce8e8 <rtc_set_alarm+0x3a4>
 c1ce86c:	e0831392 	umull	r1, r3, r2, r3
 c1ce870:	e1a011a3 	lsr	r1, r3, #3
 c1ce874:	e1a03001 	mov	r3, r1
 c1ce878:	e1a03103 	lsl	r3, r3, #2
 c1ce87c:	e0833001 	add	r3, r3, r1
 c1ce880:	e1a03083 	lsl	r3, r3, #1
 c1ce884:	e0633002 	rsb	r3, r3, r2
 c1ce888:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce88c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce890:	e1a0200c 	mov	r2, ip
 c1ce894:	e1823003 	orr	r3, r2, r3
 c1ce898:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce89c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce8a0:	e5c03000 	strb	r3, [r0]

	//Enable alarm (bits [7:0] = 1)
    rRTCALM  = 0x7F;
 c1ce8a4:	e59f3054 	ldr	r3, [pc, #84]	; c1ce900 <rtc_set_alarm+0x3bc>
 c1ce8a8:	e3a0207f 	mov	r2, #127	; 0x7f
 c1ce8ac:	e5c32000 	strb	r2, [r3]

    ic_conf_line(INT_RTC, IRQ);
 c1ce8b0:	e3a00001 	mov	r0, #1
 c1ce8b4:	e3a01000 	mov	r1, #0
 c1ce8b8:	ebfff733 	bl	c1cc58c <ic_conf_line>
    ic_cleanflag(INT_RTC);
 c1ce8bc:	e3a00001 	mov	r0, #1
 c1ce8c0:	ebfff794 	bl	c1cc718 <ic_cleanflag>
    ic_enable(INT_RTC);
 c1ce8c4:	e3a00001 	mov	r0, #1
 c1ce8c8:	ebfff75f 	bl	c1cc64c <ic_enable>

    pISR_RTC = (unsigned) isr;
 c1ce8cc:	e59f3030 	ldr	r3, [pc, #48]	; c1ce904 <rtc_set_alarm+0x3c0>
 c1ce8d0:	e51b2010 	ldr	r2, [fp, #-16]
 c1ce8d4:	e5832000 	str	r2, [r3]
}
 c1ce8d8:	e24bd00c 	sub	sp, fp, #12
 c1ce8dc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce8e0:	e12fff1e 	bx	lr
 c1ce8e4:	01d70068 	.word	0x01d70068
 c1ce8e8:	cccccccd 	.word	0xcccccccd
 c1ce8ec:	01d70064 	.word	0x01d70064
 c1ce8f0:	01d70060 	.word	0x01d70060
 c1ce8f4:	01d7005c 	.word	0x01d7005c
 c1ce8f8:	01d70058 	.word	0x01d70058
 c1ce8fc:	01d70054 	.word	0x01d70054
 c1ce900:	01d70050 	.word	0x01d70050
 c1ce904:	0c7fff24 	.word	0x0c7fff24

0c1ce908 <rtc_clear_alarm>:

void rtc_clear_alarm() {
 c1ce908:	e1a0c00d 	mov	ip, sp
 c1ce90c:	e92dd800 	push	{fp, ip, lr, pc}
 c1ce910:	e24cb004 	sub	fp, ip, #4
	ic_disable(INT_RTC);
 c1ce914:	e3a00001 	mov	r0, #1
 c1ce918:	ebfff765 	bl	c1cc6b4 <ic_disable>
	pISR_RTC = (unsigned) isr_ALARM_dummy;
 c1ce91c:	e59f301c 	ldr	r3, [pc, #28]	; c1ce940 <rtc_clear_alarm+0x38>
 c1ce920:	e59f201c 	ldr	r2, [pc, #28]	; c1ce944 <rtc_clear_alarm+0x3c>
 c1ce924:	e5832000 	str	r2, [r3]
    rRTCALM  = 0;
 c1ce928:	e59f3018 	ldr	r3, [pc, #24]	; c1ce948 <rtc_clear_alarm+0x40>
 c1ce92c:	e3a02000 	mov	r2, #0
 c1ce930:	e5c32000 	strb	r2, [r3]
}
 c1ce934:	e24bd00c 	sub	sp, fp, #12
 c1ce938:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce93c:	e12fff1e 	bx	lr
 c1ce940:	0c7fff24 	.word	0x0c7fff24
 c1ce944:	0c1cdc34 	.word	0x0c1cdc34
 c1ce948:	01d70050 	.word	0x01d70050

0c1ce94c <rtc_open>:

// Sets ISR to RTC ticks (tick_count)
void rtc_open( void (*isr)(void), uint8 tick_count )
{
 c1ce94c:	e1a0c00d 	mov	ip, sp
 c1ce950:	e92dd800 	push	{fp, ip, lr, pc}
 c1ce954:	e24cb004 	sub	fp, ip, #4
 c1ce958:	e24dd008 	sub	sp, sp, #8
 c1ce95c:	e50b0010 	str	r0, [fp, #-16]
 c1ce960:	e1a03001 	mov	r3, r1
 c1ce964:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    pISR_TICK = (unsigned)isr;
 c1ce968:	e59f3044 	ldr	r3, [pc, #68]	; c1ce9b4 <rtc_open+0x68>
 c1ce96c:	e51b2010 	ldr	r2, [fp, #-16]
 c1ce970:	e5832000 	str	r2, [r3]

    ic_conf_line(INT_TICK, IRQ);
 c1ce974:	e3a00014 	mov	r0, #20
 c1ce978:	e3a01000 	mov	r1, #0
 c1ce97c:	ebfff702 	bl	c1cc58c <ic_conf_line>
    ic_cleanflag(INT_TICK);
 c1ce980:	e3a00014 	mov	r0, #20
 c1ce984:	ebfff763 	bl	c1cc718 <ic_cleanflag>
    ic_enable(INT_TICK);
 c1ce988:	e3a00014 	mov	r0, #20
 c1ce98c:	ebfff72e 	bl	c1cc64c <ic_enable>

    rTICINT = 1 << 7 | (tick_count & 0b1111111);
 c1ce990:	e59f2020 	ldr	r2, [pc, #32]	; c1ce9b8 <rtc_open+0x6c>
 c1ce994:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1ce998:	e1e03c83 	mvn	r3, r3, lsl #25
 c1ce99c:	e1e03ca3 	mvn	r3, r3, lsr #25
 c1ce9a0:	e20330ff 	and	r3, r3, #255	; 0xff
 c1ce9a4:	e5c23000 	strb	r3, [r2]
}
 c1ce9a8:	e24bd00c 	sub	sp, fp, #12
 c1ce9ac:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce9b0:	e12fff1e 	bx	lr
 c1ce9b4:	0c7fff70 	.word	0x0c7fff70
 c1ce9b8:	01d7008c 	.word	0x01d7008c

0c1ce9bc <rtc_close>:

// Removes RTC ISR
void rtc_close( void )
{
 c1ce9bc:	e1a0c00d 	mov	ip, sp
 c1ce9c0:	e92dd800 	push	{fp, ip, lr, pc}
 c1ce9c4:	e24cb004 	sub	fp, ip, #4
    rTICINT = 0;
 c1ce9c8:	e59f3024 	ldr	r3, [pc, #36]	; c1ce9f4 <rtc_close+0x38>
 c1ce9cc:	e3a02000 	mov	r2, #0
 c1ce9d0:	e5c32000 	strb	r2, [r3]
    ic_disable(INT_TICK);
 c1ce9d4:	e3a00014 	mov	r0, #20
 c1ce9d8:	ebfff735 	bl	c1cc6b4 <ic_disable>
    pISR_TICK = (unsigned)isr_TICK_dummy;
 c1ce9dc:	e59f3014 	ldr	r3, [pc, #20]	; c1ce9f8 <rtc_close+0x3c>
 c1ce9e0:	e59f2014 	ldr	r2, [pc, #20]	; c1ce9fc <rtc_close+0x40>
 c1ce9e4:	e5832000 	str	r2, [r3]
}
 c1ce9e8:	e24bd00c 	sub	sp, fp, #12
 c1ce9ec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ce9f0:	e12fff1e 	bx	lr
 c1ce9f4:	01d7008c 	.word	0x01d7008c
 c1ce9f8:	0c7fff70 	.word	0x0c7fff70
 c1ce9fc:	0c1cdc0c 	.word	0x0c1cdc0c

0c1cea00 <tmr_set_prescaler>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "timer.h"

int tmr_set_prescaler(int p, int  value)
{
 c1cea00:	e1a0c00d 	mov	ip, sp
 c1cea04:	e92dd800 	push	{fp, ip, lr, pc}
 c1cea08:	e24cb004 	sub	fp, ip, #4
 c1cea0c:	e24dd018 	sub	sp, sp, #24
 c1cea10:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c1cea14:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
	int offset = p*8;
 c1cea18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cea1c:	e1a03183 	lsl	r3, r3, #3
 c1cea20:	e50b3010 	str	r3, [fp, #-16]
	value &= 0xFF;
 c1cea24:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cea28:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cea2c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

	if (p < 0 || p > 3)
 c1cea30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cea34:	e3530000 	cmp	r3, #0
 c1cea38:	ba000002 	blt	c1cea48 <tmr_set_prescaler+0x48>
 c1cea3c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cea40:	e3530003 	cmp	r3, #3
 c1cea44:	da000001 	ble	c1cea50 <tmr_set_prescaler+0x50>
		return -1;
 c1cea48:	e3e03000 	mvn	r3, #0
 c1cea4c:	ea00001d 	b	c1ceac8 <tmr_set_prescaler+0xc8>

	//COMPLETAR: escribir el valor value a partir de la posiciÃ³n offset en el
	//registro rTCFG0, para establecer el valor de pre-escalado del mÃ³dulo p

	int bitfield = value, mask = 0xff, reg = rTCFG0;
 c1cea50:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c1cea54:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cea58:	e3a030ff 	mov	r3, #255	; 0xff
 c1cea5c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1cea60:	e59f3070 	ldr	r3, [pc, #112]	; c1cead8 <tmr_set_prescaler+0xd8>
 c1cea64:	e5933000 	ldr	r3, [r3]
 c1cea68:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= offset;
 c1cea6c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cea70:	e51b3010 	ldr	r3, [fp, #-16]
 c1cea74:	e1a03312 	lsl	r3, r2, r3
 c1cea78:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= offset;
 c1cea7c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cea80:	e51b3010 	ldr	r3, [fp, #-16]
 c1cea84:	e1a03312 	lsl	r3, r2, r3
 c1cea88:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c1cea8c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cea90:	e1e03003 	mvn	r3, r3
 c1cea94:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo byte
 c1cea98:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cea9c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1ceaa0:	e0023003 	and	r3, r2, r3
 c1ceaa4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo byte
 c1ceaa8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1ceaac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1ceab0:	e1823003 	orr	r3, r2, r3
 c1ceab4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG0 = reg;
 c1ceab8:	e59f3018 	ldr	r3, [pc, #24]	; c1cead8 <tmr_set_prescaler+0xd8>
 c1ceabc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1ceac0:	e5832000 	str	r2, [r3]

	return 0;
 c1ceac4:	e3a03000 	mov	r3, #0
}
 c1ceac8:	e1a00003 	mov	r0, r3
 c1ceacc:	e24bd00c 	sub	sp, fp, #12
 c1cead0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cead4:	e12fff1e 	bx	lr
 c1cead8:	01d50000 	.word	0x01d50000

0c1ceadc <tmr_set_divider>:

int tmr_set_divider(int d, enum tmr_div div)
{
 c1ceadc:	e1a0c00d 	mov	ip, sp
 c1ceae0:	e92dd800 	push	{fp, ip, lr, pc}
 c1ceae4:	e24cb004 	sub	fp, ip, #4
 c1ceae8:	e24dd018 	sub	sp, sp, #24
 c1ceaec:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c1ceaf0:	e1a03001 	mov	r3, r1
 c1ceaf4:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
	int pos = d*4;
 c1ceaf8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceafc:	e1a03103 	lsl	r3, r3, #2
 c1ceb00:	e50b3010 	str	r3, [fp, #-16]

	if ((d < 0 || d > 5) ||
 c1ceb04:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceb08:	e3530000 	cmp	r3, #0
 c1ceb0c:	ba000014 	blt	c1ceb64 <tmr_set_divider+0x88>
 c1ceb10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceb14:	e3530005 	cmp	r3, #5
 c1ceb18:	ca000011 	bgt	c1ceb64 <tmr_set_divider+0x88>
 c1ceb1c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb20:	e3530004 	cmp	r3, #4
 c1ceb24:	1a000002 	bne	c1ceb34 <tmr_set_divider+0x58>
			(div == D1_32 && d > 3) ||
 c1ceb28:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceb2c:	e3530003 	cmp	r3, #3
 c1ceb30:	ca00000b 	bgt	c1ceb64 <tmr_set_divider+0x88>
 c1ceb34:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb38:	e3530005 	cmp	r3, #5
 c1ceb3c:	1a000002 	bne	c1ceb4c <tmr_set_divider+0x70>
			(div == EXTCLK && d != 5) ||
 c1ceb40:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceb44:	e3530005 	cmp	r3, #5
 c1ceb48:	1a000005 	bne	c1ceb64 <tmr_set_divider+0x88>
 c1ceb4c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb50:	e3530006 	cmp	r3, #6
 c1ceb54:	1a000004 	bne	c1ceb6c <tmr_set_divider+0x90>
			(div == TCLK && d != 4))
 c1ceb58:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1ceb5c:	e3530004 	cmp	r3, #4
 c1ceb60:	0a000001 	beq	c1ceb6c <tmr_set_divider+0x90>
		return -1;
 c1ceb64:	e3e03000 	mvn	r3, #0
 c1ceb68:	ea000025 	b	c1cec04 <tmr_set_divider+0x128>

	if (div == EXTCLK || div == TCLK)
 c1ceb6c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb70:	e3530005 	cmp	r3, #5
 c1ceb74:	0a000002 	beq	c1ceb84 <tmr_set_divider+0xa8>
 c1ceb78:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb7c:	e3530006 	cmp	r3, #6
 c1ceb80:	1a000001 	bne	c1ceb8c <tmr_set_divider+0xb0>
		div = 4;
 c1ceb84:	e3a03004 	mov	r3, #4
 c1ceb88:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

	//COMPLETAR: escribir el valor div a partir de la posiciÃ³n pos en el
	//registro rTCFG1 para establecer el valor para el divisor d

	int bitfield = div, mask = 0xf, reg = rTCFG1;
 c1ceb8c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c1ceb90:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1ceb94:	e3a0300f 	mov	r3, #15
 c1ceb98:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1ceb9c:	e59f3070 	ldr	r3, [pc, #112]	; c1cec14 <tmr_set_divider+0x138>
 c1ceba0:	e5933000 	ldr	r3, [r3]
 c1ceba4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= pos;
 c1ceba8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cebac:	e51b3010 	ldr	r3, [fp, #-16]
 c1cebb0:	e1a03312 	lsl	r3, r2, r3
 c1cebb4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= pos;
 c1cebb8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cebbc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cebc0:	e1a03312 	lsl	r3, r2, r3
 c1cebc4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c1cebc8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cebcc:	e1e03003 	mvn	r3, r3
 c1cebd0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo nibble
 c1cebd4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cebd8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cebdc:	e0023003 	and	r3, r2, r3
 c1cebe0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo nibble
 c1cebe4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cebe8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cebec:	e1823003 	orr	r3, r2, r3
 c1cebf0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG1 = reg;
 c1cebf4:	e59f3018 	ldr	r3, [pc, #24]	; c1cec14 <tmr_set_divider+0x138>
 c1cebf8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cebfc:	e5832000 	str	r2, [r3]

	return 0;
 c1cec00:	e3a03000 	mov	r3, #0
}
 c1cec04:	e1a00003 	mov	r0, r3
 c1cec08:	e24bd00c 	sub	sp, fp, #12
 c1cec0c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cec10:	e12fff1e 	bx	lr
 c1cec14:	01d50004 	.word	0x01d50004

0c1cec18 <tmr_set_count>:

int tmr_set_count(enum tmr_timer t, int count, int cmp)
{
 c1cec18:	e1a0c00d 	mov	ip, sp
 c1cec1c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cec20:	e24cb004 	sub	fp, ip, #4
 c1cec24:	e24dd018 	sub	sp, sp, #24
 c1cec28:	e1a03000 	mov	r3, r0
 c1cec2c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c1cec30:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c1cec34:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int err = 0;
 c1cec38:	e3a03000 	mov	r3, #0
 c1cec3c:	e50b3010 	str	r3, [fp, #-16]
	switch (t) {
 c1cec40:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cec44:	e3530005 	cmp	r3, #5
 c1cec48:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c1cec4c:	ea00002c 	b	c1ced04 <tmr_set_count+0xec>
 c1cec50:	0c1cec68 	.word	0x0c1cec68
 c1cec54:	0c1cec84 	.word	0x0c1cec84
 c1cec58:	0c1ceca0 	.word	0x0c1ceca0
 c1cec5c:	0c1cecbc 	.word	0x0c1cecbc
 c1cec60:	0c1cecd8 	.word	0x0c1cecd8
 c1cec64:	0c1cecf4 	.word	0x0c1cecf4
		case TIMER0:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer0 (rTCNTB0 y
			//rTCMPB0)
			rTCNTB0 = count;
 c1cec68:	e59f30b0 	ldr	r3, [pc, #176]	; c1ced20 <tmr_set_count+0x108>
 c1cec6c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cec70:	e5832000 	str	r2, [r3]
			rTCMPB0 = cmp;
 c1cec74:	e59f30a8 	ldr	r3, [pc, #168]	; c1ced24 <tmr_set_count+0x10c>
 c1cec78:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cec7c:	e5832000 	str	r2, [r3]
			break;
 c1cec80:	ea000021 	b	c1ced0c <tmr_set_count+0xf4>
		case TIMER1:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer1 (rTCNTB1 y
			//rTCMPB1)
			rTCNTB1 = count;
 c1cec84:	e59f309c 	ldr	r3, [pc, #156]	; c1ced28 <tmr_set_count+0x110>
 c1cec88:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cec8c:	e5832000 	str	r2, [r3]
			rTCMPB1 = cmp;
 c1cec90:	e59f3094 	ldr	r3, [pc, #148]	; c1ced2c <tmr_set_count+0x114>
 c1cec94:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cec98:	e5832000 	str	r2, [r3]
			 break;
 c1cec9c:	ea00001a 	b	c1ced0c <tmr_set_count+0xf4>
		case TIMER2:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer2 (rTCNTB2 y
			//rTCMPB2)
			rTCNTB2 = count;
 c1ceca0:	e59f3088 	ldr	r3, [pc, #136]	; c1ced30 <tmr_set_count+0x118>
 c1ceca4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1ceca8:	e5832000 	str	r2, [r3]
			rTCMPB2 = cmp;
 c1cecac:	e59f3080 	ldr	r3, [pc, #128]	; c1ced34 <tmr_set_count+0x11c>
 c1cecb0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cecb4:	e5832000 	str	r2, [r3]
			 break;
 c1cecb8:	ea000013 	b	c1ced0c <tmr_set_count+0xf4>
		case TIMER3:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer3 (rTCNTB3 y
			//rTCMPB3)
			rTCNTB3 = count;
 c1cecbc:	e59f3074 	ldr	r3, [pc, #116]	; c1ced38 <tmr_set_count+0x120>
 c1cecc0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cecc4:	e5832000 	str	r2, [r3]
			rTCMPB3 = cmp;
 c1cecc8:	e59f306c 	ldr	r3, [pc, #108]	; c1ced3c <tmr_set_count+0x124>
 c1ceccc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cecd0:	e5832000 	str	r2, [r3]
			 break;
 c1cecd4:	ea00000c 	b	c1ced0c <tmr_set_count+0xf4>
		case TIMER4:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaciÃ³n cmp en los registros de buffer del timer4 (rTCNTB4 y
			//rTCMPB4)
			rTCNTB4 = count;
 c1cecd8:	e59f3060 	ldr	r3, [pc, #96]	; c1ced40 <tmr_set_count+0x128>
 c1cecdc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cece0:	e5832000 	str	r2, [r3]
			rTCMPB4 = cmp;
 c1cece4:	e59f3058 	ldr	r3, [pc, #88]	; c1ced44 <tmr_set_count+0x12c>
 c1cece8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c1cecec:	e5832000 	str	r2, [r3]
			 break;
 c1cecf0:	ea000005 	b	c1ced0c <tmr_set_count+0xf4>
		case TIMER5:
			//COMPLETAR: establecer el valor de cuenta count en el registro de 
			//buffer del timer5 (rTCNTB5)
			rTCNTB5 = count;
 c1cecf4:	e59f304c 	ldr	r3, [pc, #76]	; c1ced48 <tmr_set_count+0x130>
 c1cecf8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c1cecfc:	e5832000 	str	r2, [r3]
			 break;
 c1ced00:	ea000001 	b	c1ced0c <tmr_set_count+0xf4>
		default:
			err = -1;
 c1ced04:	e3e03000 	mvn	r3, #0
 c1ced08:	e50b3010 	str	r3, [fp, #-16]
	}

	return err;
 c1ced0c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1ced10:	e1a00003 	mov	r0, r3
 c1ced14:	e24bd00c 	sub	sp, fp, #12
 c1ced18:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1ced1c:	e12fff1e 	bx	lr
 c1ced20:	01d5000c 	.word	0x01d5000c
 c1ced24:	01d50010 	.word	0x01d50010
 c1ced28:	01d50018 	.word	0x01d50018
 c1ced2c:	01d5001c 	.word	0x01d5001c
 c1ced30:	01d50024 	.word	0x01d50024
 c1ced34:	01d50028 	.word	0x01d50028
 c1ced38:	01d50030 	.word	0x01d50030
 c1ced3c:	01d50034 	.word	0x01d50034
 c1ced40:	01d5003c 	.word	0x01d5003c
 c1ced44:	01d50040 	.word	0x01d50040
 c1ced48:	01d50048 	.word	0x01d50048

0c1ced4c <tmr_update>:

int tmr_update(enum tmr_timer t)
{
 c1ced4c:	e1a0c00d 	mov	ip, sp
 c1ced50:	e92dd800 	push	{fp, ip, lr, pc}
 c1ced54:	e24cb004 	sub	fp, ip, #4
 c1ced58:	e24dd010 	sub	sp, sp, #16
 c1ced5c:	e1a03000 	mov	r3, r0
 c1ced60:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c1ced64:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1ced68:	e1a03103 	lsl	r3, r3, #2
 c1ced6c:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c1ced70:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1ced74:	e3530000 	cmp	r3, #0
 c1ced78:	0a000002 	beq	c1ced88 <tmr_update+0x3c>
		pos += 4;
 c1ced7c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ced80:	e2833004 	add	r3, r3, #4
 c1ced84:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c1ced88:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1ced8c:	e3530005 	cmp	r3, #5
 c1ced90:	9a000001 	bls	c1ced9c <tmr_update+0x50>
		return -1;
 c1ced94:	e3e03000 	mvn	r3, #0
 c1ced98:	ea000014 	b	c1cedf0 <tmr_update+0xa4>

	pos++;
 c1ced9c:	e51b3010 	ldr	r3, [fp, #-16]
 c1ceda0:	e2833001 	add	r3, r3, #1
 c1ceda4:	e50b3010 	str	r3, [fp, #-16]

	//COMPLETAR: poner a 1 en el registro rTCON el bit indicado por pos 
	// y justo despuÃ©s ponerlo a 0 (deben ser stores distintos, lo hacemos con
	// sentencias C distintas)
	rTCON |= 1 << pos;
 c1ceda8:	e59f3050 	ldr	r3, [pc, #80]	; c1cee00 <tmr_update+0xb4>
 c1cedac:	e59f204c 	ldr	r2, [pc, #76]	; c1cee00 <tmr_update+0xb4>
 c1cedb0:	e5921000 	ldr	r1, [r2]
 c1cedb4:	e3a00001 	mov	r0, #1
 c1cedb8:	e51b2010 	ldr	r2, [fp, #-16]
 c1cedbc:	e1a02210 	lsl	r2, r0, r2
 c1cedc0:	e1812002 	orr	r2, r1, r2
 c1cedc4:	e5832000 	str	r2, [r3]
	rTCON &= ~(1 << pos);
 c1cedc8:	e59f3030 	ldr	r3, [pc, #48]	; c1cee00 <tmr_update+0xb4>
 c1cedcc:	e59f202c 	ldr	r2, [pc, #44]	; c1cee00 <tmr_update+0xb4>
 c1cedd0:	e5921000 	ldr	r1, [r2]
 c1cedd4:	e3a00001 	mov	r0, #1
 c1cedd8:	e51b2010 	ldr	r2, [fp, #-16]
 c1ceddc:	e1a02210 	lsl	r2, r0, r2
 c1cede0:	e1e02002 	mvn	r2, r2
 c1cede4:	e0012002 	and	r2, r1, r2
 c1cede8:	e5832000 	str	r2, [r3]

	return 0;
 c1cedec:	e3a03000 	mov	r3, #0
}
 c1cedf0:	e1a00003 	mov	r0, r3
 c1cedf4:	e24bd00c 	sub	sp, fp, #12
 c1cedf8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cedfc:	e12fff1e 	bx	lr
 c1cee00:	01d50008 	.word	0x01d50008

0c1cee04 <tmr_set_mode>:

int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
{
 c1cee04:	e1a0c00d 	mov	ip, sp
 c1cee08:	e92dd800 	push	{fp, ip, lr, pc}
 c1cee0c:	e24cb004 	sub	fp, ip, #4
 c1cee10:	e24dd010 	sub	sp, sp, #16
 c1cee14:	e1a02000 	mov	r2, r0
 c1cee18:	e1a03001 	mov	r3, r1
 c1cee1c:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c1cee20:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int err = 0;
 c1cee24:	e3a03000 	mov	r3, #0
 c1cee28:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c1cee2c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cee30:	e1a03103 	lsl	r3, r3, #2
 c1cee34:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c1cee38:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cee3c:	e3530000 	cmp	r3, #0
 c1cee40:	0a000002 	beq	c1cee50 <tmr_set_mode+0x4c>
		pos += 4;
 c1cee44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cee48:	e2833004 	add	r3, r3, #4
 c1cee4c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (t < 0 || t > 5)
 c1cee50:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cee54:	e3530005 	cmp	r3, #5
 c1cee58:	9a000001 	bls	c1cee64 <tmr_set_mode+0x60>
		return -1;
 c1cee5c:	e3e03000 	mvn	r3, #0
 c1cee60:	ea000025 	b	c1ceefc <tmr_set_mode+0xf8>

	if(t == 5)
 c1cee64:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cee68:	e3530005 	cmp	r3, #5
 c1cee6c:	1a000003 	bne	c1cee80 <tmr_set_mode+0x7c>
		pos += 2;
 c1cee70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cee74:	e2833002 	add	r3, r3, #2
 c1cee78:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cee7c:	ea000002 	b	c1cee8c <tmr_set_mode+0x88>
	else
		pos += 3;
 c1cee80:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cee84:	e2833003 	add	r3, r3, #3
 c1cee88:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (mode == ONE_SHOT)
 c1cee8c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1cee90:	e3530000 	cmp	r3, #0
 c1cee94:	1a000009 	bne	c1ceec0 <tmr_set_mode+0xbc>
		//COMPLETAR: poner a 0 el bit autoreload a partir de la posiciÃ³n pos (es
		//el cuarto bit a partir de esa posiciÃ³n)
		rTCON &= ~(1 << pos);
 c1cee98:	e59f306c 	ldr	r3, [pc, #108]	; c1cef0c <tmr_set_mode+0x108>
 c1cee9c:	e59f2068 	ldr	r2, [pc, #104]	; c1cef0c <tmr_set_mode+0x108>
 c1ceea0:	e5921000 	ldr	r1, [r2]
 c1ceea4:	e3a00001 	mov	r0, #1
 c1ceea8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1ceeac:	e1a02210 	lsl	r2, r0, r2
 c1ceeb0:	e1e02002 	mvn	r2, r2
 c1ceeb4:	e0012002 	and	r2, r1, r2
 c1ceeb8:	e5832000 	str	r2, [r3]
 c1ceebc:	ea00000d 	b	c1ceef8 <tmr_set_mode+0xf4>
	else if (mode == RELOAD)
 c1ceec0:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c1ceec4:	e3530001 	cmp	r3, #1
 c1ceec8:	1a000008 	bne	c1ceef0 <tmr_set_mode+0xec>
		//COMPLETAR: poner a 1 el bit autoreload a partir de la posiciÃ³n pos (es
		//el cuarto bit a partir de esa posiciÃ³n)
		rTCON |= 1 << pos;
 c1ceecc:	e59f3038 	ldr	r3, [pc, #56]	; c1cef0c <tmr_set_mode+0x108>
 c1ceed0:	e59f2034 	ldr	r2, [pc, #52]	; c1cef0c <tmr_set_mode+0x108>
 c1ceed4:	e5921000 	ldr	r1, [r2]
 c1ceed8:	e3a00001 	mov	r0, #1
 c1ceedc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1ceee0:	e1a02210 	lsl	r2, r0, r2
 c1ceee4:	e1812002 	orr	r2, r1, r2
 c1ceee8:	e5832000 	str	r2, [r3]
 c1ceeec:	ea000001 	b	c1ceef8 <tmr_set_mode+0xf4>
	else
		err = -1;
 c1ceef0:	e3e03000 	mvn	r3, #0
 c1ceef4:	e50b3010 	str	r3, [fp, #-16]

	return err;
 c1ceef8:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1ceefc:	e1a00003 	mov	r0, r3
 c1cef00:	e24bd00c 	sub	sp, fp, #12
 c1cef04:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cef08:	e12fff1e 	bx	lr
 c1cef0c:	01d50008 	.word	0x01d50008

0c1cef10 <tmr_start>:

int tmr_start(enum tmr_timer t)
{
 c1cef10:	e1a0c00d 	mov	ip, sp
 c1cef14:	e92dd800 	push	{fp, ip, lr, pc}
 c1cef18:	e24cb004 	sub	fp, ip, #4
 c1cef1c:	e24dd010 	sub	sp, sp, #16
 c1cef20:	e1a03000 	mov	r3, r0
 c1cef24:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c1cef28:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cef2c:	e1a03103 	lsl	r3, r3, #2
 c1cef30:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c1cef34:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cef38:	e3530000 	cmp	r3, #0
 c1cef3c:	0a000002 	beq	c1cef4c <tmr_start+0x3c>
		pos += 4;
 c1cef40:	e51b3010 	ldr	r3, [fp, #-16]
 c1cef44:	e2833004 	add	r3, r3, #4
 c1cef48:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c1cef4c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cef50:	e3530005 	cmp	r3, #5
 c1cef54:	9a000001 	bls	c1cef60 <tmr_start+0x50>
		return -1;
 c1cef58:	e3e03000 	mvn	r3, #0
 c1cef5c:	ea000008 	b	c1cef84 <tmr_start+0x74>

	//COMPLETAR: poner a 1 el bit de start a partir de la posiciÃ³n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON |= 1 << pos;
 c1cef60:	e59f302c 	ldr	r3, [pc, #44]	; c1cef94 <tmr_start+0x84>
 c1cef64:	e59f2028 	ldr	r2, [pc, #40]	; c1cef94 <tmr_start+0x84>
 c1cef68:	e5921000 	ldr	r1, [r2]
 c1cef6c:	e3a00001 	mov	r0, #1
 c1cef70:	e51b2010 	ldr	r2, [fp, #-16]
 c1cef74:	e1a02210 	lsl	r2, r0, r2
 c1cef78:	e1812002 	orr	r2, r1, r2
 c1cef7c:	e5832000 	str	r2, [r3]
	return 0;
 c1cef80:	e3a03000 	mov	r3, #0
}
 c1cef84:	e1a00003 	mov	r0, r3
 c1cef88:	e24bd00c 	sub	sp, fp, #12
 c1cef8c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cef90:	e12fff1e 	bx	lr
 c1cef94:	01d50008 	.word	0x01d50008

0c1cef98 <tmr_stop>:

int tmr_stop(enum tmr_timer t)
{
 c1cef98:	e1a0c00d 	mov	ip, sp
 c1cef9c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cefa0:	e24cb004 	sub	fp, ip, #4
 c1cefa4:	e24dd010 	sub	sp, sp, #16
 c1cefa8:	e1a03000 	mov	r3, r0
 c1cefac:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c1cefb0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cefb4:	e1a03103 	lsl	r3, r3, #2
 c1cefb8:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c1cefbc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cefc0:	e3530000 	cmp	r3, #0
 c1cefc4:	0a000002 	beq	c1cefd4 <tmr_stop+0x3c>
		pos += 4;
 c1cefc8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cefcc:	e2833004 	add	r3, r3, #4
 c1cefd0:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c1cefd4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cefd8:	e3530005 	cmp	r3, #5
 c1cefdc:	9a000001 	bls	c1cefe8 <tmr_stop+0x50>
		return -1;
 c1cefe0:	e3e03000 	mvn	r3, #0
 c1cefe4:	ea000009 	b	c1cf010 <tmr_stop+0x78>

	//COMPLETAR: poner a 0 el bit de start a partir de la posiciÃ³n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON &= ~(1 << pos);
 c1cefe8:	e59f3030 	ldr	r3, [pc, #48]	; c1cf020 <tmr_stop+0x88>
 c1cefec:	e59f202c 	ldr	r2, [pc, #44]	; c1cf020 <tmr_stop+0x88>
 c1ceff0:	e5921000 	ldr	r1, [r2]
 c1ceff4:	e3a00001 	mov	r0, #1
 c1ceff8:	e51b2010 	ldr	r2, [fp, #-16]
 c1ceffc:	e1a02210 	lsl	r2, r0, r2
 c1cf000:	e1e02002 	mvn	r2, r2
 c1cf004:	e0012002 	and	r2, r1, r2
 c1cf008:	e5832000 	str	r2, [r3]

	return 0;
 c1cf00c:	e3a03000 	mov	r3, #0
}
 c1cf010:	e1a00003 	mov	r0, r3
 c1cf014:	e24bd00c 	sub	sp, fp, #12
 c1cf018:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf01c:	e12fff1e 	bx	lr
 c1cf020:	01d50008 	.word	0x01d50008

0c1cf024 <tmr_isrunning>:

int tmr_isrunning(enum tmr_timer t)
{
 c1cf024:	e1a0c00d 	mov	ip, sp
 c1cf028:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf02c:	e24cb004 	sub	fp, ip, #4
 c1cf030:	e24dd010 	sub	sp, sp, #16
 c1cf034:	e1a03000 	mov	r3, r0
 c1cf038:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c1cf03c:	e3a03000 	mov	r3, #0
 c1cf040:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c1cf044:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cf048:	e1a03103 	lsl	r3, r3, #2
 c1cf04c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c1cf050:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cf054:	e3530000 	cmp	r3, #0
 c1cf058:	0a000002 	beq	c1cf068 <tmr_isrunning+0x44>
		pos += 4;
 c1cf05c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf060:	e2833004 	add	r3, r3, #4
 c1cf064:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if ((t >= 0) && (t <= 5) 
 c1cf068:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cf06c:	e3530005 	cmp	r3, #5
 c1cf070:	8a000009 	bhi	c1cf09c <tmr_isrunning+0x78>
			&& (rTCON & (0x1 << pos)))
 c1cf074:	e59f3034 	ldr	r3, [pc, #52]	; c1cf0b0 <tmr_isrunning+0x8c>
 c1cf078:	e5932000 	ldr	r2, [r3]
 c1cf07c:	e3a01001 	mov	r1, #1
 c1cf080:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf084:	e1a03311 	lsl	r3, r1, r3
 c1cf088:	e0023003 	and	r3, r2, r3
 c1cf08c:	e3530000 	cmp	r3, #0
 c1cf090:	0a000001 	beq	c1cf09c <tmr_isrunning+0x78>
		ret = 1;
 c1cf094:	e3a03001 	mov	r3, #1
 c1cf098:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c1cf09c:	e51b3010 	ldr	r3, [fp, #-16]
}
 c1cf0a0:	e1a00003 	mov	r0, r3
 c1cf0a4:	e24bd00c 	sub	sp, fp, #12
 c1cf0a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf0ac:	e12fff1e 	bx	lr
 c1cf0b0:	01d50008 	.word	0x01d50008

0c1cf0b4 <isr_TS_dummy>:
static uint8 state;

extern void isr_TS_dummy( void ) __attribute__ ((interrupt ("IRQ")));

void isr_TS_dummy( void )
{
 c1cf0b4:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c1cf0b8:	e1a0c00d 	mov	ip, sp
 c1cf0bc:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c1cf0c0:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_EINT2);
 c1cf0c4:	e3a00017 	mov	r0, #23
 c1cf0c8:	ebfff592 	bl	c1cc718 <ic_cleanflag>
}
 c1cf0cc:	e24bd01c 	sub	sp, fp, #28
 c1cf0d0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c1cf0d4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c1cf0d8:	e25ef004 	subs	pc, lr, #4

0c1cf0dc <ts_init>:
static void ts_scan( uint16 *Vx, uint16 *Vy );
static void ts_calibrate( void );
static void ts_sample2coord( uint16 Vx, uint16 Vy, uint16 *x, uint16 *y );

void ts_init( void )
{
 c1cf0dc:	e1a0c00d 	mov	ip, sp
 c1cf0e0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf0e4:	e24cb004 	sub	fp, ip, #4
    lcd_init();
 c1cf0e8:	ebfff61d 	bl	c1cc964 <lcd_init>
    adc_init();
 c1cf0ec:	ebffee42 	bl	c1ca9fc <adc_init>

    //Conf PE[7..4] as Output
    rPCONE &= ~(0xff << 8);
 c1cf0f0:	e59f3070 	ldr	r3, [pc, #112]	; c1cf168 <ts_init+0x8c>
 c1cf0f4:	e59f206c 	ldr	r2, [pc, #108]	; c1cf168 <ts_init+0x8c>
 c1cf0f8:	e5922000 	ldr	r2, [r2]
 c1cf0fc:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
 c1cf100:	e5832000 	str	r2, [r3]
    rPCONE |= 0b01010101 << 8;
 c1cf104:	e59f305c 	ldr	r3, [pc, #92]	; c1cf168 <ts_init+0x8c>
 c1cf108:	e59f2058 	ldr	r2, [pc, #88]	; c1cf168 <ts_init+0x8c>
 c1cf10c:	e5922000 	ldr	r2, [r2]
 c1cf110:	e3822c55 	orr	r2, r2, #21760	; 0x5500
 c1cf114:	e5832000 	str	r2, [r3]

    //Conecta Yâ con GND dejando el resto de terminales abiertos
    //PE[7..4] = 1011
    rPDATE &= ~(0xf << 4);
 c1cf118:	e59f304c 	ldr	r3, [pc, #76]	; c1cf16c <ts_init+0x90>
 c1cf11c:	e59f2048 	ldr	r2, [pc, #72]	; c1cf16c <ts_init+0x90>
 c1cf120:	e5922000 	ldr	r2, [r2]
 c1cf124:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c1cf128:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1011 << 4;
 c1cf12c:	e59f3038 	ldr	r3, [pc, #56]	; c1cf16c <ts_init+0x90>
 c1cf130:	e59f2034 	ldr	r2, [pc, #52]	; c1cf16c <ts_init+0x90>
 c1cf134:	e5922000 	ldr	r2, [r2]
 c1cf138:	e38220b0 	orr	r2, r2, #176	; 0xb0
 c1cf13c:	e5832000 	str	r2, [r3]

    Delay( 1 );
 c1cf140:	e3a00001 	mov	r0, #1
 c1cf144:	eb0003c3 	bl	c1d0058 <Delay>
    portG_conf(2, INPUT);
 c1cf148:	e3a00002 	mov	r0, #2
 c1cf14c:	e3a01000 	mov	r1, #0
 c1cf150:	ebfff076 	bl	c1cb330 <portG_conf>
    //portG_conf_pup(2, ENABLE);

    ts_on();
 c1cf154:	eb000005 	bl	c1cf170 <ts_on>
    ts_calibrate();
 c1cf158:	eb000033 	bl	c1cf22c <ts_calibrate>
}
 c1cf15c:	e24bd00c 	sub	sp, fp, #12
 c1cf160:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf164:	e12fff1e 	bx	lr
 c1cf168:	01d20028 	.word	0x01d20028
 c1cf16c:	01d2002c 	.word	0x01d2002c

0c1cf170 <ts_on>:

void ts_on( void )
{
 c1cf170:	e1a0c00d 	mov	ip, sp
 c1cf174:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf178:	e24cb004 	sub	fp, ip, #4
    adc_on();
 c1cf17c:	ebffee29 	bl	c1caa28 <adc_on>
    state = ON;
 c1cf180:	e59f3010 	ldr	r3, [pc, #16]	; c1cf198 <ts_on+0x28>
 c1cf184:	e3a02001 	mov	r2, #1
 c1cf188:	e5c32000 	strb	r2, [r3]
}
 c1cf18c:	e24bd00c 	sub	sp, fp, #12
 c1cf190:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf194:	e12fff1e 	bx	lr
 c1cf198:	0c10b90c 	.word	0x0c10b90c

0c1cf19c <ts_off>:

void ts_off( void )
{
 c1cf19c:	e1a0c00d 	mov	ip, sp
 c1cf1a0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf1a4:	e24cb004 	sub	fp, ip, #4
    adc_off();
 c1cf1a8:	ebffee2f 	bl	c1caa6c <adc_off>
    state = OFF;
 c1cf1ac:	e59f3010 	ldr	r3, [pc, #16]	; c1cf1c4 <ts_off+0x28>
 c1cf1b0:	e3a02000 	mov	r2, #0
 c1cf1b4:	e5c32000 	strb	r2, [r3]
}
 c1cf1b8:	e24bd00c 	sub	sp, fp, #12
 c1cf1bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf1c0:	e12fff1e 	bx	lr
 c1cf1c4:	0c10b90c 	.word	0x0c10b90c

0c1cf1c8 <ts_status>:

uint8 ts_status( void )
{
 c1cf1c8:	e1a0c00d 	mov	ip, sp
 c1cf1cc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf1d0:	e24cb004 	sub	fp, ip, #4
	return state;
 c1cf1d4:	e59f3010 	ldr	r3, [pc, #16]	; c1cf1ec <ts_status+0x24>
 c1cf1d8:	e5d33000 	ldrb	r3, [r3]
}
 c1cf1dc:	e1a00003 	mov	r0, r3
 c1cf1e0:	e24bd00c 	sub	sp, fp, #12
 c1cf1e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf1e8:	e12fff1e 	bx	lr
 c1cf1ec:	0c10b90c 	.word	0x0c10b90c

0c1cf1f0 <ts_pressed>:

uint8 ts_pressed( void )
{
 c1cf1f0:	e1a0c00d 	mov	ip, sp
 c1cf1f4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf1f8:	e24cb004 	sub	fp, ip, #4
    return !(rPDATG & (1 << 2));
 c1cf1fc:	e59f3024 	ldr	r3, [pc, #36]	; c1cf228 <ts_pressed+0x38>
 c1cf200:	e5933000 	ldr	r3, [r3]
 c1cf204:	e2033004 	and	r3, r3, #4
 c1cf208:	e3530000 	cmp	r3, #0
 c1cf20c:	13a03000 	movne	r3, #0
 c1cf210:	03a03001 	moveq	r3, #1
 c1cf214:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cf218:	e1a00003 	mov	r0, r3
 c1cf21c:	e24bd00c 	sub	sp, fp, #12
 c1cf220:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf224:	e12fff1e 	bx	lr
 c1cf228:	01d20044 	.word	0x01d20044

0c1cf22c <ts_calibrate>:

static void ts_calibrate( void )
{
 c1cf22c:	e1a0c00d 	mov	ip, sp
 c1cf230:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf234:	e24cb004 	sub	fp, ip, #4
 c1cf238:	e24dd010 	sub	sp, sp, #16
    uint16 x, y;

	uart0_puts("Calibracion pantalla tactil: \n");
 c1cf23c:	e59f01d4 	ldr	r0, [pc, #468]	; c1cf418 <ts_calibrate+0x1ec>
 c1cf240:	eb0001a5 	bl	c1cf8dc <uart0_puts>
    lcd_on();
 c1cf244:	ebfff627 	bl	c1ccae8 <lcd_on>
    do {

    	lcd_clear_color(BLACK);
 c1cf248:	e3a0000f 	mov	r0, #15
 c1cf24c:	ebfff664 	bl	c1ccbe4 <lcd_clear_color>
    	lcd_draw_box(0, 0, 0 + PX_ERROR, 0 + PX_ERROR, WHITE, 3);
 c1cf250:	e3a03000 	mov	r3, #0
 c1cf254:	e58d3000 	str	r3, [sp]
 c1cf258:	e3a03003 	mov	r3, #3
 c1cf25c:	e58d3004 	str	r3, [sp, #4]
 c1cf260:	e3a00000 	mov	r0, #0
 c1cf264:	e3a01000 	mov	r1, #0
 c1cf268:	e3a02005 	mov	r2, #5
 c1cf26c:	e3a03005 	mov	r3, #5
 c1cf270:	ebfff73c 	bl	c1ccf68 <lcd_draw_box>
    	uart0_puts("Pulse el punto en la esquina superior izquierda...");
 c1cf274:	e59f01a0 	ldr	r0, [pc, #416]	; c1cf41c <ts_calibrate+0x1f0>
 c1cf278:	eb000197 	bl	c1cf8dc <uart0_puts>

    	while(rPDATG & (1 << 2));
 c1cf27c:	e1a00000 	nop			; (mov r0, r0)
 c1cf280:	e59f3198 	ldr	r3, [pc, #408]	; c1cf420 <ts_calibrate+0x1f4>
 c1cf284:	e5933000 	ldr	r3, [r3]
 c1cf288:	e2033004 	and	r3, r3, #4
 c1cf28c:	e3530000 	cmp	r3, #0
 c1cf290:	1afffffa 	bne	c1cf280 <ts_calibrate+0x54>
        Delay( TS_DOWN_DELAY );
 c1cf294:	e3a00064 	mov	r0, #100	; 0x64
 c1cf298:	eb00036e 	bl	c1d0058 <Delay>
        ts_scan( &Vxmin, &Vymax );
 c1cf29c:	e59f0180 	ldr	r0, [pc, #384]	; c1cf424 <ts_calibrate+0x1f8>
 c1cf2a0:	e59f1180 	ldr	r1, [pc, #384]	; c1cf428 <ts_calibrate+0x1fc>
 c1cf2a4:	eb000091 	bl	c1cf4f0 <ts_scan>
    	while(!(rPDATG & (1 << 2)));
 c1cf2a8:	e1a00000 	nop			; (mov r0, r0)
 c1cf2ac:	e59f316c 	ldr	r3, [pc, #364]	; c1cf420 <ts_calibrate+0x1f4>
 c1cf2b0:	e5933000 	ldr	r3, [r3]
 c1cf2b4:	e2033004 	and	r3, r3, #4
 c1cf2b8:	e3530000 	cmp	r3, #0
 c1cf2bc:	0afffffa 	beq	c1cf2ac <ts_calibrate+0x80>
        Delay( TS_UP_DELAY );
 c1cf2c0:	e3a000c8 	mov	r0, #200	; 0xc8
 c1cf2c4:	eb000363 	bl	c1d0058 <Delay>

    	uart0_puts(" Ok\n");
 c1cf2c8:	e59f015c 	ldr	r0, [pc, #348]	; c1cf42c <ts_calibrate+0x200>
 c1cf2cc:	eb000182 	bl	c1cf8dc <uart0_puts>

    	lcd_clear_color(BLACK);
 c1cf2d0:	e3a0000f 	mov	r0, #15
 c1cf2d4:	ebfff642 	bl	c1ccbe4 <lcd_clear_color>
    	lcd_draw_box(LCD_WIDTH - 1 - PX_ERROR, LCD_HEIGHT - 1 - PX_ERROR, LCD_WIDTH - 1, LCD_HEIGHT - 1, WHITE, 3);
 c1cf2d8:	e3a03000 	mov	r3, #0
 c1cf2dc:	e58d3000 	str	r3, [sp]
 c1cf2e0:	e3a03003 	mov	r3, #3
 c1cf2e4:	e58d3004 	str	r3, [sp, #4]
 c1cf2e8:	e59f0140 	ldr	r0, [pc, #320]	; c1cf430 <ts_calibrate+0x204>
 c1cf2ec:	e3a010ea 	mov	r1, #234	; 0xea
 c1cf2f0:	e59f213c 	ldr	r2, [pc, #316]	; c1cf434 <ts_calibrate+0x208>
 c1cf2f4:	e3a030ef 	mov	r3, #239	; 0xef
 c1cf2f8:	ebfff71a 	bl	c1ccf68 <lcd_draw_box>
    	uart0_puts("Pulse el punto en la esquina inferior derecha...");
 c1cf2fc:	e59f0134 	ldr	r0, [pc, #308]	; c1cf438 <ts_calibrate+0x20c>
 c1cf300:	eb000175 	bl	c1cf8dc <uart0_puts>

    	while(rPDATG & (1 << 2));
 c1cf304:	e1a00000 	nop			; (mov r0, r0)
 c1cf308:	e59f3110 	ldr	r3, [pc, #272]	; c1cf420 <ts_calibrate+0x1f4>
 c1cf30c:	e5933000 	ldr	r3, [r3]
 c1cf310:	e2033004 	and	r3, r3, #4
 c1cf314:	e3530000 	cmp	r3, #0
 c1cf318:	1afffffa 	bne	c1cf308 <ts_calibrate+0xdc>
        Delay( TS_DOWN_DELAY );
 c1cf31c:	e3a00064 	mov	r0, #100	; 0x64
 c1cf320:	eb00034c 	bl	c1d0058 <Delay>
        ts_scan( &Vxmax, &Vymin );
 c1cf324:	e59f0110 	ldr	r0, [pc, #272]	; c1cf43c <ts_calibrate+0x210>
 c1cf328:	e59f1110 	ldr	r1, [pc, #272]	; c1cf440 <ts_calibrate+0x214>
 c1cf32c:	eb00006f 	bl	c1cf4f0 <ts_scan>
    	while(!(rPDATG & (1 << 2)));
 c1cf330:	e1a00000 	nop			; (mov r0, r0)
 c1cf334:	e59f30e4 	ldr	r3, [pc, #228]	; c1cf420 <ts_calibrate+0x1f4>
 c1cf338:	e5933000 	ldr	r3, [r3]
 c1cf33c:	e2033004 	and	r3, r3, #4
 c1cf340:	e3530000 	cmp	r3, #0
 c1cf344:	0afffffa 	beq	c1cf334 <ts_calibrate+0x108>
        Delay( TS_UP_DELAY );
 c1cf348:	e3a000c8 	mov	r0, #200	; 0xc8
 c1cf34c:	eb000341 	bl	c1d0058 <Delay>

        uart0_puts(" Ok\n");
 c1cf350:	e59f00d4 	ldr	r0, [pc, #212]	; c1cf42c <ts_calibrate+0x200>
 c1cf354:	eb000160 	bl	c1cf8dc <uart0_puts>

    	lcd_clear_color(BLACK);
 c1cf358:	e3a0000f 	mov	r0, #15
 c1cf35c:	ebfff620 	bl	c1ccbe4 <lcd_clear_color>
    	lcd_draw_box(LCD_WIDTH/2 - PX_ERROR / 2, LCD_HEIGHT/2 - PX_ERROR / 2, LCD_WIDTH/2 + PX_ERROR / 2, LCD_HEIGHT/2 + PX_ERROR / 2, WHITE, 3);
 c1cf360:	e3a03000 	mov	r3, #0
 c1cf364:	e58d3000 	str	r3, [sp]
 c1cf368:	e3a03003 	mov	r3, #3
 c1cf36c:	e58d3004 	str	r3, [sp, #4]
 c1cf370:	e3a0009e 	mov	r0, #158	; 0x9e
 c1cf374:	e3a01076 	mov	r1, #118	; 0x76
 c1cf378:	e3a020a2 	mov	r2, #162	; 0xa2
 c1cf37c:	e3a0307a 	mov	r3, #122	; 0x7a
 c1cf380:	ebfff6f8 	bl	c1ccf68 <lcd_draw_box>

    	uart0_puts("Pulse el punto en el centro...");
 c1cf384:	e59f00b8 	ldr	r0, [pc, #184]	; c1cf444 <ts_calibrate+0x218>
 c1cf388:	eb000153 	bl	c1cf8dc <uart0_puts>

        ts_getpos( &x, &y );
 c1cf38c:	e24b200e 	sub	r2, fp, #14
 c1cf390:	e24b3010 	sub	r3, fp, #16
 c1cf394:	e1a00002 	mov	r0, r2
 c1cf398:	e1a01003 	mov	r1, r3
 c1cf39c:	eb00002d 	bl	c1cf458 <ts_getpos>

    	uart0_puts("X: ");
 c1cf3a0:	e59f00a0 	ldr	r0, [pc, #160]	; c1cf448 <ts_calibrate+0x21c>
 c1cf3a4:	eb00014c 	bl	c1cf8dc <uart0_puts>
    	uart0_putint(x);
 c1cf3a8:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cf3ac:	e1a00003 	mov	r0, r3
 c1cf3b0:	eb00015d 	bl	c1cf92c <uart0_putint>
    	uart0_puts(", Y: ");
 c1cf3b4:	e59f0090 	ldr	r0, [pc, #144]	; c1cf44c <ts_calibrate+0x220>
 c1cf3b8:	eb000147 	bl	c1cf8dc <uart0_puts>
    	uart0_putint(y);
 c1cf3bc:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cf3c0:	e1a00003 	mov	r0, r3
 c1cf3c4:	eb000158 	bl	c1cf92c <uart0_putint>
    	uart0_puts("\n");
 c1cf3c8:	e59f0080 	ldr	r0, [pc, #128]	; c1cf450 <ts_calibrate+0x224>
 c1cf3cc:	eb000142 	bl	c1cf8dc <uart0_puts>

    } while( (x > LCD_WIDTH/2+PX_ERROR) || (x < LCD_WIDTH/2-PX_ERROR) || (y > LCD_HEIGHT/2+PX_ERROR) || (y < LCD_HEIGHT/2-PX_ERROR) );
 c1cf3d0:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cf3d4:	e35300a5 	cmp	r3, #165	; 0xa5
 c1cf3d8:	8affff9a 	bhi	c1cf248 <ts_calibrate+0x1c>
 c1cf3dc:	e15b30be 	ldrh	r3, [fp, #-14]
 c1cf3e0:	e353009a 	cmp	r3, #154	; 0x9a
 c1cf3e4:	9affff97 	bls	c1cf248 <ts_calibrate+0x1c>
 c1cf3e8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cf3ec:	e353007d 	cmp	r3, #125	; 0x7d
 c1cf3f0:	8affff94 	bhi	c1cf248 <ts_calibrate+0x1c>
 c1cf3f4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cf3f8:	e3530072 	cmp	r3, #114	; 0x72
 c1cf3fc:	9affff91 	bls	c1cf248 <ts_calibrate+0x1c>

    uart0_puts("Calibracion completada\n");
 c1cf400:	e59f004c 	ldr	r0, [pc, #76]	; c1cf454 <ts_calibrate+0x228>
 c1cf404:	eb000134 	bl	c1cf8dc <uart0_puts>
    lcd_clear();
 c1cf408:	ebfff5de 	bl	c1ccb88 <lcd_clear>
}
 c1cf40c:	e24bd00c 	sub	sp, fp, #12
 c1cf410:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf414:	e12fff1e 	bx	lr
 c1cf418:	0c102164 	.word	0x0c102164
 c1cf41c:	0c102184 	.word	0x0c102184
 c1cf420:	01d20044 	.word	0x01d20044
 c1cf424:	0c10b904 	.word	0x0c10b904
 c1cf428:	0c10b90a 	.word	0x0c10b90a
 c1cf42c:	0c1021b8 	.word	0x0c1021b8
 c1cf430:	0000013a 	.word	0x0000013a
 c1cf434:	0000013f 	.word	0x0000013f
 c1cf438:	0c1021c0 	.word	0x0c1021c0
 c1cf43c:	0c10b906 	.word	0x0c10b906
 c1cf440:	0c10b908 	.word	0x0c10b908
 c1cf444:	0c1021f4 	.word	0x0c1021f4
 c1cf448:	0c102214 	.word	0x0c102214
 c1cf44c:	0c102218 	.word	0x0c102218
 c1cf450:	0c102220 	.word	0x0c102220
 c1cf454:	0c102224 	.word	0x0c102224

0c1cf458 <ts_getpos>:

void ts_getpos( uint16 *x, uint16 *y )
{
 c1cf458:	e1a0c00d 	mov	ip, sp
 c1cf45c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf460:	e24cb004 	sub	fp, ip, #4
 c1cf464:	e24dd010 	sub	sp, sp, #16
 c1cf468:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c1cf46c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
	uint16 Vx, Vy;

	//Esperar a que PG[2]=0
	while(rPDATG & (1 << 2));
 c1cf470:	e1a00000 	nop			; (mov r0, r0)
 c1cf474:	e59f3070 	ldr	r3, [pc, #112]	; c1cf4ec <ts_getpos+0x94>
 c1cf478:	e5933000 	ldr	r3, [r3]
 c1cf47c:	e2033004 	and	r3, r3, #4
 c1cf480:	e3530000 	cmp	r3, #0
 c1cf484:	1afffffa 	bne	c1cf474 <ts_getpos+0x1c>

	//Esperar TS_DOWN_DELAY
	Delay(TS_DOWN_DELAY);
 c1cf488:	e3a00064 	mov	r0, #100	; 0x64
 c1cf48c:	eb0002f1 	bl	c1d0058 <Delay>

	ts_scan(&Vx, &Vy);
 c1cf490:	e24b200e 	sub	r2, fp, #14
 c1cf494:	e24b3010 	sub	r3, fp, #16
 c1cf498:	e1a00002 	mov	r0, r2
 c1cf49c:	e1a01003 	mov	r1, r3
 c1cf4a0:	eb000012 	bl	c1cf4f0 <ts_scan>
	ts_sample2coord(Vx, Vy, x, y);
 c1cf4a4:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cf4a8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c1cf4ac:	e1a00002 	mov	r0, r2
 c1cf4b0:	e1a01003 	mov	r1, r3
 c1cf4b4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c1cf4b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c1cf4bc:	eb000041 	bl	c1cf5c8 <ts_sample2coord>

	//Esperar a que PG[2]=1
	while(!(rPDATG & (1 << 2)));
 c1cf4c0:	e1a00000 	nop			; (mov r0, r0)
 c1cf4c4:	e59f3020 	ldr	r3, [pc, #32]	; c1cf4ec <ts_getpos+0x94>
 c1cf4c8:	e5933000 	ldr	r3, [r3]
 c1cf4cc:	e2033004 	and	r3, r3, #4
 c1cf4d0:	e3530000 	cmp	r3, #0
 c1cf4d4:	0afffffa 	beq	c1cf4c4 <ts_getpos+0x6c>

	//Esperar TS_UP_DELAY
	Delay(TS_UP_DELAY);
 c1cf4d8:	e3a000c8 	mov	r0, #200	; 0xc8
 c1cf4dc:	eb0002dd 	bl	c1d0058 <Delay>
}
 c1cf4e0:	e24bd00c 	sub	sp, fp, #12
 c1cf4e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf4e8:	e12fff1e 	bx	lr
 c1cf4ec:	01d20044 	.word	0x01d20044

0c1cf4f0 <ts_scan>:

static void ts_scan( uint16 *Vx, uint16 *Vy )
{
 c1cf4f0:	e1a0c00d 	mov	ip, sp
 c1cf4f4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf4f8:	e24cb004 	sub	fp, ip, #4
 c1cf4fc:	e24dd008 	sub	sp, sp, #8
 c1cf500:	e50b0010 	str	r0, [fp, #-16]
 c1cf504:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	//PE[7..4] = (0,1,1,0)
    rPDATE &= ~(0xf << 4);
 c1cf508:	e59f30b4 	ldr	r3, [pc, #180]	; c1cf5c4 <ts_scan+0xd4>
 c1cf50c:	e59f20b0 	ldr	r2, [pc, #176]	; c1cf5c4 <ts_scan+0xd4>
 c1cf510:	e5922000 	ldr	r2, [r2]
 c1cf514:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c1cf518:	e5832000 	str	r2, [r3]
    rPDATE |= 0b0110 << 4;
 c1cf51c:	e59f30a0 	ldr	r3, [pc, #160]	; c1cf5c4 <ts_scan+0xd4>
 c1cf520:	e59f209c 	ldr	r2, [pc, #156]	; c1cf5c4 <ts_scan+0xd4>
 c1cf524:	e5922000 	ldr	r2, [r2]
 c1cf528:	e3822060 	orr	r2, r2, #96	; 0x60
 c1cf52c:	e5832000 	str	r2, [r3]

    //leer Vx por canal AIN1

    *Vx = adc_getSample( ADC_AIN1 );
 c1cf530:	e3a00001 	mov	r0, #1
 c1cf534:	ebffed65 	bl	c1caad0 <adc_getSample>
 c1cf538:	e1a03000 	mov	r3, r0
 c1cf53c:	e1a02003 	mov	r2, r3
 c1cf540:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf544:	e1c320b0 	strh	r2, [r3]

	//PE[7..4] = (1,0,0,1)
    rPDATE &= ~(0xf << 4);
 c1cf548:	e59f3074 	ldr	r3, [pc, #116]	; c1cf5c4 <ts_scan+0xd4>
 c1cf54c:	e59f2070 	ldr	r2, [pc, #112]	; c1cf5c4 <ts_scan+0xd4>
 c1cf550:	e5922000 	ldr	r2, [r2]
 c1cf554:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c1cf558:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1001 << 4;
 c1cf55c:	e59f3060 	ldr	r3, [pc, #96]	; c1cf5c4 <ts_scan+0xd4>
 c1cf560:	e59f205c 	ldr	r2, [pc, #92]	; c1cf5c4 <ts_scan+0xd4>
 c1cf564:	e5922000 	ldr	r2, [r2]
 c1cf568:	e3822090 	orr	r2, r2, #144	; 0x90
 c1cf56c:	e5832000 	str	r2, [r3]

    //leer Vy por canal AIN0

    *Vy = adc_getSample( ADC_AIN0 );
 c1cf570:	e3a00000 	mov	r0, #0
 c1cf574:	ebffed55 	bl	c1caad0 <adc_getSample>
 c1cf578:	e1a03000 	mov	r3, r0
 c1cf57c:	e1a02003 	mov	r2, r3
 c1cf580:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf584:	e1c320b0 	strh	r2, [r3]

	//PE[7..4] = (1,0,1,1)
    rPDATE &= ~(0xf << 4);
 c1cf588:	e59f3034 	ldr	r3, [pc, #52]	; c1cf5c4 <ts_scan+0xd4>
 c1cf58c:	e59f2030 	ldr	r2, [pc, #48]	; c1cf5c4 <ts_scan+0xd4>
 c1cf590:	e5922000 	ldr	r2, [r2]
 c1cf594:	e3c220f0 	bic	r2, r2, #240	; 0xf0
 c1cf598:	e5832000 	str	r2, [r3]
    rPDATE |= 0b1011 << 4;
 c1cf59c:	e59f3020 	ldr	r3, [pc, #32]	; c1cf5c4 <ts_scan+0xd4>
 c1cf5a0:	e59f201c 	ldr	r2, [pc, #28]	; c1cf5c4 <ts_scan+0xd4>
 c1cf5a4:	e5922000 	ldr	r2, [r2]
 c1cf5a8:	e38220b0 	orr	r2, r2, #176	; 0xb0
 c1cf5ac:	e5832000 	str	r2, [r3]

    Delay(1);
 c1cf5b0:	e3a00001 	mov	r0, #1
 c1cf5b4:	eb0002a7 	bl	c1d0058 <Delay>
}
 c1cf5b8:	e24bd00c 	sub	sp, fp, #12
 c1cf5bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf5c0:	e12fff1e 	bx	lr
 c1cf5c4:	01d2002c 	.word	0x01d2002c

0c1cf5c8 <ts_sample2coord>:

static void ts_sample2coord( uint16 Vx, uint16 Vy, uint16 *x, uint16 *y )
{
 c1cf5c8:	e1a0c00d 	mov	ip, sp
 c1cf5cc:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf5d0:	e24cb004 	sub	fp, ip, #4
 c1cf5d4:	e24dd010 	sub	sp, sp, #16
 c1cf5d8:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
 c1cf5dc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1cf5e0:	e14b00be 	strh	r0, [fp, #-14]
 c1cf5e4:	e14b11b0 	strh	r1, [fp, #-16]
	//Interpolate Vx
    if( Vx < Vxmin )
 c1cf5e8:	e59f3168 	ldr	r3, [pc, #360]	; c1cf758 <ts_sample2coord+0x190>
 c1cf5ec:	e1d330b0 	ldrh	r3, [r3]
 c1cf5f0:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cf5f4:	e1520003 	cmp	r2, r3
 c1cf5f8:	2a000003 	bcs	c1cf60c <ts_sample2coord+0x44>
        *x = 0;
 c1cf5fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf600:	e3a02000 	mov	r2, #0
 c1cf604:	e1c320b0 	strh	r2, [r3]
 c1cf608:	ea00001f 	b	c1cf68c <ts_sample2coord+0xc4>
    else if( Vx > Vxmax )
 c1cf60c:	e59f3148 	ldr	r3, [pc, #328]	; c1cf75c <ts_sample2coord+0x194>
 c1cf610:	e1d330b0 	ldrh	r3, [r3]
 c1cf614:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cf618:	e1520003 	cmp	r2, r3
 c1cf61c:	9a000003 	bls	c1cf630 <ts_sample2coord+0x68>
        *x = LCD_WIDTH-1;
 c1cf620:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf624:	e59f2134 	ldr	r2, [pc, #308]	; c1cf760 <ts_sample2coord+0x198>
 c1cf628:	e1c320b0 	strh	r2, [r3]
 c1cf62c:	ea000016 	b	c1cf68c <ts_sample2coord+0xc4>
    else
        *x = LCD_WIDTH*(Vx-Vxmin) / (Vxmax-Vxmin);
 c1cf630:	e15b20be 	ldrh	r2, [fp, #-14]
 c1cf634:	e59f311c 	ldr	r3, [pc, #284]	; c1cf758 <ts_sample2coord+0x190>
 c1cf638:	e1d330b0 	ldrh	r3, [r3]
 c1cf63c:	e0632002 	rsb	r2, r3, r2
 c1cf640:	e1a03002 	mov	r3, r2
 c1cf644:	e1a03103 	lsl	r3, r3, #2
 c1cf648:	e0833002 	add	r3, r3, r2
 c1cf64c:	e1a03303 	lsl	r3, r3, #6
 c1cf650:	e1a02003 	mov	r2, r3
 c1cf654:	e59f3100 	ldr	r3, [pc, #256]	; c1cf75c <ts_sample2coord+0x194>
 c1cf658:	e1d330b0 	ldrh	r3, [r3]
 c1cf65c:	e1a01003 	mov	r1, r3
 c1cf660:	e59f30f0 	ldr	r3, [pc, #240]	; c1cf758 <ts_sample2coord+0x190>
 c1cf664:	e1d330b0 	ldrh	r3, [r3]
 c1cf668:	e0633001 	rsb	r3, r3, r1
 c1cf66c:	e1a00002 	mov	r0, r2
 c1cf670:	e1a01003 	mov	r1, r3
 c1cf674:	eb0002d1 	bl	c1d01c0 <__aeabi_idiv>
 c1cf678:	e1a03000 	mov	r3, r0
 c1cf67c:	e1a03803 	lsl	r3, r3, #16
 c1cf680:	e1a02823 	lsr	r2, r3, #16
 c1cf684:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf688:	e1c320b0 	strh	r2, [r3]

    //Interpolate Vy
    if( Vy < Vymin )
 c1cf68c:	e59f30d0 	ldr	r3, [pc, #208]	; c1cf764 <ts_sample2coord+0x19c>
 c1cf690:	e1d330b0 	ldrh	r3, [r3]
 c1cf694:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1cf698:	e1520003 	cmp	r2, r3
 c1cf69c:	2a000003 	bcs	c1cf6b0 <ts_sample2coord+0xe8>
        *y = 0;
 c1cf6a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cf6a4:	e3a02000 	mov	r2, #0
 c1cf6a8:	e1c320b0 	strh	r2, [r3]
 c1cf6ac:	ea00001f 	b	c1cf730 <ts_sample2coord+0x168>
    else if( Vy > Vymax )
 c1cf6b0:	e59f30b0 	ldr	r3, [pc, #176]	; c1cf768 <ts_sample2coord+0x1a0>
 c1cf6b4:	e1d330b0 	ldrh	r3, [r3]
 c1cf6b8:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1cf6bc:	e1520003 	cmp	r2, r3
 c1cf6c0:	9a000003 	bls	c1cf6d4 <ts_sample2coord+0x10c>
        *y = LCD_HEIGHT-1;
 c1cf6c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cf6c8:	e3a020ef 	mov	r2, #239	; 0xef
 c1cf6cc:	e1c320b0 	strh	r2, [r3]
 c1cf6d0:	ea000016 	b	c1cf730 <ts_sample2coord+0x168>
    else
        *y = LCD_HEIGHT*(Vy-Vymin) / (Vymax-Vymin);
 c1cf6d4:	e15b21b0 	ldrh	r2, [fp, #-16]
 c1cf6d8:	e59f3084 	ldr	r3, [pc, #132]	; c1cf764 <ts_sample2coord+0x19c>
 c1cf6dc:	e1d330b0 	ldrh	r3, [r3]
 c1cf6e0:	e0632002 	rsb	r2, r3, r2
 c1cf6e4:	e1a03002 	mov	r3, r2
 c1cf6e8:	e1a03203 	lsl	r3, r3, #4
 c1cf6ec:	e0623003 	rsb	r3, r2, r3
 c1cf6f0:	e1a03203 	lsl	r3, r3, #4
 c1cf6f4:	e1a02003 	mov	r2, r3
 c1cf6f8:	e59f3068 	ldr	r3, [pc, #104]	; c1cf768 <ts_sample2coord+0x1a0>
 c1cf6fc:	e1d330b0 	ldrh	r3, [r3]
 c1cf700:	e1a01003 	mov	r1, r3
 c1cf704:	e59f3058 	ldr	r3, [pc, #88]	; c1cf764 <ts_sample2coord+0x19c>
 c1cf708:	e1d330b0 	ldrh	r3, [r3]
 c1cf70c:	e0633001 	rsb	r3, r3, r1
 c1cf710:	e1a00002 	mov	r0, r2
 c1cf714:	e1a01003 	mov	r1, r3
 c1cf718:	eb0002a8 	bl	c1d01c0 <__aeabi_idiv>
 c1cf71c:	e1a03000 	mov	r3, r0
 c1cf720:	e1a03803 	lsl	r3, r3, #16
 c1cf724:	e1a02823 	lsr	r2, r3, #16
 c1cf728:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cf72c:	e1c320b0 	strh	r2, [r3]

    //Vy crece cuando y decrece
    *y = LCD_HEIGHT - *y;
 c1cf730:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cf734:	e1d330b0 	ldrh	r3, [r3]
 c1cf738:	e26330f0 	rsb	r3, r3, #240	; 0xf0
 c1cf73c:	e1a03803 	lsl	r3, r3, #16
 c1cf740:	e1a02823 	lsr	r2, r3, #16
 c1cf744:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cf748:	e1c320b0 	strh	r2, [r3]
}
 c1cf74c:	e24bd00c 	sub	sp, fp, #12
 c1cf750:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf754:	e12fff1e 	bx	lr
 c1cf758:	0c10b904 	.word	0x0c10b904
 c1cf75c:	0c10b906 	.word	0x0c10b906
 c1cf760:	0000013f 	.word	0x0000013f
 c1cf764:	0c10b908 	.word	0x0c10b908
 c1cf768:	0c10b90a 	.word	0x0c10b90a

0c1cf76c <ts_open>:

void ts_open( void (*isr)(void) )
{
 c1cf76c:	e1a0c00d 	mov	ip, sp
 c1cf770:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf774:	e24cb004 	sub	fp, ip, #4
 c1cf778:	e24dd008 	sub	sp, sp, #8
 c1cf77c:	e50b0010 	str	r0, [fp, #-16]
	pISR_EINT2 = (unsigned) isr;
 c1cf780:	e59f3020 	ldr	r3, [pc, #32]	; c1cf7a8 <ts_open+0x3c>
 c1cf784:	e51b2010 	ldr	r2, [fp, #-16]
 c1cf788:	e5832000 	str	r2, [r3]
	ic_cleanflag(INT_EINT2);
 c1cf78c:	e3a00017 	mov	r0, #23
 c1cf790:	ebfff3e0 	bl	c1cc718 <ic_cleanflag>
	ic_enable(INT_EINT2);
 c1cf794:	e3a00017 	mov	r0, #23
 c1cf798:	ebfff3ab 	bl	c1cc64c <ic_enable>
}
 c1cf79c:	e24bd00c 	sub	sp, fp, #12
 c1cf7a0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf7a4:	e12fff1e 	bx	lr
 c1cf7a8:	0c7fff7c 	.word	0x0c7fff7c

0c1cf7ac <ts_close>:

void ts_close( void )
{
 c1cf7ac:	e1a0c00d 	mov	ip, sp
 c1cf7b0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf7b4:	e24cb004 	sub	fp, ip, #4
    ic_disable(INT_EINT2);
 c1cf7b8:	e3a00017 	mov	r0, #23
 c1cf7bc:	ebfff3bc 	bl	c1cc6b4 <ic_disable>
    pISR_EINT2 = (unsigned) isr_TS_dummy;
 c1cf7c0:	e59f3010 	ldr	r3, [pc, #16]	; c1cf7d8 <ts_close+0x2c>
 c1cf7c4:	e59f2010 	ldr	r2, [pc, #16]	; c1cf7dc <ts_close+0x30>
 c1cf7c8:	e5832000 	str	r2, [r3]
}
 c1cf7cc:	e24bd00c 	sub	sp, fp, #12
 c1cf7d0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf7d4:	e12fff1e 	bx	lr
 c1cf7d8:	0c7fff7c 	.word	0x0c7fff7c
 c1cf7dc:	0c1cf0b4 	.word	0x0c1cf0b4

0c1cf7e0 <uart0_init>:
#include "uart.h"
#include "44b.h"

void uart0_init( void )
{
 c1cf7e0:	e1a0c00d 	mov	ip, sp
 c1cf7e4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf7e8:	e24cb004 	sub	fp, ip, #4
	//*Enable FIFO, Rx normal, Tx normal
	//UFCON0[0] = 1
	//UFCON0[1] = 0  Rx FIFO normal (no reset)
	//UFCON0[2] = 0  Rx FIFO normal (no reset)
    rUFCON0 = 0x1;
 c1cf7ec:	e59f3040 	ldr	r3, [pc, #64]	; c1cf834 <uart0_init+0x54>
 c1cf7f0:	e3a02001 	mov	r2, #1
 c1cf7f4:	e5832000 	str	r2, [r3]

    //Disable Auto Flow Control and disable Request to Send
    //UMCON0[4] = 0
    rUMCON0 = 0x0;
 c1cf7f8:	e59f3038 	ldr	r3, [pc, #56]	; c1cf838 <uart0_init+0x58>
 c1cf7fc:	e3a02000 	mov	r2, #0
 c1cf800:	e5832000 	str	r2, [r3]
    //* Formato de la trama:
    //ULCON0[6]   = 0  normal (no infrarrojos)
    //ULCON0[5:3] = 0  sin paridad
    //ULCON0[2]   = 0  1 bit de stop
    //ULCON0[1:0] = 3  8 bits de datos
    rULCON0 = 0x3;
 c1cf804:	e3a0361d 	mov	r3, #30408704	; 0x1d00000
 c1cf808:	e3a02003 	mov	r2, #3
 c1cf80c:	e5832000 	str	r2, [r3]

    //* 115200 Baudios
    //UBRDIV0 = 34  64MHz / (115200 Ã 16) â 1
    rUBRDIV0 = 34;
 c1cf810:	e59f3024 	ldr	r3, [pc, #36]	; c1cf83c <uart0_init+0x5c>
 c1cf814:	e3a02022 	mov	r2, #34	; 0x22
 c1cf818:	e5832000 	str	r2, [r3]

    //UCON0[1:0] = 1  Rx: polling/interrupt mode
    //UCON0[3:2] = 1  Tx: polling/interrupt mode
    //UCON0[4]   = 0  no break
    //UCON0[5]   = 0  no loopback
    rUCON0 = 0x5;
 c1cf81c:	e59f301c 	ldr	r3, [pc, #28]	; c1cf840 <uart0_init+0x60>
 c1cf820:	e3a02005 	mov	r2, #5
 c1cf824:	e5832000 	str	r2, [r3]
}
 c1cf828:	e24bd00c 	sub	sp, fp, #12
 c1cf82c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf830:	e12fff1e 	bx	lr
 c1cf834:	01d00008 	.word	0x01d00008
 c1cf838:	01d0000c 	.word	0x01d0000c
 c1cf83c:	01d00028 	.word	0x01d00028
 c1cf840:	01d00004 	.word	0x01d00004

0c1cf844 <uart0_putchar>:

void uart0_putchar( char ch )
{
 c1cf844:	e1a0c00d 	mov	ip, sp
 c1cf848:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf84c:	e24cb004 	sub	fp, ip, #4
 c1cf850:	e24dd008 	sub	sp, sp, #8
 c1cf854:	e1a03000 	mov	r3, r0
 c1cf858:	e54b300d 	strb	r3, [fp, #-13]
	//While FIFO is full wait (while UFSTAT0[9] == 1)
    while( rUFSTAT0 & (1 << 9) );
 c1cf85c:	e1a00000 	nop			; (mov r0, r0)
 c1cf860:	e59f3024 	ldr	r3, [pc, #36]	; c1cf88c <uart0_putchar+0x48>
 c1cf864:	e5933000 	ldr	r3, [r3]
 c1cf868:	e2033c02 	and	r3, r3, #512	; 0x200
 c1cf86c:	e3530000 	cmp	r3, #0
 c1cf870:	1afffffa 	bne	c1cf860 <uart0_putchar+0x1c>
    rUTXH0 = ch;
 c1cf874:	e59f3014 	ldr	r3, [pc, #20]	; c1cf890 <uart0_putchar+0x4c>
 c1cf878:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cf87c:	e5c32000 	strb	r2, [r3]
}
 c1cf880:	e24bd00c 	sub	sp, fp, #12
 c1cf884:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf888:	e12fff1e 	bx	lr
 c1cf88c:	01d00018 	.word	0x01d00018
 c1cf890:	01d00020 	.word	0x01d00020

0c1cf894 <uart0_getchar>:

char uart0_getchar( void )
{
 c1cf894:	e1a0c00d 	mov	ip, sp
 c1cf898:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf89c:	e24cb004 	sub	fp, ip, #4
	//While FIFO is empty wait (while UFSTAT0[3:0] == 0)
    while( (rUFSTAT0 & 0b1111) == 0 );
 c1cf8a0:	e1a00000 	nop			; (mov r0, r0)
 c1cf8a4:	e59f3028 	ldr	r3, [pc, #40]	; c1cf8d4 <uart0_getchar+0x40>
 c1cf8a8:	e5933000 	ldr	r3, [r3]
 c1cf8ac:	e203300f 	and	r3, r3, #15
 c1cf8b0:	e3530000 	cmp	r3, #0
 c1cf8b4:	0afffffa 	beq	c1cf8a4 <uart0_getchar+0x10>

    //Read URXH0
    return rURXH0;
 c1cf8b8:	e59f3018 	ldr	r3, [pc, #24]	; c1cf8d8 <uart0_getchar+0x44>
 c1cf8bc:	e5d33000 	ldrb	r3, [r3]
 c1cf8c0:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c1cf8c4:	e1a00003 	mov	r0, r3
 c1cf8c8:	e24bd00c 	sub	sp, fp, #12
 c1cf8cc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf8d0:	e12fff1e 	bx	lr
 c1cf8d4:	01d00018 	.word	0x01d00018
 c1cf8d8:	01d00024 	.word	0x01d00024

0c1cf8dc <uart0_puts>:

void uart0_puts( char *s )
{
 c1cf8dc:	e1a0c00d 	mov	ip, sp
 c1cf8e0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf8e4:	e24cb004 	sub	fp, ip, #4
 c1cf8e8:	e24dd008 	sub	sp, sp, #8
 c1cf8ec:	e50b0010 	str	r0, [fp, #-16]
    while(*s) {
 c1cf8f0:	ea000006 	b	c1cf910 <uart0_puts+0x34>
    	uart0_putchar(*s);
 c1cf8f4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf8f8:	e5d33000 	ldrb	r3, [r3]
 c1cf8fc:	e1a00003 	mov	r0, r3
 c1cf900:	ebffffcf 	bl	c1cf844 <uart0_putchar>
    	s++;
 c1cf904:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf908:	e2833001 	add	r3, r3, #1
 c1cf90c:	e50b3010 	str	r3, [fp, #-16]
    return rURXH0;
}

void uart0_puts( char *s )
{
    while(*s) {
 c1cf910:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf914:	e5d33000 	ldrb	r3, [r3]
 c1cf918:	e3530000 	cmp	r3, #0
 c1cf91c:	1afffff4 	bne	c1cf8f4 <uart0_puts+0x18>
    	uart0_putchar(*s);
    	s++;
    }
}
 c1cf920:	e24bd00c 	sub	sp, fp, #12
 c1cf924:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cf928:	e12fff1e 	bx	lr

0c1cf92c <uart0_putint>:

void uart0_putint( int32 i )
{
 c1cf92c:	e1a0c00d 	mov	ip, sp
 c1cf930:	e92dd800 	push	{fp, ip, lr, pc}
 c1cf934:	e24cb004 	sub	fp, ip, #4
 c1cf938:	e24dd020 	sub	sp, sp, #32
 c1cf93c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
	char s[11 + 1];
	int negative = i < 0;
 c1cf940:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c1cf944:	e1a03fa3 	lsr	r3, r3, #31
 c1cf948:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	char* p = s + 11;
 c1cf94c:	e24b3020 	sub	r3, fp, #32
 c1cf950:	e283300b 	add	r3, r3, #11
 c1cf954:	e50b3010 	str	r3, [fp, #-16]

	*p = '\0';
 c1cf958:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf95c:	e3a02000 	mov	r2, #0
 c1cf960:	e5c32000 	strb	r2, [r3]
	if (negative)
 c1cf964:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf968:	e3530000 	cmp	r3, #0
 c1cf96c:	0a000002 	beq	c1cf97c <uart0_putint+0x50>
		i *= -1;
 c1cf970:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c1cf974:	e2633000 	rsb	r3, r3, #0
 c1cf978:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

	do {
		*--p = '0' + ( i % 10 );
 c1cf97c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf980:	e2433001 	sub	r3, r3, #1
 c1cf984:	e50b3010 	str	r3, [fp, #-16]
 c1cf988:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
 c1cf98c:	e59f3094 	ldr	r3, [pc, #148]	; c1cfa28 <uart0_putint+0xfc>
 c1cf990:	e0c32391 	smull	r2, r3, r1, r3
 c1cf994:	e1a02143 	asr	r2, r3, #2
 c1cf998:	e1a03fc1 	asr	r3, r1, #31
 c1cf99c:	e0632002 	rsb	r2, r3, r2
 c1cf9a0:	e1a03002 	mov	r3, r2
 c1cf9a4:	e1a03103 	lsl	r3, r3, #2
 c1cf9a8:	e0833002 	add	r3, r3, r2
 c1cf9ac:	e1a03083 	lsl	r3, r3, #1
 c1cf9b0:	e0632001 	rsb	r2, r3, r1
 c1cf9b4:	e20230ff 	and	r3, r2, #255	; 0xff
 c1cf9b8:	e2833030 	add	r3, r3, #48	; 0x30
 c1cf9bc:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cf9c0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cf9c4:	e5c32000 	strb	r2, [r3]
		i /= 10;
 c1cf9c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c1cf9cc:	e59f2054 	ldr	r2, [pc, #84]	; c1cfa28 <uart0_putint+0xfc>
 c1cf9d0:	e0c21293 	smull	r1, r2, r3, r2
 c1cf9d4:	e1a02142 	asr	r2, r2, #2
 c1cf9d8:	e1a03fc3 	asr	r3, r3, #31
 c1cf9dc:	e0633002 	rsb	r3, r3, r2
 c1cf9e0:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
	} while(i > 0);
 c1cf9e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c1cf9e8:	e3530000 	cmp	r3, #0
 c1cf9ec:	caffffe2 	bgt	c1cf97c <uart0_putint+0x50>

	if(negative) {
 c1cf9f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cf9f4:	e3530000 	cmp	r3, #0
 c1cf9f8:	0a000005 	beq	c1cfa14 <uart0_putint+0xe8>
		*--p = '-';
 c1cf9fc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa00:	e2433001 	sub	r3, r3, #1
 c1cfa04:	e50b3010 	str	r3, [fp, #-16]
 c1cfa08:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa0c:	e3a0202d 	mov	r2, #45	; 0x2d
 c1cfa10:	e5c32000 	strb	r2, [r3]
	}

	uart0_puts(p);
 c1cfa14:	e51b0010 	ldr	r0, [fp, #-16]
 c1cfa18:	ebffffaf 	bl	c1cf8dc <uart0_puts>
}
 c1cfa1c:	e24bd00c 	sub	sp, fp, #12
 c1cfa20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfa24:	e12fff1e 	bx	lr
 c1cfa28:	66666667 	.word	0x66666667

0c1cfa2c <uart0_puthex>:

void uart0_puthex( uint32 i )
{
 c1cfa2c:	e1a0c00d 	mov	ip, sp
 c1cfa30:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfa34:	e24cb004 	sub	fp, ip, #4
 c1cfa38:	e24dd018 	sub	sp, sp, #24
 c1cfa3c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    char buf[8 + 1];
    char *p = buf + 8;
 c1cfa40:	e24b301c 	sub	r3, fp, #28
 c1cfa44:	e2833008 	add	r3, r3, #8
 c1cfa48:	e50b3010 	str	r3, [fp, #-16]
    uint8 c;

    *p = '\0';
 c1cfa4c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa50:	e3a02000 	mov	r2, #0
 c1cfa54:	e5c32000 	strb	r2, [r3]

    do {
        c = i & 0xf;
 c1cfa58:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cfa5c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cfa60:	e203300f 	and	r3, r3, #15
 c1cfa64:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        if( c < 10 )
 c1cfa68:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cfa6c:	e3530009 	cmp	r3, #9
 c1cfa70:	8a000008 	bhi	c1cfa98 <uart0_puthex+0x6c>
            *--p = '0' + c;
 c1cfa74:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa78:	e2433001 	sub	r3, r3, #1
 c1cfa7c:	e50b3010 	str	r3, [fp, #-16]
 c1cfa80:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cfa84:	e2833030 	add	r3, r3, #48	; 0x30
 c1cfa88:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cfa8c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa90:	e5c32000 	strb	r2, [r3]
 c1cfa94:	ea000007 	b	c1cfab8 <uart0_puthex+0x8c>
        else
            *--p = 'a' + c - 10;
 c1cfa98:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfa9c:	e2433001 	sub	r3, r3, #1
 c1cfaa0:	e50b3010 	str	r3, [fp, #-16]
 c1cfaa4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c1cfaa8:	e2833057 	add	r3, r3, #87	; 0x57
 c1cfaac:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cfab0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfab4:	e5c32000 	strb	r2, [r3]
        i = i >> 4;
 c1cfab8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cfabc:	e1a03223 	lsr	r3, r3, #4
 c1cfac0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    } while( i );
 c1cfac4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c1cfac8:	e3530000 	cmp	r3, #0
 c1cfacc:	1affffe1 	bne	c1cfa58 <uart0_puthex+0x2c>

    uart0_puts( p );
 c1cfad0:	e51b0010 	ldr	r0, [fp, #-16]
 c1cfad4:	ebffff80 	bl	c1cf8dc <uart0_puts>
}
 c1cfad8:	e24bd00c 	sub	sp, fp, #12
 c1cfadc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfae0:	e12fff1e 	bx	lr

0c1cfae4 <uart0_gets>:

void uart0_gets( char *s )
{
 c1cfae4:	e1a0c00d 	mov	ip, sp
 c1cfae8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfaec:	e24cb004 	sub	fp, ip, #4
 c1cfaf0:	e24dd010 	sub	sp, sp, #16
 c1cfaf4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	char c = uart0_getchar();
 c1cfaf8:	ebffff65 	bl	c1cf894 <uart0_getchar>
 c1cfafc:	e1a03000 	mov	r3, r0
 c1cfb00:	e54b300d 	strb	r3, [fp, #-13]

	while(c != '\n') {
 c1cfb04:	ea000008 	b	c1cfb2c <uart0_gets+0x48>
		*s = c;
 c1cfb08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cfb0c:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cfb10:	e5c32000 	strb	r2, [r3]
		s++;
 c1cfb14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cfb18:	e2833001 	add	r3, r3, #1
 c1cfb1c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		c = uart0_getchar();
 c1cfb20:	ebffff5b 	bl	c1cf894 <uart0_getchar>
 c1cfb24:	e1a03000 	mov	r3, r0
 c1cfb28:	e54b300d 	strb	r3, [fp, #-13]

void uart0_gets( char *s )
{
	char c = uart0_getchar();

	while(c != '\n') {
 c1cfb2c:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cfb30:	e353000a 	cmp	r3, #10
 c1cfb34:	1afffff3 	bne	c1cfb08 <uart0_gets+0x24>
		*s = c;
		s++;
		c = uart0_getchar();
	}

	*s = '\0';
 c1cfb38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1cfb3c:	e3a02000 	mov	r2, #0
 c1cfb40:	e5c32000 	strb	r2, [r3]
}
 c1cfb44:	e24bd00c 	sub	sp, fp, #12
 c1cfb48:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfb4c:	e12fff1e 	bx	lr

0c1cfb50 <uart0_getint>:

int32 uart0_getint( void )
{
 c1cfb50:	e1a0c00d 	mov	ip, sp
 c1cfb54:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfb58:	e24cb004 	sub	fp, ip, #4
 c1cfb5c:	e24dd018 	sub	sp, sp, #24
	char s[11 + 1];
	char* p = s;
 c1cfb60:	e24b3020 	sub	r3, fp, #32
 c1cfb64:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c1cfb68:	e3a03000 	mov	r3, #0
 c1cfb6c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c1cfb70:	e24b3020 	sub	r3, fp, #32
 c1cfb74:	e1a00003 	mov	r0, r3
 c1cfb78:	ebffffd9 	bl	c1cfae4 <uart0_gets>

	if(s[0] == '\0')
 c1cfb7c:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c1cfb80:	e3530000 	cmp	r3, #0
 c1cfb84:	1a000001 	bne	c1cfb90 <uart0_getint+0x40>
		return 0;
 c1cfb88:	e3a03000 	mov	r3, #0
 c1cfb8c:	ea000021 	b	c1cfc18 <uart0_getint+0xc8>

	if(s[0]=='-')
 c1cfb90:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c1cfb94:	e353002d 	cmp	r3, #45	; 0x2d
 c1cfb98:	1a000012 	bne	c1cfbe8 <uart0_getint+0x98>
		p++;
 c1cfb9c:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfba0:	e2833001 	add	r3, r3, #1
 c1cfba4:	e50b3010 	str	r3, [fp, #-16]

	while(*p) {
 c1cfba8:	ea00000f 	b	c1cfbec <uart0_getint+0x9c>
		res = 10 * res + (*p - '0');
 c1cfbac:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cfbb0:	e1a03002 	mov	r3, r2
 c1cfbb4:	e1a03103 	lsl	r3, r3, #2
 c1cfbb8:	e0833002 	add	r3, r3, r2
 c1cfbbc:	e1a03083 	lsl	r3, r3, #1
 c1cfbc0:	e1a02003 	mov	r2, r3
 c1cfbc4:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfbc8:	e5d33000 	ldrb	r3, [r3]
 c1cfbcc:	e2433030 	sub	r3, r3, #48	; 0x30
 c1cfbd0:	e0823003 	add	r3, r2, r3
 c1cfbd4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c1cfbd8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfbdc:	e2833001 	add	r3, r3, #1
 c1cfbe0:	e50b3010 	str	r3, [fp, #-16]
 c1cfbe4:	ea000000 	b	c1cfbec <uart0_getint+0x9c>
		return 0;

	if(s[0]=='-')
		p++;

	while(*p) {
 c1cfbe8:	e1a00000 	nop			; (mov r0, r0)
 c1cfbec:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfbf0:	e5d33000 	ldrb	r3, [r3]
 c1cfbf4:	e3530000 	cmp	r3, #0
 c1cfbf8:	1affffeb 	bne	c1cfbac <uart0_getint+0x5c>
		res = 10 * res + (*p - '0');
		p++;
	}

	if(s[0] == '-')
 c1cfbfc:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c1cfc00:	e353002d 	cmp	r3, #45	; 0x2d
 c1cfc04:	1a000002 	bne	c1cfc14 <uart0_getint+0xc4>
		res *= -1;
 c1cfc08:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cfc0c:	e2633000 	rsb	r3, r3, #0
 c1cfc10:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	return res;
 c1cfc14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c1cfc18:	e1a00003 	mov	r0, r3
 c1cfc1c:	e24bd00c 	sub	sp, fp, #12
 c1cfc20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfc24:	e12fff1e 	bx	lr

0c1cfc28 <uart0_gethex>:

uint32 uart0_gethex( void )
{
 c1cfc28:	e1a0c00d 	mov	ip, sp
 c1cfc2c:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfc30:	e24cb004 	sub	fp, ip, #4
 c1cfc34:	e24dd018 	sub	sp, sp, #24
	char s[8 + 1];
	char* p = s;
 c1cfc38:	e24b3020 	sub	r3, fp, #32
 c1cfc3c:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c1cfc40:	e3a03000 	mov	r3, #0
 c1cfc44:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c1cfc48:	e24b3020 	sub	r3, fp, #32
 c1cfc4c:	e1a00003 	mov	r0, r3
 c1cfc50:	ebffffa3 	bl	c1cfae4 <uart0_gets>

	while(*p) {
 c1cfc54:	ea00002b 	b	c1cfd08 <uart0_gethex+0xe0>
		res = res << 4;
 c1cfc58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1cfc5c:	e1a03203 	lsl	r3, r3, #4
 c1cfc60:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		char c = *p;
 c1cfc64:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfc68:	e5d33000 	ldrb	r3, [r3]
 c1cfc6c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
		if(c >= '0' && c <= '9')
 c1cfc70:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfc74:	e353002f 	cmp	r3, #47	; 0x2f
 c1cfc78:	9a000008 	bls	c1cfca0 <uart0_gethex+0x78>
 c1cfc7c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfc80:	e3530039 	cmp	r3, #57	; 0x39
 c1cfc84:	8a000005 	bhi	c1cfca0 <uart0_gethex+0x78>
			res += c - '0';
 c1cfc88:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfc8c:	e2433030 	sub	r3, r3, #48	; 0x30
 c1cfc90:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cfc94:	e0823003 	add	r3, r2, r3
 c1cfc98:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cfc9c:	ea000016 	b	c1cfcfc <uart0_gethex+0xd4>
		else if(c >= 'a' && c <= 'f')
 c1cfca0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfca4:	e3530060 	cmp	r3, #96	; 0x60
 c1cfca8:	9a000008 	bls	c1cfcd0 <uart0_gethex+0xa8>
 c1cfcac:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfcb0:	e3530066 	cmp	r3, #102	; 0x66
 c1cfcb4:	8a000005 	bhi	c1cfcd0 <uart0_gethex+0xa8>
			res += 10 + c - 'a';
 c1cfcb8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfcbc:	e2433057 	sub	r3, r3, #87	; 0x57
 c1cfcc0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cfcc4:	e0823003 	add	r3, r2, r3
 c1cfcc8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c1cfccc:	ea00000a 	b	c1cfcfc <uart0_gethex+0xd4>
		else if(c >= 'A' && c <= 'F')
 c1cfcd0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfcd4:	e3530040 	cmp	r3, #64	; 0x40
 c1cfcd8:	9a000007 	bls	c1cfcfc <uart0_gethex+0xd4>
 c1cfcdc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfce0:	e3530046 	cmp	r3, #70	; 0x46
 c1cfce4:	8a000004 	bhi	c1cfcfc <uart0_gethex+0xd4>
			res += 10 + c - 'A';
 c1cfce8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c1cfcec:	e2433037 	sub	r3, r3, #55	; 0x37
 c1cfcf0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c1cfcf4:	e0823003 	add	r3, r2, r3
 c1cfcf8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c1cfcfc:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd00:	e2833001 	add	r3, r3, #1
 c1cfd04:	e50b3010 	str	r3, [fp, #-16]
	char* p = s;
	int32 res = 0;

	uart0_gets(s);

	while(*p) {
 c1cfd08:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd0c:	e5d33000 	ldrb	r3, [r3]
 c1cfd10:	e3530000 	cmp	r3, #0
 c1cfd14:	1affffcf 	bne	c1cfc58 <uart0_gethex+0x30>
		else if(c >= 'A' && c <= 'F')
			res += 10 + c - 'A';
		p++;
	}

	return res;
 c1cfd18:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c1cfd1c:	e1a00003 	mov	r0, r3
 c1cfd20:	e24bd00c 	sub	sp, fp, #12
 c1cfd24:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfd28:	e12fff1e 	bx	lr

0c1cfd2c <uart0_put_rtc_time>:

void uart0_put_rtc_time( rtc_time_t* rtc_time )
{
 c1cfd2c:	e1a0c00d 	mov	ip, sp
 c1cfd30:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfd34:	e24cb004 	sub	fp, ip, #4
 c1cfd38:	e24dd008 	sub	sp, sp, #8
 c1cfd3c:	e50b0010 	str	r0, [fp, #-16]
	uart0_putint( rtc_time->mday );
 c1cfd40:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd44:	e5d33003 	ldrb	r3, [r3, #3]
 c1cfd48:	e1a00003 	mov	r0, r3
 c1cfd4c:	ebfffef6 	bl	c1cf92c <uart0_putint>
	uart0_putchar( '/' );
 c1cfd50:	e3a0002f 	mov	r0, #47	; 0x2f
 c1cfd54:	ebfffeba 	bl	c1cf844 <uart0_putchar>
	uart0_putint( rtc_time->mon );
 c1cfd58:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd5c:	e5d33005 	ldrb	r3, [r3, #5]
 c1cfd60:	e1a00003 	mov	r0, r3
 c1cfd64:	ebfffef0 	bl	c1cf92c <uart0_putint>
	uart0_putchar( '/' );
 c1cfd68:	e3a0002f 	mov	r0, #47	; 0x2f
 c1cfd6c:	ebfffeb4 	bl	c1cf844 <uart0_putchar>
	uart0_putint( rtc_time->year );
 c1cfd70:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd74:	e5d33006 	ldrb	r3, [r3, #6]
 c1cfd78:	e1a00003 	mov	r0, r3
 c1cfd7c:	ebfffeea 	bl	c1cf92c <uart0_putint>
	uart0_putchar( ' ' );
 c1cfd80:	e3a00020 	mov	r0, #32
 c1cfd84:	ebfffeae 	bl	c1cf844 <uart0_putchar>
	uart0_putint( rtc_time->hour );
 c1cfd88:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfd8c:	e5d33002 	ldrb	r3, [r3, #2]
 c1cfd90:	e1a00003 	mov	r0, r3
 c1cfd94:	ebfffee4 	bl	c1cf92c <uart0_putint>
	uart0_putchar( ':' );
 c1cfd98:	e3a0003a 	mov	r0, #58	; 0x3a
 c1cfd9c:	ebfffea8 	bl	c1cf844 <uart0_putchar>
	uart0_putint( rtc_time->min );
 c1cfda0:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfda4:	e5d33001 	ldrb	r3, [r3, #1]
 c1cfda8:	e1a00003 	mov	r0, r3
 c1cfdac:	ebfffede 	bl	c1cf92c <uart0_putint>
	uart0_putchar( ':' );
 c1cfdb0:	e3a0003a 	mov	r0, #58	; 0x3a
 c1cfdb4:	ebfffea2 	bl	c1cf844 <uart0_putchar>
	uart0_putint( rtc_time->sec );
 c1cfdb8:	e51b3010 	ldr	r3, [fp, #-16]
 c1cfdbc:	e5d33000 	ldrb	r3, [r3]
 c1cfdc0:	e1a00003 	mov	r0, r3
 c1cfdc4:	ebfffed8 	bl	c1cf92c <uart0_putint>
}
 c1cfdc8:	e24bd00c 	sub	sp, fp, #12
 c1cfdcc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfdd0:	e12fff1e 	bx	lr

0c1cfdd4 <uda1341ts_init>:

static uint8 volume;
static uint8 state;

void uda1341ts_init( void )
{
 c1cfdd4:	e1a0c00d 	mov	ip, sp
 c1cfdd8:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfddc:	e24cb004 	sub	fp, ip, #4
    L3_init();
 c1cfde0:	ebffea4f 	bl	c1ca724 <L3_init>

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c1cfde4:	e3a00016 	mov	r0, #22
 c1cfde8:	e3a01000 	mov	r1, #0
 c1cfdec:	ebffea74 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( (1 << 6) | (2 << 4), L3_DATA_MODE );
 c1cfdf0:	e3a00060 	mov	r0, #96	; 0x60
 c1cfdf4:	e3a01001 	mov	r1, #1
 c1cfdf8:	ebffea71 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( (2 << 4), L3_DATA_MODE );
 c1cfdfc:	e3a00020 	mov	r0, #32
 c1cfe00:	e3a01001 	mov	r1, #1
 c1cfe04:	ebffea6e 	bl	c1ca7c4 <L3_putByte>

    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE  );
 c1cfe08:	e3a00014 	mov	r0, #20
 c1cfe0c:	e3a01000 	mov	r1, #0
 c1cfe10:	ebffea6b 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( EA | (2), L3_DATA_MODE );
 c1cfe14:	e3a000c2 	mov	r0, #194	; 0xc2
 c1cfe18:	e3a01001 	mov	r1, #1
 c1cfe1c:	ebffea68 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( ED | 1, L3_DATA_MODE );
 c1cfe20:	e3a000e1 	mov	r0, #225	; 0xe1
 c1cfe24:	e3a01001 	mov	r1, #1
 c1cfe28:	ebffea65 	bl	c1ca7c4 <L3_putByte>

    uda1341ts_setvol( VOL_MAX );
 c1cfe2c:	e3a0003f 	mov	r0, #63	; 0x3f
 c1cfe30:	eb000066 	bl	c1cffd0 <uda1341ts_setvol>

    uda1341ts_on( UDA_DAC );
 c1cfe34:	e3a00001 	mov	r0, #1
 c1cfe38:	eb00001b 	bl	c1cfeac <uda1341ts_on>
    uda1341ts_on( UDA_ADC );
 c1cfe3c:	e3a00002 	mov	r0, #2
 c1cfe40:	eb000019 	bl	c1cfeac <uda1341ts_on>
}
 c1cfe44:	e24bd00c 	sub	sp, fp, #12
 c1cfe48:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfe4c:	e12fff1e 	bx	lr

0c1cfe50 <uda1341ts_mute>:

void uda1341ts_mute( uint8 on )
{
 c1cfe50:	e1a0c00d 	mov	ip, sp
 c1cfe54:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfe58:	e24cb004 	sub	fp, ip, #4
 c1cfe5c:	e24dd008 	sub	sp, sp, #8
 c1cfe60:	e1a03000 	mov	r3, r0
 c1cfe64:	e54b300d 	strb	r3, [fp, #-13]
	//DATA0[7:6] = 2 y DATA0[2]=1/0 (0 no mute, 1 mute)
    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE );
 c1cfe68:	e3a00014 	mov	r0, #20
 c1cfe6c:	e3a01000 	mov	r1, #0
 c1cfe70:	ebffea53 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( (0x2 << 6) | ((on & 1) << 2) , L3_DATA_MODE);
 c1cfe74:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cfe78:	e2033001 	and	r3, r3, #1
 c1cfe7c:	e1a03103 	lsl	r3, r3, #2
 c1cfe80:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cfe84:	e1e03c83 	mvn	r3, r3, lsl #25
 c1cfe88:	e1e03ca3 	mvn	r3, r3, lsr #25
 c1cfe8c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cfe90:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cfe94:	e1a00003 	mov	r0, r3
 c1cfe98:	e3a01001 	mov	r1, #1
 c1cfe9c:	ebffea48 	bl	c1ca7c4 <L3_putByte>
}
 c1cfea0:	e24bd00c 	sub	sp, fp, #12
 c1cfea4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cfea8:	e12fff1e 	bx	lr

0c1cfeac <uda1341ts_on>:

void uda1341ts_on( enum UDA_converter_t converter )
{
 c1cfeac:	e1a0c00d 	mov	ip, sp
 c1cfeb0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cfeb4:	e24cb004 	sub	fp, ip, #4
 c1cfeb8:	e24dd008 	sub	sp, sp, #8
 c1cfebc:	e1a03000 	mov	r3, r0
 c1cfec0:	e54b300d 	strb	r3, [fp, #-13]
    state |= converter;
 c1cfec4:	e59f304c 	ldr	r3, [pc, #76]	; c1cff18 <uda1341ts_on+0x6c>
 c1cfec8:	e5d32000 	ldrb	r2, [r3]
 c1cfecc:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cfed0:	e1823003 	orr	r3, r2, r3
 c1cfed4:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cfed8:	e59f3038 	ldr	r3, [pc, #56]	; c1cff18 <uda1341ts_on+0x6c>
 c1cfedc:	e5c32000 	strb	r2, [r3]

    //STATUS[6]=1 y STATUS[5]=1 6dB de ganancia
    //STATUS[4]=0 y STATUS[3]=0 non inverting ADC/DAC polarity
    //STATUS[2]=0 no double speed

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c1cfee0:	e3a00016 	mov	r0, #22
 c1cfee4:	e3a01000 	mov	r1, #0
 c1cfee8:	ebffea35 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( (0x1 << 7) | (0b11000 << 2) | state , L3_DATA_MODE);
 c1cfeec:	e59f3024 	ldr	r3, [pc, #36]	; c1cff18 <uda1341ts_on+0x6c>
 c1cfef0:	e5d33000 	ldrb	r3, [r3]
 c1cfef4:	e1e03d83 	mvn	r3, r3, lsl #27
 c1cfef8:	e1e03da3 	mvn	r3, r3, lsr #27
 c1cfefc:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cff00:	e1a00003 	mov	r0, r3
 c1cff04:	e3a01001 	mov	r1, #1
 c1cff08:	ebffea2d 	bl	c1ca7c4 <L3_putByte>
}
 c1cff0c:	e24bd00c 	sub	sp, fp, #12
 c1cff10:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cff14:	e12fff1e 	bx	lr
 c1cff18:	0c10b90f 	.word	0x0c10b90f

0c1cff1c <uda1341ts_off>:

void uda1341ts_off( enum UDA_converter_t converter )
{
 c1cff1c:	e1a0c00d 	mov	ip, sp
 c1cff20:	e92dd800 	push	{fp, ip, lr, pc}
 c1cff24:	e24cb004 	sub	fp, ip, #4
 c1cff28:	e24dd008 	sub	sp, sp, #8
 c1cff2c:	e1a03000 	mov	r3, r0
 c1cff30:	e54b300d 	strb	r3, [fp, #-13]
    state &= ~converter;
 c1cff34:	e55b300d 	ldrb	r3, [fp, #-13]
 c1cff38:	e1e03003 	mvn	r3, r3
 c1cff3c:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cff40:	e59f3050 	ldr	r3, [pc, #80]	; c1cff98 <uda1341ts_off+0x7c>
 c1cff44:	e5d33000 	ldrb	r3, [r3]
 c1cff48:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cff4c:	e0023003 	and	r3, r2, r3
 c1cff50:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cff54:	e20320ff 	and	r2, r3, #255	; 0xff
 c1cff58:	e59f3038 	ldr	r3, [pc, #56]	; c1cff98 <uda1341ts_off+0x7c>
 c1cff5c:	e5c32000 	strb	r2, [r3]
    //STATUS[7]=1 y STATUS[1:0]=X valor según corresponda
    //STATUS[6]=1 y STATUS[5]=1 6dB de ganancia
    //STATUS[4]=0 y STATUS[3]=0 non inverting ADC/DAC polarity
    //STATUS[2]=0 no double speed

    L3_putByte( (ADDRESS << 2) | STATUS, L3_ADDR_MODE );
 c1cff60:	e3a00016 	mov	r0, #22
 c1cff64:	e3a01000 	mov	r1, #0
 c1cff68:	ebffea15 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( (0x1 << 7) | (0b11000 << 2) | state , L3_DATA_MODE);
 c1cff6c:	e59f3024 	ldr	r3, [pc, #36]	; c1cff98 <uda1341ts_off+0x7c>
 c1cff70:	e5d33000 	ldrb	r3, [r3]
 c1cff74:	e1e03d83 	mvn	r3, r3, lsl #27
 c1cff78:	e1e03da3 	mvn	r3, r3, lsr #27
 c1cff7c:	e20330ff 	and	r3, r3, #255	; 0xff
 c1cff80:	e1a00003 	mov	r0, r3
 c1cff84:	e3a01001 	mov	r1, #1
 c1cff88:	ebffea0d 	bl	c1ca7c4 <L3_putByte>
}
 c1cff8c:	e24bd00c 	sub	sp, fp, #12
 c1cff90:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cff94:	e12fff1e 	bx	lr
 c1cff98:	0c10b90f 	.word	0x0c10b90f

0c1cff9c <uda1341ts_status>:

uint8 uda1341ts_status( enum UDA_converter_t converter )
{
 c1cff9c:	e1a0c00d 	mov	ip, sp
 c1cffa0:	e92dd800 	push	{fp, ip, lr, pc}
 c1cffa4:	e24cb004 	sub	fp, ip, #4
 c1cffa8:	e24dd008 	sub	sp, sp, #8
 c1cffac:	e1a03000 	mov	r3, r0
 c1cffb0:	e54b300d 	strb	r3, [fp, #-13]
    return state;
 c1cffb4:	e59f3010 	ldr	r3, [pc, #16]	; c1cffcc <uda1341ts_status+0x30>
 c1cffb8:	e5d33000 	ldrb	r3, [r3]
}
 c1cffbc:	e1a00003 	mov	r0, r3
 c1cffc0:	e24bd00c 	sub	sp, fp, #12
 c1cffc4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1cffc8:	e12fff1e 	bx	lr
 c1cffcc:	0c10b90f 	.word	0x0c10b90f

0c1cffd0 <uda1341ts_setvol>:

void uda1341ts_setvol( uint8 vol )
{
 c1cffd0:	e1a0c00d 	mov	ip, sp
 c1cffd4:	e92dd800 	push	{fp, ip, lr, pc}
 c1cffd8:	e24cb004 	sub	fp, ip, #4
 c1cffdc:	e24dd008 	sub	sp, sp, #8
 c1cffe0:	e1a03000 	mov	r3, r0
 c1cffe4:	e54b300d 	strb	r3, [fp, #-13]
	volume = vol;
 c1cffe8:	e59f303c 	ldr	r3, [pc, #60]	; c1d002c <uda1341ts_setvol+0x5c>
 c1cffec:	e55b200d 	ldrb	r2, [fp, #-13]
 c1cfff0:	e5c32000 	strb	r2, [r3]

	//DATA0[7:6] = 0 y DATA0[5:0]=atenuación (a mayor atenuación, menor volumen)
    L3_putByte( (ADDRESS << 2) | DATA0, L3_ADDR_MODE );
 c1cfff4:	e3a00014 	mov	r0, #20
 c1cfff8:	e3a01000 	mov	r1, #0
 c1cfffc:	ebffe9f0 	bl	c1ca7c4 <L3_putByte>
    L3_putByte( 0x3f - (vol & 0x3f) , L3_DATA_MODE );
 c1d0000:	e55b300d 	ldrb	r3, [fp, #-13]
 c1d0004:	e1e03003 	mvn	r3, r3
 c1d0008:	e20330ff 	and	r3, r3, #255	; 0xff
 c1d000c:	e203303f 	and	r3, r3, #63	; 0x3f
 c1d0010:	e20330ff 	and	r3, r3, #255	; 0xff
 c1d0014:	e1a00003 	mov	r0, r3
 c1d0018:	e3a01001 	mov	r1, #1
 c1d001c:	ebffe9e8 	bl	c1ca7c4 <L3_putByte>
}
 c1d0020:	e24bd00c 	sub	sp, fp, #12
 c1d0024:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1d0028:	e12fff1e 	bx	lr
 c1d002c:	0c10b90e 	.word	0x0c10b90e

0c1d0030 <uda1341ts_getvol>:

uint8 uda1341ts_getvol( void )
{
 c1d0030:	e1a0c00d 	mov	ip, sp
 c1d0034:	e92dd800 	push	{fp, ip, lr, pc}
 c1d0038:	e24cb004 	sub	fp, ip, #4
    return volume;
 c1d003c:	e59f3010 	ldr	r3, [pc, #16]	; c1d0054 <uda1341ts_getvol+0x24>
 c1d0040:	e5d33000 	ldrb	r3, [r3]
}
 c1d0044:	e1a00003 	mov	r0, r3
 c1d0048:	e24bd00c 	sub	sp, fp, #12
 c1d004c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1d0050:	e12fff1e 	bx	lr
 c1d0054:	0c10b90e 	.word	0x0c10b90e

0c1d0058 <Delay>:

void Delay(int time)
// time=0: adjust the Delay function by WatchDog timer.//
// time>0: the number of loop time//
// 100us resolution.//
{
 c1d0058:	e1a0c00d 	mov	ip, sp
 c1d005c:	e92dd800 	push	{fp, ip, lr, pc}
 c1d0060:	e24cb004 	sub	fp, ip, #4
 c1d0064:	e24dd010 	sub	sp, sp, #16
 c1d0068:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	int i,adjust=0;
 c1d006c:	e3a03000 	mov	r3, #0
 c1d0070:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if(time==0)
 c1d0074:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1d0078:	e3530000 	cmp	r3, #0
 c1d007c:	1a000021 	bne	c1d0108 <Delay+0xb0>
	{
		time=200;
 c1d0080:	e3a030c8 	mov	r3, #200	; 0xc8
 c1d0084:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		adjust=1;
 c1d0088:	e3a03001 	mov	r3, #1
 c1d008c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		delayLoopCount=400;
 c1d0090:	e59f30d8 	ldr	r3, [pc, #216]	; c1d0170 <Delay+0x118>
 c1d0094:	e3a02e19 	mov	r2, #400	; 0x190
 c1d0098:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
 c1d009c:	e59f30d0 	ldr	r3, [pc, #208]	; c1d0174 <Delay+0x11c>
 c1d00a0:	e59f20d0 	ldr	r2, [pc, #208]	; c1d0178 <Delay+0x120>
 c1d00a4:	e5832000 	str	r2, [r3]
		rWTDAT=0xffff;
 c1d00a8:	e59f30cc 	ldr	r3, [pc, #204]	; c1d017c <Delay+0x124>
 c1d00ac:	e59f20cc 	ldr	r2, [pc, #204]	; c1d0180 <Delay+0x128>
 c1d00b0:	e5832000 	str	r2, [r3]
		rWTCNT=0xffff;
 c1d00b4:	e59f30c8 	ldr	r3, [pc, #200]	; c1d0184 <Delay+0x12c>
 c1d00b8:	e59f20c0 	ldr	r2, [pc, #192]	; c1d0180 <Delay+0x128>
 c1d00bc:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
 c1d00c0:	e59f30ac 	ldr	r3, [pc, #172]	; c1d0174 <Delay+0x11c>
 c1d00c4:	e59f20bc 	ldr	r2, [pc, #188]	; c1d0188 <Delay+0x130>
 c1d00c8:	e5832000 	str	r2, [r3]
	}
	for(;time>0;time--)
 c1d00cc:	ea00000d 	b	c1d0108 <Delay+0xb0>
		for(i=0;i<delayLoopCount;i++);
 c1d00d0:	e3a03000 	mov	r3, #0
 c1d00d4:	e50b3010 	str	r3, [fp, #-16]
 c1d00d8:	ea000002 	b	c1d00e8 <Delay+0x90>
 c1d00dc:	e51b3010 	ldr	r3, [fp, #-16]
 c1d00e0:	e2833001 	add	r3, r3, #1
 c1d00e4:	e50b3010 	str	r3, [fp, #-16]
 c1d00e8:	e59f3080 	ldr	r3, [pc, #128]	; c1d0170 <Delay+0x118>
 c1d00ec:	e5933000 	ldr	r3, [r3]
 c1d00f0:	e51b2010 	ldr	r2, [fp, #-16]
 c1d00f4:	e1520003 	cmp	r2, r3
 c1d00f8:	bafffff7 	blt	c1d00dc <Delay+0x84>
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
		rWTDAT=0xffff;
		rWTCNT=0xffff;
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
	}
	for(;time>0;time--)
 c1d00fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1d0100:	e2433001 	sub	r3, r3, #1
 c1d0104:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c1d0108:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c1d010c:	e3530000 	cmp	r3, #0
 c1d0110:	caffffee 	bgt	c1d00d0 <Delay+0x78>
		for(i=0;i<delayLoopCount;i++);
	if(adjust==1)
 c1d0114:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c1d0118:	e3530001 	cmp	r3, #1
 c1d011c:	1a000010 	bne	c1d0164 <Delay+0x10c>
	{
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);
 c1d0120:	e59f304c 	ldr	r3, [pc, #76]	; c1d0174 <Delay+0x11c>
 c1d0124:	e59f204c 	ldr	r2, [pc, #76]	; c1d0178 <Delay+0x120>
 c1d0128:	e5832000 	str	r2, [r3]
		i=0xffff-rWTCNT;   //  1count/16us?????????//
 c1d012c:	e59f3050 	ldr	r3, [pc, #80]	; c1d0184 <Delay+0x12c>
 c1d0130:	e5933000 	ldr	r3, [r3]
 c1d0134:	e2633cff 	rsb	r3, r3, #65280	; 0xff00
 c1d0138:	e28330ff 	add	r3, r3, #255	; 0xff
 c1d013c:	e50b3010 	str	r3, [fp, #-16]
		delayLoopCount=8000000/(i*64);	//400*100/(i*64/200)   //
 c1d0140:	e51b3010 	ldr	r3, [fp, #-16]
 c1d0144:	e1a03303 	lsl	r3, r3, #6
 c1d0148:	e59f003c 	ldr	r0, [pc, #60]	; c1d018c <Delay+0x134>
 c1d014c:	e1a01003 	mov	r1, r3
 c1d0150:	eb00001a 	bl	c1d01c0 <__aeabi_idiv>
 c1d0154:	e1a03000 	mov	r3, r0
 c1d0158:	e1a02003 	mov	r2, r3
 c1d015c:	e59f300c 	ldr	r3, [pc, #12]	; c1d0170 <Delay+0x118>
 c1d0160:	e5832000 	str	r2, [r3]
	}
}
 c1d0164:	e24bd00c 	sub	sp, fp, #12
 c1d0168:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1d016c:	e12fff1e 	bx	lr
 c1d0170:	0c10014c 	.word	0x0c10014c
 c1d0174:	01d30000 	.word	0x01d30000
 c1d0178:	00003f10 	.word	0x00003f10
 c1d017c:	01d30004 	.word	0x01d30004
 c1d0180:	0000ffff 	.word	0x0000ffff
 c1d0184:	01d30008 	.word	0x01d30008
 c1d0188:	00003f30 	.word	0x00003f30
 c1d018c:	007a1200 	.word	0x007a1200

0c1d0190 <sleep>:

inline void sleep(void)
{
 c1d0190:	e1a0c00d 	mov	ip, sp
 c1d0194:	e92dd800 	push	{fp, ip, lr, pc}
 c1d0198:	e24cb004 	sub	fp, ip, #4
    rCLKCON |= (1 << 2);    // Pone a la CPU en estado IDLE
 c1d019c:	e59f3018 	ldr	r3, [pc, #24]	; c1d01bc <sleep+0x2c>
 c1d01a0:	e59f2014 	ldr	r2, [pc, #20]	; c1d01bc <sleep+0x2c>
 c1d01a4:	e5922000 	ldr	r2, [r2]
 c1d01a8:	e3822004 	orr	r2, r2, #4
 c1d01ac:	e5832000 	str	r2, [r3]
}
 c1d01b0:	e24bd00c 	sub	sp, fp, #12
 c1d01b4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c1d01b8:	e12fff1e 	bx	lr
 c1d01bc:	01d80004 	.word	0x01d80004

0c1d01c0 <__aeabi_idiv>:
 c1d01c0:	e3510000 	cmp	r1, #0
 c1d01c4:	0a000043 	beq	c1d02d8 <.divsi3_skip_div0_test+0x110>

0c1d01c8 <.divsi3_skip_div0_test>:
 c1d01c8:	e020c001 	eor	ip, r0, r1
 c1d01cc:	42611000 	rsbmi	r1, r1, #0
 c1d01d0:	e2512001 	subs	r2, r1, #1
 c1d01d4:	0a000027 	beq	c1d0278 <.divsi3_skip_div0_test+0xb0>
 c1d01d8:	e1b03000 	movs	r3, r0
 c1d01dc:	42603000 	rsbmi	r3, r0, #0
 c1d01e0:	e1530001 	cmp	r3, r1
 c1d01e4:	9a000026 	bls	c1d0284 <.divsi3_skip_div0_test+0xbc>
 c1d01e8:	e1110002 	tst	r1, r2
 c1d01ec:	0a000028 	beq	c1d0294 <.divsi3_skip_div0_test+0xcc>
 c1d01f0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
 c1d01f4:	01a01181 	lsleq	r1, r1, #3
 c1d01f8:	03a02008 	moveq	r2, #8
 c1d01fc:	13a02001 	movne	r2, #1
 c1d0200:	e3510201 	cmp	r1, #268435456	; 0x10000000
 c1d0204:	31510003 	cmpcc	r1, r3
 c1d0208:	31a01201 	lslcc	r1, r1, #4
 c1d020c:	31a02202 	lslcc	r2, r2, #4
 c1d0210:	3afffffa 	bcc	c1d0200 <.divsi3_skip_div0_test+0x38>
 c1d0214:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
 c1d0218:	31510003 	cmpcc	r1, r3
 c1d021c:	31a01081 	lslcc	r1, r1, #1
 c1d0220:	31a02082 	lslcc	r2, r2, #1
 c1d0224:	3afffffa 	bcc	c1d0214 <.divsi3_skip_div0_test+0x4c>
 c1d0228:	e3a00000 	mov	r0, #0
 c1d022c:	e1530001 	cmp	r3, r1
 c1d0230:	20433001 	subcs	r3, r3, r1
 c1d0234:	21800002 	orrcs	r0, r0, r2
 c1d0238:	e15300a1 	cmp	r3, r1, lsr #1
 c1d023c:	204330a1 	subcs	r3, r3, r1, lsr #1
 c1d0240:	218000a2 	orrcs	r0, r0, r2, lsr #1
 c1d0244:	e1530121 	cmp	r3, r1, lsr #2
 c1d0248:	20433121 	subcs	r3, r3, r1, lsr #2
 c1d024c:	21800122 	orrcs	r0, r0, r2, lsr #2
 c1d0250:	e15301a1 	cmp	r3, r1, lsr #3
 c1d0254:	204331a1 	subcs	r3, r3, r1, lsr #3
 c1d0258:	218001a2 	orrcs	r0, r0, r2, lsr #3
 c1d025c:	e3530000 	cmp	r3, #0
 c1d0260:	11b02222 	lsrsne	r2, r2, #4
 c1d0264:	11a01221 	lsrne	r1, r1, #4
 c1d0268:	1affffef 	bne	c1d022c <.divsi3_skip_div0_test+0x64>
 c1d026c:	e35c0000 	cmp	ip, #0
 c1d0270:	42600000 	rsbmi	r0, r0, #0
 c1d0274:	e12fff1e 	bx	lr
 c1d0278:	e13c0000 	teq	ip, r0
 c1d027c:	42600000 	rsbmi	r0, r0, #0
 c1d0280:	e12fff1e 	bx	lr
 c1d0284:	33a00000 	movcc	r0, #0
 c1d0288:	01a00fcc 	asreq	r0, ip, #31
 c1d028c:	03800001 	orreq	r0, r0, #1
 c1d0290:	e12fff1e 	bx	lr
 c1d0294:	e3510801 	cmp	r1, #65536	; 0x10000
 c1d0298:	21a01821 	lsrcs	r1, r1, #16
 c1d029c:	23a02010 	movcs	r2, #16
 c1d02a0:	33a02000 	movcc	r2, #0
 c1d02a4:	e3510c01 	cmp	r1, #256	; 0x100
 c1d02a8:	21a01421 	lsrcs	r1, r1, #8
 c1d02ac:	22822008 	addcs	r2, r2, #8
 c1d02b0:	e3510010 	cmp	r1, #16
 c1d02b4:	21a01221 	lsrcs	r1, r1, #4
 c1d02b8:	22822004 	addcs	r2, r2, #4
 c1d02bc:	e3510004 	cmp	r1, #4
 c1d02c0:	82822003 	addhi	r2, r2, #3
 c1d02c4:	908220a1 	addls	r2, r2, r1, lsr #1
 c1d02c8:	e35c0000 	cmp	ip, #0
 c1d02cc:	e1a00233 	lsr	r0, r3, r2
 c1d02d0:	42600000 	rsbmi	r0, r0, #0
 c1d02d4:	e12fff1e 	bx	lr
 c1d02d8:	e3500000 	cmp	r0, #0
 c1d02dc:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
 c1d02e0:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
 c1d02e4:	ea000007 	b	c1d0308 <__aeabi_idiv0>

0c1d02e8 <__aeabi_idivmod>:
 c1d02e8:	e3510000 	cmp	r1, #0
 c1d02ec:	0afffff9 	beq	c1d02d8 <.divsi3_skip_div0_test+0x110>
 c1d02f0:	e92d4003 	push	{r0, r1, lr}
 c1d02f4:	ebffffb3 	bl	c1d01c8 <.divsi3_skip_div0_test>
 c1d02f8:	e8bd4006 	pop	{r1, r2, lr}
 c1d02fc:	e0030092 	mul	r3, r2, r0
 c1d0300:	e0411003 	sub	r1, r1, r3
 c1d0304:	e12fff1e 	bx	lr

0c1d0308 <__aeabi_idiv0>:
 c1d0308:	e12fff1e 	bx	lr
