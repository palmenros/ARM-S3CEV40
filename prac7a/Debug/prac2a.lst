
prac2a.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000013d4  0c100000  0c100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .bss          0000961c  0c1013d4  0c1013d4  000093d4  2**2
                  ALLOC
  2 .text         00004b04  0c10a9f0  0c10a9f0  0000a9f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .debug_abbrev 00000b3e  00000000  00000000  0000f4f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000020ed  00000000  00000000  00010032  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000fe1  00000000  00000000  0001211f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 00048906  00000000  00000000  00013100  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000fa4  00000000  00000000  0005ba06  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000006b2  00000000  00000000  0005c9aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubtypes 0000034c  00000000  00000000  0005d05c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000001e0  00000000  00000000  0005d3a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000008ab  00000000  00000000  0005d588  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002a  00000000  00000000  0005de33  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000030  00000000  00000000  0005de5d  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000cb8  00000000  00000000  0005de90  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c10a9f0 <D8Led_init>:
	 							 DIGIT_4, DIGIT_5, DIGIT_6, DIGIT_7, 
								 DIGIT_8, DIGIT_9, DIGIT_A, DIGIT_B,
								 DIGIT_C, DIGIT_D, DIGIT_E, DIGIT_F };
			  					  
void D8Led_init(void)
{
 c10a9f0:	e1a0c00d 	mov	ip, sp
 c10a9f4:	e92dd800 	push	{fp, ip, lr, pc}
 c10a9f8:	e24cb004 	sub	fp, ip, #4
    LED8ADDR = ~0 ;
 c10a9fc:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c10aa00:	e3e02000 	mvn	r2, #0
 c10aa04:	e5c32000 	strb	r2, [r3]
}
 c10aa08:	e24bd00c 	sub	sp, fp, #12
 c10aa0c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10aa10:	e12fff1e 	bx	lr

0c10aa14 <D8Led_segment>:

void D8Led_segment(int value)
{
 c10aa14:	e1a0c00d 	mov	ip, sp
 c10aa18:	e92dd800 	push	{fp, ip, lr, pc}
 c10aa1c:	e24cb004 	sub	fp, ip, #4
 c10aa20:	e24dd008 	sub	sp, sp, #8
 c10aa24:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 8) )
 c10aa28:	e51b3010 	ldr	r3, [fp, #-16]
 c10aa2c:	e3530000 	cmp	r3, #0
 c10aa30:	ba00000a 	blt	c10aa60 <D8Led_segment+0x4c>
 c10aa34:	e51b3010 	ldr	r3, [fp, #-16]
 c10aa38:	e3530007 	cmp	r3, #7
 c10aa3c:	ca000007 	bgt	c10aa60 <D8Led_segment+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el segmento que est· en la posiciÛn
		// value del array Segmentes. Hay que tener en cuente que el display
		// usa lÛgica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Segments[value];
 c10aa40:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c10aa44:	e59f2020 	ldr	r2, [pc, #32]	; c10aa6c <D8Led_segment+0x58>
 c10aa48:	e51b1010 	ldr	r1, [fp, #-16]
 c10aa4c:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c10aa50:	e20220ff 	and	r2, r2, #255	; 0xff
 c10aa54:	e1e02002 	mvn	r2, r2
 c10aa58:	e20220ff 	and	r2, r2, #255	; 0xff
 c10aa5c:	e5c32000 	strb	r2, [r3]
}
 c10aa60:	e24bd00c 	sub	sp, fp, #12
 c10aa64:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10aa68:	e12fff1e 	bx	lr
 c10aa6c:	0c100000 	.word	0x0c100000

0c10aa70 <D8Led_digit>:

void D8Led_digit(int value)
{
 c10aa70:	e1a0c00d 	mov	ip, sp
 c10aa74:	e92dd800 	push	{fp, ip, lr, pc}
 c10aa78:	e24cb004 	sub	fp, ip, #4
 c10aa7c:	e24dd008 	sub	sp, sp, #8
 c10aa80:	e50b0010 	str	r0, [fp, #-16]
	if( (value >= 0) && (value < 16) )
 c10aa84:	e51b3010 	ldr	r3, [fp, #-16]
 c10aa88:	e3530000 	cmp	r3, #0
 c10aa8c:	ba00000a 	blt	c10aabc <D8Led_digit+0x4c>
 c10aa90:	e51b3010 	ldr	r3, [fp, #-16]
 c10aa94:	e353000f 	cmp	r3, #15
 c10aa98:	ca000007 	bgt	c10aabc <D8Led_digit+0x4c>
		// COMPLETAR: debemos escribir en el display (LED8ADDR) el valor
		// correcto para que se ilumine el dÌgito que est· en la posiciÛn
		// value del array Digits. Hay que tener en cuente que el display
		// usa lÛgica invertida (0 enciende, 1 apaga).
		LED8ADDR = ~Digits[value];
 c10aa9c:	e3a03785 	mov	r3, #34865152	; 0x2140000
 c10aaa0:	e59f2020 	ldr	r2, [pc, #32]	; c10aac8 <D8Led_digit+0x58>
 c10aaa4:	e51b1010 	ldr	r1, [fp, #-16]
 c10aaa8:	e7922101 	ldr	r2, [r2, r1, lsl #2]
 c10aaac:	e20220ff 	and	r2, r2, #255	; 0xff
 c10aab0:	e1e02002 	mvn	r2, r2
 c10aab4:	e20220ff 	and	r2, r2, #255	; 0xff
 c10aab8:	e5c32000 	strb	r2, [r3]
}
 c10aabc:	e24bd00c 	sub	sp, fp, #12
 c10aac0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10aac4:	e12fff1e 	bx	lr
 c10aac8:	0c100020 	.word	0x0c100020

0c10aacc <at24c04_clear>:

#define READ  (1)
#define WRITE (0)

void at24c04_clear( void )
{
 c10aacc:	e1a0c00d 	mov	ip, sp
 c10aad0:	e92dd800 	push	{fp, ip, lr, pc}
 c10aad4:	e24cb004 	sub	fp, ip, #4
 c10aad8:	e24dd010 	sub	sp, sp, #16
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
 c10aadc:	e3a03000 	mov	r3, #0
 c10aae0:	e50b3010 	str	r3, [fp, #-16]
 c10aae4:	e3a03000 	mov	r3, #0
 c10aae8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c10aaec:	e3a03000 	mov	r3, #0
 c10aaf0:	e50b3010 	str	r3, [fp, #-16]
 c10aaf4:	ea000025 	b	c10ab90 <at24c04_clear+0xc4>
		//Store page
		int addr = page_count * 16;
 c10aaf8:	e51b3010 	ldr	r3, [fp, #-16]
 c10aafc:	e1a03203 	lsl	r3, r3, #4
 c10ab00:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		bit = (addr & 0x100) >> 8;
 c10ab04:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ab08:	e2033c01 	and	r3, r3, #256	; 0x100
 c10ab0c:	e1a03443 	asr	r3, r3, #8
 c10ab10:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

		//Se env√≠a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits m√°s significativos de la direcci√≥n del dispositivo IIC (101000)
		//-el bit 8 de la direcci√≥n del dato
		//-un 0 para indicar la operaci√≥n de escritura
		iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c10ab14:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10ab18:	e1a03083 	lsl	r3, r3, #1
 c10ab1c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ab20:	e1e03003 	mvn	r3, r3
 c10ab24:	e203305f 	and	r3, r3, #95	; 0x5f
 c10ab28:	e1e03003 	mvn	r3, r3
 c10ab2c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ab30:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ab34:	e3a00003 	mov	r0, #3
 c10ab38:	e1a01003 	mov	r1, r3
 c10ab3c:	eb00032e 	bl	c10b7fc <iic_start>

		//Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
		iic_putByte(addr & 0xff);
 c10ab40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ab44:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ab48:	e1a00003 	mov	r0, r3
 c10ab4c:	eb00034b 	bl	c10b880 <iic_putByte>

		//Se env√≠an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c10ab50:	e3a03000 	mov	r3, #0
 c10ab54:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10ab58:	ea000004 	b	c10ab70 <at24c04_clear+0xa4>
			iic_putByte(0);
 c10ab5c:	e3a00000 	mov	r0, #0
 c10ab60:	eb000346 	bl	c10b880 <iic_putByte>

		//Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
		iic_putByte(addr & 0xff);

		//Se env√≠an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
		for(byte_count = 0; byte_count < 16; byte_count++) {
 c10ab64:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ab68:	e2833001 	add	r3, r3, #1
 c10ab6c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10ab70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ab74:	e353000f 	cmp	r3, #15
 c10ab78:	dafffff7 	ble	c10ab5c <at24c04_clear+0x90>
			iic_putByte(0);
		}

		//Se env√≠a la stop condition
		iic_stop(5);
 c10ab7c:	e3a00005 	mov	r0, #5
 c10ab80:	eb00037f 	bl	c10b984 <iic_stop>
{
    //Store 32 pages of 16 bytes zeros
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c10ab84:	e51b3010 	ldr	r3, [fp, #-16]
 c10ab88:	e2833001 	add	r3, r3, #1
 c10ab8c:	e50b3010 	str	r3, [fp, #-16]
 c10ab90:	e51b3010 	ldr	r3, [fp, #-16]
 c10ab94:	e353001f 	cmp	r3, #31
 c10ab98:	daffffd6 	ble	c10aaf8 <at24c04_clear+0x2c>
		}

		//Se env√≠a la stop condition
		iic_stop(5);
	}
}
 c10ab9c:	e24bd00c 	sub	sp, fp, #12
 c10aba0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10aba4:	e12fff1e 	bx	lr

0c10aba8 <at24c04_bytewrite>:

void at24c04_bytewrite( uint16 addr, uint8 data )
{
 c10aba8:	e1a0c00d 	mov	ip, sp
 c10abac:	e92dd800 	push	{fp, ip, lr, pc}
 c10abb0:	e24cb004 	sub	fp, ip, #4
 c10abb4:	e24dd010 	sub	sp, sp, #16
 c10abb8:	e1a02000 	mov	r2, r0
 c10abbc:	e1a03001 	mov	r3, r1
 c10abc0:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c10abc4:	e54b3017 	strb	r3, [fp, #-23]	; 0xffffffe9
    uint8 page;

    page = (addr & 0x100) >> 8;
 c10abc8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10abcc:	e2033c01 	and	r3, r3, #256	; 0x100
 c10abd0:	e1a03443 	asr	r3, r3, #8
 c10abd4:	e54b300d 	strb	r3, [fp, #-13]

    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c10abd8:	e55b300d 	ldrb	r3, [fp, #-13]
 c10abdc:	e1a03083 	lsl	r3, r3, #1
 c10abe0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10abe4:	e1e03003 	mvn	r3, r3
 c10abe8:	e203305f 	and	r3, r3, #95	; 0x5f
 c10abec:	e1e03003 	mvn	r3, r3
 c10abf0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10abf4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10abf8:	e3a00003 	mov	r0, #3
 c10abfc:	e1a01003 	mov	r1, r3
 c10ac00:	eb0002fd 	bl	c10b7fc <iic_start>
    iic_putByte( addr & 0xFF );
 c10ac04:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10ac08:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ac0c:	e1a00003 	mov	r0, r3
 c10ac10:	eb00031a 	bl	c10b880 <iic_putByte>
    iic_putByte( data );
 c10ac14:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
 c10ac18:	e1a00003 	mov	r0, r3
 c10ac1c:	eb000317 	bl	c10b880 <iic_putByte>
    iic_stop( 5 );
 c10ac20:	e3a00005 	mov	r0, #5
 c10ac24:	eb000356 	bl	c10b984 <iic_stop>
}
 c10ac28:	e24bd00c 	sub	sp, fp, #12
 c10ac2c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ac30:	e12fff1e 	bx	lr

0c10ac34 <at24c04_byteread>:

void at24c04_byteread( uint16 addr, uint8 *data )
{
 c10ac34:	e1a0c00d 	mov	ip, sp
 c10ac38:	e92dd800 	push	{fp, ip, lr, pc}
 c10ac3c:	e24cb004 	sub	fp, ip, #4
 c10ac40:	e24dd010 	sub	sp, sp, #16
 c10ac44:	e1a03000 	mov	r3, r0
 c10ac48:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c10ac4c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
	//Read random byte
	uint8 page;
    page = (addr & 0x100) >> 8;
 c10ac50:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10ac54:	e2033c01 	and	r3, r3, #256	; 0x100
 c10ac58:	e1a03443 	asr	r3, r3, #8
 c10ac5c:	e54b300d 	strb	r3, [fp, #-13]
	//Steps:
	//Se env√≠a la start condition seguida del 1er. byte que incluye:
	//- los 6 bits m√°s significativos de la direcci√≥n del dispositivo IIC (101000)
	//- el bit 8 de la direcci√≥n del dato
	//- un 0 para indicar la operaci√≥n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (page << 1) | WRITE );
 c10ac60:	e55b300d 	ldrb	r3, [fp, #-13]
 c10ac64:	e1a03083 	lsl	r3, r3, #1
 c10ac68:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ac6c:	e1e03003 	mvn	r3, r3
 c10ac70:	e203305f 	and	r3, r3, #95	; 0x5f
 c10ac74:	e1e03003 	mvn	r3, r3
 c10ac78:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ac7c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ac80:	e3a00003 	mov	r0, #3
 c10ac84:	e1a01003 	mov	r1, r3
 c10ac88:	eb0002db 	bl	c10b7fc <iic_start>

	//Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
    iic_putByte( addr & 0xFF );
 c10ac8c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10ac90:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ac94:	e1a00003 	mov	r0, r3
 c10ac98:	eb0002f8 	bl	c10b880 <iic_putByte>

	//Se env√≠a la start condition seguida del 3er. byte que incluye:
	//- La misma informaci√≥n que el 1er. byte pero con un 1 final para indicar la operaci√≥n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (page << 1) | READ);
 c10ac9c:	e55b300d 	ldrb	r3, [fp, #-13]
 c10aca0:	e1a03083 	lsl	r3, r3, #1
 c10aca4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10aca8:	e1e03003 	mvn	r3, r3
 c10acac:	e203305e 	and	r3, r3, #94	; 0x5e
 c10acb0:	e1e03003 	mvn	r3, r3
 c10acb4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10acb8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10acbc:	e3a00002 	mov	r0, #2
 c10acc0:	e1a01003 	mov	r1, r3
 c10acc4:	eb0002cc 	bl	c10b7fc <iic_start>

	//Se recibe el byte que incluye el dato (sin enviar ACK).
    *data = iic_getByte(NO_RxACK);
 c10acc8:	e3a00000 	mov	r0, #0
 c10accc:	eb000304 	bl	c10b8e4 <iic_getByte>
 c10acd0:	e1a03000 	mov	r3, r0
 c10acd4:	e1a02003 	mov	r2, r3
 c10acd8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c10acdc:	e5c32000 	strb	r2, [r3]

	//Se env√≠a la stop condition
    iic_stop( 5 );
 c10ace0:	e3a00005 	mov	r0, #5
 c10ace4:	eb000326 	bl	c10b984 <iic_stop>
}
 c10ace8:	e24bd00c 	sub	sp, fp, #12
 c10acec:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10acf0:	e12fff1e 	bx	lr

0c10acf4 <at24c04_load>:

void at24c04_load( uint8 *buffer )
{
 c10acf4:	e1a0c00d 	mov	ip, sp
 c10acf8:	e92dd800 	push	{fp, ip, lr, pc}
 c10acfc:	e24cb004 	sub	fp, ip, #4
 c10ad00:	e24dd010 	sub	sp, sp, #16
 c10ad04:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    //Load sequentially all 512 bytes from 0x0
	int i = 0;
 c10ad08:	e3a03000 	mov	r3, #0
 c10ad0c:	e50b3010 	str	r3, [fp, #-16]

	//Se env√≠a la start condition seguida del 1er. byte que incluye:
	// - los 6 bits m√°s significativos de la direcci√≥n del dispositivo IIC (101000)
	// - el bit 8 de la direcci√≥n del dato
	// -un 0 para indicar la operaci√≥n de escritura (escritura ficticia)
    iic_start( IIC_Tx, DEVICE_ADDR | (0 << 1) | WRITE );
 c10ad10:	e3a00003 	mov	r0, #3
 c10ad14:	e3a010a0 	mov	r1, #160	; 0xa0
 c10ad18:	eb0002b7 	bl	c10b7fc <iic_start>

	//Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
    iic_putByte(00);
 c10ad1c:	e3a00000 	mov	r0, #0
 c10ad20:	eb0002d6 	bl	c10b880 <iic_putByte>

	//Se env√≠a la start condition seguida del 3er. byte que incluye:
	// - La misma informaci√≥n que el 1er. byte pero con un 1 final para indicar la operaci√≥n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );
 c10ad24:	e3a00002 	mov	r0, #2
 c10ad28:	e3a010a1 	mov	r1, #161	; 0xa1
 c10ad2c:	eb0002b2 	bl	c10b7fc <iic_start>

	//Se reciben n‚Äê1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c10ad30:	e3a03000 	mov	r3, #0
 c10ad34:	e50b3010 	str	r3, [fp, #-16]
 c10ad38:	ea00000b 	b	c10ad6c <at24c04_load+0x78>
    	*buffer = iic_getByte(RxACK);
 c10ad3c:	e3a00001 	mov	r0, #1
 c10ad40:	eb0002e7 	bl	c10b8e4 <iic_getByte>
 c10ad44:	e1a03000 	mov	r3, r0
 c10ad48:	e1a02003 	mov	r2, r3
 c10ad4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ad50:	e5c32000 	strb	r2, [r3]
    	buffer++;
 c10ad54:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ad58:	e2833001 	add	r3, r3, #1
 c10ad5c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	//Se env√≠a la start condition seguida del 3er. byte que incluye:
	// - La misma informaci√≥n que el 1er. byte pero con un 1 final para indicar la operaci√≥n de lectura
    iic_start( IIC_Rx, DEVICE_ADDR | (0 << 1) | READ );

	//Se reciben n‚Äê1 bytes que incluyen los datos (enviando ACK en cada uno)
    for(i = 0; i < 512 - 1; ++i) {
 c10ad60:	e51b3010 	ldr	r3, [fp, #-16]
 c10ad64:	e2833001 	add	r3, r3, #1
 c10ad68:	e50b3010 	str	r3, [fp, #-16]
 c10ad6c:	e51b2010 	ldr	r2, [fp, #-16]
 c10ad70:	e59f3030 	ldr	r3, [pc, #48]	; c10ada8 <at24c04_load+0xb4>
 c10ad74:	e1520003 	cmp	r2, r3
 c10ad78:	daffffef 	ble	c10ad3c <at24c04_load+0x48>
    	*buffer = iic_getByte(RxACK);
    	buffer++;
    }

	//Se recibe el √∫ltimo byte que incluye datos (sin enviar ACK).
	*buffer = iic_getByte(NO_RxACK);
 c10ad7c:	e3a00000 	mov	r0, #0
 c10ad80:	eb0002d7 	bl	c10b8e4 <iic_getByte>
 c10ad84:	e1a03000 	mov	r3, r0
 c10ad88:	e1a02003 	mov	r2, r3
 c10ad8c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ad90:	e5c32000 	strb	r2, [r3]

	//Se env√≠a la stop condition.
    iic_stop( 5 );
 c10ad94:	e3a00005 	mov	r0, #5
 c10ad98:	eb0002f9 	bl	c10b984 <iic_stop>
}
 c10ad9c:	e24bd00c 	sub	sp, fp, #12
 c10ada0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ada4:	e12fff1e 	bx	lr
 c10ada8:	000001fe 	.word	0x000001fe

0c10adac <at24c04_store>:

void at24c04_store( uint8 *buffer )
{
 c10adac:	e1a0c00d 	mov	ip, sp
 c10adb0:	e92dd800 	push	{fp, ip, lr, pc}
 c10adb4:	e24cb004 	sub	fp, ip, #4
 c10adb8:	e24dd018 	sub	sp, sp, #24
 c10adbc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
 c10adc0:	e3a03000 	mov	r3, #0
 c10adc4:	e50b3010 	str	r3, [fp, #-16]
 c10adc8:	e3a03000 	mov	r3, #0
 c10adcc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c10add0:	e3a03000 	mov	r3, #0
 c10add4:	e50b3010 	str	r3, [fp, #-16]
 c10add8:	ea00002a 	b	c10ae88 <at24c04_store+0xdc>
		//Store page
		int addr = page_count * 16;
 c10addc:	e51b3010 	ldr	r3, [fp, #-16]
 c10ade0:	e1a03203 	lsl	r3, r3, #4
 c10ade4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	    bit = (addr & 0x100) >> 8;
 c10ade8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10adec:	e2033c01 	and	r3, r3, #256	; 0x100
 c10adf0:	e1a03443 	asr	r3, r3, #8
 c10adf4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

	    //Se env√≠a la start condition seguida del 1er. byte que incluye:
		//-los 6 bits m√°s significativos de la direcci√≥n del dispositivo IIC (101000)
		//-el bit 8 de la direcci√≥n del dato
		//-un 0 para indicar la operaci√≥n de escritura
	    iic_start( IIC_Tx, DEVICE_ADDR | (bit << 1) | WRITE );
 c10adf8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10adfc:	e1a03083 	lsl	r3, r3, #1
 c10ae00:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ae04:	e1e03003 	mvn	r3, r3
 c10ae08:	e203305f 	and	r3, r3, #95	; 0x5f
 c10ae0c:	e1e03003 	mvn	r3, r3
 c10ae10:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ae14:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ae18:	e3a00003 	mov	r0, #3
 c10ae1c:	e1a01003 	mov	r1, r3
 c10ae20:	eb000275 	bl	c10b7fc <iic_start>

	    //Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
	    iic_putByte(addr & 0xff);
 c10ae24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10ae28:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ae2c:	e1a00003 	mov	r0, r3
 c10ae30:	eb000292 	bl	c10b880 <iic_putByte>

	    //Se env√≠an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c10ae34:	e3a03000 	mov	r3, #0
 c10ae38:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10ae3c:	ea000009 	b	c10ae68 <at24c04_store+0xbc>
	    	iic_putByte(*buffer);
 c10ae40:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10ae44:	e5d33000 	ldrb	r3, [r3]
 c10ae48:	e1a00003 	mov	r0, r3
 c10ae4c:	eb00028b 	bl	c10b880 <iic_putByte>
	    	++buffer;
 c10ae50:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10ae54:	e2833001 	add	r3, r3, #1
 c10ae58:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	    //Se env√≠a el 2do. byte que incluye los bits 7..0 (8 bits) de la direcci√≥n del dato.
	    iic_putByte(addr & 0xff);

	    //Se env√≠an del 3er. al 18vo. byte que incluyen los 16 primeros datos (8 bits cada uno).
	    for(byte_count = 0; byte_count < 16; byte_count++) {
 c10ae5c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ae60:	e2833001 	add	r3, r3, #1
 c10ae64:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10ae68:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ae6c:	e353000f 	cmp	r3, #15
 c10ae70:	dafffff2 	ble	c10ae40 <at24c04_store+0x94>
	    	iic_putByte(*buffer);
	    	++buffer;
	    }

	    //Se env√≠a la stop condition
	    iic_stop(5);
 c10ae74:	e3a00005 	mov	r0, #5
 c10ae78:	eb0002c1 	bl	c10b984 <iic_stop>
{
    //32 stores of 16 byte pages
	int page_count = 0, byte_count = 0;
	uint8 bit;

	for(page_count=0; page_count < 32; ++page_count) {
 c10ae7c:	e51b3010 	ldr	r3, [fp, #-16]
 c10ae80:	e2833001 	add	r3, r3, #1
 c10ae84:	e50b3010 	str	r3, [fp, #-16]
 c10ae88:	e51b3010 	ldr	r3, [fp, #-16]
 c10ae8c:	e353001f 	cmp	r3, #31
 c10ae90:	daffffd1 	ble	c10addc <at24c04_store+0x30>
	    }

	    //Se env√≠a la stop condition
	    iic_stop(5);
	}
}
 c10ae94:	e24bd00c 	sub	sp, fp, #12
 c10ae98:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ae9c:	e12fff1e 	bx	lr

0c10aea0 <read_button>:
#include "button.h"
#include "leds.h"
#include "gpio.h"

unsigned int read_button(void)
{
 c10aea0:	e1a0c00d 	mov	ip, sp
 c10aea4:	e92dd800 	push	{fp, ip, lr, pc}
 c10aea8:	e24cb004 	sub	fp, ip, #4
 c10aeac:	e24dd008 	sub	sp, sp, #8
	unsigned int buttons = 0;
 c10aeb0:	e3a03000 	mov	r3, #0
 c10aeb4:	e50b3010 	str	r3, [fp, #-16]
	//pines 6 y 7 del puerto G (portG_read) debemos devolver un valor (buttons)
	//en el que el bit 0 (el menos significativo) representa el estado del bot√≥n
	//del pin 6 y el bit 1 representa el estado del bot√≥n del pin 7 (a 1 si
	//est√°n pulsados a 0 si no lo est√°n).

	portG_read(6, &val);
 c10aeb8:	e24b3011 	sub	r3, fp, #17
 c10aebc:	e3a00006 	mov	r0, #6
 c10aec0:	e1a01003 	mov	r1, r3
 c10aec4:	eb0001d7 	bl	c10b628 <portG_read>
	if(!val)
 c10aec8:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10aecc:	e3530000 	cmp	r3, #0
 c10aed0:	1a000002 	bne	c10aee0 <read_button+0x40>
		buttons |= BUT1;
 c10aed4:	e51b3010 	ldr	r3, [fp, #-16]
 c10aed8:	e3833001 	orr	r3, r3, #1
 c10aedc:	e50b3010 	str	r3, [fp, #-16]

	portG_read(7, &val);
 c10aee0:	e24b3011 	sub	r3, fp, #17
 c10aee4:	e3a00007 	mov	r0, #7
 c10aee8:	e1a01003 	mov	r1, r3
 c10aeec:	eb0001cd 	bl	c10b628 <portG_read>
	if(!val)
 c10aef0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10aef4:	e3530000 	cmp	r3, #0
 c10aef8:	1a000002 	bne	c10af08 <read_button+0x68>
		buttons |= BUT2;
 c10aefc:	e51b3010 	ldr	r3, [fp, #-16]
 c10af00:	e3833002 	orr	r3, r3, #2
 c10af04:	e50b3010 	str	r3, [fp, #-16]

	return buttons;
 c10af08:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10af0c:	e1a00003 	mov	r0, r3
 c10af10:	e24bd00c 	sub	sp, fp, #12
 c10af14:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10af18:	e12fff1e 	bx	lr

0c10af1c <portB_conf>:
#include "gpio.h"

/* Port B interface implementation */

int portB_conf(int pin, enum port_mode mode)
{
 c10af1c:	e1a0c00d 	mov	ip, sp
 c10af20:	e92dd800 	push	{fp, ip, lr, pc}
 c10af24:	e24cb004 	sub	fp, ip, #4
 c10af28:	e24dd010 	sub	sp, sp, #16
 c10af2c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c10af30:	e1a03001 	mov	r3, r1
 c10af34:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int ret = 0;
 c10af38:	e3a03000 	mov	r3, #0
 c10af3c:	e50b3010 	str	r3, [fp, #-16]
	if (pin < 0 || pin > 10)
 c10af40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10af44:	e3530000 	cmp	r3, #0
 c10af48:	ba000002 	blt	c10af58 <portB_conf+0x3c>
 c10af4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10af50:	e353000a 	cmp	r3, #10
 c10af54:	da000001 	ble	c10af60 <portB_conf+0x44>
		return -1; // indica error
 c10af58:	e3e03000 	mvn	r3, #0
 c10af5c:	ea00001b 	b	c10afd0 <portB_conf+0xb4>

	if (mode == SIGOUT)
 c10af60:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10af64:	e3530002 	cmp	r3, #2
 c10af68:	1a000008 	bne	c10af90 <portB_conf+0x74>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 1 para que por
		// dicho pin en el puerto B salga la se√±al correspondiente del
		// controlador de memoria
		rPCONB |= 1 << pin;
 c10af6c:	e59f306c 	ldr	r3, [pc, #108]	; c10afe0 <portB_conf+0xc4>
 c10af70:	e59f2068 	ldr	r2, [pc, #104]	; c10afe0 <portB_conf+0xc4>
 c10af74:	e5921000 	ldr	r1, [r2]
 c10af78:	e3a00001 	mov	r0, #1
 c10af7c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10af80:	e1a02210 	lsl	r2, r0, r2
 c10af84:	e1812002 	orr	r2, r1, r2
 c10af88:	e5832000 	str	r2, [r3]
 c10af8c:	ea00000e 	b	c10afcc <portB_conf+0xb0>
	else if (mode == OUTPUT)
 c10af90:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10af94:	e3530001 	cmp	r3, #1
 c10af98:	1a000009 	bne	c10afc4 <portB_conf+0xa8>
		// COMPLETAR: poner en rPCONB el bit indicado por pin a 0 para que dicho
		// pin sea un pin de salida
		rPCONB &= ~(1 << pin);
 c10af9c:	e59f303c 	ldr	r3, [pc, #60]	; c10afe0 <portB_conf+0xc4>
 c10afa0:	e59f2038 	ldr	r2, [pc, #56]	; c10afe0 <portB_conf+0xc4>
 c10afa4:	e5921000 	ldr	r1, [r2]
 c10afa8:	e3a00001 	mov	r0, #1
 c10afac:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10afb0:	e1a02210 	lsl	r2, r0, r2
 c10afb4:	e1e02002 	mvn	r2, r2
 c10afb8:	e0012002 	and	r2, r1, r2
 c10afbc:	e5832000 	str	r2, [r3]
 c10afc0:	ea000001 	b	c10afcc <portB_conf+0xb0>
	else
		ret = -1; // indica error
 c10afc4:	e3e03000 	mvn	r3, #0
 c10afc8:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c10afcc:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10afd0:	e1a00003 	mov	r0, r3
 c10afd4:	e24bd00c 	sub	sp, fp, #12
 c10afd8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10afdc:	e12fff1e 	bx	lr
 c10afe0:	01d20008 	.word	0x01d20008

0c10afe4 <portB_write>:

int portB_write(int pin, enum digital val)
{
 c10afe4:	e1a0c00d 	mov	ip, sp
 c10afe8:	e92dd800 	push	{fp, ip, lr, pc}
 c10afec:	e24cb004 	sub	fp, ip, #4
 c10aff0:	e24dd008 	sub	sp, sp, #8
 c10aff4:	e50b0010 	str	r0, [fp, #-16]
 c10aff8:	e1a03001 	mov	r3, r1
 c10affc:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 10)
 c10b000:	e51b3010 	ldr	r3, [fp, #-16]
 c10b004:	e3530000 	cmp	r3, #0
 c10b008:	ba000002 	blt	c10b018 <portB_write+0x34>
 c10b00c:	e51b3010 	ldr	r3, [fp, #-16]
 c10b010:	e353000a 	cmp	r3, #10
 c10b014:	da000001 	ble	c10b020 <portB_write+0x3c>
		return -1; // indica error
 c10b018:	e3e03000 	mvn	r3, #0
 c10b01c:	ea00001a 	b	c10b08c <portB_write+0xa8>

	if (val < 0 || val > 1)
 c10b020:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10b024:	e3530001 	cmp	r3, #1
 c10b028:	9a000001 	bls	c10b034 <portB_write+0x50>
		return -1; // indica error
 c10b02c:	e3e03000 	mvn	r3, #0
 c10b030:	ea000015 	b	c10b08c <portB_write+0xa8>

	if (val)
 c10b034:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10b038:	e3530000 	cmp	r3, #0
 c10b03c:	0a000008 	beq	c10b064 <portB_write+0x80>
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 1
		rPDATB |= 1 << pin;
 c10b040:	e59f3054 	ldr	r3, [pc, #84]	; c10b09c <portB_write+0xb8>
 c10b044:	e59f2050 	ldr	r2, [pc, #80]	; c10b09c <portB_write+0xb8>
 c10b048:	e5921000 	ldr	r1, [r2]
 c10b04c:	e3a00001 	mov	r0, #1
 c10b050:	e51b2010 	ldr	r2, [fp, #-16]
 c10b054:	e1a02210 	lsl	r2, r0, r2
 c10b058:	e1812002 	orr	r2, r1, r2
 c10b05c:	e5832000 	str	r2, [r3]
 c10b060:	ea000008 	b	c10b088 <portB_write+0xa4>
	else
		// COMPLETAR: poner en rPDATB el bit indicado por pin a 0
		rPDATB &= ~(1 << pin);
 c10b064:	e59f3030 	ldr	r3, [pc, #48]	; c10b09c <portB_write+0xb8>
 c10b068:	e59f202c 	ldr	r2, [pc, #44]	; c10b09c <portB_write+0xb8>
 c10b06c:	e5921000 	ldr	r1, [r2]
 c10b070:	e3a00001 	mov	r0, #1
 c10b074:	e51b2010 	ldr	r2, [fp, #-16]
 c10b078:	e1a02210 	lsl	r2, r0, r2
 c10b07c:	e1e02002 	mvn	r2, r2
 c10b080:	e0012002 	and	r2, r1, r2
 c10b084:	e5832000 	str	r2, [r3]

	return 0;
 c10b088:	e3a03000 	mov	r3, #0
}
 c10b08c:	e1a00003 	mov	r0, r3
 c10b090:	e24bd00c 	sub	sp, fp, #12
 c10b094:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b098:	e12fff1e 	bx	lr
 c10b09c:	01d2000c 	.word	0x01d2000c

0c10b0a0 <portG_conf>:

/* Port G interface implementation */

int portG_conf(int pin, enum port_mode mode)
{
 c10b0a0:	e1a0c00d 	mov	ip, sp
 c10b0a4:	e92dd800 	push	{fp, ip, lr, pc}
 c10b0a8:	e24cb004 	sub	fp, ip, #4
 c10b0ac:	e24dd010 	sub	sp, sp, #16
 c10b0b0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c10b0b4:	e1a03001 	mov	r3, r1
 c10b0b8:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos  = pin*2;
 c10b0bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b0c0:	e1a03083 	lsl	r3, r3, #1
 c10b0c4:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c10b0c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b0cc:	e3530000 	cmp	r3, #0
 c10b0d0:	ba000002 	blt	c10b0e0 <portG_conf+0x40>
 c10b0d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b0d8:	e3530007 	cmp	r3, #7
 c10b0dc:	da000001 	ble	c10b0e8 <portG_conf+0x48>
		return -1; // indica error
 c10b0e0:	e3e03000 	mvn	r3, #0
 c10b0e4:	ea000056 	b	c10b244 <portG_conf+0x1a4>

	switch (mode) {
 c10b0e8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10b0ec:	e3530003 	cmp	r3, #3
 c10b0f0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c10b0f4:	ea00004f 	b	c10b238 <portG_conf+0x198>
 c10b0f8:	0c10b108 	.word	0x0c10b108
 c10b0fc:	0c10b158 	.word	0x0c10b158
 c10b100:	0c10b1a4 	.word	0x0c10b1a4
 c10b104:	0c10b1f0 	.word	0x0c10b1f0
		case INPUT:
			// COMPLETAR: poner en rPCONG 00 a partir de la posici√≥n pos para
			// configurar como pin de entrada el pin indicado por el par√°metro pin
			rPCONG &= ~(1 << pos);  	 // 0
 c10b108:	e59f3144 	ldr	r3, [pc, #324]	; c10b254 <portG_conf+0x1b4>
 c10b10c:	e59f2140 	ldr	r2, [pc, #320]	; c10b254 <portG_conf+0x1b4>
 c10b110:	e5921000 	ldr	r1, [r2]
 c10b114:	e3a00001 	mov	r0, #1
 c10b118:	e51b2010 	ldr	r2, [fp, #-16]
 c10b11c:	e1a02210 	lsl	r2, r0, r2
 c10b120:	e1e02002 	mvn	r2, r2
 c10b124:	e0012002 	and	r2, r1, r2
 c10b128:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c10b12c:	e59f3120 	ldr	r3, [pc, #288]	; c10b254 <portG_conf+0x1b4>
 c10b130:	e59f211c 	ldr	r2, [pc, #284]	; c10b254 <portG_conf+0x1b4>
 c10b134:	e5921000 	ldr	r1, [r2]
 c10b138:	e51b2010 	ldr	r2, [fp, #-16]
 c10b13c:	e2822001 	add	r2, r2, #1
 c10b140:	e3a00001 	mov	r0, #1
 c10b144:	e1a02210 	lsl	r2, r0, r2
 c10b148:	e1e02002 	mvn	r2, r2
 c10b14c:	e0012002 	and	r2, r1, r2
 c10b150:	e5832000 	str	r2, [r3]
			break;
 c10b154:	ea000039 	b	c10b240 <portG_conf+0x1a0>
		case OUTPUT:
			// COMPLETAR: poner en rPCONG 01 a partir de la posici√≥n pos para
			// configurar como pin de salida el pin indicado por el par√°metro pin
			rPCONG |= 1 << pos;			 // 1
 c10b158:	e59f30f4 	ldr	r3, [pc, #244]	; c10b254 <portG_conf+0x1b4>
 c10b15c:	e59f20f0 	ldr	r2, [pc, #240]	; c10b254 <portG_conf+0x1b4>
 c10b160:	e5921000 	ldr	r1, [r2]
 c10b164:	e3a00001 	mov	r0, #1
 c10b168:	e51b2010 	ldr	r2, [fp, #-16]
 c10b16c:	e1a02210 	lsl	r2, r0, r2
 c10b170:	e1812002 	orr	r2, r1, r2
 c10b174:	e5832000 	str	r2, [r3]
			rPCONG &= ~(1 << (pos + 1)); // 0
 c10b178:	e59f30d4 	ldr	r3, [pc, #212]	; c10b254 <portG_conf+0x1b4>
 c10b17c:	e59f20d0 	ldr	r2, [pc, #208]	; c10b254 <portG_conf+0x1b4>
 c10b180:	e5921000 	ldr	r1, [r2]
 c10b184:	e51b2010 	ldr	r2, [fp, #-16]
 c10b188:	e2822001 	add	r2, r2, #1
 c10b18c:	e3a00001 	mov	r0, #1
 c10b190:	e1a02210 	lsl	r2, r0, r2
 c10b194:	e1e02002 	mvn	r2, r2
 c10b198:	e0012002 	and	r2, r1, r2
 c10b19c:	e5832000 	str	r2, [r3]
			break;
 c10b1a0:	ea000026 	b	c10b240 <portG_conf+0x1a0>
		case SIGOUT:
			// COMPLETAR: poner en rPCONG 10 a partir de la posici√≥n pos para
			// que salga la se√±al interna correspondiente por el pin indicado
			// por el par√°metro pin
			rPCONG &= ~(1 << pos); 		// 0
 c10b1a4:	e59f30a8 	ldr	r3, [pc, #168]	; c10b254 <portG_conf+0x1b4>
 c10b1a8:	e59f20a4 	ldr	r2, [pc, #164]	; c10b254 <portG_conf+0x1b4>
 c10b1ac:	e5921000 	ldr	r1, [r2]
 c10b1b0:	e3a00001 	mov	r0, #1
 c10b1b4:	e51b2010 	ldr	r2, [fp, #-16]
 c10b1b8:	e1a02210 	lsl	r2, r0, r2
 c10b1bc:	e1e02002 	mvn	r2, r2
 c10b1c0:	e0012002 	and	r2, r1, r2
 c10b1c4:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c10b1c8:	e59f3084 	ldr	r3, [pc, #132]	; c10b254 <portG_conf+0x1b4>
 c10b1cc:	e59f2080 	ldr	r2, [pc, #128]	; c10b254 <portG_conf+0x1b4>
 c10b1d0:	e5921000 	ldr	r1, [r2]
 c10b1d4:	e51b2010 	ldr	r2, [fp, #-16]
 c10b1d8:	e2822001 	add	r2, r2, #1
 c10b1dc:	e3a00001 	mov	r0, #1
 c10b1e0:	e1a02210 	lsl	r2, r0, r2
 c10b1e4:	e1812002 	orr	r2, r1, r2
 c10b1e8:	e5832000 	str	r2, [r3]
			break;
 c10b1ec:	ea000013 	b	c10b240 <portG_conf+0x1a0>
		case EINT:
			// COMPLETAR: poner en rPCONG 11 a partir de la posici√≥n pos para
			// habilitar la generaci√≥n de interrupciones externas por el pin
			// indicado por el par√°metro pin
			rPCONG |= 1 << pos;			// 1
 c10b1f0:	e59f305c 	ldr	r3, [pc, #92]	; c10b254 <portG_conf+0x1b4>
 c10b1f4:	e59f2058 	ldr	r2, [pc, #88]	; c10b254 <portG_conf+0x1b4>
 c10b1f8:	e5921000 	ldr	r1, [r2]
 c10b1fc:	e3a00001 	mov	r0, #1
 c10b200:	e51b2010 	ldr	r2, [fp, #-16]
 c10b204:	e1a02210 	lsl	r2, r0, r2
 c10b208:	e1812002 	orr	r2, r1, r2
 c10b20c:	e5832000 	str	r2, [r3]
			rPCONG |= 1 << (pos + 1);	// 1
 c10b210:	e59f303c 	ldr	r3, [pc, #60]	; c10b254 <portG_conf+0x1b4>
 c10b214:	e59f2038 	ldr	r2, [pc, #56]	; c10b254 <portG_conf+0x1b4>
 c10b218:	e5921000 	ldr	r1, [r2]
 c10b21c:	e51b2010 	ldr	r2, [fp, #-16]
 c10b220:	e2822001 	add	r2, r2, #1
 c10b224:	e3a00001 	mov	r0, #1
 c10b228:	e1a02210 	lsl	r2, r0, r2
 c10b22c:	e1812002 	orr	r2, r1, r2
 c10b230:	e5832000 	str	r2, [r3]
			break;
 c10b234:	ea000001 	b	c10b240 <portG_conf+0x1a0>
		default:
			return -1;
 c10b238:	e3e03000 	mvn	r3, #0
 c10b23c:	ea000000 	b	c10b244 <portG_conf+0x1a4>
	}

	return 0;
 c10b240:	e3a03000 	mov	r3, #0
}
 c10b244:	e1a00003 	mov	r0, r3
 c10b248:	e24bd00c 	sub	sp, fp, #12
 c10b24c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b250:	e12fff1e 	bx	lr
 c10b254:	01d20040 	.word	0x01d20040

0c10b258 <portG_eint_trig>:

int portG_eint_trig(int pin, enum trigger trig)
{
 c10b258:	e1a0c00d 	mov	ip, sp
 c10b25c:	e92dd800 	push	{fp, ip, lr, pc}
 c10b260:	e24cb004 	sub	fp, ip, #4
 c10b264:	e24dd010 	sub	sp, sp, #16
 c10b268:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c10b26c:	e1a03001 	mov	r3, r1
 c10b270:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*4;
 c10b274:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b278:	e1a03103 	lsl	r3, r3, #2
 c10b27c:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c10b280:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b284:	e3530000 	cmp	r3, #0
 c10b288:	ba000002 	blt	c10b298 <portG_eint_trig+0x40>
 c10b28c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b290:	e3530007 	cmp	r3, #7
 c10b294:	da000001 	ble	c10b2a0 <portG_eint_trig+0x48>
		return -1;
 c10b298:	e3e03000 	mvn	r3, #0
 c10b29c:	ea00009c 	b	c10b514 <portG_eint_trig+0x2bc>

switch (trig) {
 c10b2a0:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10b2a4:	e3530004 	cmp	r3, #4
 c10b2a8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c10b2ac:	ea000095 	b	c10b508 <portG_eint_trig+0x2b0>
 c10b2b0:	0c10b2c4 	.word	0x0c10b2c4
 c10b2b4:	0c10b33c 	.word	0x0c10b33c
 c10b2b8:	0c10b3b0 	.word	0x0c10b3b0
 c10b2bc:	0c10b424 	.word	0x0c10b424
 c10b2c0:	0c10b498 	.word	0x0c10b498
		case LLOW:
			// COMPLETAR: poner en rEXTINT a partir de la posici√≥n pos tres bits
			// a 000, para configurar interrupciones externas por nivel bajo
			rEXTINT &= ~(1 << pos);	 		// 0
 c10b2c4:	e59f3258 	ldr	r3, [pc, #600]	; c10b524 <portG_eint_trig+0x2cc>
 c10b2c8:	e59f2254 	ldr	r2, [pc, #596]	; c10b524 <portG_eint_trig+0x2cc>
 c10b2cc:	e5921000 	ldr	r1, [r2]
 c10b2d0:	e3a00001 	mov	r0, #1
 c10b2d4:	e51b2010 	ldr	r2, [fp, #-16]
 c10b2d8:	e1a02210 	lsl	r2, r0, r2
 c10b2dc:	e1e02002 	mvn	r2, r2
 c10b2e0:	e0012002 	and	r2, r1, r2
 c10b2e4:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c10b2e8:	e59f3234 	ldr	r3, [pc, #564]	; c10b524 <portG_eint_trig+0x2cc>
 c10b2ec:	e59f2230 	ldr	r2, [pc, #560]	; c10b524 <portG_eint_trig+0x2cc>
 c10b2f0:	e5921000 	ldr	r1, [r2]
 c10b2f4:	e51b2010 	ldr	r2, [fp, #-16]
 c10b2f8:	e2822001 	add	r2, r2, #1
 c10b2fc:	e3a00001 	mov	r0, #1
 c10b300:	e1a02210 	lsl	r2, r0, r2
 c10b304:	e1e02002 	mvn	r2, r2
 c10b308:	e0012002 	and	r2, r1, r2
 c10b30c:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c10b310:	e59f320c 	ldr	r3, [pc, #524]	; c10b524 <portG_eint_trig+0x2cc>
 c10b314:	e59f2208 	ldr	r2, [pc, #520]	; c10b524 <portG_eint_trig+0x2cc>
 c10b318:	e5921000 	ldr	r1, [r2]
 c10b31c:	e51b2010 	ldr	r2, [fp, #-16]
 c10b320:	e2822002 	add	r2, r2, #2
 c10b324:	e3a00001 	mov	r0, #1
 c10b328:	e1a02210 	lsl	r2, r0, r2
 c10b32c:	e1e02002 	mvn	r2, r2
 c10b330:	e0012002 	and	r2, r1, r2
 c10b334:	e5832000 	str	r2, [r3]
			break;
 c10b338:	ea000074 	b	c10b510 <portG_eint_trig+0x2b8>
		case LHIGH:
			// COMPLETAR: poner en rEXTINT a partir de la posici√≥n pos tres bits
			// a 001, para configurar interrupciones externas por nivel alto
			rEXTINT |= 1 << pos;	 		// 1
 c10b33c:	e59f31e0 	ldr	r3, [pc, #480]	; c10b524 <portG_eint_trig+0x2cc>
 c10b340:	e59f21dc 	ldr	r2, [pc, #476]	; c10b524 <portG_eint_trig+0x2cc>
 c10b344:	e5921000 	ldr	r1, [r2]
 c10b348:	e3a00001 	mov	r0, #1
 c10b34c:	e51b2010 	ldr	r2, [fp, #-16]
 c10b350:	e1a02210 	lsl	r2, r0, r2
 c10b354:	e1812002 	orr	r2, r1, r2
 c10b358:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c10b35c:	e59f31c0 	ldr	r3, [pc, #448]	; c10b524 <portG_eint_trig+0x2cc>
 c10b360:	e59f21bc 	ldr	r2, [pc, #444]	; c10b524 <portG_eint_trig+0x2cc>
 c10b364:	e5921000 	ldr	r1, [r2]
 c10b368:	e51b2010 	ldr	r2, [fp, #-16]
 c10b36c:	e2822001 	add	r2, r2, #1
 c10b370:	e3a00001 	mov	r0, #1
 c10b374:	e1a02210 	lsl	r2, r0, r2
 c10b378:	e1e02002 	mvn	r2, r2
 c10b37c:	e0012002 	and	r2, r1, r2
 c10b380:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c10b384:	e59f3198 	ldr	r3, [pc, #408]	; c10b524 <portG_eint_trig+0x2cc>
 c10b388:	e59f2194 	ldr	r2, [pc, #404]	; c10b524 <portG_eint_trig+0x2cc>
 c10b38c:	e5921000 	ldr	r1, [r2]
 c10b390:	e51b2010 	ldr	r2, [fp, #-16]
 c10b394:	e2822002 	add	r2, r2, #2
 c10b398:	e3a00001 	mov	r0, #1
 c10b39c:	e1a02210 	lsl	r2, r0, r2
 c10b3a0:	e1e02002 	mvn	r2, r2
 c10b3a4:	e0012002 	and	r2, r1, r2
 c10b3a8:	e5832000 	str	r2, [r3]
			break;
 c10b3ac:	ea000057 	b	c10b510 <portG_eint_trig+0x2b8>
		case FALLING:
			// COMPLETAR: poner en rEXTINT a partir de la posici√≥n pos tres bits
			// a 010, para configurar interrupciones externas por flanco de
			// bajada
			rEXTINT &= ~(1 << pos);	 		// 0
 c10b3b0:	e59f316c 	ldr	r3, [pc, #364]	; c10b524 <portG_eint_trig+0x2cc>
 c10b3b4:	e59f2168 	ldr	r2, [pc, #360]	; c10b524 <portG_eint_trig+0x2cc>
 c10b3b8:	e5921000 	ldr	r1, [r2]
 c10b3bc:	e3a00001 	mov	r0, #1
 c10b3c0:	e51b2010 	ldr	r2, [fp, #-16]
 c10b3c4:	e1a02210 	lsl	r2, r0, r2
 c10b3c8:	e1e02002 	mvn	r2, r2
 c10b3cc:	e0012002 	and	r2, r1, r2
 c10b3d0:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c10b3d4:	e59f3148 	ldr	r3, [pc, #328]	; c10b524 <portG_eint_trig+0x2cc>
 c10b3d8:	e59f2144 	ldr	r2, [pc, #324]	; c10b524 <portG_eint_trig+0x2cc>
 c10b3dc:	e5921000 	ldr	r1, [r2]
 c10b3e0:	e51b2010 	ldr	r2, [fp, #-16]
 c10b3e4:	e2822001 	add	r2, r2, #1
 c10b3e8:	e3a00001 	mov	r0, #1
 c10b3ec:	e1a02210 	lsl	r2, r0, r2
 c10b3f0:	e1812002 	orr	r2, r1, r2
 c10b3f4:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 2));	// 0
 c10b3f8:	e59f3124 	ldr	r3, [pc, #292]	; c10b524 <portG_eint_trig+0x2cc>
 c10b3fc:	e59f2120 	ldr	r2, [pc, #288]	; c10b524 <portG_eint_trig+0x2cc>
 c10b400:	e5921000 	ldr	r1, [r2]
 c10b404:	e51b2010 	ldr	r2, [fp, #-16]
 c10b408:	e2822002 	add	r2, r2, #2
 c10b40c:	e3a00001 	mov	r0, #1
 c10b410:	e1a02210 	lsl	r2, r0, r2
 c10b414:	e1e02002 	mvn	r2, r2
 c10b418:	e0012002 	and	r2, r1, r2
 c10b41c:	e5832000 	str	r2, [r3]
			break;
 c10b420:	ea00003a 	b	c10b510 <portG_eint_trig+0x2b8>
		case RISING:
			// COMPLETAR: poner en rEXTINT a partir de la posici√≥n pos tres bits
			// a 100, para configurar interrupciones externas por flanco de
			// subida
			rEXTINT &= ~(1 << pos);	 		// 0
 c10b424:	e59f30f8 	ldr	r3, [pc, #248]	; c10b524 <portG_eint_trig+0x2cc>
 c10b428:	e59f20f4 	ldr	r2, [pc, #244]	; c10b524 <portG_eint_trig+0x2cc>
 c10b42c:	e5921000 	ldr	r1, [r2]
 c10b430:	e3a00001 	mov	r0, #1
 c10b434:	e51b2010 	ldr	r2, [fp, #-16]
 c10b438:	e1a02210 	lsl	r2, r0, r2
 c10b43c:	e1e02002 	mvn	r2, r2
 c10b440:	e0012002 	and	r2, r1, r2
 c10b444:	e5832000 	str	r2, [r3]
			rEXTINT &= ~(1 << (pos + 1));	// 0
 c10b448:	e59f30d4 	ldr	r3, [pc, #212]	; c10b524 <portG_eint_trig+0x2cc>
 c10b44c:	e59f20d0 	ldr	r2, [pc, #208]	; c10b524 <portG_eint_trig+0x2cc>
 c10b450:	e5921000 	ldr	r1, [r2]
 c10b454:	e51b2010 	ldr	r2, [fp, #-16]
 c10b458:	e2822001 	add	r2, r2, #1
 c10b45c:	e3a00001 	mov	r0, #1
 c10b460:	e1a02210 	lsl	r2, r0, r2
 c10b464:	e1e02002 	mvn	r2, r2
 c10b468:	e0012002 	and	r2, r1, r2
 c10b46c:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c10b470:	e59f30ac 	ldr	r3, [pc, #172]	; c10b524 <portG_eint_trig+0x2cc>
 c10b474:	e59f20a8 	ldr	r2, [pc, #168]	; c10b524 <portG_eint_trig+0x2cc>
 c10b478:	e5921000 	ldr	r1, [r2]
 c10b47c:	e51b2010 	ldr	r2, [fp, #-16]
 c10b480:	e2822002 	add	r2, r2, #2
 c10b484:	e3a00001 	mov	r0, #1
 c10b488:	e1a02210 	lsl	r2, r0, r2
 c10b48c:	e1812002 	orr	r2, r1, r2
 c10b490:	e5832000 	str	r2, [r3]
			break;
 c10b494:	ea00001d 	b	c10b510 <portG_eint_trig+0x2b8>
		case EDGE:
			// COMPLETAR: poner en rEXTINT a partir de la posici√≥n pos tres bits
			// a 110, para configurar interrupciones externas por cualquier
			// flanco
			rEXTINT &= ~(1 << pos);	 		// 0
 c10b498:	e59f3084 	ldr	r3, [pc, #132]	; c10b524 <portG_eint_trig+0x2cc>
 c10b49c:	e59f2080 	ldr	r2, [pc, #128]	; c10b524 <portG_eint_trig+0x2cc>
 c10b4a0:	e5921000 	ldr	r1, [r2]
 c10b4a4:	e3a00001 	mov	r0, #1
 c10b4a8:	e51b2010 	ldr	r2, [fp, #-16]
 c10b4ac:	e1a02210 	lsl	r2, r0, r2
 c10b4b0:	e1e02002 	mvn	r2, r2
 c10b4b4:	e0012002 	and	r2, r1, r2
 c10b4b8:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 1);	 	// 1
 c10b4bc:	e59f3060 	ldr	r3, [pc, #96]	; c10b524 <portG_eint_trig+0x2cc>
 c10b4c0:	e59f205c 	ldr	r2, [pc, #92]	; c10b524 <portG_eint_trig+0x2cc>
 c10b4c4:	e5921000 	ldr	r1, [r2]
 c10b4c8:	e51b2010 	ldr	r2, [fp, #-16]
 c10b4cc:	e2822001 	add	r2, r2, #1
 c10b4d0:	e3a00001 	mov	r0, #1
 c10b4d4:	e1a02210 	lsl	r2, r0, r2
 c10b4d8:	e1812002 	orr	r2, r1, r2
 c10b4dc:	e5832000 	str	r2, [r3]
			rEXTINT |= 1 << (pos + 2);	 	// 1
 c10b4e0:	e59f303c 	ldr	r3, [pc, #60]	; c10b524 <portG_eint_trig+0x2cc>
 c10b4e4:	e59f2038 	ldr	r2, [pc, #56]	; c10b524 <portG_eint_trig+0x2cc>
 c10b4e8:	e5921000 	ldr	r1, [r2]
 c10b4ec:	e51b2010 	ldr	r2, [fp, #-16]
 c10b4f0:	e2822002 	add	r2, r2, #2
 c10b4f4:	e3a00001 	mov	r0, #1
 c10b4f8:	e1a02210 	lsl	r2, r0, r2
 c10b4fc:	e1812002 	orr	r2, r1, r2
 c10b500:	e5832000 	str	r2, [r3]
			break;
 c10b504:	ea000001 	b	c10b510 <portG_eint_trig+0x2b8>
		default:
			return -1;
 c10b508:	e3e03000 	mvn	r3, #0
 c10b50c:	ea000000 	b	c10b514 <portG_eint_trig+0x2bc>
	}
	return 0;
 c10b510:	e3a03000 	mov	r3, #0
}
 c10b514:	e1a00003 	mov	r0, r3
 c10b518:	e24bd00c 	sub	sp, fp, #12
 c10b51c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b520:	e12fff1e 	bx	lr
 c10b524:	01d20050 	.word	0x01d20050

0c10b528 <portG_write>:

int portG_write(int pin, enum digital val)
{
 c10b528:	e1a0c00d 	mov	ip, sp
 c10b52c:	e92dd800 	push	{fp, ip, lr, pc}
 c10b530:	e24cb004 	sub	fp, ip, #4
 c10b534:	e24dd010 	sub	sp, sp, #16
 c10b538:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c10b53c:	e1a03001 	mov	r3, r1
 c10b540:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
	int pos = pin*2;
 c10b544:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b548:	e1a03083 	lsl	r3, r3, #1
 c10b54c:	e50b3010 	str	r3, [fp, #-16]

		if (pin < 0 || pin > 7)
 c10b550:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b554:	e3530000 	cmp	r3, #0
 c10b558:	ba000002 	blt	c10b568 <portG_write+0x40>
 c10b55c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b560:	e3530007 	cmp	r3, #7
 c10b564:	da000001 	ble	c10b570 <portG_write+0x48>
			return -1; // indica error
 c10b568:	e3e03000 	mvn	r3, #0
 c10b56c:	ea000027 	b	c10b610 <portG_write+0xe8>

		if (val < 0 || val > 1)
 c10b570:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10b574:	e3530001 	cmp	r3, #1
 c10b578:	9a000001 	bls	c10b584 <portG_write+0x5c>
			return -1; // indica error
 c10b57c:	e3e03000 	mvn	r3, #0
 c10b580:	ea000022 	b	c10b610 <portG_write+0xe8>

		if ((rPCONG & (0x3 << pos)) != (0x1 << pos))
 c10b584:	e59f3094 	ldr	r3, [pc, #148]	; c10b620 <portG_write+0xf8>
 c10b588:	e5932000 	ldr	r2, [r3]
 c10b58c:	e3a01003 	mov	r1, #3
 c10b590:	e51b3010 	ldr	r3, [fp, #-16]
 c10b594:	e1a03311 	lsl	r3, r1, r3
 c10b598:	e0022003 	and	r2, r2, r3
 c10b59c:	e3a01001 	mov	r1, #1
 c10b5a0:	e51b3010 	ldr	r3, [fp, #-16]
 c10b5a4:	e1a03311 	lsl	r3, r1, r3
 c10b5a8:	e1520003 	cmp	r2, r3
 c10b5ac:	0a000001 	beq	c10b5b8 <portG_write+0x90>
			return -1; // indica error
 c10b5b0:	e3e03000 	mvn	r3, #0
 c10b5b4:	ea000015 	b	c10b610 <portG_write+0xe8>

		if (val)
 c10b5b8:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10b5bc:	e3530000 	cmp	r3, #0
 c10b5c0:	0a000008 	beq	c10b5e8 <portG_write+0xc0>
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 1
			rPDATG |= 1 << pin;
 c10b5c4:	e59f3058 	ldr	r3, [pc, #88]	; c10b624 <portG_write+0xfc>
 c10b5c8:	e59f2054 	ldr	r2, [pc, #84]	; c10b624 <portG_write+0xfc>
 c10b5cc:	e5921000 	ldr	r1, [r2]
 c10b5d0:	e3a00001 	mov	r0, #1
 c10b5d4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10b5d8:	e1a02210 	lsl	r2, r0, r2
 c10b5dc:	e1812002 	orr	r2, r1, r2
 c10b5e0:	e5832000 	str	r2, [r3]
 c10b5e4:	ea000008 	b	c10b60c <portG_write+0xe4>
		else
			// COMPLETAR: poner en rPDATG el bit indicado por pin a 0
			rPDATG &= ~(1 << pin);
 c10b5e8:	e59f3034 	ldr	r3, [pc, #52]	; c10b624 <portG_write+0xfc>
 c10b5ec:	e59f2030 	ldr	r2, [pc, #48]	; c10b624 <portG_write+0xfc>
 c10b5f0:	e5921000 	ldr	r1, [r2]
 c10b5f4:	e3a00001 	mov	r0, #1
 c10b5f8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10b5fc:	e1a02210 	lsl	r2, r0, r2
 c10b600:	e1e02002 	mvn	r2, r2
 c10b604:	e0012002 	and	r2, r1, r2
 c10b608:	e5832000 	str	r2, [r3]

		return 0;
 c10b60c:	e3a03000 	mov	r3, #0
}
 c10b610:	e1a00003 	mov	r0, r3
 c10b614:	e24bd00c 	sub	sp, fp, #12
 c10b618:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b61c:	e12fff1e 	bx	lr
 c10b620:	01d20040 	.word	0x01d20040
 c10b624:	01d20044 	.word	0x01d20044

0c10b628 <portG_read>:

int portG_read(int pin, enum digital* val)
{
 c10b628:	e1a0c00d 	mov	ip, sp
 c10b62c:	e92dd800 	push	{fp, ip, lr, pc}
 c10b630:	e24cb004 	sub	fp, ip, #4
 c10b634:	e24dd010 	sub	sp, sp, #16
 c10b638:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c10b63c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
	int pos = pin*2;
 c10b640:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b644:	e1a03083 	lsl	r3, r3, #1
 c10b648:	e50b3010 	str	r3, [fp, #-16]

	if (pin < 0 || pin > 7)
 c10b64c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b650:	e3530000 	cmp	r3, #0
 c10b654:	ba000002 	blt	c10b664 <portG_read+0x3c>
 c10b658:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b65c:	e3530007 	cmp	r3, #7
 c10b660:	da000001 	ble	c10b66c <portG_read+0x44>
		return -1; // indica error
 c10b664:	e3e03000 	mvn	r3, #0
 c10b668:	ea000019 	b	c10b6d4 <portG_read+0xac>

	if (rPCONG & (0x3 << pos))
 c10b66c:	e59f3070 	ldr	r3, [pc, #112]	; c10b6e4 <portG_read+0xbc>
 c10b670:	e5932000 	ldr	r2, [r3]
 c10b674:	e3a01003 	mov	r1, #3
 c10b678:	e51b3010 	ldr	r3, [fp, #-16]
 c10b67c:	e1a03311 	lsl	r3, r1, r3
 c10b680:	e0023003 	and	r3, r2, r3
 c10b684:	e3530000 	cmp	r3, #0
 c10b688:	0a000001 	beq	c10b694 <portG_read+0x6c>
		return -1; // indica error
 c10b68c:	e3e03000 	mvn	r3, #0
 c10b690:	ea00000f 	b	c10b6d4 <portG_read+0xac>

	/*COMPLETAR: true si est√° a 1 en rPDATG el pin indicado por el par√°metro pin*/
	if (rPDATG & (1 << pin))
 c10b694:	e59f304c 	ldr	r3, [pc, #76]	; c10b6e8 <portG_read+0xc0>
 c10b698:	e5932000 	ldr	r2, [r3]
 c10b69c:	e3a01001 	mov	r1, #1
 c10b6a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10b6a4:	e1a03311 	lsl	r3, r1, r3
 c10b6a8:	e0023003 	and	r3, r2, r3
 c10b6ac:	e3530000 	cmp	r3, #0
 c10b6b0:	0a000003 	beq	c10b6c4 <portG_read+0x9c>
		*val = HIGH;
 c10b6b4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c10b6b8:	e3a02001 	mov	r2, #1
 c10b6bc:	e5c32000 	strb	r2, [r3]
 c10b6c0:	ea000002 	b	c10b6d0 <portG_read+0xa8>
	else
		*val = LOW;
 c10b6c4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c10b6c8:	e3a02000 	mov	r2, #0
 c10b6cc:	e5c32000 	strb	r2, [r3]

	return 0;
 c10b6d0:	e3a03000 	mov	r3, #0
}
 c10b6d4:	e1a00003 	mov	r0, r3
 c10b6d8:	e24bd00c 	sub	sp, fp, #12
 c10b6dc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b6e0:	e12fff1e 	bx	lr
 c10b6e4:	01d20040 	.word	0x01d20040
 c10b6e8:	01d20044 	.word	0x01d20044

0c10b6ec <portG_conf_pup>:

int portG_conf_pup(int pin, enum enable st)
{
 c10b6ec:	e1a0c00d 	mov	ip, sp
 c10b6f0:	e92dd800 	push	{fp, ip, lr, pc}
 c10b6f4:	e24cb004 	sub	fp, ip, #4
 c10b6f8:	e24dd008 	sub	sp, sp, #8
 c10b6fc:	e50b0010 	str	r0, [fp, #-16]
 c10b700:	e1a03001 	mov	r3, r1
 c10b704:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	if (pin < 0 || pin > 7)
 c10b708:	e51b3010 	ldr	r3, [fp, #-16]
 c10b70c:	e3530000 	cmp	r3, #0
 c10b710:	ba000002 	blt	c10b720 <portG_conf_pup+0x34>
 c10b714:	e51b3010 	ldr	r3, [fp, #-16]
 c10b718:	e3530007 	cmp	r3, #7
 c10b71c:	da000001 	ble	c10b728 <portG_conf_pup+0x3c>
		return -1; // indica error
 c10b720:	e3e03000 	mvn	r3, #0
 c10b724:	ea00001d 	b	c10b7a0 <portG_conf_pup+0xb4>

	if (st != ENABLE && st != DISABLE)
 c10b728:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10b72c:	e3530001 	cmp	r3, #1
 c10b730:	0a000004 	beq	c10b748 <portG_conf_pup+0x5c>
 c10b734:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10b738:	e3530000 	cmp	r3, #0
 c10b73c:	0a000001 	beq	c10b748 <portG_conf_pup+0x5c>
		return -1; // indica error
 c10b740:	e3e03000 	mvn	r3, #0
 c10b744:	ea000015 	b	c10b7a0 <portG_conf_pup+0xb4>

	if (st == ENABLE)
 c10b748:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10b74c:	e3530001 	cmp	r3, #1
 c10b750:	1a000009 	bne	c10b77c <portG_conf_pup+0x90>
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para activar la resistencia de pull-up
		rPUPG &= ~(1 << pin);
 c10b754:	e59f3054 	ldr	r3, [pc, #84]	; c10b7b0 <portG_conf_pup+0xc4>
 c10b758:	e59f2050 	ldr	r2, [pc, #80]	; c10b7b0 <portG_conf_pup+0xc4>
 c10b75c:	e5921000 	ldr	r1, [r2]
 c10b760:	e3a00001 	mov	r0, #1
 c10b764:	e51b2010 	ldr	r2, [fp, #-16]
 c10b768:	e1a02210 	lsl	r2, r0, r2
 c10b76c:	e1e02002 	mvn	r2, r2
 c10b770:	e0012002 	and	r2, r1, r2
 c10b774:	e5832000 	str	r2, [r3]
 c10b778:	ea000007 	b	c10b79c <portG_conf_pup+0xb0>
	else
		// COMPLETAR: poner el pin de rPUPG indicado por el parametro pin al valor adecuado,
		// para desactivar la resistencia de pull-up
		rPUPG |= 1 << pin;
 c10b77c:	e59f302c 	ldr	r3, [pc, #44]	; c10b7b0 <portG_conf_pup+0xc4>
 c10b780:	e59f2028 	ldr	r2, [pc, #40]	; c10b7b0 <portG_conf_pup+0xc4>
 c10b784:	e5921000 	ldr	r1, [r2]
 c10b788:	e3a00001 	mov	r0, #1
 c10b78c:	e51b2010 	ldr	r2, [fp, #-16]
 c10b790:	e1a02210 	lsl	r2, r0, r2
 c10b794:	e1812002 	orr	r2, r1, r2
 c10b798:	e5832000 	str	r2, [r3]

	return 0;
 c10b79c:	e3a03000 	mov	r3, #0
}
 c10b7a0:	e1a00003 	mov	r0, r3
 c10b7a4:	e24bd00c 	sub	sp, fp, #12
 c10b7a8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b7ac:	e12fff1e 	bx	lr
 c10b7b0:	01d20048 	.word	0x01d20048

0c10b7b4 <iic_init>:
#include "44b.h"
#include "iic.h"
#include "utils.h"

void iic_init( void )
{
 c10b7b4:	e1a0c00d 	mov	ip, sp
 c10b7b8:	e92dd800 	push	{fp, ip, lr, pc}
 c10b7bc:	e24cb004 	sub	fp, ip, #4
	//Slave Address: Undefined, always going to be master
	rIICADD = 0;
 c10b7c0:	e59f3028 	ldr	r3, [pc, #40]	; c10b7f0 <iic_init+0x3c>
 c10b7c4:	e3a02000 	mov	r2, #0
 c10b7c8:	e5832000 	str	r2, [r3]
	//*250kHz
	//IICCON[7]	  = 1   Generate ACK
	//IICCON[6]   = 0   IICCLK = MCLK / 16
	//IICCON[5]   = 1	Enable RX/TX Interrupts
	//IICCON[3:0] = 15  TxCLK = IICCLK / (15+1) = 64 MHz / 256
	rIICCON = 0xAF;
 c10b7cc:	e59f3020 	ldr	r3, [pc, #32]	; c10b7f4 <iic_init+0x40>
 c10b7d0:	e3a020af 	mov	r2, #175	; 0xaf
 c10b7d4:	e5832000 	str	r2, [r3]

	//*Transfer mode: set per transfer
	//ICCSTAT[4] = 1 read/write enable
	rIICSTAT = 0x10;
 c10b7d8:	e59f3018 	ldr	r3, [pc, #24]	; c10b7f8 <iic_init+0x44>
 c10b7dc:	e3a02010 	mov	r2, #16
 c10b7e0:	e5832000 	str	r2, [r3]
}
 c10b7e4:	e24bd00c 	sub	sp, fp, #12
 c10b7e8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b7ec:	e12fff1e 	bx	lr
 c10b7f0:	01d60008 	.word	0x01d60008
 c10b7f4:	01d60000 	.word	0x01d60000
 c10b7f8:	01d60004 	.word	0x01d60004

0c10b7fc <iic_start>:

void iic_start(enum IIC_Mode_t mode, uint8 addr)
{
 c10b7fc:	e1a0c00d 	mov	ip, sp
 c10b800:	e92dd800 	push	{fp, ip, lr, pc}
 c10b804:	e24cb004 	sub	fp, ip, #4
 c10b808:	e24dd008 	sub	sp, sp, #8
 c10b80c:	e1a02000 	mov	r2, r0
 c10b810:	e1a03001 	mov	r3, r1
 c10b814:	e54b200d 	strb	r2, [fp, #-13]
 c10b818:	e54b300e 	strb	r3, [fp, #-14]
	//Address
    rIICDS = addr;
 c10b81c:	e59f3050 	ldr	r3, [pc, #80]	; c10b874 <iic_start+0x78>
 c10b820:	e55b200e 	ldrb	r2, [fp, #-14]
 c10b824:	e5832000 	str	r2, [r3]

    //Set mode, send START signal, Serial Output enable
    rIICSTAT = mode << 6 | 0b11 << 4;
 c10b828:	e59f3048 	ldr	r3, [pc, #72]	; c10b878 <iic_start+0x7c>
 c10b82c:	e55b200d 	ldrb	r2, [fp, #-13]
 c10b830:	e1a02302 	lsl	r2, r2, #6
 c10b834:	e3822030 	orr	r2, r2, #48	; 0x30
 c10b838:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c10b83c:	e59f3038 	ldr	r3, [pc, #56]	; c10b87c <iic_start+0x80>
 c10b840:	e59f2034 	ldr	r2, [pc, #52]	; c10b87c <iic_start+0x80>
 c10b844:	e5922000 	ldr	r2, [r2]
 c10b848:	e3c22010 	bic	r2, r2, #16
 c10b84c:	e5832000 	str	r2, [r3]

    while(!( rIICCON & (1 << 4)));
 c10b850:	e1a00000 	nop			; (mov r0, r0)
 c10b854:	e59f3020 	ldr	r3, [pc, #32]	; c10b87c <iic_start+0x80>
 c10b858:	e5933000 	ldr	r3, [r3]
 c10b85c:	e2033010 	and	r3, r3, #16
 c10b860:	e3530000 	cmp	r3, #0
 c10b864:	0afffffa 	beq	c10b854 <iic_start+0x58>
}
 c10b868:	e24bd00c 	sub	sp, fp, #12
 c10b86c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b870:	e12fff1e 	bx	lr
 c10b874:	01d6000c 	.word	0x01d6000c
 c10b878:	01d60004 	.word	0x01d60004
 c10b87c:	01d60000 	.word	0x01d60000

0c10b880 <iic_putByte>:


void iic_putByte( uint8 byte )
{
 c10b880:	e1a0c00d 	mov	ip, sp
 c10b884:	e92dd800 	push	{fp, ip, lr, pc}
 c10b888:	e24cb004 	sub	fp, ip, #4
 c10b88c:	e24dd008 	sub	sp, sp, #8
 c10b890:	e1a03000 	mov	r3, r0
 c10b894:	e54b300d 	strb	r3, [fp, #-13]
    rIICDS   = byte;
 c10b898:	e59f303c 	ldr	r3, [pc, #60]	; c10b8dc <iic_putByte+0x5c>
 c10b89c:	e55b200d 	ldrb	r2, [fp, #-13]
 c10b8a0:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c10b8a4:	e59f3034 	ldr	r3, [pc, #52]	; c10b8e0 <iic_putByte+0x60>
 c10b8a8:	e59f2030 	ldr	r2, [pc, #48]	; c10b8e0 <iic_putByte+0x60>
 c10b8ac:	e5922000 	ldr	r2, [r2]
 c10b8b0:	e3c22010 	bic	r2, r2, #16
 c10b8b4:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c10b8b8:	e1a00000 	nop			; (mov r0, r0)
 c10b8bc:	e59f301c 	ldr	r3, [pc, #28]	; c10b8e0 <iic_putByte+0x60>
 c10b8c0:	e5933000 	ldr	r3, [r3]
 c10b8c4:	e2033010 	and	r3, r3, #16
 c10b8c8:	e3530000 	cmp	r3, #0
 c10b8cc:	0afffffa 	beq	c10b8bc <iic_putByte+0x3c>
}
 c10b8d0:	e24bd00c 	sub	sp, fp, #12
 c10b8d4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b8d8:	e12fff1e 	bx	lr
 c10b8dc:	01d6000c 	.word	0x01d6000c
 c10b8e0:	01d60000 	.word	0x01d60000

0c10b8e4 <iic_getByte>:

uint8 iic_getByte(enum IIC_ACK_t ack)
{
 c10b8e4:	e1a0c00d 	mov	ip, sp
 c10b8e8:	e92dd800 	push	{fp, ip, lr, pc}
 c10b8ec:	e24cb004 	sub	fp, ip, #4
 c10b8f0:	e24dd008 	sub	sp, sp, #8
 c10b8f4:	e1a03000 	mov	r3, r0
 c10b8f8:	e54b300d 	strb	r3, [fp, #-13]
	// Setup ACK or not
	if(ack == RxACK) {
 c10b8fc:	e55b300d 	ldrb	r3, [fp, #-13]
 c10b900:	e3530001 	cmp	r3, #1
 c10b904:	1a000005 	bne	c10b920 <iic_getByte+0x3c>
		//IICCON[7] = 1   Generate ACK
	    rIICCON |= 1 << 7;
 c10b908:	e59f306c 	ldr	r3, [pc, #108]	; c10b97c <iic_getByte+0x98>
 c10b90c:	e59f2068 	ldr	r2, [pc, #104]	; c10b97c <iic_getByte+0x98>
 c10b910:	e5922000 	ldr	r2, [r2]
 c10b914:	e3822080 	orr	r2, r2, #128	; 0x80
 c10b918:	e5832000 	str	r2, [r3]
 c10b91c:	ea000004 	b	c10b934 <iic_getByte+0x50>
	} else {
		//IICCON[7] = 0   Don't generate ACK
	    rIICCON &= ~(1 << 7);
 c10b920:	e59f3054 	ldr	r3, [pc, #84]	; c10b97c <iic_getByte+0x98>
 c10b924:	e59f2050 	ldr	r2, [pc, #80]	; c10b97c <iic_getByte+0x98>
 c10b928:	e5922000 	ldr	r2, [r2]
 c10b92c:	e3c22080 	bic	r2, r2, #128	; 0x80
 c10b930:	e5832000 	str	r2, [r3]
	}

    //rIICCON[4] = 0  start transmission
    rIICCON &= ~(1 << 4);
 c10b934:	e59f3040 	ldr	r3, [pc, #64]	; c10b97c <iic_getByte+0x98>
 c10b938:	e59f203c 	ldr	r2, [pc, #60]	; c10b97c <iic_getByte+0x98>
 c10b93c:	e5922000 	ldr	r2, [r2]
 c10b940:	e3c22010 	bic	r2, r2, #16
 c10b944:	e5832000 	str	r2, [r3]
    while(!( rIICCON & (1 << 4)));
 c10b948:	e1a00000 	nop			; (mov r0, r0)
 c10b94c:	e59f3028 	ldr	r3, [pc, #40]	; c10b97c <iic_getByte+0x98>
 c10b950:	e5933000 	ldr	r3, [r3]
 c10b954:	e2033010 	and	r3, r3, #16
 c10b958:	e3530000 	cmp	r3, #0
 c10b95c:	0afffffa 	beq	c10b94c <iic_getByte+0x68>

    return rIICDS;
 c10b960:	e59f3018 	ldr	r3, [pc, #24]	; c10b980 <iic_getByte+0x9c>
 c10b964:	e5933000 	ldr	r3, [r3]
 c10b968:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c10b96c:	e1a00003 	mov	r0, r3
 c10b970:	e24bd00c 	sub	sp, fp, #12
 c10b974:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b978:	e12fff1e 	bx	lr
 c10b97c:	01d60000 	.word	0x01d60000
 c10b980:	01d6000c 	.word	0x01d6000c

0c10b984 <iic_stop>:

void iic_stop( uint16 ms )
{
 c10b984:	e1a0c00d 	mov	ip, sp
 c10b988:	e92dd800 	push	{fp, ip, lr, pc}
 c10b98c:	e24cb004 	sub	fp, ip, #4
 c10b990:	e24dd008 	sub	sp, sp, #8
 c10b994:	e1a03000 	mov	r3, r0
 c10b998:	e14b30be 	strh	r3, [fp, #-14]
	//Generate STOP signal (ICCSTAT[5]=0)
    rIICSTAT &= ~(1 << 5);
 c10b99c:	e59f3038 	ldr	r3, [pc, #56]	; c10b9dc <iic_stop+0x58>
 c10b9a0:	e59f2034 	ldr	r2, [pc, #52]	; c10b9dc <iic_stop+0x58>
 c10b9a4:	e5922000 	ldr	r2, [r2]
 c10b9a8:	e3c22020 	bic	r2, r2, #32
 c10b9ac:	e5832000 	str	r2, [r3]

    //rIICCON[4] = 0  start transmission of STOP signal
    rIICCON &= ~(1 << 4);
 c10b9b0:	e59f3028 	ldr	r3, [pc, #40]	; c10b9e0 <iic_stop+0x5c>
 c10b9b4:	e59f2024 	ldr	r2, [pc, #36]	; c10b9e0 <iic_stop+0x5c>
 c10b9b8:	e5922000 	ldr	r2, [r2]
 c10b9bc:	e3c22010 	bic	r2, r2, #16
 c10b9c0:	e5832000 	str	r2, [r3]

    Delay(ms);
 c10b9c4:	e15b30be 	ldrh	r3, [fp, #-14]
 c10b9c8:	e1a00003 	mov	r0, r3
 c10b9cc:	eb000e27 	bl	c10f270 <Delay>
}
 c10b9d0:	e24bd00c 	sub	sp, fp, #12
 c10b9d4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10b9d8:	e12fff1e 	bx	lr
 c10b9dc:	01d60004 	.word	0x01d60004
 c10b9e0:	01d60000 	.word	0x01d60000

0c10b9e4 <start>:
	.equ rEXTINTPND, 0x1d20054

start:

	/* Pasa a modo supervisor */
    mrs	r0, cpsr
 c10b9e4:	e10f0000 	mrs	r0, CPSR
    bic	r0, r0, #MODEMASK
 c10b9e8:	e3c0001f 	bic	r0, r0, #31
    orr	r1, r0, #SVCMODE
 c10b9ec:	e3801013 	orr	r1, r0, #19
    msr	cpsr_c, r1 
 c10b9f0:	e121f001 	msr	CPSR_c, r1

	/* Inicializaci√≥n de la secci√≥n bss a 0, est√°ndar C */
    ldr	    r3, =Image_ZI_Base
 c10b9f4:	e59f30b8 	ldr	r3, [pc, #184]	; c10bab4 <InitStacks+0x48>
	ldr	    r1, =Image_ZI_Limit	/* Top of zero init segment */
 c10b9f8:	e59f10b8 	ldr	r1, [pc, #184]	; c10bab8 <InitStacks+0x4c>
    mov	    r2, #0
 c10b9fc:	e3a02000 	mov	r2, #0

0c10ba00 <L0>:
L0:
    cmp	    r3, r1	    		/* Zero init */
 c10ba00:	e1530001 	cmp	r3, r1
    strcc   r2, [r3], #4
 c10ba04:	34832004 	strcc	r2, [r3], #4
    bcc	    L0
 c10ba08:	3afffffc 	bcc	c10ba00 <L0>
	/****************************************************/

	/* Desde modo SVC inicializa los SP de todos los modos de ejecuciÔøΩn privilegiados */
    bl InitStacks
 c10ba0c:	eb000016 	bl	c10ba6c <InitStacks>

	ldr r0, =rEXTINTPND
 c10ba10:	e59f00a4 	ldr	r0, [pc, #164]	; c10babc <InitStacks+0x50>
	ldr r1, =0xff
 c10ba14:	e3a010ff 	mov	r1, #255	; 0xff
	str r1, [r0]
 c10ba18:	e5801000 	str	r1, [r0]
	ldr r0, =rI_ISPC
 c10ba1c:	e59f009c 	ldr	r0, [pc, #156]	; c10bac0 <InitStacks+0x54>
	ldr r1, =0x1fffffff
 c10ba20:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c10ba24:	e5801000 	str	r1, [r0]
	ldr r0, =rF_ISPC
 c10ba28:	e59f0094 	ldr	r0, [pc, #148]	; c10bac4 <InitStacks+0x58>
	ldr r1, =0x1fffffff
 c10ba2c:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
	str r1, [r0]
 c10ba30:	e5801000 	str	r1, [r0]

	/* Enmascara interrupciones */
	ldr r0, =rINTMSK
 c10ba34:	e59f008c 	ldr	r0, [pc, #140]	; c10bac8 <InitStacks+0x5c>
	ldr r1, =0x1fffffff
 c10ba38:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
    str r1, [r0]
 c10ba3c:	e5801000 	str	r1, [r0]

	/* Habilita linea IRQ y FIQ del CPSR */
	mrs r0, cpsr
 c10ba40:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #0xC0
 c10ba44:	e3c000c0 	bic	r0, r0, #192	; 0xc0
	msr cpsr_c, r0
 c10ba48:	e121f000 	msr	CPSR_c, r0
	
	/* Desde modo SVC cambia a modo USR e inicializa el SP_usr */
	mrs r0, cpsr
 c10ba4c:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c10ba50:	e3c0001f 	bic	r0, r0, #31
	orr r1, r0, #USRMODE  
 c10ba54:	e3801010 	orr	r1, r0, #16
	msr cpsr_c, r1
 c10ba58:	e121f001 	msr	CPSR_c, r1
	ldr sp, =USRSTACK
 c10ba5c:	e59fd068 	ldr	sp, [pc, #104]	; c10bacc <InitStacks+0x60>

    mov fp, #0
 c10ba60:	e3a0b000 	mov	fp, #0

    bl main
 c10ba64:	eb000753 	bl	c10d7b8 <main>

0c10ba68 <End>:
End:
    B End
 c10ba68:	eafffffe 	b	c10ba68 <End>

0c10ba6c <InitStacks>:

InitStacks:
	mrs r0, cpsr
 c10ba6c:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #MODEMASK
 c10ba70:	e3c0001f 	bic	r0, r0, #31

	orr r1, r0, #UNDMODE  /* desde modo SVC cambia a modo UND e inicializa el SP_und */
 c10ba74:	e380101b 	orr	r1, r0, #27
	msr cpsr_c, r1    
 c10ba78:	e121f001 	msr	CPSR_c, r1
	ldr sp, =UNDSTACK
 c10ba7c:	e59fd04c 	ldr	sp, [pc, #76]	; c10bad0 <InitStacks+0x64>

	orr r1, r0, #ABTMODE  /* desde modo UND cambia a modo ABT e inicializa el SP_abt */
 c10ba80:	e3801017 	orr	r1, r0, #23
	msr cpsr_c, r1 
 c10ba84:	e121f001 	msr	CPSR_c, r1
	ldr sp, =ABTSTACK
 c10ba88:	e59fd044 	ldr	sp, [pc, #68]	; c10bad4 <InitStacks+0x68>

	orr r1, r0, #IRQMODE  /* desde modo ABT cambia a modo IRQ e inicializa el SP_abt */
 c10ba8c:	e3801012 	orr	r1, r0, #18
	msr cpsr_c, r1
 c10ba90:	e121f001 	msr	CPSR_c, r1
	ldr sp, =IRQSTACK
 c10ba94:	e59fd03c 	ldr	sp, [pc, #60]	; c10bad8 <InitStacks+0x6c>

	orr r1, r0, #FIQMODE  /* desde modo IRQ cambia a modo FIQ e inicializa el SP_fiq */
 c10ba98:	e3801011 	orr	r1, r0, #17
	msr cpsr_c, r1
 c10ba9c:	e121f001 	msr	CPSR_c, r1
	ldr sp, =FIQSTACK
 c10baa0:	e59fd034 	ldr	sp, [pc, #52]	; c10badc <InitStacks+0x70>

	orr r1, r0, #SVCMODE  /* desde modo FIQ cambia a modo SVC e inicializa el SP_svc */
 c10baa4:	e3801013 	orr	r1, r0, #19
	msr cpsr_c, r1
 c10baa8:	e121f001 	msr	CPSR_c, r1
	ldr sp, =SVCSTACK
 c10baac:	e59fd02c 	ldr	sp, [pc, #44]	; c10bae0 <InitStacks+0x74>
	
    mov pc, lr
 c10bab0:	e1a0f00e 	mov	pc, lr
 c10bab4:	0c1013d4 	.word	0x0c1013d4
 c10bab8:	0c10a9f0 	.word	0x0c10a9f0
 c10babc:	01d20054 	.word	0x01d20054
 c10bac0:	01e00024 	.word	0x01e00024
 c10bac4:	01e0003c 	.word	0x01e0003c
 c10bac8:	01e0000c 	.word	0x01e0000c
 c10bacc:	0c7ff000 	.word	0x0c7ff000
 c10bad0:	0c7ff200 	.word	0x0c7ff200
 c10bad4:	0c7ff300 	.word	0x0c7ff300
 c10bad8:	0c7ff400 	.word	0x0c7ff400
 c10badc:	0c7ff500 	.word	0x0c7ff500
 c10bae0:	0c7ff100 	.word	0x0c7ff100

0c10bae4 <ic_init>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "intcontroller.h"

void ic_init(void)
{
 c10bae4:	e1a0c00d 	mov	ip, sp
 c10bae8:	e92dd800 	push	{fp, ip, lr, pc}
 c10baec:	e24cb004 	sub	fp, ip, #4
	 *    Lineas IRQ y FIQ no habilitadas
	 *    Linea IRQ en modo no vectorizado
	 *    Todo por la l√≠nea IRQ
	 *    Todas las interrupciones enmascaradas
	 **/
	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 c10baf0:	e59f3028 	ldr	r3, [pc, #40]	; c10bb20 <ic_init+0x3c>
 c10baf4:	e3a02000 	mov	r2, #0
 c10baf8:	e5832000 	str	r2, [r3]
	rINTCON = 0x7; // IRQ y FIQ enmascaradas, IRQ en modo no vectorizado
 c10bafc:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c10bb00:	e3a02007 	mov	r2, #7
 c10bb04:	e5832000 	str	r2, [r3]
	rINTMSK = ~(0x0); // Enmascara todas las lineas
 c10bb08:	e59f3014 	ldr	r3, [pc, #20]	; c10bb24 <ic_init+0x40>
 c10bb0c:	e3e02000 	mvn	r2, #0
 c10bb10:	e5832000 	str	r2, [r3]
}
 c10bb14:	e24bd00c 	sub	sp, fp, #12
 c10bb18:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bb1c:	e12fff1e 	bx	lr
 c10bb20:	01e00008 	.word	0x01e00008
 c10bb24:	01e0000c 	.word	0x01e0000c

0c10bb28 <ic_conf_irq>:

int ic_conf_irq(enum enable st, enum int_vec vec)
{
 c10bb28:	e1a0c00d 	mov	ip, sp
 c10bb2c:	e92dd800 	push	{fp, ip, lr, pc}
 c10bb30:	e24cb004 	sub	fp, ip, #4
 c10bb34:	e24dd010 	sub	sp, sp, #16
 c10bb38:	e1a02000 	mov	r2, r0
 c10bb3c:	e1a03001 	mov	r3, r1
 c10bb40:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c10bb44:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int conf = rINTCON;
 c10bb48:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c10bb4c:	e5933000 	ldr	r3, [r3]
 c10bb50:	e50b3010 	str	r3, [fp, #-16]

	if (st != ENABLE && st != DISABLE)
 c10bb54:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bb58:	e3530001 	cmp	r3, #1
 c10bb5c:	0a000004 	beq	c10bb74 <ic_conf_irq+0x4c>
 c10bb60:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bb64:	e3530000 	cmp	r3, #0
 c10bb68:	0a000001 	beq	c10bb74 <ic_conf_irq+0x4c>
		return -1;
 c10bb6c:	e3e03000 	mvn	r3, #0
 c10bb70:	ea000017 	b	c10bbd4 <ic_conf_irq+0xac>

	if (vec == VEC)
 c10bb74:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10bb78:	e3530000 	cmp	r3, #0
 c10bb7c:	1a000003 	bne	c10bb90 <ic_conf_irq+0x68>
		//COMPLETAR: poner la linea IRQ en modo vectorizado
		conf &= ~(1 << 2);
 c10bb80:	e51b3010 	ldr	r3, [fp, #-16]
 c10bb84:	e3c33004 	bic	r3, r3, #4
 c10bb88:	e50b3010 	str	r3, [fp, #-16]
 c10bb8c:	ea000002 	b	c10bb9c <ic_conf_irq+0x74>
	else
		//COMPLETAR: poner la linea IRQ en modo no vectorizado
		conf |= 1 << 2;
 c10bb90:	e51b3010 	ldr	r3, [fp, #-16]
 c10bb94:	e3833004 	orr	r3, r3, #4
 c10bb98:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c10bb9c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bba0:	e3530001 	cmp	r3, #1
 c10bba4:	1a000003 	bne	c10bbb8 <ic_conf_irq+0x90>
		//COMPLETAR: habilitar la linea IRQ
		conf &= ~(1 << 1);
 c10bba8:	e51b3010 	ldr	r3, [fp, #-16]
 c10bbac:	e3c33002 	bic	r3, r3, #2
 c10bbb0:	e50b3010 	str	r3, [fp, #-16]
 c10bbb4:	ea000002 	b	c10bbc4 <ic_conf_irq+0x9c>
	else
		//COMPLETAR: deshabilitar la linea IRQ
		conf |= 1 << 1;
 c10bbb8:	e51b3010 	ldr	r3, [fp, #-16]
 c10bbbc:	e3833002 	orr	r3, r3, #2
 c10bbc0:	e50b3010 	str	r3, [fp, #-16]

	rINTCON = conf;
 c10bbc4:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c10bbc8:	e51b2010 	ldr	r2, [fp, #-16]
 c10bbcc:	e5832000 	str	r2, [r3]
	return 0;
 c10bbd0:	e3a03000 	mov	r3, #0
}
 c10bbd4:	e1a00003 	mov	r0, r3
 c10bbd8:	e24bd00c 	sub	sp, fp, #12
 c10bbdc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bbe0:	e12fff1e 	bx	lr

0c10bbe4 <ic_conf_fiq>:

int ic_conf_fiq(enum enable st)
{
 c10bbe4:	e1a0c00d 	mov	ip, sp
 c10bbe8:	e92dd800 	push	{fp, ip, lr, pc}
 c10bbec:	e24cb004 	sub	fp, ip, #4
 c10bbf0:	e24dd010 	sub	sp, sp, #16
 c10bbf4:	e1a03000 	mov	r3, r0
 c10bbf8:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c10bbfc:	e3a03000 	mov	r3, #0
 c10bc00:	e50b3010 	str	r3, [fp, #-16]

	if (st == ENABLE)
 c10bc04:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bc08:	e3530001 	cmp	r3, #1
 c10bc0c:	1a000005 	bne	c10bc28 <ic_conf_fiq+0x44>
		//COMPLETAR: habilitar la linea FIQ
		rINTCON &= ~(1 << 0);
 c10bc10:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c10bc14:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c10bc18:	e5922000 	ldr	r2, [r2]
 c10bc1c:	e3c22001 	bic	r2, r2, #1
 c10bc20:	e5832000 	str	r2, [r3]
 c10bc24:	ea00000a 	b	c10bc54 <ic_conf_fiq+0x70>
	else if (st == DISABLE)
 c10bc28:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bc2c:	e3530000 	cmp	r3, #0
 c10bc30:	1a000005 	bne	c10bc4c <ic_conf_fiq+0x68>
		//COMPLETAR: deshabilitar la linea FIQ
		rINTCON |= 1 << 0;
 c10bc34:	e3a0361e 	mov	r3, #31457280	; 0x1e00000
 c10bc38:	e3a0261e 	mov	r2, #31457280	; 0x1e00000
 c10bc3c:	e5922000 	ldr	r2, [r2]
 c10bc40:	e3822001 	orr	r2, r2, #1
 c10bc44:	e5832000 	str	r2, [r3]
 c10bc48:	ea000001 	b	c10bc54 <ic_conf_fiq+0x70>
	else
		ret = -1;
 c10bc4c:	e3e03000 	mvn	r3, #0
 c10bc50:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c10bc54:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10bc58:	e1a00003 	mov	r0, r3
 c10bc5c:	e24bd00c 	sub	sp, fp, #12
 c10bc60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bc64:	e12fff1e 	bx	lr

0c10bc68 <ic_conf_line>:

int ic_conf_line(enum int_line line, enum int_mode mode)
{
 c10bc68:	e1a0c00d 	mov	ip, sp
 c10bc6c:	e92dd800 	push	{fp, ip, lr, pc}
 c10bc70:	e24cb004 	sub	fp, ip, #4
 c10bc74:	e24dd010 	sub	sp, sp, #16
 c10bc78:	e1a02000 	mov	r2, r0
 c10bc7c:	e1a03001 	mov	r3, r1
 c10bc80:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c10bc84:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	unsigned int bit = INT_BIT(line);
 c10bc88:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bc8c:	e3a02001 	mov	r2, #1
 c10bc90:	e1a03312 	lsl	r3, r2, r3
 c10bc94:	e50b3010 	str	r3, [fp, #-16]

	if (line < 0 || line > 26)
 c10bc98:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10bc9c:	e353001a 	cmp	r3, #26
 c10bca0:	9a000001 	bls	c10bcac <ic_conf_line+0x44>
		return -1;
 c10bca4:	e3e03000 	mvn	r3, #0
 c10bca8:	ea000019 	b	c10bd14 <ic_conf_line+0xac>

	if (mode != IRQ && mode != FIQ)
 c10bcac:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10bcb0:	e3530000 	cmp	r3, #0
 c10bcb4:	0a000004 	beq	c10bccc <ic_conf_line+0x64>
 c10bcb8:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10bcbc:	e3530001 	cmp	r3, #1
 c10bcc0:	0a000001 	beq	c10bccc <ic_conf_line+0x64>
		return -1;
 c10bcc4:	e3e03000 	mvn	r3, #0
 c10bcc8:	ea000011 	b	c10bd14 <ic_conf_line+0xac>

	if (mode == IRQ)
 c10bccc:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10bcd0:	e3530000 	cmp	r3, #0
 c10bcd4:	1a000007 	bne	c10bcf8 <ic_conf_line+0x90>
		//COMPLETAR: poner la linea line en modo IRQ
		rINTMOD &= ~bit;
 c10bcd8:	e59f3044 	ldr	r3, [pc, #68]	; c10bd24 <ic_conf_line+0xbc>
 c10bcdc:	e59f2040 	ldr	r2, [pc, #64]	; c10bd24 <ic_conf_line+0xbc>
 c10bce0:	e5921000 	ldr	r1, [r2]
 c10bce4:	e51b2010 	ldr	r2, [fp, #-16]
 c10bce8:	e1e02002 	mvn	r2, r2
 c10bcec:	e0012002 	and	r2, r1, r2
 c10bcf0:	e5832000 	str	r2, [r3]
 c10bcf4:	ea000005 	b	c10bd10 <ic_conf_line+0xa8>
	else
		//COMPLETAR: poner la linea line en modo FIQ
		rINTMOD |= bit;
 c10bcf8:	e59f3024 	ldr	r3, [pc, #36]	; c10bd24 <ic_conf_line+0xbc>
 c10bcfc:	e59f2020 	ldr	r2, [pc, #32]	; c10bd24 <ic_conf_line+0xbc>
 c10bd00:	e5921000 	ldr	r1, [r2]
 c10bd04:	e51b2010 	ldr	r2, [fp, #-16]
 c10bd08:	e1812002 	orr	r2, r1, r2
 c10bd0c:	e5832000 	str	r2, [r3]
	return 0;
 c10bd10:	e3a03000 	mov	r3, #0
}
 c10bd14:	e1a00003 	mov	r0, r3
 c10bd18:	e24bd00c 	sub	sp, fp, #12
 c10bd1c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bd20:	e12fff1e 	bx	lr
 c10bd24:	01e00008 	.word	0x01e00008

0c10bd28 <ic_enable>:

int ic_enable(enum int_line line)
{
 c10bd28:	e1a0c00d 	mov	ip, sp
 c10bd2c:	e92dd800 	push	{fp, ip, lr, pc}
 c10bd30:	e24cb004 	sub	fp, ip, #4
 c10bd34:	e24dd008 	sub	sp, sp, #8
 c10bd38:	e1a03000 	mov	r3, r0
 c10bd3c:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c10bd40:	e55b300d 	ldrb	r3, [fp, #-13]
 c10bd44:	e353001a 	cmp	r3, #26
 c10bd48:	9a000001 	bls	c10bd54 <ic_enable+0x2c>
		return -1;
 c10bd4c:	e3e03000 	mvn	r3, #0
 c10bd50:	ea000009 	b	c10bd7c <ic_enable+0x54>

	//COMPLETAR: habilitar las interrupciones por la linea line
	rINTMSK &= ~(1 << line);
 c10bd54:	e59f3030 	ldr	r3, [pc, #48]	; c10bd8c <ic_enable+0x64>
 c10bd58:	e59f202c 	ldr	r2, [pc, #44]	; c10bd8c <ic_enable+0x64>
 c10bd5c:	e5921000 	ldr	r1, [r2]
 c10bd60:	e55b200d 	ldrb	r2, [fp, #-13]
 c10bd64:	e3a00001 	mov	r0, #1
 c10bd68:	e1a02210 	lsl	r2, r0, r2
 c10bd6c:	e1e02002 	mvn	r2, r2
 c10bd70:	e0012002 	and	r2, r1, r2
 c10bd74:	e5832000 	str	r2, [r3]
	return 0;
 c10bd78:	e3a03000 	mov	r3, #0
}
 c10bd7c:	e1a00003 	mov	r0, r3
 c10bd80:	e24bd00c 	sub	sp, fp, #12
 c10bd84:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bd88:	e12fff1e 	bx	lr
 c10bd8c:	01e0000c 	.word	0x01e0000c

0c10bd90 <ic_disable>:

int ic_disable(enum int_line line)
{
 c10bd90:	e1a0c00d 	mov	ip, sp
 c10bd94:	e92dd800 	push	{fp, ip, lr, pc}
 c10bd98:	e24cb004 	sub	fp, ip, #4
 c10bd9c:	e24dd008 	sub	sp, sp, #8
 c10bda0:	e1a03000 	mov	r3, r0
 c10bda4:	e54b300d 	strb	r3, [fp, #-13]
	if (line < 0 || line > 26)
 c10bda8:	e55b300d 	ldrb	r3, [fp, #-13]
 c10bdac:	e353001a 	cmp	r3, #26
 c10bdb0:	9a000001 	bls	c10bdbc <ic_disable+0x2c>
		return -1;
 c10bdb4:	e3e03000 	mvn	r3, #0
 c10bdb8:	ea000008 	b	c10bde0 <ic_disable+0x50>

	//COMPLETAR: enmascarar las interrupciones por la linea line
	rINTMSK |= 1 << line;
 c10bdbc:	e59f302c 	ldr	r3, [pc, #44]	; c10bdf0 <ic_disable+0x60>
 c10bdc0:	e59f2028 	ldr	r2, [pc, #40]	; c10bdf0 <ic_disable+0x60>
 c10bdc4:	e5921000 	ldr	r1, [r2]
 c10bdc8:	e55b200d 	ldrb	r2, [fp, #-13]
 c10bdcc:	e3a00001 	mov	r0, #1
 c10bdd0:	e1a02210 	lsl	r2, r0, r2
 c10bdd4:	e1812002 	orr	r2, r1, r2
 c10bdd8:	e5832000 	str	r2, [r3]
	return 0;
 c10bddc:	e3a03000 	mov	r3, #0
}
 c10bde0:	e1a00003 	mov	r0, r3
 c10bde4:	e24bd00c 	sub	sp, fp, #12
 c10bde8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10bdec:	e12fff1e 	bx	lr
 c10bdf0:	01e0000c 	.word	0x01e0000c

0c10bdf4 <ic_cleanflag>:

int ic_cleanflag(enum int_line line)
{
 c10bdf4:	e1a0c00d 	mov	ip, sp
 c10bdf8:	e92dd800 	push	{fp, ip, lr, pc}
 c10bdfc:	e24cb004 	sub	fp, ip, #4
 c10be00:	e24dd010 	sub	sp, sp, #16
 c10be04:	e1a03000 	mov	r3, r0
 c10be08:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int bit;

	if (line < 0 || line > 26)
 c10be0c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10be10:	e353001a 	cmp	r3, #26
 c10be14:	9a000001 	bls	c10be20 <ic_cleanflag+0x2c>
		return -1;
 c10be18:	e3e03000 	mvn	r3, #0
 c10be1c:	ea000017 	b	c10be80 <ic_cleanflag+0x8c>

	bit = INT_BIT(line);
 c10be20:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10be24:	e3a02001 	mov	r2, #1
 c10be28:	e1a03312 	lsl	r3, r2, r3
 c10be2c:	e50b3010 	str	r3, [fp, #-16]

	if (rINTMOD & bit)
 c10be30:	e59f3058 	ldr	r3, [pc, #88]	; c10be90 <ic_cleanflag+0x9c>
 c10be34:	e5932000 	ldr	r2, [r3]
 c10be38:	e51b3010 	ldr	r3, [fp, #-16]
 c10be3c:	e0023003 	and	r3, r2, r3
 c10be40:	e3530000 	cmp	r3, #0
 c10be44:	0a000006 	beq	c10be64 <ic_cleanflag+0x70>
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por FIQ
		rF_ISPC |= bit;
 c10be48:	e59f3044 	ldr	r3, [pc, #68]	; c10be94 <ic_cleanflag+0xa0>
 c10be4c:	e59f2040 	ldr	r2, [pc, #64]	; c10be94 <ic_cleanflag+0xa0>
 c10be50:	e5921000 	ldr	r1, [r2]
 c10be54:	e51b2010 	ldr	r2, [fp, #-16]
 c10be58:	e1812002 	orr	r2, r1, r2
 c10be5c:	e5832000 	str	r2, [r3]
 c10be60:	ea000005 	b	c10be7c <ic_cleanflag+0x88>
	else
		//COMPLETAR: borrar el flag de interrupcion correspondiente a la linea line
		//con la linea configurada por IRQ
		rI_ISPC |= bit;
 c10be64:	e59f302c 	ldr	r3, [pc, #44]	; c10be98 <ic_cleanflag+0xa4>
 c10be68:	e59f2028 	ldr	r2, [pc, #40]	; c10be98 <ic_cleanflag+0xa4>
 c10be6c:	e5921000 	ldr	r1, [r2]
 c10be70:	e51b2010 	ldr	r2, [fp, #-16]
 c10be74:	e1812002 	orr	r2, r1, r2
 c10be78:	e5832000 	str	r2, [r3]
	return 0;
 c10be7c:	e3a03000 	mov	r3, #0
}
 c10be80:	e1a00003 	mov	r0, r3
 c10be84:	e24bd00c 	sub	sp, fp, #12
 c10be88:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10be8c:	e12fff1e 	bx	lr
 c10be90:	01e00008 	.word	0x01e00008
 c10be94:	01e0003c 	.word	0x01e0003c
 c10be98:	01e00024 	.word	0x01e00024

0c10be9c <kb_scan>:
/*--- Variables globales ---*/
volatile static unsigned char *keyboard_base = (unsigned char *)0x06000000;


int kb_scan(void)
{
 c10be9c:	e1a0c00d 	mov	ip, sp
 c10bea0:	e92dd810 	push	{r4, fp, ip, lr, pc}
 c10bea4:	e24cb004 	sub	fp, ip, #4
 c10bea8:	e24dd064 	sub	sp, sp, #100	; 0x64
	int value = -1;
 c10beac:	e3e03000 	mvn	r3, #0
 c10beb0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	int i;
	char temp;
	int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};
 c10beb4:	e59f3178 	ldr	r3, [pc, #376]	; c10c034 <kb_scan+0x198>
 c10beb8:	e24bc030 	sub	ip, fp, #48	; 0x30
 c10bebc:	e893000f 	ldm	r3, {r0, r1, r2, r3}
 c10bec0:	e88c000f 	stm	ip, {r0, r1, r2, r3}
	int map[4][4] = {{0, 1, 2, 3},
 c10bec4:	e59f316c 	ldr	r3, [pc, #364]	; c10c038 <kb_scan+0x19c>
 c10bec8:	e24bc070 	sub	ip, fp, #112	; 0x70
 c10becc:	e1a04003 	mov	r4, r3
 c10bed0:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c10bed4:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c10bed8:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c10bedc:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c10bee0:	e8b4000f 	ldm	r4!, {r0, r1, r2, r3}
 c10bee4:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
 c10bee8:	e894000f 	ldm	r4, {r0, r1, r2, r3}
 c10beec:	e88c000f 	stm	ip, {r0, r1, r2, r3}
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c10bef0:	e3a03000 	mov	r3, #0
 c10bef4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10bef8:	ea000042 	b	c10c008 <kb_scan+0x16c>
		temp = *(keyboard_base+lines[i]);
 c10befc:	e59f3138 	ldr	r3, [pc, #312]	; c10c03c <kb_scan+0x1a0>
 c10bf00:	e5932000 	ldr	r2, [r3]
 c10bf04:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
 c10bf08:	e3e0301b 	mvn	r3, #27
 c10bf0c:	e1a01101 	lsl	r1, r1, #2
 c10bf10:	e24b0014 	sub	r0, fp, #20
 c10bf14:	e0801001 	add	r1, r0, r1
 c10bf18:	e0813003 	add	r3, r1, r3
 c10bf1c:	e5933000 	ldr	r3, [r3]
 c10bf20:	e0823003 	add	r3, r2, r3
 c10bf24:	e5d33000 	ldrb	r3, [r3]
 c10bf28:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3

		if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {
 c10bf2c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c10bf30:	e203300f 	and	r3, r3, #15
 c10bf34:	e353000f 	cmp	r3, #15
 c10bf38:	0a00002f 	beq	c10bffc <kb_scan+0x160>
			//COMPLETAR: 
			//      si est√° el bit 1 a 0 la tecla es la map[i][3]
			//      si est√° el bit 2 a 0 la tecla es la map[i][2]
			//      si est√° el bit 3 a 0 la tecla es la map[i][1]
			//      si est√° el bit 4 a 0 la tecla es la map[i][0]
			if(!(temp & 1 << 0)) {
 c10bf3c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c10bf40:	e2033001 	and	r3, r3, #1
 c10bf44:	e3530000 	cmp	r3, #0
 c10bf48:	1a000007 	bne	c10bf6c <kb_scan+0xd0>
				return map[i][3];
 c10bf4c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10bf50:	e3e0304f 	mvn	r3, #79	; 0x4f
 c10bf54:	e1a02202 	lsl	r2, r2, #4
 c10bf58:	e24b1014 	sub	r1, fp, #20
 c10bf5c:	e0812002 	add	r2, r1, r2
 c10bf60:	e0823003 	add	r3, r2, r3
 c10bf64:	e5933000 	ldr	r3, [r3]
 c10bf68:	ea00002d 	b	c10c024 <kb_scan+0x188>
			}

			if(!(temp & 1 << 1)) {
 c10bf6c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c10bf70:	e2033002 	and	r3, r3, #2
 c10bf74:	e3530000 	cmp	r3, #0
 c10bf78:	1a000007 	bne	c10bf9c <kb_scan+0x100>
				return map[i][2];
 c10bf7c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10bf80:	e3e03053 	mvn	r3, #83	; 0x53
 c10bf84:	e1a02202 	lsl	r2, r2, #4
 c10bf88:	e24b0014 	sub	r0, fp, #20
 c10bf8c:	e0802002 	add	r2, r0, r2
 c10bf90:	e0823003 	add	r3, r2, r3
 c10bf94:	e5933000 	ldr	r3, [r3]
 c10bf98:	ea000021 	b	c10c024 <kb_scan+0x188>
			}

			if(!(temp & 1 << 2)) {
 c10bf9c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c10bfa0:	e2033004 	and	r3, r3, #4
 c10bfa4:	e3530000 	cmp	r3, #0
 c10bfa8:	1a000007 	bne	c10bfcc <kb_scan+0x130>
				return map[i][1];
 c10bfac:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10bfb0:	e3e03057 	mvn	r3, #87	; 0x57
 c10bfb4:	e1a02202 	lsl	r2, r2, #4
 c10bfb8:	e24b1014 	sub	r1, fp, #20
 c10bfbc:	e0812002 	add	r2, r1, r2
 c10bfc0:	e0823003 	add	r3, r2, r3
 c10bfc4:	e5933000 	ldr	r3, [r3]
 c10bfc8:	ea000015 	b	c10c024 <kb_scan+0x188>
			}

			if(!(temp & 1 << 3)) {
 c10bfcc:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
 c10bfd0:	e2033008 	and	r3, r3, #8
 c10bfd4:	e3530000 	cmp	r3, #0
 c10bfd8:	1a000007 	bne	c10bffc <kb_scan+0x160>
				return map[i][0];
 c10bfdc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10bfe0:	e3e0305b 	mvn	r3, #91	; 0x5b
 c10bfe4:	e1a02202 	lsl	r2, r2, #4
 c10bfe8:	e24b0014 	sub	r0, fp, #20
 c10bfec:	e0802002 	add	r2, r0, r2
 c10bff0:	e0823003 	add	r3, r2, r3
 c10bff4:	e5933000 	ldr	r3, [r3]
 c10bff8:	ea000009 	b	c10c024 <kb_scan+0x188>
	int map[4][4] = {{0, 1, 2, 3},
					{4, 5, 6, 7},
					{8, 9, 0xA, 0xB},
					{0xC, 0xD, 0xE, 0xF}};

	for (i = 0; (i < 4) && (value == -1); i++) {
 c10bffc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c000:	e2833001 	add	r3, r3, #1
 c10c004:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10c008:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c00c:	e3530003 	cmp	r3, #3
 c10c010:	ca000002 	bgt	c10c020 <kb_scan+0x184>
 c10c014:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c10c018:	e3730001 	cmn	r3, #1
 c10c01c:	0affffb6 	beq	c10befc <kb_scan+0x60>
			}

	}
	}

	return value;
 c10c020:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
 c10c024:	e1a00003 	mov	r0, r3
 c10c028:	e24bd010 	sub	sp, fp, #16
 c10c02c:	e89d6810 	ldm	sp, {r4, fp, sp, lr}
 c10c030:	e12fff1e 	bx	lr
 c10c034:	0c101068 	.word	0x0c101068
 c10c038:	0c101078 	.word	0x0c101078
 c10c03c:	0c100060 	.word	0x0c100060

0c10c040 <lcd_init>:
static uint8 lcd_buffer[LCD_BUFFER_SIZE];

static uint8 state;

void lcd_init( void )
{
 c10c040:	e1a0c00d 	mov	ip, sp
 c10c044:	e92dd800 	push	{fp, ip, lr, pc}
 c10c048:	e24cb004 	sub	fp, ip, #4
	//Initialize dithering patterns to recommended patterns
	rDITHMODE = 0x12210;
 c10c04c:	e59f30fc 	ldr	r3, [pc, #252]	; c10c150 <lcd_init+0x110>
 c10c050:	e59f20fc 	ldr	r2, [pc, #252]	; c10c154 <lcd_init+0x114>
 c10c054:	e5832000 	str	r2, [r3]
	rDP1_2 = 0xA5A5;
 c10c058:	e59f30f8 	ldr	r3, [pc, #248]	; c10c158 <lcd_init+0x118>
 c10c05c:	e59f20f8 	ldr	r2, [pc, #248]	; c10c15c <lcd_init+0x11c>
 c10c060:	e5832000 	str	r2, [r3]
	rDP4_7 = 0xBA5DA65;
 c10c064:	e59f30f4 	ldr	r3, [pc, #244]	; c10c160 <lcd_init+0x120>
 c10c068:	e59f20f4 	ldr	r2, [pc, #244]	; c10c164 <lcd_init+0x124>
 c10c06c:	e5832000 	str	r2, [r3]
	rDP3_5 = 0xA5A5F;
 c10c070:	e59f30f0 	ldr	r3, [pc, #240]	; c10c168 <lcd_init+0x128>
 c10c074:	e59f20f0 	ldr	r2, [pc, #240]	; c10c16c <lcd_init+0x12c>
 c10c078:	e5832000 	str	r2, [r3]
	rDP2_3 = 0xD6B;
 c10c07c:	e59f30ec 	ldr	r3, [pc, #236]	; c10c170 <lcd_init+0x130>
 c10c080:	e59f20ec 	ldr	r2, [pc, #236]	; c10c174 <lcd_init+0x134>
 c10c084:	e5832000 	str	r2, [r3]
	rDP5_7 = 0xEB7B5ED;
 c10c088:	e59f30e8 	ldr	r3, [pc, #232]	; c10c178 <lcd_init+0x138>
 c10c08c:	e59f20e8 	ldr	r2, [pc, #232]	; c10c17c <lcd_init+0x13c>
 c10c090:	e5832000 	str	r2, [r3]
	rDP3_4 = 0x7DBE;
 c10c094:	e59f30e4 	ldr	r3, [pc, #228]	; c10c180 <lcd_init+0x140>
 c10c098:	e59f20e4 	ldr	r2, [pc, #228]	; c10c184 <lcd_init+0x144>
 c10c09c:	e5832000 	str	r2, [r3]
	rDP4_5 = 0x7EBDF;
 c10c0a0:	e59f30e0 	ldr	r3, [pc, #224]	; c10c188 <lcd_init+0x148>
 c10c0a4:	e59f20e0 	ldr	r2, [pc, #224]	; c10c18c <lcd_init+0x14c>
 c10c0a8:	e5832000 	str	r2, [r3]
	rDP6_7 = 0x7FDFBFE;
 c10c0ac:	e59f30dc 	ldr	r3, [pc, #220]	; c10c190 <lcd_init+0x150>
 c10c0b0:	e59f20dc 	ldr	r2, [pc, #220]	; c10c194 <lcd_init+0x154>
 c10c0b4:	e5832000 	str	r2, [r3]

	//Zero, black and white LCD
    rREDLUT   = 0;
 c10c0b8:	e59f30d8 	ldr	r3, [pc, #216]	; c10c198 <lcd_init+0x158>
 c10c0bc:	e3a02000 	mov	r2, #0
 c10c0c0:	e5832000 	str	r2, [r3]
    rGREENLUT = 0;
 c10c0c4:	e59f30d0 	ldr	r3, [pc, #208]	; c10c19c <lcd_init+0x15c>
 c10c0c8:	e3a02000 	mov	r2, #0
 c10c0cc:	e5832000 	str	r2, [r3]
    rBLUELUT  = 0;
 c10c0d0:	e59f30c8 	ldr	r3, [pc, #200]	; c10c1a0 <lcd_init+0x160>
 c10c0d4:	e3a02000 	mov	r2, #0
 c10c0d8:	e5832000 	str	r2, [r3]
    //LCDCON1[3]     = 0   no invierte la seÒal VLINE
    //LCDCON1[4]     = 0   las seÒales de vÌdeo se muestrean a flanco de bajada
    //LCDCON1[9:8]   = 0   WDLY = 4 ciclos (minimum blanking)
    //LCDCON1[11:10] = 0   WLH = 4 ciclos  (minimum blanking)
    //LCDCON1[21:12] = 28  CLKVAL = 28 => tFRAME = 59,4 Hz
    rLCDCON1  = 0x1C020;
 c10c0dc:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c10c0e0:	e59f20bc 	ldr	r2, [pc, #188]	; c10c1a4 <lcd_init+0x164>
 c10c0e4:	e5832000 	str	r2, [r3]

    //LCDCON2[31:21] =  0 LINEBLANK = 0 ciclos (minimum horizontal blanking
    //LCDCON2[20:10] = 79   HOZVAL = (320 / 4) ñ 1 (Horizontal resolution)
    //LCDCON2[9:0]   = 239  LINEVAL = 240 ñ 1 (Vertical resolution)
    rLCDCON2  = 0x13CEF;
 c10c0e8:	e59f30b8 	ldr	r3, [pc, #184]	; c10c1a8 <lcd_init+0x168>
 c10c0ec:	e59f20b8 	ldr	r2, [pc, #184]	; c10c1ac <lcd_init+0x16c>
 c10c0f0:	e5832000 	str	r2, [r3]

    //LCDCON3[0] = 0  Disable self refresh
    rLCDCON3  = 0;
 c10c0f4:	e59f30b4 	ldr	r3, [pc, #180]	; c10c1b0 <lcd_init+0x170>
 c10c0f8:	e3a02000 	mov	r2, #0
 c10c0fc:	e5832000 	str	r2, [r3]

    //Start of lcd_buffer
    rLCDSADDR1 = (2 << 27) | ((uint32)lcd_buffer >> 1);
 c10c100:	e59f30ac 	ldr	r3, [pc, #172]	; c10c1b4 <lcd_init+0x174>
 c10c104:	e59f20ac 	ldr	r2, [pc, #172]	; c10c1b8 <lcd_init+0x178>
 c10c108:	e1a020a2 	lsr	r2, r2, #1
 c10c10c:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
 c10c110:	e5832000 	str	r2, [r3]

    //End of lcd_buffer
    rLCDSADDR2 = (1 << 29) | (((uint32)lcd_buffer + LCD_BUFFER_SIZE) & 0x3FFFFF) >> 1;
 c10c114:	e59f20a0 	ldr	r2, [pc, #160]	; c10c1bc <lcd_init+0x17c>
 c10c118:	e59f3098 	ldr	r3, [pc, #152]	; c10c1b8 <lcd_init+0x178>
 c10c11c:	e2833c96 	add	r3, r3, #38400	; 0x9600
 c10c120:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
 c10c124:	e3c33503 	bic	r3, r3, #12582912	; 0xc00000
 c10c128:	e1a030a3 	lsr	r3, r3, #1
 c10c12c:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
 c10c130:	e5823000 	str	r3, [r2]

    //No virtual screen
    //LCDSADDR3[19:9] = 0 OFFSIZE = 0
    //LCDSADDR3[8:0] = 80 PAGEWIDTH = HOZVAL + 1 = 320 / 4
    rLCDSADDR3 = 0x50;
 c10c134:	e59f3084 	ldr	r3, [pc, #132]	; c10c1c0 <lcd_init+0x180>
 c10c138:	e3a02050 	mov	r2, #80	; 0x50
 c10c13c:	e5832000 	str	r2, [r3]

    lcd_off();
 c10c140:	eb00002e 	bl	c10c200 <lcd_off>
}
 c10c144:	e24bd00c 	sub	sp, fp, #12
 c10c148:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c14c:	e12fff1e 	bx	lr
 c10c150:	01f00044 	.word	0x01f00044
 c10c154:	00012210 	.word	0x00012210
 c10c158:	01f00020 	.word	0x01f00020
 c10c15c:	0000a5a5 	.word	0x0000a5a5
 c10c160:	01f00024 	.word	0x01f00024
 c10c164:	0ba5da65 	.word	0x0ba5da65
 c10c168:	01f00028 	.word	0x01f00028
 c10c16c:	000a5a5f 	.word	0x000a5a5f
 c10c170:	01f0002c 	.word	0x01f0002c
 c10c174:	00000d6b 	.word	0x00000d6b
 c10c178:	01f00030 	.word	0x01f00030
 c10c17c:	0eb7b5ed 	.word	0x0eb7b5ed
 c10c180:	01f00034 	.word	0x01f00034
 c10c184:	00007dbe 	.word	0x00007dbe
 c10c188:	01f00038 	.word	0x01f00038
 c10c18c:	0007ebdf 	.word	0x0007ebdf
 c10c190:	01f0003c 	.word	0x01f0003c
 c10c194:	07fdfbfe 	.word	0x07fdfbfe
 c10c198:	01f00014 	.word	0x01f00014
 c10c19c:	01f00018 	.word	0x01f00018
 c10c1a0:	01f0001c 	.word	0x01f0001c
 c10c1a4:	0001c020 	.word	0x0001c020
 c10c1a8:	01f00004 	.word	0x01f00004
 c10c1ac:	00013cef 	.word	0x00013cef
 c10c1b0:	01f00040 	.word	0x01f00040
 c10c1b4:	01f00008 	.word	0x01f00008
 c10c1b8:	0c1013d4 	.word	0x0c1013d4
 c10c1bc:	01f0000c 	.word	0x01f0000c
 c10c1c0:	01f00010 	.word	0x01f00010

0c10c1c4 <lcd_on>:

void lcd_on( void )
{
 c10c1c4:	e1a0c00d 	mov	ip, sp
 c10c1c8:	e92dd800 	push	{fp, ip, lr, pc}
 c10c1cc:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 |= 1;
 c10c1d0:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c10c1d4:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c10c1d8:	e5922000 	ldr	r2, [r2]
 c10c1dc:	e3822001 	orr	r2, r2, #1
 c10c1e0:	e5832000 	str	r2, [r3]
	state = 1;
 c10c1e4:	e59f3010 	ldr	r3, [pc, #16]	; c10c1fc <lcd_on+0x38>
 c10c1e8:	e3a02001 	mov	r2, #1
 c10c1ec:	e5c32000 	strb	r2, [r3]
}
 c10c1f0:	e24bd00c 	sub	sp, fp, #12
 c10c1f4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c1f8:	e12fff1e 	bx	lr
 c10c1fc:	0c10a9d4 	.word	0x0c10a9d4

0c10c200 <lcd_off>:

void lcd_off( void )
{
 c10c200:	e1a0c00d 	mov	ip, sp
 c10c204:	e92dd800 	push	{fp, ip, lr, pc}
 c10c208:	e24cb004 	sub	fp, ip, #4
    rLCDCON1 &= ~1;
 c10c20c:	e3a0361f 	mov	r3, #32505856	; 0x1f00000
 c10c210:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
 c10c214:	e5922000 	ldr	r2, [r2]
 c10c218:	e3c22001 	bic	r2, r2, #1
 c10c21c:	e5832000 	str	r2, [r3]
	state = 0;
 c10c220:	e59f3010 	ldr	r3, [pc, #16]	; c10c238 <lcd_off+0x38>
 c10c224:	e3a02000 	mov	r2, #0
 c10c228:	e5c32000 	strb	r2, [r3]
}
 c10c22c:	e24bd00c 	sub	sp, fp, #12
 c10c230:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c234:	e12fff1e 	bx	lr
 c10c238:	0c10a9d4 	.word	0x0c10a9d4

0c10c23c <lcd_status>:

uint8 lcd_status( void )
{
 c10c23c:	e1a0c00d 	mov	ip, sp
 c10c240:	e92dd800 	push	{fp, ip, lr, pc}
 c10c244:	e24cb004 	sub	fp, ip, #4
	return state;
 c10c248:	e59f3010 	ldr	r3, [pc, #16]	; c10c260 <lcd_status+0x24>
 c10c24c:	e5d33000 	ldrb	r3, [r3]
}
 c10c250:	e1a00003 	mov	r0, r3
 c10c254:	e24bd00c 	sub	sp, fp, #12
 c10c258:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c25c:	e12fff1e 	bx	lr
 c10c260:	0c10a9d4 	.word	0x0c10a9d4

0c10c264 <lcd_clear>:

void lcd_clear( void )
{
 c10c264:	e1a0c00d 	mov	ip, sp
 c10c268:	e92dd800 	push	{fp, ip, lr, pc}
 c10c26c:	e24cb004 	sub	fp, ip, #4
 c10c270:	e24dd008 	sub	sp, sp, #8
	uint16 i = 0;
 c10c274:	e3a03000 	mov	r3, #0
 c10c278:	e14b30be 	strh	r3, [fp, #-14]
    while(i < LCD_BUFFER_SIZE) {
 c10c27c:	ea000006 	b	c10c29c <lcd_clear+0x38>
    	lcd_buffer[i] = 0x0;
 c10c280:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c284:	e59f202c 	ldr	r2, [pc, #44]	; c10c2b8 <lcd_clear+0x54>
 c10c288:	e3a01000 	mov	r1, #0
 c10c28c:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c10c290:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c294:	e2833001 	add	r3, r3, #1
 c10c298:	e14b30be 	strh	r3, [fp, #-14]
}

void lcd_clear( void )
{
	uint16 i = 0;
    while(i < LCD_BUFFER_SIZE) {
 c10c29c:	e15b20be 	ldrh	r2, [fp, #-14]
 c10c2a0:	e59f3014 	ldr	r3, [pc, #20]	; c10c2bc <lcd_clear+0x58>
 c10c2a4:	e1520003 	cmp	r2, r3
 c10c2a8:	9afffff4 	bls	c10c280 <lcd_clear+0x1c>
    	lcd_buffer[i] = 0x0;
    	i++;
    }
}
 c10c2ac:	e24bd00c 	sub	sp, fp, #12
 c10c2b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c2b4:	e12fff1e 	bx	lr
 c10c2b8:	0c1013d4 	.word	0x0c1013d4
 c10c2bc:	000095ff 	.word	0x000095ff

0c10c2c0 <lcd_clear_color>:

void lcd_clear_color( uint8 color )
{
 c10c2c0:	e1a0c00d 	mov	ip, sp
 c10c2c4:	e92dd800 	push	{fp, ip, lr, pc}
 c10c2c8:	e24cb004 	sub	fp, ip, #4
 c10c2cc:	e24dd010 	sub	sp, sp, #16
 c10c2d0:	e1a03000 	mov	r3, r0
 c10c2d4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	uint16 i = 0;
 c10c2d8:	e3a03000 	mov	r3, #0
 c10c2dc:	e14b30be 	strh	r3, [fp, #-14]
	uint8 c = color & 0xf;
 c10c2e0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10c2e4:	e203300f 	and	r3, r3, #15
 c10c2e8:	e54b300f 	strb	r3, [fp, #-15]

    while(i < LCD_BUFFER_SIZE) {
 c10c2ec:	ea00000c 	b	c10c324 <lcd_clear_color+0x64>
    	lcd_buffer[i] = (c << 4) | c;
 c10c2f0:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c2f4:	e55b200f 	ldrb	r2, [fp, #-15]
 c10c2f8:	e1a02202 	lsl	r2, r2, #4
 c10c2fc:	e20210ff 	and	r1, r2, #255	; 0xff
 c10c300:	e55b200f 	ldrb	r2, [fp, #-15]
 c10c304:	e1812002 	orr	r2, r1, r2
 c10c308:	e20220ff 	and	r2, r2, #255	; 0xff
 c10c30c:	e20210ff 	and	r1, r2, #255	; 0xff
 c10c310:	e59f2028 	ldr	r2, [pc, #40]	; c10c340 <lcd_clear_color+0x80>
 c10c314:	e7c21003 	strb	r1, [r2, r3]
    	i++;
 c10c318:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c31c:	e2833001 	add	r3, r3, #1
 c10c320:	e14b30be 	strh	r3, [fp, #-14]
void lcd_clear_color( uint8 color )
{
	uint16 i = 0;
	uint8 c = color & 0xf;

    while(i < LCD_BUFFER_SIZE) {
 c10c324:	e15b20be 	ldrh	r2, [fp, #-14]
 c10c328:	e59f3014 	ldr	r3, [pc, #20]	; c10c344 <lcd_clear_color+0x84>
 c10c32c:	e1520003 	cmp	r2, r3
 c10c330:	9affffee 	bls	c10c2f0 <lcd_clear_color+0x30>
    	lcd_buffer[i] = (c << 4) | c;
    	i++;
    }
}
 c10c334:	e24bd00c 	sub	sp, fp, #12
 c10c338:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c33c:	e12fff1e 	bx	lr
 c10c340:	0c1013d4 	.word	0x0c1013d4
 c10c344:	000095ff 	.word	0x000095ff

0c10c348 <lcd_putpixel>:


void lcd_putpixel( uint16 x, uint16 y, uint8 c)
{
 c10c348:	e1a0c00d 	mov	ip, sp
 c10c34c:	e92dd800 	push	{fp, ip, lr, pc}
 c10c350:	e24cb004 	sub	fp, ip, #4
 c10c354:	e24dd010 	sub	sp, sp, #16
 c10c358:	e1a03002 	mov	r3, r2
 c10c35c:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c10c360:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c10c364:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    uint8 byte, bit;
    uint16 i;

    i = x/2 + y*(LCD_WIDTH/2);
 c10c368:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c36c:	e1a030a3 	lsr	r3, r3, #1
 c10c370:	e1a03803 	lsl	r3, r3, #16
 c10c374:	e1a02823 	lsr	r2, r3, #16
 c10c378:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c10c37c:	e1a01003 	mov	r1, r3
 c10c380:	e1a01101 	lsl	r1, r1, #2
 c10c384:	e0813003 	add	r3, r1, r3
 c10c388:	e1a03283 	lsl	r3, r3, #5
 c10c38c:	e1a03803 	lsl	r3, r3, #16
 c10c390:	e1a03823 	lsr	r3, r3, #16
 c10c394:	e0823003 	add	r3, r2, r3
 c10c398:	e14b30be 	strh	r3, [fp, #-14]
    bit = (1-x%2)*4;
 c10c39c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c3a0:	e2033001 	and	r3, r3, #1
 c10c3a4:	e3530000 	cmp	r3, #0
 c10c3a8:	1a000001 	bne	c10c3b4 <lcd_putpixel+0x6c>
 c10c3ac:	e3a03004 	mov	r3, #4
 c10c3b0:	ea000000 	b	c10c3b8 <lcd_putpixel+0x70>
 c10c3b4:	e3a03000 	mov	r3, #0
 c10c3b8:	e54b300f 	strb	r3, [fp, #-15]

    byte = lcd_buffer[i];
 c10c3bc:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c3c0:	e59f2068 	ldr	r2, [pc, #104]	; c10c430 <lcd_putpixel+0xe8>
 c10c3c4:	e7d23003 	ldrb	r3, [r2, r3]
 c10c3c8:	e54b3010 	strb	r3, [fp, #-16]
    byte &= ~(0xF << bit);
 c10c3cc:	e55b300f 	ldrb	r3, [fp, #-15]
 c10c3d0:	e3a0200f 	mov	r2, #15
 c10c3d4:	e1a03312 	lsl	r3, r2, r3
 c10c3d8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10c3dc:	e1e03003 	mvn	r3, r3
 c10c3e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10c3e4:	e55b3010 	ldrb	r3, [fp, #-16]
 c10c3e8:	e0023003 	and	r3, r2, r3
 c10c3ec:	e20330ff 	and	r3, r3, #255	; 0xff
 c10c3f0:	e54b3010 	strb	r3, [fp, #-16]
    byte |= c << bit;
 c10c3f4:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
 c10c3f8:	e55b300f 	ldrb	r3, [fp, #-15]
 c10c3fc:	e1a03312 	lsl	r3, r2, r3
 c10c400:	e20320ff 	and	r2, r3, #255	; 0xff
 c10c404:	e55b3010 	ldrb	r3, [fp, #-16]
 c10c408:	e1823003 	orr	r3, r2, r3
 c10c40c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10c410:	e54b3010 	strb	r3, [fp, #-16]
    lcd_buffer[i] = byte;
 c10c414:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c418:	e59f2010 	ldr	r2, [pc, #16]	; c10c430 <lcd_putpixel+0xe8>
 c10c41c:	e55b1010 	ldrb	r1, [fp, #-16]
 c10c420:	e7c21003 	strb	r1, [r2, r3]
}
 c10c424:	e24bd00c 	sub	sp, fp, #12
 c10c428:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c42c:	e12fff1e 	bx	lr
 c10c430:	0c1013d4 	.word	0x0c1013d4

0c10c434 <lcd_getpixel>:

uint8 lcd_getpixel( uint16 x, uint16 y )
{
 c10c434:	e1a0c00d 	mov	ip, sp
 c10c438:	e92dd800 	push	{fp, ip, lr, pc}
 c10c43c:	e24cb004 	sub	fp, ip, #4
 c10c440:	e24dd010 	sub	sp, sp, #16
 c10c444:	e1a02000 	mov	r2, r0
 c10c448:	e1a03001 	mov	r3, r1
 c10c44c:	e14b21b6 	strh	r2, [fp, #-22]	; 0xffffffea
 c10c450:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
	uint8 byte, bit;
	uint16 i = x/2 + y*(LCD_WIDTH/2);
 c10c454:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c458:	e1a030a3 	lsr	r3, r3, #1
 c10c45c:	e1a03803 	lsl	r3, r3, #16
 c10c460:	e1a02823 	lsr	r2, r3, #16
 c10c464:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c10c468:	e1a01003 	mov	r1, r3
 c10c46c:	e1a01101 	lsl	r1, r1, #2
 c10c470:	e0813003 	add	r3, r1, r3
 c10c474:	e1a03283 	lsl	r3, r3, #5
 c10c478:	e1a03803 	lsl	r3, r3, #16
 c10c47c:	e1a03823 	lsr	r3, r3, #16
 c10c480:	e0823003 	add	r3, r2, r3
 c10c484:	e14b30be 	strh	r3, [fp, #-14]

	bit = (1-x%2)*4;
 c10c488:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c48c:	e2033001 	and	r3, r3, #1
 c10c490:	e3530000 	cmp	r3, #0
 c10c494:	1a000001 	bne	c10c4a0 <lcd_getpixel+0x6c>
 c10c498:	e3a03004 	mov	r3, #4
 c10c49c:	ea000000 	b	c10c4a4 <lcd_getpixel+0x70>
 c10c4a0:	e3a03000 	mov	r3, #0
 c10c4a4:	e54b300f 	strb	r3, [fp, #-15]
	byte = lcd_buffer[i];
 c10c4a8:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c4ac:	e59f202c 	ldr	r2, [pc, #44]	; c10c4e0 <lcd_getpixel+0xac>
 c10c4b0:	e7d23003 	ldrb	r3, [r2, r3]
 c10c4b4:	e54b3010 	strb	r3, [fp, #-16]

	return (byte >> bit ) & 0xf;
 c10c4b8:	e55b2010 	ldrb	r2, [fp, #-16]
 c10c4bc:	e55b300f 	ldrb	r3, [fp, #-15]
 c10c4c0:	e1a03352 	asr	r3, r2, r3
 c10c4c4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10c4c8:	e203300f 	and	r3, r3, #15
 c10c4cc:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c10c4d0:	e1a00003 	mov	r0, r3
 c10c4d4:	e24bd00c 	sub	sp, fp, #12
 c10c4d8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c4dc:	e12fff1e 	bx	lr
 c10c4e0:	0c1013d4 	.word	0x0c1013d4

0c10c4e4 <lcd_draw_hline>:

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
 c10c4e4:	e1a0c00d 	mov	ip, sp
 c10c4e8:	e92dd800 	push	{fp, ip, lr, pc}
 c10c4ec:	e24cb004 	sub	fp, ip, #4
 c10c4f0:	e24dd010 	sub	sp, sp, #16
 c10c4f4:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c10c4f8:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c10c4fc:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c10c500:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c10c504:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c508:	e50b3010 	str	r3, [fp, #-16]
 c10c50c:	ea000019 	b	c10c578 <lcd_draw_hline+0x94>
		for(y_i = y; y_i < y + width; ++y_i)
 c10c510:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c10c514:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10c518:	ea00000d 	b	c10c554 <lcd_draw_hline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c10c51c:	e51b3010 	ldr	r3, [fp, #-16]
 c10c520:	e1a03803 	lsl	r3, r3, #16
 c10c524:	e1a01823 	lsr	r1, r3, #16
 c10c528:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c52c:	e1a03803 	lsl	r3, r3, #16
 c10c530:	e1a02823 	lsr	r2, r3, #16
 c10c534:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c10c538:	e1a00001 	mov	r0, r1
 c10c53c:	e1a01002 	mov	r1, r2
 c10c540:	e1a02003 	mov	r2, r3
 c10c544:	ebffff7f 	bl	c10c348 <lcd_putpixel>

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
		for(y_i = y; y_i < y + width; ++y_i)
 c10c548:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c54c:	e2833001 	add	r3, r3, #1
 c10c550:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10c554:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c10c558:	e1db30b4 	ldrh	r3, [fp, #4]
 c10c55c:	e0822003 	add	r2, r2, r3
 c10c560:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c564:	e1520003 	cmp	r2, r3
 c10c568:	caffffeb 	bgt	c10c51c <lcd_draw_hline+0x38>
}

void lcd_draw_hline( uint16 xleft, uint16 xright, uint16 y, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(x_i = xleft; x_i <= xright; ++x_i)
 c10c56c:	e51b3010 	ldr	r3, [fp, #-16]
 c10c570:	e2833001 	add	r3, r3, #1
 c10c574:	e50b3010 	str	r3, [fp, #-16]
 c10c578:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c10c57c:	e51b3010 	ldr	r3, [fp, #-16]
 c10c580:	e1520003 	cmp	r2, r3
 c10c584:	aaffffe1 	bge	c10c510 <lcd_draw_hline+0x2c>
		for(y_i = y; y_i < y + width; ++y_i)
			lcd_putpixel(x_i, y_i, color);
}
 c10c588:	e24bd00c 	sub	sp, fp, #12
 c10c58c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c590:	e12fff1e 	bx	lr

0c10c594 <lcd_draw_vline>:

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
 c10c594:	e1a0c00d 	mov	ip, sp
 c10c598:	e92dd800 	push	{fp, ip, lr, pc}
 c10c59c:	e24cb004 	sub	fp, ip, #4
 c10c5a0:	e24dd010 	sub	sp, sp, #16
 c10c5a4:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c10c5a8:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c10c5ac:	e14b21ba 	strh	r2, [fp, #-26]	; 0xffffffe6
 c10c5b0:	e54b301b 	strb	r3, [fp, #-27]	; 0xffffffe5
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c10c5b4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c5b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10c5bc:	ea000019 	b	c10c628 <lcd_draw_vline+0x94>
		for(x_i = x; x_i < x + width; ++x_i)
 c10c5c0:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
 c10c5c4:	e50b3010 	str	r3, [fp, #-16]
 c10c5c8:	ea00000d 	b	c10c604 <lcd_draw_vline+0x70>
			lcd_putpixel(x_i, y_i, color);
 c10c5cc:	e51b3010 	ldr	r3, [fp, #-16]
 c10c5d0:	e1a03803 	lsl	r3, r3, #16
 c10c5d4:	e1a01823 	lsr	r1, r3, #16
 c10c5d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c5dc:	e1a03803 	lsl	r3, r3, #16
 c10c5e0:	e1a02823 	lsr	r2, r3, #16
 c10c5e4:	e55b301b 	ldrb	r3, [fp, #-27]	; 0xffffffe5
 c10c5e8:	e1a00001 	mov	r0, r1
 c10c5ec:	e1a01002 	mov	r1, r2
 c10c5f0:	e1a02003 	mov	r2, r3
 c10c5f4:	ebffff53 	bl	c10c348 <lcd_putpixel>

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
		for(x_i = x; x_i < x + width; ++x_i)
 c10c5f8:	e51b3010 	ldr	r3, [fp, #-16]
 c10c5fc:	e2833001 	add	r3, r3, #1
 c10c600:	e50b3010 	str	r3, [fp, #-16]
 c10c604:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c10c608:	e1db30b4 	ldrh	r3, [fp, #4]
 c10c60c:	e0822003 	add	r2, r2, r3
 c10c610:	e51b3010 	ldr	r3, [fp, #-16]
 c10c614:	e1520003 	cmp	r2, r3
 c10c618:	caffffeb 	bgt	c10c5cc <lcd_draw_vline+0x38>
}

void lcd_draw_vline( uint16 yup, uint16 ydown, uint16 x, uint8 color, uint16 width )
{
	int x_i, y_i;
	for(y_i = yup; y_i <= ydown; ++y_i)
 c10c61c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c620:	e2833001 	add	r3, r3, #1
 c10c624:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10c628:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
 c10c62c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10c630:	e1520003 	cmp	r2, r3
 c10c634:	aaffffe1 	bge	c10c5c0 <lcd_draw_vline+0x2c>
		for(x_i = x; x_i < x + width; ++x_i)
			lcd_putpixel(x_i, y_i, color);
}
 c10c638:	e24bd00c 	sub	sp, fp, #12
 c10c63c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c640:	e12fff1e 	bx	lr

0c10c644 <lcd_draw_box>:

void lcd_draw_box( uint16 xleft, uint16 yup, uint16 xright, uint16 ydown, uint8 color, uint16 width )
{
 c10c644:	e1a0c00d 	mov	ip, sp
 c10c648:	e92dd800 	push	{fp, ip, lr, pc}
 c10c64c:	e24cb004 	sub	fp, ip, #4
 c10c650:	e24dd010 	sub	sp, sp, #16
 c10c654:	e14b00be 	strh	r0, [fp, #-14]
 c10c658:	e14b11b0 	strh	r1, [fp, #-16]
 c10c65c:	e14b21b2 	strh	r2, [fp, #-18]	; 0xffffffee
 c10c660:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
	lcd_draw_hline(xleft, xright, yup, color, width);
 c10c664:	e15b00be 	ldrh	r0, [fp, #-14]
 c10c668:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c10c66c:	e15b21b0 	ldrh	r2, [fp, #-16]
 c10c670:	e5db3004 	ldrb	r3, [fp, #4]
 c10c674:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c10c678:	e58dc000 	str	ip, [sp]
 c10c67c:	ebffff98 	bl	c10c4e4 <lcd_draw_hline>
	lcd_draw_vline(yup, ydown, xleft, color, width);
 c10c680:	e15b01b0 	ldrh	r0, [fp, #-16]
 c10c684:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c10c688:	e15b20be 	ldrh	r2, [fp, #-14]
 c10c68c:	e5db3004 	ldrb	r3, [fp, #4]
 c10c690:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c10c694:	e58dc000 	str	ip, [sp]
 c10c698:	ebffffbd 	bl	c10c594 <lcd_draw_vline>
	lcd_draw_vline(yup, ydown, xright - width + 1, color, width);
 c10c69c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c10c6a0:	e1db30b8 	ldrh	r3, [fp, #8]
 c10c6a4:	e0633002 	rsb	r3, r3, r2
 c10c6a8:	e1a03803 	lsl	r3, r3, #16
 c10c6ac:	e1a03823 	lsr	r3, r3, #16
 c10c6b0:	e2833001 	add	r3, r3, #1
 c10c6b4:	e1a03803 	lsl	r3, r3, #16
 c10c6b8:	e1a02823 	lsr	r2, r3, #16
 c10c6bc:	e15b01b0 	ldrh	r0, [fp, #-16]
 c10c6c0:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
 c10c6c4:	e5db3004 	ldrb	r3, [fp, #4]
 c10c6c8:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c10c6cc:	e58dc000 	str	ip, [sp]
 c10c6d0:	ebffffaf 	bl	c10c594 <lcd_draw_vline>
	lcd_draw_hline(xleft, xright, ydown - width + 1, color, width);
 c10c6d4:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
 c10c6d8:	e1db30b8 	ldrh	r3, [fp, #8]
 c10c6dc:	e0633002 	rsb	r3, r3, r2
 c10c6e0:	e1a03803 	lsl	r3, r3, #16
 c10c6e4:	e1a03823 	lsr	r3, r3, #16
 c10c6e8:	e2833001 	add	r3, r3, #1
 c10c6ec:	e1a03803 	lsl	r3, r3, #16
 c10c6f0:	e1a02823 	lsr	r2, r3, #16
 c10c6f4:	e15b00be 	ldrh	r0, [fp, #-14]
 c10c6f8:	e15b11b2 	ldrh	r1, [fp, #-18]	; 0xffffffee
 c10c6fc:	e5db3004 	ldrb	r3, [fp, #4]
 c10c700:	e1dbc0b8 	ldrh	ip, [fp, #8]
 c10c704:	e58dc000 	str	ip, [sp]
 c10c708:	ebffff75 	bl	c10c4e4 <lcd_draw_hline>
}
 c10c70c:	e24bd00c 	sub	sp, fp, #12
 c10c710:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c714:	e12fff1e 	bx	lr

0c10c718 <lcd_putchar>:

void lcd_putchar( uint16 x, uint16 y, uint8 color, char ch )
{
 c10c718:	e1a0c00d 	mov	ip, sp
 c10c71c:	e92dd800 	push	{fp, ip, lr, pc}
 c10c720:	e24cb004 	sub	fp, ip, #4
 c10c724:	e24dd010 	sub	sp, sp, #16
 c10c728:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
 c10c72c:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
 c10c730:	e54b2019 	strb	r2, [fp, #-25]	; 0xffffffe7
 c10c734:	e54b301a 	strb	r3, [fp, #-26]	; 0xffffffe6
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
 c10c738:	e55b301a 	ldrb	r3, [fp, #-26]	; 0xffffffe6
 c10c73c:	e1a03203 	lsl	r3, r3, #4
 c10c740:	e1a02003 	mov	r2, r3
 c10c744:	e59f311c 	ldr	r3, [pc, #284]	; c10c868 <lcd_putchar+0x150>
 c10c748:	e0823003 	add	r3, r2, r3
 c10c74c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for( line=0; line<16; line++ )
 c10c750:	e3a03000 	mov	r3, #0
 c10c754:	e54b300d 	strb	r3, [fp, #-13]
 c10c758:	ea00003c 	b	c10c850 <lcd_putchar+0x138>
        for( row=0; row<8; row++ )
 c10c75c:	e3a03000 	mov	r3, #0
 c10c760:	e54b300e 	strb	r3, [fp, #-14]
 c10c764:	ea000033 	b	c10c838 <lcd_putchar+0x120>
            if( bitmap[line] & (0x80 >> row) )
 c10c768:	e55b300d 	ldrb	r3, [fp, #-13]
 c10c76c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10c770:	e0823003 	add	r3, r2, r3
 c10c774:	e5d33000 	ldrb	r3, [r3]
 c10c778:	e1a02003 	mov	r2, r3
 c10c77c:	e55b300e 	ldrb	r3, [fp, #-14]
 c10c780:	e3a01080 	mov	r1, #128	; 0x80
 c10c784:	e1a03351 	asr	r3, r1, r3
 c10c788:	e0023003 	and	r3, r2, r3
 c10c78c:	e3530000 	cmp	r3, #0
 c10c790:	0a000013 	beq	c10c7e4 <lcd_putchar+0xcc>
                lcd_putpixel( x+row, y+line, color );
 c10c794:	e55b300e 	ldrb	r3, [fp, #-14]
 c10c798:	e1a03803 	lsl	r3, r3, #16
 c10c79c:	e1a02823 	lsr	r2, r3, #16
 c10c7a0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c7a4:	e0823003 	add	r3, r2, r3
 c10c7a8:	e1a03803 	lsl	r3, r3, #16
 c10c7ac:	e1a01823 	lsr	r1, r3, #16
 c10c7b0:	e55b300d 	ldrb	r3, [fp, #-13]
 c10c7b4:	e1a03803 	lsl	r3, r3, #16
 c10c7b8:	e1a02823 	lsr	r2, r3, #16
 c10c7bc:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c10c7c0:	e0823003 	add	r3, r2, r3
 c10c7c4:	e1a03803 	lsl	r3, r3, #16
 c10c7c8:	e1a02823 	lsr	r2, r3, #16
 c10c7cc:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c10c7d0:	e1a00001 	mov	r0, r1
 c10c7d4:	e1a01002 	mov	r1, r2
 c10c7d8:	e1a02003 	mov	r2, r3
 c10c7dc:	ebfffed9 	bl	c10c348 <lcd_putpixel>
 c10c7e0:	ea000011 	b	c10c82c <lcd_putchar+0x114>
            else
                lcd_putpixel( x+row, y+line, WHITE );
 c10c7e4:	e55b300e 	ldrb	r3, [fp, #-14]
 c10c7e8:	e1a03803 	lsl	r3, r3, #16
 c10c7ec:	e1a02823 	lsr	r2, r3, #16
 c10c7f0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
 c10c7f4:	e0823003 	add	r3, r2, r3
 c10c7f8:	e1a03803 	lsl	r3, r3, #16
 c10c7fc:	e1a02823 	lsr	r2, r3, #16
 c10c800:	e55b300d 	ldrb	r3, [fp, #-13]
 c10c804:	e1a03803 	lsl	r3, r3, #16
 c10c808:	e1a01823 	lsr	r1, r3, #16
 c10c80c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
 c10c810:	e0813003 	add	r3, r1, r3
 c10c814:	e1a03803 	lsl	r3, r3, #16
 c10c818:	e1a03823 	lsr	r3, r3, #16
 c10c81c:	e1a00002 	mov	r0, r2
 c10c820:	e1a01003 	mov	r1, r3
 c10c824:	e3a02000 	mov	r2, #0
 c10c828:	ebfffec6 	bl	c10c348 <lcd_putpixel>
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
        for( row=0; row<8; row++ )
 c10c82c:	e55b300e 	ldrb	r3, [fp, #-14]
 c10c830:	e2833001 	add	r3, r3, #1
 c10c834:	e54b300e 	strb	r3, [fp, #-14]
 c10c838:	e55b300e 	ldrb	r3, [fp, #-14]
 c10c83c:	e3530007 	cmp	r3, #7
 c10c840:	9affffc8 	bls	c10c768 <lcd_putchar+0x50>
{
    uint8 line, row;
    uint8 *bitmap;

    bitmap = font + ch*16;
    for( line=0; line<16; line++ )
 c10c844:	e55b300d 	ldrb	r3, [fp, #-13]
 c10c848:	e2833001 	add	r3, r3, #1
 c10c84c:	e54b300d 	strb	r3, [fp, #-13]
 c10c850:	e55b300d 	ldrb	r3, [fp, #-13]
 c10c854:	e353000f 	cmp	r3, #15
 c10c858:	9affffbf 	bls	c10c75c <lcd_putchar+0x44>
        for( row=0; row<8; row++ )
            if( bitmap[line] & (0x80 >> row) )
                lcd_putpixel( x+row, y+line, color );
            else
                lcd_putpixel( x+row, y+line, WHITE );
}
 c10c85c:	e24bd00c 	sub	sp, fp, #12
 c10c860:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c864:	e12fff1e 	bx	lr
 c10c868:	0c100068 	.word	0x0c100068

0c10c86c <lcd_puts>:

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
 c10c86c:	e1a0c00d 	mov	ip, sp
 c10c870:	e92dd800 	push	{fp, ip, lr, pc}
 c10c874:	e24cb004 	sub	fp, ip, #4
 c10c878:	e24dd010 	sub	sp, sp, #16
 c10c87c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10c880:	e14b00be 	strh	r0, [fp, #-14]
 c10c884:	e14b11b0 	strh	r1, [fp, #-16]
 c10c888:	e1a03002 	mov	r3, r2
 c10c88c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
	while(*s) {
 c10c890:	ea000015 	b	c10c8ec <lcd_puts+0x80>
		lcd_putchar(x, y, color, *s);
 c10c894:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c898:	e5d33000 	ldrb	r3, [r3]
 c10c89c:	e15b00be 	ldrh	r0, [fp, #-14]
 c10c8a0:	e15b11b0 	ldrh	r1, [fp, #-16]
 c10c8a4:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
 c10c8a8:	ebffff9a 	bl	c10c718 <lcd_putchar>

		x += 8;
 c10c8ac:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c8b0:	e2833008 	add	r3, r3, #8
 c10c8b4:	e14b30be 	strh	r3, [fp, #-14]
		if(x + 8 >= LCD_WIDTH) {
 c10c8b8:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c8bc:	e2832008 	add	r2, r3, #8
 c10c8c0:	e59f3040 	ldr	r3, [pc, #64]	; c10c908 <lcd_puts+0x9c>
 c10c8c4:	e1520003 	cmp	r2, r3
 c10c8c8:	da000004 	ble	c10c8e0 <lcd_puts+0x74>
			x = 0;
 c10c8cc:	e3a03000 	mov	r3, #0
 c10c8d0:	e14b30be 	strh	r3, [fp, #-14]
			y += 16;
 c10c8d4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10c8d8:	e2833010 	add	r3, r3, #16
 c10c8dc:	e14b31b0 	strh	r3, [fp, #-16]
		}
		s++;
 c10c8e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c8e4:	e2833001 	add	r3, r3, #1
 c10c8e8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
                lcd_putpixel( x+row, y+line, WHITE );
}

void lcd_puts( uint16 x, uint16 y, uint8 color, char *s )
{
	while(*s) {
 c10c8ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c8f0:	e5d33000 	ldrb	r3, [r3]
 c10c8f4:	e3530000 	cmp	r3, #0
 c10c8f8:	1affffe5 	bne	c10c894 <lcd_puts+0x28>
			x = 0;
			y += 16;
		}
		s++;
	}
}
 c10c8fc:	e24bd00c 	sub	sp, fp, #12
 c10c900:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10c904:	e12fff1e 	bx	lr
 c10c908:	0000013f 	.word	0x0000013f

0c10c90c <lcd_putWallpaper>:

void lcd_putWallpaper( uint8 *bmp )
{
 c10c90c:	e1a0c00d 	mov	ip, sp
 c10c910:	e92dd800 	push	{fp, ip, lr, pc}
 c10c914:	e24cb004 	sub	fp, ip, #4
 c10c918:	e24dd018 	sub	sp, sp, #24
 c10c91c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    uint32 headerSize;

    uint16 x, ySrc, yDst;
    uint16 offsetSrc, offsetDst;

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);
 c10c920:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10c924:	e283300a 	add	r3, r3, #10
 c10c928:	e5d33000 	ldrb	r3, [r3]
 c10c92c:	e1a02003 	mov	r2, r3
 c10c930:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10c934:	e283300b 	add	r3, r3, #11
 c10c938:	e5d33000 	ldrb	r3, [r3]
 c10c93c:	e1a03403 	lsl	r3, r3, #8
 c10c940:	e0822003 	add	r2, r2, r3
 c10c944:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10c948:	e283300c 	add	r3, r3, #12
 c10c94c:	e5d33000 	ldrb	r3, [r3]
 c10c950:	e1a03803 	lsl	r3, r3, #16
 c10c954:	e0822003 	add	r2, r2, r3
 c10c958:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10c95c:	e283300d 	add	r3, r3, #13
 c10c960:	e5d33000 	ldrb	r3, [r3]
 c10c964:	e1a03c03 	lsl	r3, r3, #24
 c10c968:	e0823003 	add	r3, r2, r3
 c10c96c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    bmp = bmp + headerSize;
 c10c970:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10c974:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10c978:	e0823003 	add	r3, r2, r3
 c10c97c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c10c980:	e3a03000 	mov	r3, #0
 c10c984:	e14b31b0 	strh	r3, [fp, #-16]
 c10c988:	e3a030ef 	mov	r3, #239	; 0xef
 c10c98c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c10c990:	ea00002d 	b	c10ca4c <lcd_putWallpaper+0x140>
    {
        offsetDst = yDst*LCD_WIDTH/2;
 c10c994:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
 c10c998:	e1a03002 	mov	r3, r2
 c10c99c:	e1a03103 	lsl	r3, r3, #2
 c10c9a0:	e0833002 	add	r3, r3, r2
 c10c9a4:	e1a03303 	lsl	r3, r3, #6
 c10c9a8:	e1a02fa3 	lsr	r2, r3, #31
 c10c9ac:	e0823003 	add	r3, r2, r3
 c10c9b0:	e1a030c3 	asr	r3, r3, #1
 c10c9b4:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
        offsetSrc = ySrc*LCD_WIDTH/2;
 c10c9b8:	e15b21b0 	ldrh	r2, [fp, #-16]
 c10c9bc:	e1a03002 	mov	r3, r2
 c10c9c0:	e1a03103 	lsl	r3, r3, #2
 c10c9c4:	e0833002 	add	r3, r3, r2
 c10c9c8:	e1a03303 	lsl	r3, r3, #6
 c10c9cc:	e1a02fa3 	lsr	r2, r3, #31
 c10c9d0:	e0823003 	add	r3, r2, r3
 c10c9d4:	e1a030c3 	asr	r3, r3, #1
 c10c9d8:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
        for( x=0; x<LCD_WIDTH/2; x++ )
 c10c9dc:	e3a03000 	mov	r3, #0
 c10c9e0:	e14b30be 	strh	r3, [fp, #-14]
 c10c9e4:	ea00000f 	b	c10ca28 <lcd_putWallpaper+0x11c>
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
 c10c9e8:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
 c10c9ec:	e15b30be 	ldrh	r3, [fp, #-14]
 c10c9f0:	e0823003 	add	r3, r2, r3
 c10c9f4:	e15b11bc 	ldrh	r1, [fp, #-28]	; 0xffffffe4
 c10c9f8:	e15b20be 	ldrh	r2, [fp, #-14]
 c10c9fc:	e0812002 	add	r2, r1, r2
 c10ca00:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
 c10ca04:	e0812002 	add	r2, r1, r2
 c10ca08:	e5d22000 	ldrb	r2, [r2]
 c10ca0c:	e1e02002 	mvn	r2, r2
 c10ca10:	e20210ff 	and	r1, r2, #255	; 0xff
 c10ca14:	e59f2048 	ldr	r2, [pc, #72]	; c10ca64 <lcd_putWallpaper+0x158>
 c10ca18:	e7c21003 	strb	r1, [r2, r3]

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
    {
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
 c10ca1c:	e15b30be 	ldrh	r3, [fp, #-14]
 c10ca20:	e2833001 	add	r3, r3, #1
 c10ca24:	e14b30be 	strh	r3, [fp, #-14]
 c10ca28:	e15b30be 	ldrh	r3, [fp, #-14]
 c10ca2c:	e353009f 	cmp	r3, #159	; 0x9f
 c10ca30:	9affffec 	bls	c10c9e8 <lcd_putWallpaper+0xdc>

    headerSize = bmp[10] + (bmp[11] << 8) + (bmp[12] << 16) + (bmp[13] << 24);

    bmp = bmp + headerSize;

    for( ySrc=0, yDst=LCD_HEIGHT-1; ySrc<LCD_HEIGHT; ySrc++, yDst-- )
 c10ca34:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10ca38:	e2833001 	add	r3, r3, #1
 c10ca3c:	e14b31b0 	strh	r3, [fp, #-16]
 c10ca40:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
 c10ca44:	e2433001 	sub	r3, r3, #1
 c10ca48:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
 c10ca4c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10ca50:	e35300ef 	cmp	r3, #239	; 0xef
 c10ca54:	9affffce 	bls	c10c994 <lcd_putWallpaper+0x88>
        offsetDst = yDst*LCD_WIDTH/2;
        offsetSrc = ySrc*LCD_WIDTH/2;
        for( x=0; x<LCD_WIDTH/2; x++ )
            lcd_buffer[offsetDst+x] = ~bmp[offsetSrc+x];
    }
}
 c10ca58:	e24bd00c 	sub	sp, fp, #12
 c10ca5c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ca60:	e12fff1e 	bx	lr
 c10ca64:	0c1013d4 	.word	0x0c1013d4

0c10ca68 <leds_init>:
// significativos, cada uno para un led
// 1 encendido y 0 apagado
static unsigned int status = 0;

void leds_init( void )
{
 c10ca68:	e1a0c00d 	mov	ip, sp
 c10ca6c:	e92dd800 	push	{fp, ip, lr, pc}
 c10ca70:	e24cb004 	sub	fp, ip, #4
	//COMPLETAR usando el interfaz del puerto B definido en gpio.h
	// hay que configurar los pines 9 y 10 como pines de salida
	portB_conf(BIT_LED1, OUTPUT);
 c10ca74:	e3a00009 	mov	r0, #9
 c10ca78:	e3a01001 	mov	r1, #1
 c10ca7c:	ebfff926 	bl	c10af1c <portB_conf>
	portB_conf(BIT_LED2, OUTPUT);
 c10ca80:	e3a0000a 	mov	r0, #10
 c10ca84:	e3a01001 	mov	r1, #1
 c10ca88:	ebfff923 	bl	c10af1c <portB_conf>
	leds_display( status );
 c10ca8c:	e59f3014 	ldr	r3, [pc, #20]	; c10caa8 <leds_init+0x40>
 c10ca90:	e5933000 	ldr	r3, [r3]
 c10ca94:	e1a00003 	mov	r0, r3
 c10ca98:	eb000073 	bl	c10cc6c <leds_display>
}
 c10ca9c:	e24bd00c 	sub	sp, fp, #12
 c10caa0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10caa4:	e12fff1e 	bx	lr
 c10caa8:	0c10a9d8 	.word	0x0c10a9d8

0c10caac <led1_on>:

void led1_on( void )
{
 c10caac:	e1a0c00d 	mov	ip, sp
 c10cab0:	e92dd800 	push	{fp, ip, lr, pc}
 c10cab4:	e24cb004 	sub	fp, ip, #4
	status |=  LED1;
 c10cab8:	e59f3028 	ldr	r3, [pc, #40]	; c10cae8 <led1_on+0x3c>
 c10cabc:	e5933000 	ldr	r3, [r3]
 c10cac0:	e3832001 	orr	r2, r3, #1
 c10cac4:	e59f301c 	ldr	r3, [pc, #28]	; c10cae8 <led1_on+0x3c>
 c10cac8:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cacc:	e59f3014 	ldr	r3, [pc, #20]	; c10cae8 <led1_on+0x3c>
 c10cad0:	e5933000 	ldr	r3, [r3]
 c10cad4:	e1a00003 	mov	r0, r3
 c10cad8:	eb000063 	bl	c10cc6c <leds_display>
}
 c10cadc:	e24bd00c 	sub	sp, fp, #12
 c10cae0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cae4:	e12fff1e 	bx	lr
 c10cae8:	0c10a9d8 	.word	0x0c10a9d8

0c10caec <led1_off>:

void led1_off( void )
{
 c10caec:	e1a0c00d 	mov	ip, sp
 c10caf0:	e92dd800 	push	{fp, ip, lr, pc}
 c10caf4:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED1;
 c10caf8:	e59f3028 	ldr	r3, [pc, #40]	; c10cb28 <led1_off+0x3c>
 c10cafc:	e5933000 	ldr	r3, [r3]
 c10cb00:	e3c32001 	bic	r2, r3, #1
 c10cb04:	e59f301c 	ldr	r3, [pc, #28]	; c10cb28 <led1_off+0x3c>
 c10cb08:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cb0c:	e59f3014 	ldr	r3, [pc, #20]	; c10cb28 <led1_off+0x3c>
 c10cb10:	e5933000 	ldr	r3, [r3]
 c10cb14:	e1a00003 	mov	r0, r3
 c10cb18:	eb000053 	bl	c10cc6c <leds_display>
}
 c10cb1c:	e24bd00c 	sub	sp, fp, #12
 c10cb20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cb24:	e12fff1e 	bx	lr
 c10cb28:	0c10a9d8 	.word	0x0c10a9d8

0c10cb2c <led2_on>:

void led2_on( void )
{
 c10cb2c:	e1a0c00d 	mov	ip, sp
 c10cb30:	e92dd800 	push	{fp, ip, lr, pc}
 c10cb34:	e24cb004 	sub	fp, ip, #4
	status |=  LED2;
 c10cb38:	e59f3028 	ldr	r3, [pc, #40]	; c10cb68 <led2_on+0x3c>
 c10cb3c:	e5933000 	ldr	r3, [r3]
 c10cb40:	e3832002 	orr	r2, r3, #2
 c10cb44:	e59f301c 	ldr	r3, [pc, #28]	; c10cb68 <led2_on+0x3c>
 c10cb48:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cb4c:	e59f3014 	ldr	r3, [pc, #20]	; c10cb68 <led2_on+0x3c>
 c10cb50:	e5933000 	ldr	r3, [r3]
 c10cb54:	e1a00003 	mov	r0, r3
 c10cb58:	eb000043 	bl	c10cc6c <leds_display>
}
 c10cb5c:	e24bd00c 	sub	sp, fp, #12
 c10cb60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cb64:	e12fff1e 	bx	lr
 c10cb68:	0c10a9d8 	.word	0x0c10a9d8

0c10cb6c <led2_off>:

void led2_off( void )
{
 c10cb6c:	e1a0c00d 	mov	ip, sp
 c10cb70:	e92dd800 	push	{fp, ip, lr, pc}
 c10cb74:	e24cb004 	sub	fp, ip, #4
	status &=  ~LED2;
 c10cb78:	e59f3028 	ldr	r3, [pc, #40]	; c10cba8 <led2_off+0x3c>
 c10cb7c:	e5933000 	ldr	r3, [r3]
 c10cb80:	e3c32002 	bic	r2, r3, #2
 c10cb84:	e59f301c 	ldr	r3, [pc, #28]	; c10cba8 <led2_off+0x3c>
 c10cb88:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cb8c:	e59f3014 	ldr	r3, [pc, #20]	; c10cba8 <led2_off+0x3c>
 c10cb90:	e5933000 	ldr	r3, [r3]
 c10cb94:	e1a00003 	mov	r0, r3
 c10cb98:	eb000033 	bl	c10cc6c <leds_display>
}
 c10cb9c:	e24bd00c 	sub	sp, fp, #12
 c10cba0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cba4:	e12fff1e 	bx	lr
 c10cba8:	0c10a9d8 	.word	0x0c10a9d8

0c10cbac <led1_switch>:

void led1_switch( void )
{
 c10cbac:	e1a0c00d 	mov	ip, sp
 c10cbb0:	e92dd800 	push	{fp, ip, lr, pc}
 c10cbb4:	e24cb004 	sub	fp, ip, #4
	status ^= LED1;
 c10cbb8:	e59f3028 	ldr	r3, [pc, #40]	; c10cbe8 <led1_switch+0x3c>
 c10cbbc:	e5933000 	ldr	r3, [r3]
 c10cbc0:	e2232001 	eor	r2, r3, #1
 c10cbc4:	e59f301c 	ldr	r3, [pc, #28]	; c10cbe8 <led1_switch+0x3c>
 c10cbc8:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cbcc:	e59f3014 	ldr	r3, [pc, #20]	; c10cbe8 <led1_switch+0x3c>
 c10cbd0:	e5933000 	ldr	r3, [r3]
 c10cbd4:	e1a00003 	mov	r0, r3
 c10cbd8:	eb000023 	bl	c10cc6c <leds_display>
}
 c10cbdc:	e24bd00c 	sub	sp, fp, #12
 c10cbe0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cbe4:	e12fff1e 	bx	lr
 c10cbe8:	0c10a9d8 	.word	0x0c10a9d8

0c10cbec <led2_switch>:

void led2_switch( void )
{
 c10cbec:	e1a0c00d 	mov	ip, sp
 c10cbf0:	e92dd800 	push	{fp, ip, lr, pc}
 c10cbf4:	e24cb004 	sub	fp, ip, #4
	status ^= LED2;
 c10cbf8:	e59f3028 	ldr	r3, [pc, #40]	; c10cc28 <led2_switch+0x3c>
 c10cbfc:	e5933000 	ldr	r3, [r3]
 c10cc00:	e2232002 	eor	r2, r3, #2
 c10cc04:	e59f301c 	ldr	r3, [pc, #28]	; c10cc28 <led2_switch+0x3c>
 c10cc08:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cc0c:	e59f3014 	ldr	r3, [pc, #20]	; c10cc28 <led2_switch+0x3c>
 c10cc10:	e5933000 	ldr	r3, [r3]
 c10cc14:	e1a00003 	mov	r0, r3
 c10cc18:	eb000013 	bl	c10cc6c <leds_display>
}
 c10cc1c:	e24bd00c 	sub	sp, fp, #12
 c10cc20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cc24:	e12fff1e 	bx	lr
 c10cc28:	0c10a9d8 	.word	0x0c10a9d8

0c10cc2c <leds_switch>:

void leds_switch( void ){
 c10cc2c:	e1a0c00d 	mov	ip, sp
 c10cc30:	e92dd800 	push	{fp, ip, lr, pc}
 c10cc34:	e24cb004 	sub	fp, ip, #4
	status ^= (LED1 | LED2);
 c10cc38:	e59f3028 	ldr	r3, [pc, #40]	; c10cc68 <leds_switch+0x3c>
 c10cc3c:	e5933000 	ldr	r3, [r3]
 c10cc40:	e2232003 	eor	r2, r3, #3
 c10cc44:	e59f301c 	ldr	r3, [pc, #28]	; c10cc68 <leds_switch+0x3c>
 c10cc48:	e5832000 	str	r2, [r3]
	leds_display( status );
 c10cc4c:	e59f3014 	ldr	r3, [pc, #20]	; c10cc68 <leds_switch+0x3c>
 c10cc50:	e5933000 	ldr	r3, [r3]
 c10cc54:	e1a00003 	mov	r0, r3
 c10cc58:	eb000003 	bl	c10cc6c <leds_display>
}
 c10cc5c:	e24bd00c 	sub	sp, fp, #12
 c10cc60:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cc64:	e12fff1e 	bx	lr
 c10cc68:	0c10a9d8 	.word	0x0c10a9d8

0c10cc6c <leds_display>:

void leds_display( unsigned int leds_status )
{
 c10cc6c:	e1a0c00d 	mov	ip, sp
 c10cc70:	e92dd800 	push	{fp, ip, lr, pc}
 c10cc74:	e24cb004 	sub	fp, ip, #4
 c10cc78:	e24dd008 	sub	sp, sp, #8
 c10cc7c:	e50b0010 	str	r0, [fp, #-16]
	status = leds_status;
 c10cc80:	e59f3074 	ldr	r3, [pc, #116]	; c10ccfc <leds_display+0x90>
 c10cc84:	e51b2010 	ldr	r2, [fp, #-16]
 c10cc88:	e5832000 	str	r2, [r3]
	
	// LED 1
	if( status & LED1 )
 c10cc8c:	e59f3068 	ldr	r3, [pc, #104]	; c10ccfc <leds_display+0x90>
 c10cc90:	e5933000 	ldr	r3, [r3]
 c10cc94:	e2033001 	and	r3, r3, #1
 c10cc98:	e20330ff 	and	r3, r3, #255	; 0xff
 c10cc9c:	e3530000 	cmp	r3, #0
 c10cca0:	0a000003 	beq	c10ccb4 <leds_display+0x48>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 1
		portB_write(BIT_LED1, DISABLE);
 c10cca4:	e3a00009 	mov	r0, #9
 c10cca8:	e3a01000 	mov	r1, #0
 c10ccac:	ebfff8cc 	bl	c10afe4 <portB_write>
 c10ccb0:	ea000002 	b	c10ccc0 <leds_display+0x54>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 1
		portB_write(BIT_LED1, ENABLE);
 c10ccb4:	e3a00009 	mov	r0, #9
 c10ccb8:	e3a01001 	mov	r1, #1
 c10ccbc:	ebfff8c8 	bl	c10afe4 <portB_write>

	// LED 2
	if( status & LED2 )
 c10ccc0:	e59f3034 	ldr	r3, [pc, #52]	; c10ccfc <leds_display+0x90>
 c10ccc4:	e5933000 	ldr	r3, [r3]
 c10ccc8:	e2033002 	and	r3, r3, #2
 c10cccc:	e3530000 	cmp	r3, #0
 c10ccd0:	0a000003 	beq	c10cce4 <leds_display+0x78>
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel bajo el bit correspondiente al led 2
		portB_write(BIT_LED2, DISABLE);
 c10ccd4:	e3a0000a 	mov	r0, #10
 c10ccd8:	e3a01000 	mov	r1, #0
 c10ccdc:	ebfff8c0 	bl	c10afe4 <portB_write>
 c10cce0:	ea000002 	b	c10ccf0 <leds_display+0x84>
	else
		//COMPLETAR usando el interfaz del puerto B definido en gpio.h
		//hay que poner a nivel alto el bit correspondiente al led 2
		portB_write(BIT_LED2, ENABLE);
 c10cce4:	e3a0000a 	mov	r0, #10
 c10cce8:	e3a01001 	mov	r1, #1
 c10ccec:	ebfff8bc 	bl	c10afe4 <portB_write>
}
 c10ccf0:	e24bd00c 	sub	sp, fp, #12
 c10ccf4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ccf8:	e12fff1e 	bx	lr
 c10ccfc:	0c10a9d8 	.word	0x0c10a9d8

0c10cd00 <timer_ISR>:
void keyboard_ISR(void) __attribute__ ((interrupt ("IRQ")));
void rtc_ISR(void)  __attribute__ ((interrupt ("IRQ")));
void rtc_alarm_ISR(void)  __attribute__ ((interrupt ("IRQ")));

void timer_ISR(void)
{
 c10cd00:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10cd04:	e1a0c00d 	mov	ip, sp
 c10cd08:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10cd0c:	e24cb004 	sub	fp, ip, #4
	//Timer ISR Implementation
	led1_switch();
 c10cd10:	ebffffa5 	bl	c10cbac <led1_switch>
	led2_switch();
 c10cd14:	ebffffb4 	bl	c10cbec <led2_switch>

	ic_cleanflag(INT_TIMER0);
 c10cd18:	e3a0000d 	mov	r0, #13
 c10cd1c:	ebfffc34 	bl	c10bdf4 <ic_cleanflag>
}
 c10cd20:	e24bd01c 	sub	sp, fp, #28
 c10cd24:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10cd28:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10cd2c:	e25ef004 	subs	pc, lr, #4

0c10cd30 <button_ISR>:

void button_ISR(void)
{
 c10cd30:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10cd34:	e1a0c00d 	mov	ip, sp
 c10cd38:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10cd3c:	e24cb004 	sub	fp, ip, #4
 c10cd40:	e24dd008 	sub	sp, sp, #8
	unsigned int whicheint = rEXTINTPND;
 c10cd44:	e59f3080 	ldr	r3, [pc, #128]	; c10cdcc <button_ISR+0x9c>
 c10cd48:	e5933000 	ldr	r3, [r3]
 c10cd4c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
	unsigned int buttons = (whicheint >> 2) & 0x3;
 c10cd50:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10cd54:	e1a03123 	lsr	r3, r3, #2
 c10cd58:	e2033003 	and	r3, r3, #3
 c10cd5c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
	if (buttons & BUT2) {
		//BUT2 pressed
	}

	// eliminamos rebotes
	Delay(2000);
 c10cd60:	e3a00e7d 	mov	r0, #2000	; 0x7d0
 c10cd64:	eb000941 	bl	c10f270 <Delay>
	// borramos el flag en extintpnd
	//COMPLETAR: debemos borrar las peticiones de interrupci√≥n en
	//EXTINTPND escribiendo un 1 en los flags que queremos borrar (los
	//correspondientes a los pulsadores pulsados)

	if(buttons & BUT1)
 c10cd68:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c10cd6c:	e2033001 	and	r3, r3, #1
 c10cd70:	e20330ff 	and	r3, r3, #255	; 0xff
 c10cd74:	e3530000 	cmp	r3, #0
 c10cd78:	0a000004 	beq	c10cd90 <button_ISR+0x60>
		//Borrar bit 2
		rEXTINTPND |= 1 << 2;
 c10cd7c:	e59f3048 	ldr	r3, [pc, #72]	; c10cdcc <button_ISR+0x9c>
 c10cd80:	e59f2044 	ldr	r2, [pc, #68]	; c10cdcc <button_ISR+0x9c>
 c10cd84:	e5922000 	ldr	r2, [r2]
 c10cd88:	e3822004 	orr	r2, r2, #4
 c10cd8c:	e5832000 	str	r2, [r3]

	if(buttons & BUT2)
 c10cd90:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c10cd94:	e2033002 	and	r3, r3, #2
 c10cd98:	e3530000 	cmp	r3, #0
 c10cd9c:	0a000004 	beq	c10cdb4 <button_ISR+0x84>
		//Borrar bit 3
		rEXTINTPND |= 1 << 3;
 c10cda0:	e59f3024 	ldr	r3, [pc, #36]	; c10cdcc <button_ISR+0x9c>
 c10cda4:	e59f2020 	ldr	r2, [pc, #32]	; c10cdcc <button_ISR+0x9c>
 c10cda8:	e5922000 	ldr	r2, [r2]
 c10cdac:	e3822008 	orr	r2, r2, #8
 c10cdb0:	e5832000 	str	r2, [r3]

	ic_cleanflag(INT_EINT4567);
 c10cdb4:	e3a00015 	mov	r0, #21
 c10cdb8:	ebfffc0d 	bl	c10bdf4 <ic_cleanflag>
}
 c10cdbc:	e24bd01c 	sub	sp, fp, #28
 c10cdc0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10cdc4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10cdc8:	e25ef004 	subs	pc, lr, #4
 c10cdcc:	01d20054 	.word	0x01d20054

0c10cdd0 <keyboard_ISR>:

void keyboard_ISR(void)
{
 c10cdd0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10cdd4:	e1a0c00d 	mov	ip, sp
 c10cdd8:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10cddc:	e24cb004 	sub	fp, ip, #4
 c10cde0:	e24dd008 	sub	sp, sp, #8
	static unsigned n = 0;
	int key = -1;
 c10cde4:	e3e03000 	mvn	r3, #0
 c10cde8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

	/* Eliminar rebotes de presi√≥n */
	Delay(200);
 c10cdec:	e3a000c8 	mov	r0, #200	; 0xc8
 c10cdf0:	eb00091e 	bl	c10f270 <Delay>
	
	/* Escaneo de tecla */
	key = kb_scan();
 c10cdf4:	ebfffc28 	bl	c10be9c <kb_scan>
 c10cdf8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0

	n = (n+1) & 0xf;
 c10cdfc:	e59f3044 	ldr	r3, [pc, #68]	; c10ce48 <keyboard_ISR+0x78>
 c10ce00:	e5933000 	ldr	r3, [r3]
 c10ce04:	e2833001 	add	r3, r3, #1
 c10ce08:	e203200f 	and	r2, r3, #15
 c10ce0c:	e59f3034 	ldr	r3, [pc, #52]	; c10ce48 <keyboard_ISR+0x78>
 c10ce10:	e5832000 	str	r2, [r3]

	if (key != -1) {
 c10ce14:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10ce18:	e3730001 	cmn	r3, #1
 c10ce1c:	0a000001 	beq	c10ce28 <keyboard_ISR+0x58>
		/* Visualizacion en el display */
		//COMPLETAR: mostrar la tecla en el display utilizando el interfaz
		//definido en D8Led.h

		D8Led_digit(key);
 c10ce20:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c10ce24:	ebfff711 	bl	c10aa70 <D8Led_digit>
		/* Esperar a que la tecla se suelte, consultando el registro de datos */		
		//while (/*COMPLETAR: true si est√° pulsada la tecla (leer del registro rPDATG)*/);
	}

    /* Eliminar rebotes de depresi√≥n */
    Delay(200);
 c10ce28:	e3a000c8 	mov	r0, #200	; 0xc8
 c10ce2c:	eb00090f 	bl	c10f270 <Delay>
     
    /* Borrar interrupciones pendientes */
	//COMPLETAR
	//borrar la interrupci√≥n por la l√≠nea EINT1 en el registro rI_ISPC
    ic_cleanflag(INT_EINT1);
 c10ce30:	e3a00018 	mov	r0, #24
 c10ce34:	ebfffbee 	bl	c10bdf4 <ic_cleanflag>
}
 c10ce38:	e24bd01c 	sub	sp, fp, #28
 c10ce3c:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10ce40:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10ce44:	e25ef004 	subs	pc, lr, #4
 c10ce48:	0c10a9ec 	.word	0x0c10a9ec

0c10ce4c <setup>:

int setup(void)
{
 c10ce4c:	e1a0c00d 	mov	ip, sp
 c10ce50:	e92dd800 	push	{fp, ip, lr, pc}
 c10ce54:	e24cb004 	sub	fp, ip, #4
	leds_init();
 c10ce58:	ebffff02 	bl	c10ca68 <leds_init>
	D8Led_init();
 c10ce5c:	ebfff6e3 	bl	c10a9f0 <D8Led_init>
	D8Led_segment(0x02); // "-" Symbol
 c10ce60:	e3a00002 	mov	r0, #2
 c10ce64:	ebfff6ea 	bl	c10aa14 <D8Led_segment>
	led1_on();
 c10ce68:	ebffff0f 	bl	c10caac <led1_on>
	//COMPLETAR: utilizando el interfaz para el puerto G definido en gpio.h
	//configurar los pines 1, 6 y 7 del puerto G para poder generar interrupciones
	//externas por flanco de bajada por ellos y activar las correspondientes
	//resistencias de pull-up.

	portG_conf(6, EINT);
 c10ce6c:	e3a00006 	mov	r0, #6
 c10ce70:	e3a01003 	mov	r1, #3
 c10ce74:	ebfff889 	bl	c10b0a0 <portG_conf>
	portG_eint_trig(6, FALLING);
 c10ce78:	e3a00006 	mov	r0, #6
 c10ce7c:	e3a01002 	mov	r1, #2
 c10ce80:	ebfff8f4 	bl	c10b258 <portG_eint_trig>
	portG_conf_pup(6, ENABLE);
 c10ce84:	e3a00006 	mov	r0, #6
 c10ce88:	e3a01001 	mov	r1, #1
 c10ce8c:	ebfffa16 	bl	c10b6ec <portG_conf_pup>

	portG_conf(7, EINT);
 c10ce90:	e3a00007 	mov	r0, #7
 c10ce94:	e3a01003 	mov	r1, #3
 c10ce98:	ebfff880 	bl	c10b0a0 <portG_conf>
	portG_eint_trig(7, FALLING);
 c10ce9c:	e3a00007 	mov	r0, #7
 c10cea0:	e3a01002 	mov	r1, #2
 c10cea4:	ebfff8eb 	bl	c10b258 <portG_eint_trig>
	portG_conf_pup(7, ENABLE);
 c10cea8:	e3a00007 	mov	r0, #7
 c10ceac:	e3a01001 	mov	r1, #1
 c10ceb0:	ebfffa0d 	bl	c10b6ec <portG_conf_pup>
	/********************************************************************/

	/* Configuraci√≥n del timer */

	//TIMER0: 0.5 seconds
	tmr_set_mode(TIMER0, RELOAD);
 c10ceb4:	e3a00000 	mov	r0, #0
 c10ceb8:	e3a01001 	mov	r1, #1
 c10cebc:	eb0006c2 	bl	c10e9cc <tmr_set_mode>
	tmr_set_prescaler(TIMER0, 255);
 c10cec0:	e3a00000 	mov	r0, #0
 c10cec4:	e3a010ff 	mov	r1, #255	; 0xff
 c10cec8:	eb0005be 	bl	c10e5c8 <tmr_set_prescaler>
	tmr_set_divider(TIMER0, D1_8);
 c10cecc:	e3a00000 	mov	r0, #0
 c10ced0:	e3a01002 	mov	r1, #2
 c10ced4:	eb0005f2 	bl	c10e6a4 <tmr_set_divider>
	tmr_set_count(TIMER0, 62500 >> 3, 1);
 c10ced8:	e3a00000 	mov	r0, #0
 c10cedc:	e59f10a8 	ldr	r1, [pc, #168]	; c10cf8c <setup+0x140>
 c10cee0:	e3a02001 	mov	r2, #1
 c10cee4:	eb00063d 	bl	c10e7e0 <tmr_set_count>

	tmr_update(TIMER0);
 c10cee8:	e3a00000 	mov	r0, #0
 c10ceec:	eb000688 	bl	c10e914 <tmr_update>

	//COMPLETAR: tomar el c√≥digo de la segunda parte

	tmr_start(TIMER0);
 c10cef0:	e3a00000 	mov	r0, #0
 c10cef4:	eb0006f7 	bl	c10ead8 <tmr_start>
	//if (RL.moving)
	//
	/***************************/

	// Registramos las ISRs
	pISR_TIMER0 = (unsigned)timer_ISR;//COMPLETAR: registrar la RTI del timer
 c10cef8:	e59f3090 	ldr	r3, [pc, #144]	; c10cf90 <setup+0x144>
 c10cefc:	e59f2090 	ldr	r2, [pc, #144]	; c10cf94 <setup+0x148>
 c10cf00:	e5832000 	str	r2, [r3]
	pISR_EINT4567 = (unsigned)button_ISR; //COMPLETAR: registrar la RTI de los botones
 c10cf04:	e59f308c 	ldr	r3, [pc, #140]	; c10cf98 <setup+0x14c>
 c10cf08:	e59f208c 	ldr	r2, [pc, #140]	; c10cf9c <setup+0x150>
 c10cf0c:	e5832000 	str	r2, [r3]
	pISR_EINT1    = (unsigned)keyboard_ISR; //COMPLETAR: registrar la RTI del teclado
 c10cf10:	e59f3088 	ldr	r3, [pc, #136]	; c10cfa0 <setup+0x154>
 c10cf14:	e59f2088 	ldr	r2, [pc, #136]	; c10cfa4 <setup+0x158>
 c10cf18:	e5832000 	str	r2, [r3]
	 * Configuramos el timer 0 en modo IRQ y habilitamos esta l√≠nea
	 * Configuramos la l√≠nea EINT4567 en modo IRQ y la habilitamos
	 * Configuramos la l√≠nea EINT1 en modo IRQ y la habilitamos
	 */

	uart0_init();
 c10cf1c:	eb000756 	bl	c10ec7c <uart0_init>
	iic_init();
 c10cf20:	ebfffa23 	bl	c10b7b4 <iic_init>
	rtc_init();
 c10cf24:	eb00023e 	bl	c10d824 <rtc_init>
	ic_init();
 c10cf28:	ebfffaed 	bl	c10bae4 <ic_init>
	//		habilitar la l√≠nea INT_EINT4567
	//		habilitar la l√≠nea INT_EINT1

	/***************************************************/

	ic_conf_irq(ENABLE, VEC);
 c10cf2c:	e3a00001 	mov	r0, #1
 c10cf30:	e3a01000 	mov	r1, #0
 c10cf34:	ebfffafb 	bl	c10bb28 <ic_conf_irq>
	ic_conf_fiq(DISABLE);
 c10cf38:	e3a00000 	mov	r0, #0
 c10cf3c:	ebfffb28 	bl	c10bbe4 <ic_conf_fiq>

	ic_conf_line(INT_TIMER0, IRQ);
 c10cf40:	e3a0000d 	mov	r0, #13
 c10cf44:	e3a01000 	mov	r1, #0
 c10cf48:	ebfffb46 	bl	c10bc68 <ic_conf_line>
	ic_conf_line(INT_EINT4567, IRQ);
 c10cf4c:	e3a00015 	mov	r0, #21
 c10cf50:	e3a01000 	mov	r1, #0
 c10cf54:	ebfffb43 	bl	c10bc68 <ic_conf_line>
	ic_conf_line(INT_EINT1, IRQ);
 c10cf58:	e3a00018 	mov	r0, #24
 c10cf5c:	e3a01000 	mov	r1, #0
 c10cf60:	ebfffb40 	bl	c10bc68 <ic_conf_line>

	//ic_enable(INT_TIMER0);
	//ic_enable(INT_EINT4567);
	//ic_enable(INT_EINT1);

	ic_enable(INT_GLOBAL);
 c10cf64:	e3a0001a 	mov	r0, #26
 c10cf68:	ebfffb6e 	bl	c10bd28 <ic_enable>

	lcd_init();
 c10cf6c:	ebfffc33 	bl	c10c040 <lcd_init>

	Delay(0);
 c10cf70:	e3a00000 	mov	r0, #0
 c10cf74:	eb0008bd 	bl	c10f270 <Delay>
	return 0;
 c10cf78:	e3a03000 	mov	r3, #0
}
 c10cf7c:	e1a00003 	mov	r0, r3
 c10cf80:	e24bd00c 	sub	sp, fp, #12
 c10cf84:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10cf88:	e12fff1e 	bx	lr
 c10cf8c:	00001e84 	.word	0x00001e84
 c10cf90:	0c7fff54 	.word	0x0c7fff54
 c10cf94:	0c10cd00 	.word	0x0c10cd00
 c10cf98:	0c7fff74 	.word	0x0c7fff74
 c10cf9c:	0c10cd30 	.word	0x0c10cd30
 c10cfa0:	0c7fff80 	.word	0x0c7fff80
 c10cfa4:	0c10cdd0 	.word	0x0c10cdd0

0c10cfa8 <read_date>:

void read_date(rtc_time_t* rtc_time)
{
 c10cfa8:	e1a0c00d 	mov	ip, sp
 c10cfac:	e92dd800 	push	{fp, ip, lr, pc}
 c10cfb0:	e24cb004 	sub	fp, ip, #4
 c10cfb4:	e24dd008 	sub	sp, sp, #8
 c10cfb8:	e50b0010 	str	r0, [fp, #-16]
	uart0_puts( "\nDia: " );
 c10cfbc:	e59f00c8 	ldr	r0, [pc, #200]	; c10d08c <read_date+0xe4>
 c10cfc0:	eb00076c 	bl	c10ed78 <uart0_puts>
	rtc_time->mday = uart0_getint();
 c10cfc4:	eb000808 	bl	c10efec <uart0_getint>
 c10cfc8:	e1a03000 	mov	r3, r0
 c10cfcc:	e20320ff 	and	r2, r3, #255	; 0xff
 c10cfd0:	e51b3010 	ldr	r3, [fp, #-16]
 c10cfd4:	e5c32003 	strb	r2, [r3, #3]
	uart0_puts( "\nMes: " );
 c10cfd8:	e59f00b0 	ldr	r0, [pc, #176]	; c10d090 <read_date+0xe8>
 c10cfdc:	eb000765 	bl	c10ed78 <uart0_puts>
	rtc_time->mon = uart0_getint();
 c10cfe0:	eb000801 	bl	c10efec <uart0_getint>
 c10cfe4:	e1a03000 	mov	r3, r0
 c10cfe8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10cfec:	e51b3010 	ldr	r3, [fp, #-16]
 c10cff0:	e5c32005 	strb	r2, [r3, #5]
	uart0_puts( "\nAÒo: " );
 c10cff4:	e59f0098 	ldr	r0, [pc, #152]	; c10d094 <read_date+0xec>
 c10cff8:	eb00075e 	bl	c10ed78 <uart0_puts>
	rtc_time->year = uart0_getint();
 c10cffc:	eb0007fa 	bl	c10efec <uart0_getint>
 c10d000:	e1a03000 	mov	r3, r0
 c10d004:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d008:	e51b3010 	ldr	r3, [fp, #-16]
 c10d00c:	e5c32006 	strb	r2, [r3, #6]
	uart0_puts( "\nDia de la semana: " );
 c10d010:	e59f0080 	ldr	r0, [pc, #128]	; c10d098 <read_date+0xf0>
 c10d014:	eb000757 	bl	c10ed78 <uart0_puts>
	rtc_time->wday = uart0_getint();
 c10d018:	eb0007f3 	bl	c10efec <uart0_getint>
 c10d01c:	e1a03000 	mov	r3, r0
 c10d020:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d024:	e51b3010 	ldr	r3, [fp, #-16]
 c10d028:	e5c32004 	strb	r2, [r3, #4]

	uart0_puts( "\nHora: " );
 c10d02c:	e59f0068 	ldr	r0, [pc, #104]	; c10d09c <read_date+0xf4>
 c10d030:	eb000750 	bl	c10ed78 <uart0_puts>
	rtc_time->hour = uart0_getint();
 c10d034:	eb0007ec 	bl	c10efec <uart0_getint>
 c10d038:	e1a03000 	mov	r3, r0
 c10d03c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d040:	e51b3010 	ldr	r3, [fp, #-16]
 c10d044:	e5c32002 	strb	r2, [r3, #2]
	uart0_puts( "\nMinutos: " );
 c10d048:	e59f0050 	ldr	r0, [pc, #80]	; c10d0a0 <read_date+0xf8>
 c10d04c:	eb000749 	bl	c10ed78 <uart0_puts>
	rtc_time->min = uart0_getint();
 c10d050:	eb0007e5 	bl	c10efec <uart0_getint>
 c10d054:	e1a03000 	mov	r3, r0
 c10d058:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d05c:	e51b3010 	ldr	r3, [fp, #-16]
 c10d060:	e5c32001 	strb	r2, [r3, #1]
	uart0_puts( "\nSegundos: " );
 c10d064:	e59f0038 	ldr	r0, [pc, #56]	; c10d0a4 <read_date+0xfc>
 c10d068:	eb000742 	bl	c10ed78 <uart0_puts>
	rtc_time->sec = uart0_getint();
 c10d06c:	eb0007de 	bl	c10efec <uart0_getint>
 c10d070:	e1a03000 	mov	r3, r0
 c10d074:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d078:	e51b3010 	ldr	r3, [fp, #-16]
 c10d07c:	e5c32000 	strb	r2, [r3]
}
 c10d080:	e24bd00c 	sub	sp, fp, #12
 c10d084:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10d088:	e12fff1e 	bx	lr
 c10d08c:	0c1010b8 	.word	0x0c1010b8
 c10d090:	0c1010c0 	.word	0x0c1010c0
 c10d094:	0c1010c8 	.word	0x0c1010c8
 c10d098:	0c1010d0 	.word	0x0c1010d0
 c10d09c:	0c1010e4 	.word	0x0c1010e4
 c10d0a0:	0c1010ec 	.word	0x0c1010ec
 c10d0a4:	0c1010f8 	.word	0x0c1010f8

0c10d0a8 <rtc_ISR>:

void rtc_ISR() {
 c10d0a8:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10d0ac:	e1a0c00d 	mov	ip, sp
 c10d0b0:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10d0b4:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;

	rtc_gettime(&rtc_time);
 c10d0b8:	e59f0028 	ldr	r0, [pc, #40]	; c10d0e8 <rtc_ISR+0x40>
 c10d0bc:	eb000302 	bl	c10dccc <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c10d0c0:	e59f0020 	ldr	r0, [pc, #32]	; c10d0e8 <rtc_ISR+0x40>
 c10d0c4:	eb00083f 	bl	c10f1c8 <uart0_put_rtc_time>
	uart0_putchar('\n');
 c10d0c8:	e3a0000a 	mov	r0, #10
 c10d0cc:	eb000703 	bl	c10ece0 <uart0_putchar>

	ic_cleanflag(INT_TICK);
 c10d0d0:	e3a00014 	mov	r0, #20
 c10d0d4:	ebfffb46 	bl	c10bdf4 <ic_cleanflag>
}
 c10d0d8:	e24bd01c 	sub	sp, fp, #28
 c10d0dc:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10d0e0:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10d0e4:	e25ef004 	subs	pc, lr, #4
 c10d0e8:	0c10a9e4 	.word	0x0c10a9e4

0c10d0ec <rtc_alarm_ISR>:

void rtc_alarm_ISR(void) {
 c10d0ec:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10d0f0:	e1a0c00d 	mov	ip, sp
 c10d0f4:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10d0f8:	e24cb004 	sub	fp, ip, #4
	uart0_puts("\nALARM GOES OFF!\n");
 c10d0fc:	e59f0018 	ldr	r0, [pc, #24]	; c10d11c <rtc_alarm_ISR+0x30>
 c10d100:	eb00071c 	bl	c10ed78 <uart0_puts>
	ic_cleanflag(INT_RTC);
 c10d104:	e3a00001 	mov	r0, #1
 c10d108:	ebfffb39 	bl	c10bdf4 <ic_cleanflag>
}
 c10d10c:	e24bd01c 	sub	sp, fp, #28
 c10d110:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10d114:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10d118:	e25ef004 	subs	pc, lr, #4
 c10d11c:	0c101104 	.word	0x0c101104

0c10d120 <clock_setup>:

void clock_setup() {
 c10d120:	e1a0c00d 	mov	ip, sp
 c10d124:	e92dd800 	push	{fp, ip, lr, pc}
 c10d128:	e24cb004 	sub	fp, ip, #4
	static rtc_time_t rtc_time;
	uart0_puts("Initial time: \n");
 c10d12c:	e59f0128 	ldr	r0, [pc, #296]	; c10d25c <clock_setup+0x13c>
 c10d130:	eb000710 	bl	c10ed78 <uart0_puts>
	rtc_gettime(&rtc_time);
 c10d134:	e59f0124 	ldr	r0, [pc, #292]	; c10d260 <clock_setup+0x140>
 c10d138:	eb0002e3 	bl	c10dccc <rtc_gettime>
	uart0_put_rtc_time(&rtc_time);
 c10d13c:	e59f011c 	ldr	r0, [pc, #284]	; c10d260 <clock_setup+0x140>
 c10d140:	eb000820 	bl	c10f1c8 <uart0_put_rtc_time>

	//Ask for time first time
	read_date(&rtc_time);
 c10d144:	e59f0114 	ldr	r0, [pc, #276]	; c10d260 <clock_setup+0x140>
 c10d148:	ebffff96 	bl	c10cfa8 <read_date>
	rtc_puttime(&rtc_time);
 c10d14c:	e59f010c 	ldr	r0, [pc, #268]	; c10d260 <clock_setup+0x140>
 c10d150:	eb0001e8 	bl	c10d8f8 <rtc_puttime>

	//Set alarm 10 seconds from now (imperfect but enough)

	rtc_time.sec += 10;
 c10d154:	e59f3104 	ldr	r3, [pc, #260]	; c10d260 <clock_setup+0x140>
 c10d158:	e5d33000 	ldrb	r3, [r3]
 c10d15c:	e283300a 	add	r3, r3, #10
 c10d160:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d164:	e59f30f4 	ldr	r3, [pc, #244]	; c10d260 <clock_setup+0x140>
 c10d168:	e5c32000 	strb	r2, [r3]
	if(rtc_time.sec >= 60) {
 c10d16c:	e59f30ec 	ldr	r3, [pc, #236]	; c10d260 <clock_setup+0x140>
 c10d170:	e5d33000 	ldrb	r3, [r3]
 c10d174:	e353003b 	cmp	r3, #59	; 0x3b
 c10d178:	9a00000b 	bls	c10d1ac <clock_setup+0x8c>
		rtc_time.sec -= 60;
 c10d17c:	e59f30dc 	ldr	r3, [pc, #220]	; c10d260 <clock_setup+0x140>
 c10d180:	e5d33000 	ldrb	r3, [r3]
 c10d184:	e243303c 	sub	r3, r3, #60	; 0x3c
 c10d188:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d18c:	e59f30cc 	ldr	r3, [pc, #204]	; c10d260 <clock_setup+0x140>
 c10d190:	e5c32000 	strb	r2, [r3]
		rtc_time.min++;
 c10d194:	e59f30c4 	ldr	r3, [pc, #196]	; c10d260 <clock_setup+0x140>
 c10d198:	e5d33001 	ldrb	r3, [r3, #1]
 c10d19c:	e2833001 	add	r3, r3, #1
 c10d1a0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d1a4:	e59f30b4 	ldr	r3, [pc, #180]	; c10d260 <clock_setup+0x140>
 c10d1a8:	e5c32001 	strb	r2, [r3, #1]
	}

	if(rtc_time.min >= 60) {
 c10d1ac:	e59f30ac 	ldr	r3, [pc, #172]	; c10d260 <clock_setup+0x140>
 c10d1b0:	e5d33001 	ldrb	r3, [r3, #1]
 c10d1b4:	e353003b 	cmp	r3, #59	; 0x3b
 c10d1b8:	9a00000b 	bls	c10d1ec <clock_setup+0xcc>
		rtc_time.min -= 60;
 c10d1bc:	e59f309c 	ldr	r3, [pc, #156]	; c10d260 <clock_setup+0x140>
 c10d1c0:	e5d33001 	ldrb	r3, [r3, #1]
 c10d1c4:	e243303c 	sub	r3, r3, #60	; 0x3c
 c10d1c8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d1cc:	e59f308c 	ldr	r3, [pc, #140]	; c10d260 <clock_setup+0x140>
 c10d1d0:	e5c32001 	strb	r2, [r3, #1]
		rtc_time.hour++;
 c10d1d4:	e59f3084 	ldr	r3, [pc, #132]	; c10d260 <clock_setup+0x140>
 c10d1d8:	e5d33002 	ldrb	r3, [r3, #2]
 c10d1dc:	e2833001 	add	r3, r3, #1
 c10d1e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d1e4:	e59f3074 	ldr	r3, [pc, #116]	; c10d260 <clock_setup+0x140>
 c10d1e8:	e5c32002 	strb	r2, [r3, #2]
	}

	if(rtc_time.hour >= 24) {
 c10d1ec:	e59f306c 	ldr	r3, [pc, #108]	; c10d260 <clock_setup+0x140>
 c10d1f0:	e5d33002 	ldrb	r3, [r3, #2]
 c10d1f4:	e3530017 	cmp	r3, #23
 c10d1f8:	9a00000b 	bls	c10d22c <clock_setup+0x10c>
		rtc_time.hour--;
 c10d1fc:	e59f305c 	ldr	r3, [pc, #92]	; c10d260 <clock_setup+0x140>
 c10d200:	e5d33002 	ldrb	r3, [r3, #2]
 c10d204:	e2433001 	sub	r3, r3, #1
 c10d208:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d20c:	e59f304c 	ldr	r3, [pc, #76]	; c10d260 <clock_setup+0x140>
 c10d210:	e5c32002 	strb	r2, [r3, #2]
		rtc_time.mday++;
 c10d214:	e59f3044 	ldr	r3, [pc, #68]	; c10d260 <clock_setup+0x140>
 c10d218:	e5d33003 	ldrb	r3, [r3, #3]
 c10d21c:	e2833001 	add	r3, r3, #1
 c10d220:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d224:	e59f3034 	ldr	r3, [pc, #52]	; c10d260 <clock_setup+0x140>
 c10d228:	e5c32003 	strb	r2, [r3, #3]
	}

	uart0_puts("Alarm time: ");
 c10d22c:	e59f0030 	ldr	r0, [pc, #48]	; c10d264 <clock_setup+0x144>
 c10d230:	eb0006d0 	bl	c10ed78 <uart0_puts>
	uart0_put_rtc_time(&rtc_time);
 c10d234:	e59f0024 	ldr	r0, [pc, #36]	; c10d260 <clock_setup+0x140>
 c10d238:	eb0007e2 	bl	c10f1c8 <uart0_put_rtc_time>
	uart0_putchar('\n');
 c10d23c:	e3a0000a 	mov	r0, #10
 c10d240:	eb0006a6 	bl	c10ece0 <uart0_putchar>

	rtc_set_alarm(rtc_alarm_ISR, &rtc_time);
 c10d244:	e59f001c 	ldr	r0, [pc, #28]	; c10d268 <clock_setup+0x148>
 c10d248:	e59f1010 	ldr	r1, [pc, #16]	; c10d260 <clock_setup+0x140>
 c10d24c:	eb0003ae 	bl	c10e10c <rtc_set_alarm>
}
 c10d250:	e24bd00c 	sub	sp, fp, #12
 c10d254:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10d258:	e12fff1e 	bx	lr
 c10d25c:	0c101118 	.word	0x0c101118
 c10d260:	0c10a9dc 	.word	0x0c10a9dc
 c10d264:	0c101128 	.word	0x0c101128
 c10d268:	0c10d0ec 	.word	0x0c10d0ec

0c10d26c <startup>:

void startup() {
 c10d26c:	e1a0c00d 	mov	ip, sp
 c10d270:	e92dd800 	push	{fp, ip, lr, pc}
 c10d274:	e24cb004 	sub	fp, ip, #4
 c10d278:	e24dde41 	sub	sp, sp, #1040	; 0x410
    uint8 buffer[AT24C04_DEPTH], buffer_aux[AT24C04_DEPTH];
    uint16 i, j, delay;
    uint32 addr, data;

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );
 c10d27c:	e59f04b8 	ldr	r0, [pc, #1208]	; c10d73c <startup+0x4d0>
 c10d280:	eb0006bc 	bl	c10ed78 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d284:	e3a03000 	mov	r3, #0
 c10d288:	e14b30be 	strh	r3, [fp, #-14]
 c10d28c:	ea000009 	b	c10d2b8 <startup+0x4c>
		at24c04_byteread( i, &buffer[i] );
 c10d290:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d294:	e24b2f86 	sub	r2, fp, #536	; 0x218
 c10d298:	e0823003 	add	r3, r2, r3
 c10d29c:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d2a0:	e1a00002 	mov	r0, r2
 c10d2a4:	e1a01003 	mov	r1, r3
 c10d2a8:	ebfff661 	bl	c10ac34 <at24c04_byteread>

	uart0_puts( "\n\nCargando en RAM el contenido de IIC-EEPROM AT24C04:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d2ac:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d2b0:	e2833001 	add	r3, r3, #1
 c10d2b4:	e14b30be 	strh	r3, [fp, #-14]
 c10d2b8:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d2bc:	e59f347c 	ldr	r3, [pc, #1148]	; c10d740 <startup+0x4d4>
 c10d2c0:	e1520003 	cmp	r2, r3
 c10d2c4:	9afffff1 	bls	c10d290 <startup+0x24>
		at24c04_byteread( i, &buffer[i] );
	uart0_puts( " - Lectura aleatoria (" );
 c10d2c8:	e59f0474 	ldr	r0, [pc, #1140]	; c10d744 <startup+0x4d8>
 c10d2cc:	eb0006a9 	bl	c10ed78 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c10d2d0:	e3a00c02 	mov	r0, #512	; 0x200
 c10d2d4:	eb0006bb 	bl	c10edc8 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c10d2d8:	e59f0468 	ldr	r0, [pc, #1128]	; c10d748 <startup+0x4dc>
 c10d2dc:	eb0006a5 	bl	c10ed78 <uart0_puts>

	/************************************/
	at24c04_load( buffer_aux );
 c10d2e0:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c10d2e4:	e243300c 	sub	r3, r3, #12
 c10d2e8:	e243300c 	sub	r3, r3, #12
 c10d2ec:	e1a00003 	mov	r0, r3
 c10d2f0:	ebfff67f 	bl	c10acf4 <at24c04_load>
	uart0_puts( " - Lectura secuencial (" );
 c10d2f4:	e59f0450 	ldr	r0, [pc, #1104]	; c10d74c <startup+0x4e0>
 c10d2f8:	eb00069e 	bl	c10ed78 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c10d2fc:	e3a00c02 	mov	r0, #512	; 0x200
 c10d300:	eb0006b0 	bl	c10edc8 <uart0_putint>
	uart0_puts( " bytes)" );
 c10d304:	e59f0444 	ldr	r0, [pc, #1092]	; c10d750 <startup+0x4e4>
 c10d308:	eb00069a 	bl	c10ed78 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d30c:	e3a03000 	mov	r3, #0
 c10d310:	e14b30be 	strh	r3, [fp, #-14]
 c10d314:	ea000012 	b	c10d364 <startup+0xf8>
		if( buffer[i] != buffer_aux[i] )
 c10d318:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d31c:	e59f3430 	ldr	r3, [pc, #1072]	; c10d754 <startup+0x4e8>
 c10d320:	e24b000c 	sub	r0, fp, #12
 c10d324:	e0802002 	add	r2, r0, r2
 c10d328:	e0823003 	add	r3, r2, r3
 c10d32c:	e5d32000 	ldrb	r2, [r3]
 c10d330:	e15b10be 	ldrh	r1, [fp, #-14]
 c10d334:	e59f341c 	ldr	r3, [pc, #1052]	; c10d758 <startup+0x4ec>
 c10d338:	e24b000c 	sub	r0, fp, #12
 c10d33c:	e0801001 	add	r1, r0, r1
 c10d340:	e0813003 	add	r3, r1, r3
 c10d344:	e5d33000 	ldrb	r3, [r3]
 c10d348:	e1520003 	cmp	r2, r3
 c10d34c:	0a000001 	beq	c10d358 <startup+0xec>
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );
 c10d350:	e59f0404 	ldr	r0, [pc, #1028]	; c10d75c <startup+0x4f0>
 c10d354:	eb000687 	bl	c10ed78 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d358:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d35c:	e2833001 	add	r3, r3, #1
 c10d360:	e14b30be 	strh	r3, [fp, #-14]
 c10d364:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d368:	e59f33d0 	ldr	r3, [pc, #976]	; c10d740 <startup+0x4d4>
 c10d36c:	e1520003 	cmp	r2, r3
 c10d370:	9affffe8 	bls	c10d318 <startup+0xac>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: lectura aleatoria y secuencial no son coincidentes\n" );

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );
 c10d374:	e59f03e4 	ldr	r0, [pc, #996]	; c10d760 <startup+0x4f4>
 c10d378:	eb00067e 	bl	c10ed78 <uart0_puts>

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c10d37c:	e3a03000 	mov	r3, #0
 c10d380:	e14b30be 	strh	r3, [fp, #-14]
 c10d384:	ea000066 	b	c10d524 <startup+0x2b8>
		uart0_puts( "\n" );
 c10d388:	e59f03d4 	ldr	r0, [pc, #980]	; c10d764 <startup+0x4f8>
 c10d38c:	eb000679 	bl	c10ed78 <uart0_puts>
		if( i<<4 <= 0xf )
 c10d390:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d394:	e1a03203 	lsl	r3, r3, #4
 c10d398:	e353000f 	cmp	r3, #15
 c10d39c:	ca000002 	bgt	c10d3ac <startup+0x140>
			uart0_puts( "00" );
 c10d3a0:	e59f03c0 	ldr	r0, [pc, #960]	; c10d768 <startup+0x4fc>
 c10d3a4:	eb000673 	bl	c10ed78 <uart0_puts>
 c10d3a8:	ea000005 	b	c10d3c4 <startup+0x158>
		else if( i<<4 <= 0xff )
 c10d3ac:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d3b0:	e1a03203 	lsl	r3, r3, #4
 c10d3b4:	e35300ff 	cmp	r3, #255	; 0xff
 c10d3b8:	ca000001 	bgt	c10d3c4 <startup+0x158>
			uart0_putchar( '0' );
 c10d3bc:	e3a00030 	mov	r0, #48	; 0x30
 c10d3c0:	eb000646 	bl	c10ece0 <uart0_putchar>
		uart0_puthex( i<<4 );
 c10d3c4:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d3c8:	e1a03203 	lsl	r3, r3, #4
 c10d3cc:	e1a00003 	mov	r0, r3
 c10d3d0:	eb0006bc 	bl	c10eec8 <uart0_puthex>
		uart0_puts( "h:"  );
 c10d3d4:	e59f0390 	ldr	r0, [pc, #912]	; c10d76c <startup+0x500>
 c10d3d8:	eb000666 	bl	c10ed78 <uart0_puts>
		for( j=0; j<16; j++ )
 c10d3dc:	e3a03000 	mov	r3, #0
 c10d3e0:	e14b31b0 	strh	r3, [fp, #-16]
 c10d3e4:	ea00001a 	b	c10d454 <startup+0x1e8>
		{
			if( buffer[(i<<4)+j] <= 0xf )
 c10d3e8:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d3ec:	e1a02203 	lsl	r2, r3, #4
 c10d3f0:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d3f4:	e0822003 	add	r2, r2, r3
 c10d3f8:	e59f3354 	ldr	r3, [pc, #852]	; c10d754 <startup+0x4e8>
 c10d3fc:	e24b100c 	sub	r1, fp, #12
 c10d400:	e0812002 	add	r2, r1, r2
 c10d404:	e0823003 	add	r3, r2, r3
 c10d408:	e5d33000 	ldrb	r3, [r3]
 c10d40c:	e353000f 	cmp	r3, #15
 c10d410:	8a000001 	bhi	c10d41c <startup+0x1b0>
				uart0_putchar( '0' );
 c10d414:	e3a00030 	mov	r0, #48	; 0x30
 c10d418:	eb000630 	bl	c10ece0 <uart0_putchar>
			uart0_puthex( buffer[(i<<4)+j] );
 c10d41c:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d420:	e1a02203 	lsl	r2, r3, #4
 c10d424:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d428:	e0822003 	add	r2, r2, r3
 c10d42c:	e59f3320 	ldr	r3, [pc, #800]	; c10d754 <startup+0x4e8>
 c10d430:	e24b000c 	sub	r0, fp, #12
 c10d434:	e0802002 	add	r2, r0, r2
 c10d438:	e0823003 	add	r3, r2, r3
 c10d43c:	e5d33000 	ldrb	r3, [r3]
 c10d440:	e1a00003 	mov	r0, r3
 c10d444:	eb00069f 	bl	c10eec8 <uart0_puthex>
			uart0_puts( "00" );
		else if( i<<4 <= 0xff )
			uart0_putchar( '0' );
		uart0_puthex( i<<4 );
		uart0_puts( "h:"  );
		for( j=0; j<16; j++ )
 c10d448:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d44c:	e2833001 	add	r3, r3, #1
 c10d450:	e14b31b0 	strh	r3, [fp, #-16]
 c10d454:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d458:	e353000f 	cmp	r3, #15
 c10d45c:	9affffe1 	bls	c10d3e8 <startup+0x17c>
		{
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
 c10d460:	e59f0308 	ldr	r0, [pc, #776]	; c10d770 <startup+0x504>
 c10d464:	eb000643 	bl	c10ed78 <uart0_puts>
		for( j=0; j<16; j++ )
 c10d468:	e3a03000 	mov	r3, #0
 c10d46c:	e14b31b0 	strh	r3, [fp, #-16]
 c10d470:	ea000025 	b	c10d50c <startup+0x2a0>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
 c10d474:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d478:	e1a02203 	lsl	r2, r3, #4
 c10d47c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d480:	e0822003 	add	r2, r2, r3
 c10d484:	e59f32c8 	ldr	r3, [pc, #712]	; c10d754 <startup+0x4e8>
 c10d488:	e24b100c 	sub	r1, fp, #12
 c10d48c:	e0812002 	add	r2, r1, r2
 c10d490:	e0823003 	add	r3, r2, r3
 c10d494:	e5d33000 	ldrb	r3, [r3]
 c10d498:	e353001f 	cmp	r3, #31
 c10d49c:	9a000014 	bls	c10d4f4 <startup+0x288>
 c10d4a0:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d4a4:	e1a02203 	lsl	r2, r3, #4
 c10d4a8:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d4ac:	e0822003 	add	r2, r2, r3
 c10d4b0:	e59f329c 	ldr	r3, [pc, #668]	; c10d754 <startup+0x4e8>
 c10d4b4:	e24b000c 	sub	r0, fp, #12
 c10d4b8:	e0802002 	add	r2, r0, r2
 c10d4bc:	e0823003 	add	r3, r2, r3
 c10d4c0:	e5d33000 	ldrb	r3, [r3]
 c10d4c4:	e353007e 	cmp	r3, #126	; 0x7e
 c10d4c8:	8a000009 	bhi	c10d4f4 <startup+0x288>
 c10d4cc:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d4d0:	e1a02203 	lsl	r2, r3, #4
 c10d4d4:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d4d8:	e0822003 	add	r2, r2, r3
 c10d4dc:	e59f3270 	ldr	r3, [pc, #624]	; c10d754 <startup+0x4e8>
 c10d4e0:	e24b100c 	sub	r1, fp, #12
 c10d4e4:	e0812002 	add	r2, r1, r2
 c10d4e8:	e0823003 	add	r3, r2, r3
 c10d4ec:	e5d33000 	ldrb	r3, [r3]
 c10d4f0:	ea000000 	b	c10d4f8 <startup+0x28c>
 c10d4f4:	e3a0302e 	mov	r3, #46	; 0x2e
 c10d4f8:	e1a00003 	mov	r0, r3
 c10d4fc:	eb0005f7 	bl	c10ece0 <uart0_putchar>
			if( buffer[(i<<4)+j] <= 0xf )
				uart0_putchar( '0' );
			uart0_puthex( buffer[(i<<4)+j] );
		}
		uart0_puts( " ; " );
		for( j=0; j<16; j++ )
 c10d500:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d504:	e2833001 	add	r3, r3, #1
 c10d508:	e14b31b0 	strh	r3, [fp, #-16]
 c10d50c:	e15b31b0 	ldrh	r3, [fp, #-16]
 c10d510:	e353000f 	cmp	r3, #15
 c10d514:	9affffd6 	bls	c10d474 <startup+0x208>

	/************************************/

	uart0_puts( "\nVolcado del contenido inicial de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i < (AT24C04_DEPTH>>4); i++ ){
 c10d518:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d51c:	e2833001 	add	r3, r3, #1
 c10d520:	e14b30be 	strh	r3, [fp, #-14]
 c10d524:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d528:	e353001f 	cmp	r3, #31
 c10d52c:	9affff95 	bls	c10d388 <startup+0x11c>
			  uart0_putchar( ( (31<buffer[(i<<4)+j]) && (buffer[(i<<4)+j]<127) ? buffer[(i<<4)+j] : '.' ) );
	};

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );
 c10d530:	e59f023c 	ldr	r0, [pc, #572]	; c10d774 <startup+0x508>
 c10d534:	eb00060f 	bl	c10ed78 <uart0_puts>

	for( i=0; i<5; i++ )
 c10d538:	e3a03000 	mov	r3, #0
 c10d53c:	e14b30be 	strh	r3, [fp, #-14]
 c10d540:	ea000012 	b	c10d590 <startup+0x324>
	{
		uart0_puts( "  - Introduzca una direccion (0h-1ffh): " );
 c10d544:	e59f022c 	ldr	r0, [pc, #556]	; c10d778 <startup+0x50c>
 c10d548:	eb00060a 	bl	c10ed78 <uart0_puts>
		addr = uart0_gethex( );
 c10d54c:	eb0006dc 	bl	c10f0c4 <uart0_gethex>
 c10d550:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
		uart0_puts( "  - Introduzca el dato (0h-ffh): " );
 c10d554:	e59f0220 	ldr	r0, [pc, #544]	; c10d77c <startup+0x510>
 c10d558:	eb000606 	bl	c10ed78 <uart0_puts>
		data = uart0_gethex( );
 c10d55c:	eb0006d8 	bl	c10f0c4 <uart0_gethex>
 c10d560:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
		buffer[addr] = data;
 c10d564:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10d568:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d56c:	e59f31e0 	ldr	r3, [pc, #480]	; c10d754 <startup+0x4e8>
 c10d570:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
 c10d574:	e24b000c 	sub	r0, fp, #12
 c10d578:	e0801001 	add	r1, r0, r1
 c10d57c:	e0813003 	add	r3, r1, r3
 c10d580:	e5c32000 	strb	r2, [r3]

	/************************************/

	uart0_puts( "\n\nModificacion del contenido de la memoria IIC-EEPROM AT24C04:\n" );

	for( i=0; i<5; i++ )
 c10d584:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d588:	e2833001 	add	r3, r3, #1
 c10d58c:	e14b30be 	strh	r3, [fp, #-14]
 c10d590:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d594:	e3530004 	cmp	r3, #4
 c10d598:	9affffe9 	bls	c10d544 <startup+0x2d8>
		buffer[addr] = data;
	}

	/************************************/

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );
 c10d59c:	e59f01dc 	ldr	r0, [pc, #476]	; c10d780 <startup+0x514>
 c10d5a0:	eb0005f4 	bl	c10ed78 <uart0_puts>

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d5a4:	e3a03000 	mov	r3, #0
 c10d5a8:	e14b30be 	strh	r3, [fp, #-14]
 c10d5ac:	ea00000c 	b	c10d5e4 <startup+0x378>
		at24c04_bytewrite( i, buffer[i] );
 c10d5b0:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d5b4:	e59f3198 	ldr	r3, [pc, #408]	; c10d754 <startup+0x4e8>
 c10d5b8:	e24b100c 	sub	r1, fp, #12
 c10d5bc:	e0812002 	add	r2, r1, r2
 c10d5c0:	e0823003 	add	r3, r2, r3
 c10d5c4:	e5d33000 	ldrb	r3, [r3]
 c10d5c8:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d5cc:	e1a00002 	mov	r0, r2
 c10d5d0:	e1a01003 	mov	r1, r3
 c10d5d4:	ebfff573 	bl	c10aba8 <at24c04_bytewrite>

	uart0_puts( "\nVolcando en la IIC-EEPROM AT24C04 el contenido de la RAM:\n" );

	/************************************/

	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d5d8:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d5dc:	e2833001 	add	r3, r3, #1
 c10d5e0:	e14b30be 	strh	r3, [fp, #-14]
 c10d5e4:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d5e8:	e59f3150 	ldr	r3, [pc, #336]	; c10d740 <startup+0x4d4>
 c10d5ec:	e1520003 	cmp	r2, r3
 c10d5f0:	9affffee 	bls	c10d5b0 <startup+0x344>
		at24c04_bytewrite( i, buffer[i] );
	uart0_puts( " - Escritura aleatoria (" );
 c10d5f4:	e59f0188 	ldr	r0, [pc, #392]	; c10d784 <startup+0x518>
 c10d5f8:	eb0005de 	bl	c10ed78 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c10d5fc:	e3a00c02 	mov	r0, #512	; 0x200
 c10d600:	eb0005f0 	bl	c10edc8 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c10d604:	e59f013c 	ldr	r0, [pc, #316]	; c10d748 <startup+0x4dc>
 c10d608:	eb0005da 	bl	c10ed78 <uart0_puts>

	at24c04_load( buffer_aux );
 c10d60c:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c10d610:	e243300c 	sub	r3, r3, #12
 c10d614:	e243300c 	sub	r3, r3, #12
 c10d618:	e1a00003 	mov	r0, r3
 c10d61c:	ebfff5b4 	bl	c10acf4 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d620:	e3a03000 	mov	r3, #0
 c10d624:	e14b30be 	strh	r3, [fp, #-14]
 c10d628:	ea000012 	b	c10d678 <startup+0x40c>
		if( buffer[i] != buffer_aux[i] )
 c10d62c:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d630:	e59f311c 	ldr	r3, [pc, #284]	; c10d754 <startup+0x4e8>
 c10d634:	e24b000c 	sub	r0, fp, #12
 c10d638:	e0802002 	add	r2, r0, r2
 c10d63c:	e0823003 	add	r3, r2, r3
 c10d640:	e5d32000 	ldrb	r2, [r3]
 c10d644:	e15b10be 	ldrh	r1, [fp, #-14]
 c10d648:	e59f3108 	ldr	r3, [pc, #264]	; c10d758 <startup+0x4ec>
 c10d64c:	e24b000c 	sub	r0, fp, #12
 c10d650:	e0801001 	add	r1, r0, r1
 c10d654:	e0813003 	add	r3, r1, r3
 c10d658:	e5d33000 	ldrb	r3, [r3]
 c10d65c:	e1520003 	cmp	r2, r3
 c10d660:	0a000001 	beq	c10d66c <startup+0x400>
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );
 c10d664:	e59f011c 	ldr	r0, [pc, #284]	; c10d788 <startup+0x51c>
 c10d668:	eb0005c2 	bl	c10ed78 <uart0_puts>
	uart0_puts( " - Escritura aleatoria (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d66c:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d670:	e2833001 	add	r3, r3, #1
 c10d674:	e14b30be 	strh	r3, [fp, #-14]
 c10d678:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d67c:	e59f30bc 	ldr	r3, [pc, #188]	; c10d740 <startup+0x4d4>
 c10d680:	e1520003 	cmp	r2, r3
 c10d684:	9affffe8 	bls	c10d62c <startup+0x3c0>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura aleatoria falla.\n" );

	/************************************/

	at24c04_store( buffer );
 c10d688:	e24b3f86 	sub	r3, fp, #536	; 0x218
 c10d68c:	e1a00003 	mov	r0, r3
 c10d690:	ebfff5c5 	bl	c10adac <at24c04_store>
	uart0_puts( " - Escritura secuencial (" );
 c10d694:	e59f00f0 	ldr	r0, [pc, #240]	; c10d78c <startup+0x520>
 c10d698:	eb0005b6 	bl	c10ed78 <uart0_puts>
	uart0_putint( AT24C04_DEPTH );
 c10d69c:	e3a00c02 	mov	r0, #512	; 0x200
 c10d6a0:	eb0005c8 	bl	c10edc8 <uart0_putint>
	uart0_puts( " bytes)\n" );
 c10d6a4:	e59f009c 	ldr	r0, [pc, #156]	; c10d748 <startup+0x4dc>
 c10d6a8:	eb0005b2 	bl	c10ed78 <uart0_puts>

	at24c04_load( buffer_aux );
 c10d6ac:	e24b3b01 	sub	r3, fp, #1024	; 0x400
 c10d6b0:	e243300c 	sub	r3, r3, #12
 c10d6b4:	e243300c 	sub	r3, r3, #12
 c10d6b8:	e1a00003 	mov	r0, r3
 c10d6bc:	ebfff58c 	bl	c10acf4 <at24c04_load>
	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d6c0:	e3a03000 	mov	r3, #0
 c10d6c4:	e14b30be 	strh	r3, [fp, #-14]
 c10d6c8:	ea000012 	b	c10d718 <startup+0x4ac>
		if( buffer[i] != buffer_aux[i] )
 c10d6cc:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d6d0:	e59f307c 	ldr	r3, [pc, #124]	; c10d754 <startup+0x4e8>
 c10d6d4:	e24b100c 	sub	r1, fp, #12
 c10d6d8:	e0812002 	add	r2, r1, r2
 c10d6dc:	e0823003 	add	r3, r2, r3
 c10d6e0:	e5d32000 	ldrb	r2, [r3]
 c10d6e4:	e15b10be 	ldrh	r1, [fp, #-14]
 c10d6e8:	e59f3068 	ldr	r3, [pc, #104]	; c10d758 <startup+0x4ec>
 c10d6ec:	e24b000c 	sub	r0, fp, #12
 c10d6f0:	e0801001 	add	r1, r0, r1
 c10d6f4:	e0813003 	add	r3, r1, r3
 c10d6f8:	e5d33000 	ldrb	r3, [r3]
 c10d6fc:	e1520003 	cmp	r2, r3
 c10d700:	0a000001 	beq	c10d70c <startup+0x4a0>
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );
 c10d704:	e59f0084 	ldr	r0, [pc, #132]	; c10d790 <startup+0x524>
 c10d708:	eb00059a 	bl	c10ed78 <uart0_puts>
	uart0_puts( " - Escritura secuencial (" );
	uart0_putint( AT24C04_DEPTH );
	uart0_puts( " bytes)\n" );

	at24c04_load( buffer_aux );
	for( i=0; i<AT24C04_DEPTH; i++ )
 c10d70c:	e15b30be 	ldrh	r3, [fp, #-14]
 c10d710:	e2833001 	add	r3, r3, #1
 c10d714:	e14b30be 	strh	r3, [fp, #-14]
 c10d718:	e15b20be 	ldrh	r2, [fp, #-14]
 c10d71c:	e59f301c 	ldr	r3, [pc, #28]	; c10d740 <startup+0x4d4>
 c10d720:	e1520003 	cmp	r2, r3
 c10d724:	9affffe8 	bls	c10d6cc <startup+0x460>
		if( buffer[i] != buffer_aux[i] )
			uart0_puts( "ERROR: La escritura secuencial falla.\n" );

	/************************************/

	uart0_puts( "\nApague la placa y vuelva a cargar y ejecutar el programa.\n" );
 c10d728:	e59f0064 	ldr	r0, [pc, #100]	; c10d794 <startup+0x528>
 c10d72c:	eb000591 	bl	c10ed78 <uart0_puts>
}
 c10d730:	e24bd00c 	sub	sp, fp, #12
 c10d734:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10d738:	e12fff1e 	bx	lr
 c10d73c:	0c101138 	.word	0x0c101138
 c10d740:	000001ff 	.word	0x000001ff
 c10d744:	0c101170 	.word	0x0c101170
 c10d748:	0c101188 	.word	0x0c101188
 c10d74c:	0c101194 	.word	0x0c101194
 c10d750:	0c1011ac 	.word	0x0c1011ac
 c10d754:	fffffdf4 	.word	0xfffffdf4
 c10d758:	fffffbf4 	.word	0xfffffbf4
 c10d75c:	0c1011b4 	.word	0x0c1011b4
 c10d760:	0c1011f0 	.word	0x0c1011f0
 c10d764:	0c101234 	.word	0x0c101234
 c10d768:	0c101238 	.word	0x0c101238
 c10d76c:	0c10123c 	.word	0x0c10123c
 c10d770:	0c101240 	.word	0x0c101240
 c10d774:	0c101244 	.word	0x0c101244
 c10d778:	0c101284 	.word	0x0c101284
 c10d77c:	0c1012b0 	.word	0x0c1012b0
 c10d780:	0c1012d4 	.word	0x0c1012d4
 c10d784:	0c101310 	.word	0x0c101310
 c10d788:	0c10132c 	.word	0x0c10132c
 c10d78c:	0c101354 	.word	0x0c101354
 c10d790:	0c101370 	.word	0x0c101370
 c10d794:	0c101398 	.word	0x0c101398

0c10d798 <loop>:

int loop(void) {
 c10d798:	e1a0c00d 	mov	ip, sp
 c10d79c:	e92dd800 	push	{fp, ip, lr, pc}
 c10d7a0:	e24cb004 	sub	fp, ip, #4
	return 0;
 c10d7a4:	e3a03000 	mov	r3, #0
}
 c10d7a8:	e1a00003 	mov	r0, r3
 c10d7ac:	e24bd00c 	sub	sp, fp, #12
 c10d7b0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10d7b4:	e12fff1e 	bx	lr

0c10d7b8 <main>:

int main(void) {
 c10d7b8:	e1a0c00d 	mov	ip, sp
 c10d7bc:	e92dd800 	push	{fp, ip, lr, pc}
 c10d7c0:	e24cb004 	sub	fp, ip, #4

	setup();
 c10d7c4:	ebfffda0 	bl	c10ce4c <setup>
	startup();
 c10d7c8:	ebfffea7 	bl	c10d26c <startup>

	while (1) {
		loop();
 c10d7cc:	ebfffff1 	bl	c10d798 <loop>
	}
 c10d7d0:	eafffffd 	b	c10d7cc <main+0x14>

0c10d7d4 <isr_TICK_dummy>:
#include "intcontroller.h"

void isr_TICK_dummy(void)  __attribute__ ((interrupt ("IRQ")));
void isr_ALARM_dummy(void) __attribute__ ((interrupt ("IRQ")));

void isr_TICK_dummy(void){
 c10d7d4:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10d7d8:	e1a0c00d 	mov	ip, sp
 c10d7dc:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10d7e0:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_TICK);
 c10d7e4:	e3a00014 	mov	r0, #20
 c10d7e8:	ebfff981 	bl	c10bdf4 <ic_cleanflag>
}
 c10d7ec:	e24bd01c 	sub	sp, fp, #28
 c10d7f0:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10d7f4:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10d7f8:	e25ef004 	subs	pc, lr, #4

0c10d7fc <isr_ALARM_dummy>:

void isr_ALARM_dummy(void){
 c10d7fc:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
 c10d800:	e1a0c00d 	mov	ip, sp
 c10d804:	e92dd80f 	push	{r0, r1, r2, r3, fp, ip, lr, pc}
 c10d808:	e24cb004 	sub	fp, ip, #4
	ic_cleanflag(INT_RTC);
 c10d80c:	e3a00001 	mov	r0, #1
 c10d810:	ebfff977 	bl	c10bdf4 <ic_cleanflag>
}
 c10d814:	e24bd01c 	sub	sp, fp, #28
 c10d818:	e89d680f 	ldm	sp, {r0, r1, r2, r3, fp, sp, lr}
 c10d81c:	e49dc004 	pop	{ip}		; (ldr ip, [sp], #4)
 c10d820:	e25ef004 	subs	pc, lr, #4

0c10d824 <rtc_init>:

void rtc_init( void )
{
 c10d824:	e1a0c00d 	mov	ip, sp
 c10d828:	e92dd800 	push	{fp, ip, lr, pc}
 c10d82c:	e24cb004 	sub	fp, ip, #4
	//Disable Tick interrupt
    rTICINT   = 0x0;
 c10d830:	e59f3098 	ldr	r3, [pc, #152]	; c10d8d0 <rtc_init+0xac>
 c10d834:	e3a02000 	mov	r2, #0
 c10d838:	e5c32000 	strb	r2, [r3]

    //Disable alarm
    rRTCALM  = 0x0;
 c10d83c:	e59f3090 	ldr	r3, [pc, #144]	; c10d8d4 <rtc_init+0xb0>
 c10d840:	e3a02000 	mov	r2, #0
 c10d844:	e5c32000 	strb	r2, [r3]

    //Disable Rounding
    rRTCRST  = 0x0;
 c10d848:	e59f3088 	ldr	r3, [pc, #136]	; c10d8d8 <rtc_init+0xb4>
 c10d84c:	e3a02000 	mov	r2, #0
 c10d850:	e5c32000 	strb	r2, [r3]


    // RTCCON[2] = 0 merged BCD registers: ˙nica opciÛn posible
    // RTCCON[1] = 0 Fuente de reloj primaria: ˙nica opciÛn posible: XTAL
    // RTCCON[0] = 1 Enabled register read/write
    rRTCCON  = 0x1;
 c10d854:	e59f3080 	ldr	r3, [pc, #128]	; c10d8dc <rtc_init+0xb8>
 c10d858:	e3a02001 	mov	r2, #1
 c10d85c:	e5c32000 	strb	r2, [r3]
    rBCDMIN  = 0x0;
    rBCDSEC  = 0x0;
    */

    //Init to 0
    rALMYEAR = 0;
 c10d860:	e59f3078 	ldr	r3, [pc, #120]	; c10d8e0 <rtc_init+0xbc>
 c10d864:	e3a02000 	mov	r2, #0
 c10d868:	e5c32000 	strb	r2, [r3]
    rALMMON  = 0;
 c10d86c:	e59f3070 	ldr	r3, [pc, #112]	; c10d8e4 <rtc_init+0xc0>
 c10d870:	e3a02000 	mov	r2, #0
 c10d874:	e5c32000 	strb	r2, [r3]
    rALMDAY  = 0;
 c10d878:	e59f3068 	ldr	r3, [pc, #104]	; c10d8e8 <rtc_init+0xc4>
 c10d87c:	e3a02000 	mov	r2, #0
 c10d880:	e5c32000 	strb	r2, [r3]
    rALMHOUR = 0;
 c10d884:	e59f3060 	ldr	r3, [pc, #96]	; c10d8ec <rtc_init+0xc8>
 c10d888:	e3a02000 	mov	r2, #0
 c10d88c:	e5c32000 	strb	r2, [r3]
    rALMMIN  = 0;
 c10d890:	e59f3058 	ldr	r3, [pc, #88]	; c10d8f0 <rtc_init+0xcc>
 c10d894:	e3a02000 	mov	r2, #0
 c10d898:	e5c32000 	strb	r2, [r3]
    rALMSEC  = 0;
 c10d89c:	e59f3050 	ldr	r3, [pc, #80]	; c10d8f4 <rtc_init+0xd0>
 c10d8a0:	e3a02000 	mov	r2, #0
 c10d8a4:	e5c32000 	strb	r2, [r3]

    rRTCCON &= ~1;
 c10d8a8:	e59f302c 	ldr	r3, [pc, #44]	; c10d8dc <rtc_init+0xb8>
 c10d8ac:	e59f2028 	ldr	r2, [pc, #40]	; c10d8dc <rtc_init+0xb8>
 c10d8b0:	e5d22000 	ldrb	r2, [r2]
 c10d8b4:	e20220ff 	and	r2, r2, #255	; 0xff
 c10d8b8:	e3c22001 	bic	r2, r2, #1
 c10d8bc:	e20220ff 	and	r2, r2, #255	; 0xff
 c10d8c0:	e5c32000 	strb	r2, [r3]
}
 c10d8c4:	e24bd00c 	sub	sp, fp, #12
 c10d8c8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10d8cc:	e12fff1e 	bx	lr
 c10d8d0:	01d7008c 	.word	0x01d7008c
 c10d8d4:	01d70050 	.word	0x01d70050
 c10d8d8:	01d7006c 	.word	0x01d7006c
 c10d8dc:	01d70040 	.word	0x01d70040
 c10d8e0:	01d70068 	.word	0x01d70068
 c10d8e4:	01d70064 	.word	0x01d70064
 c10d8e8:	01d70060 	.word	0x01d70060
 c10d8ec:	01d7005c 	.word	0x01d7005c
 c10d8f0:	01d70058 	.word	0x01d70058
 c10d8f4:	01d70054 	.word	0x01d70054

0c10d8f8 <rtc_puttime>:

void rtc_puttime( rtc_time_t *rtc_time )
{
 c10d8f8:	e1a0c00d 	mov	ip, sp
 c10d8fc:	e92dd800 	push	{fp, ip, lr, pc}
 c10d900:	e24cb004 	sub	fp, ip, #4
 c10d904:	e24dd008 	sub	sp, sp, #8
 c10d908:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c10d90c:	e59f3394 	ldr	r3, [pc, #916]	; c10dca8 <rtc_puttime+0x3b0>
 c10d910:	e59f2390 	ldr	r2, [pc, #912]	; c10dca8 <rtc_puttime+0x3b0>
 c10d914:	e5d22000 	ldrb	r2, [r2]
 c10d918:	e20220ff 	and	r2, r2, #255	; 0xff
 c10d91c:	e3822001 	orr	r2, r2, #1
 c10d920:	e20220ff 	and	r2, r2, #255	; 0xff
 c10d924:	e5c32000 	strb	r2, [r3]

    rBCDYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c10d928:	e59f037c 	ldr	r0, [pc, #892]	; c10dcac <rtc_puttime+0x3b4>
 c10d92c:	e51b3010 	ldr	r3, [fp, #-16]
 c10d930:	e5d32006 	ldrb	r2, [r3, #6]
 c10d934:	e59f3374 	ldr	r3, [pc, #884]	; c10dcb0 <rtc_puttime+0x3b8>
 c10d938:	e0831392 	umull	r1, r3, r2, r3
 c10d93c:	e1a031a3 	lsr	r3, r3, #3
 c10d940:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d944:	e59f3364 	ldr	r3, [pc, #868]	; c10dcb0 <rtc_puttime+0x3b8>
 c10d948:	e0831392 	umull	r1, r3, r2, r3
 c10d94c:	e1a011a3 	lsr	r1, r3, #3
 c10d950:	e1a03001 	mov	r3, r1
 c10d954:	e1a03103 	lsl	r3, r3, #2
 c10d958:	e0833001 	add	r3, r3, r1
 c10d95c:	e1a03083 	lsl	r3, r3, #1
 c10d960:	e0633002 	rsb	r3, r3, r2
 c10d964:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d968:	e1a03203 	lsl	r3, r3, #4
 c10d96c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10d970:	e51b3010 	ldr	r3, [fp, #-16]
 c10d974:	e5d32006 	ldrb	r2, [r3, #6]
 c10d978:	e59f3330 	ldr	r3, [pc, #816]	; c10dcb0 <rtc_puttime+0x3b8>
 c10d97c:	e0831392 	umull	r1, r3, r2, r3
 c10d980:	e1a011a3 	lsr	r1, r3, #3
 c10d984:	e1a03001 	mov	r3, r1
 c10d988:	e1a03103 	lsl	r3, r3, #2
 c10d98c:	e0833001 	add	r3, r3, r1
 c10d990:	e1a03083 	lsl	r3, r3, #1
 c10d994:	e0633002 	rsb	r3, r3, r2
 c10d998:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d99c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d9a0:	e1a0200c 	mov	r2, ip
 c10d9a4:	e1823003 	orr	r3, r2, r3
 c10d9a8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d9ac:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d9b0:	e5c03000 	strb	r3, [r0]
    rBCDMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c10d9b4:	e59f02f8 	ldr	r0, [pc, #760]	; c10dcb4 <rtc_puttime+0x3bc>
 c10d9b8:	e51b3010 	ldr	r3, [fp, #-16]
 c10d9bc:	e5d32005 	ldrb	r2, [r3, #5]
 c10d9c0:	e59f32e8 	ldr	r3, [pc, #744]	; c10dcb0 <rtc_puttime+0x3b8>
 c10d9c4:	e0831392 	umull	r1, r3, r2, r3
 c10d9c8:	e1a031a3 	lsr	r3, r3, #3
 c10d9cc:	e20320ff 	and	r2, r3, #255	; 0xff
 c10d9d0:	e59f32d8 	ldr	r3, [pc, #728]	; c10dcb0 <rtc_puttime+0x3b8>
 c10d9d4:	e0831392 	umull	r1, r3, r2, r3
 c10d9d8:	e1a011a3 	lsr	r1, r3, #3
 c10d9dc:	e1a03001 	mov	r3, r1
 c10d9e0:	e1a03103 	lsl	r3, r3, #2
 c10d9e4:	e0833001 	add	r3, r3, r1
 c10d9e8:	e1a03083 	lsl	r3, r3, #1
 c10d9ec:	e0633002 	rsb	r3, r3, r2
 c10d9f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10d9f4:	e1a03203 	lsl	r3, r3, #4
 c10d9f8:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10d9fc:	e51b3010 	ldr	r3, [fp, #-16]
 c10da00:	e5d32005 	ldrb	r2, [r3, #5]
 c10da04:	e59f32a4 	ldr	r3, [pc, #676]	; c10dcb0 <rtc_puttime+0x3b8>
 c10da08:	e0831392 	umull	r1, r3, r2, r3
 c10da0c:	e1a011a3 	lsr	r1, r3, #3
 c10da10:	e1a03001 	mov	r3, r1
 c10da14:	e1a03103 	lsl	r3, r3, #2
 c10da18:	e0833001 	add	r3, r3, r1
 c10da1c:	e1a03083 	lsl	r3, r3, #1
 c10da20:	e0633002 	rsb	r3, r3, r2
 c10da24:	e20330ff 	and	r3, r3, #255	; 0xff
 c10da28:	e20330ff 	and	r3, r3, #255	; 0xff
 c10da2c:	e1a0200c 	mov	r2, ip
 c10da30:	e1823003 	orr	r3, r2, r3
 c10da34:	e20330ff 	and	r3, r3, #255	; 0xff
 c10da38:	e20330ff 	and	r3, r3, #255	; 0xff
 c10da3c:	e5c03000 	strb	r3, [r0]
    rBCDDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c10da40:	e59f0270 	ldr	r0, [pc, #624]	; c10dcb8 <rtc_puttime+0x3c0>
 c10da44:	e51b3010 	ldr	r3, [fp, #-16]
 c10da48:	e5d32003 	ldrb	r2, [r3, #3]
 c10da4c:	e59f325c 	ldr	r3, [pc, #604]	; c10dcb0 <rtc_puttime+0x3b8>
 c10da50:	e0831392 	umull	r1, r3, r2, r3
 c10da54:	e1a031a3 	lsr	r3, r3, #3
 c10da58:	e20320ff 	and	r2, r3, #255	; 0xff
 c10da5c:	e59f324c 	ldr	r3, [pc, #588]	; c10dcb0 <rtc_puttime+0x3b8>
 c10da60:	e0831392 	umull	r1, r3, r2, r3
 c10da64:	e1a011a3 	lsr	r1, r3, #3
 c10da68:	e1a03001 	mov	r3, r1
 c10da6c:	e1a03103 	lsl	r3, r3, #2
 c10da70:	e0833001 	add	r3, r3, r1
 c10da74:	e1a03083 	lsl	r3, r3, #1
 c10da78:	e0633002 	rsb	r3, r3, r2
 c10da7c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10da80:	e1a03203 	lsl	r3, r3, #4
 c10da84:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10da88:	e51b3010 	ldr	r3, [fp, #-16]
 c10da8c:	e5d32003 	ldrb	r2, [r3, #3]
 c10da90:	e59f3218 	ldr	r3, [pc, #536]	; c10dcb0 <rtc_puttime+0x3b8>
 c10da94:	e0831392 	umull	r1, r3, r2, r3
 c10da98:	e1a011a3 	lsr	r1, r3, #3
 c10da9c:	e1a03001 	mov	r3, r1
 c10daa0:	e1a03103 	lsl	r3, r3, #2
 c10daa4:	e0833001 	add	r3, r3, r1
 c10daa8:	e1a03083 	lsl	r3, r3, #1
 c10daac:	e0633002 	rsb	r3, r3, r2
 c10dab0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dab4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dab8:	e1a0200c 	mov	r2, ip
 c10dabc:	e1823003 	orr	r3, r2, r3
 c10dac0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dac4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dac8:	e5c03000 	strb	r3, [r0]
    rBCDDATE = rtc_time->wday;
 c10dacc:	e59f31e8 	ldr	r3, [pc, #488]	; c10dcbc <rtc_puttime+0x3c4>
 c10dad0:	e51b2010 	ldr	r2, [fp, #-16]
 c10dad4:	e5d22004 	ldrb	r2, [r2, #4]
 c10dad8:	e5c32000 	strb	r2, [r3]
    rBCDHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c10dadc:	e59f01dc 	ldr	r0, [pc, #476]	; c10dcc0 <rtc_puttime+0x3c8>
 c10dae0:	e51b3010 	ldr	r3, [fp, #-16]
 c10dae4:	e5d32002 	ldrb	r2, [r3, #2]
 c10dae8:	e59f31c0 	ldr	r3, [pc, #448]	; c10dcb0 <rtc_puttime+0x3b8>
 c10daec:	e0831392 	umull	r1, r3, r2, r3
 c10daf0:	e1a031a3 	lsr	r3, r3, #3
 c10daf4:	e20320ff 	and	r2, r3, #255	; 0xff
 c10daf8:	e59f31b0 	ldr	r3, [pc, #432]	; c10dcb0 <rtc_puttime+0x3b8>
 c10dafc:	e0831392 	umull	r1, r3, r2, r3
 c10db00:	e1a011a3 	lsr	r1, r3, #3
 c10db04:	e1a03001 	mov	r3, r1
 c10db08:	e1a03103 	lsl	r3, r3, #2
 c10db0c:	e0833001 	add	r3, r3, r1
 c10db10:	e1a03083 	lsl	r3, r3, #1
 c10db14:	e0633002 	rsb	r3, r3, r2
 c10db18:	e20330ff 	and	r3, r3, #255	; 0xff
 c10db1c:	e1a03203 	lsl	r3, r3, #4
 c10db20:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10db24:	e51b3010 	ldr	r3, [fp, #-16]
 c10db28:	e5d32002 	ldrb	r2, [r3, #2]
 c10db2c:	e59f317c 	ldr	r3, [pc, #380]	; c10dcb0 <rtc_puttime+0x3b8>
 c10db30:	e0831392 	umull	r1, r3, r2, r3
 c10db34:	e1a011a3 	lsr	r1, r3, #3
 c10db38:	e1a03001 	mov	r3, r1
 c10db3c:	e1a03103 	lsl	r3, r3, #2
 c10db40:	e0833001 	add	r3, r3, r1
 c10db44:	e1a03083 	lsl	r3, r3, #1
 c10db48:	e0633002 	rsb	r3, r3, r2
 c10db4c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10db50:	e20330ff 	and	r3, r3, #255	; 0xff
 c10db54:	e1a0200c 	mov	r2, ip
 c10db58:	e1823003 	orr	r3, r2, r3
 c10db5c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10db60:	e20330ff 	and	r3, r3, #255	; 0xff
 c10db64:	e5c03000 	strb	r3, [r0]
    rBCDMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c10db68:	e59f0154 	ldr	r0, [pc, #340]	; c10dcc4 <rtc_puttime+0x3cc>
 c10db6c:	e51b3010 	ldr	r3, [fp, #-16]
 c10db70:	e5d32001 	ldrb	r2, [r3, #1]
 c10db74:	e59f3134 	ldr	r3, [pc, #308]	; c10dcb0 <rtc_puttime+0x3b8>
 c10db78:	e0831392 	umull	r1, r3, r2, r3
 c10db7c:	e1a031a3 	lsr	r3, r3, #3
 c10db80:	e20320ff 	and	r2, r3, #255	; 0xff
 c10db84:	e59f3124 	ldr	r3, [pc, #292]	; c10dcb0 <rtc_puttime+0x3b8>
 c10db88:	e0831392 	umull	r1, r3, r2, r3
 c10db8c:	e1a011a3 	lsr	r1, r3, #3
 c10db90:	e1a03001 	mov	r3, r1
 c10db94:	e1a03103 	lsl	r3, r3, #2
 c10db98:	e0833001 	add	r3, r3, r1
 c10db9c:	e1a03083 	lsl	r3, r3, #1
 c10dba0:	e0633002 	rsb	r3, r3, r2
 c10dba4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dba8:	e1a03203 	lsl	r3, r3, #4
 c10dbac:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10dbb0:	e51b3010 	ldr	r3, [fp, #-16]
 c10dbb4:	e5d32001 	ldrb	r2, [r3, #1]
 c10dbb8:	e59f30f0 	ldr	r3, [pc, #240]	; c10dcb0 <rtc_puttime+0x3b8>
 c10dbbc:	e0831392 	umull	r1, r3, r2, r3
 c10dbc0:	e1a011a3 	lsr	r1, r3, #3
 c10dbc4:	e1a03001 	mov	r3, r1
 c10dbc8:	e1a03103 	lsl	r3, r3, #2
 c10dbcc:	e0833001 	add	r3, r3, r1
 c10dbd0:	e1a03083 	lsl	r3, r3, #1
 c10dbd4:	e0633002 	rsb	r3, r3, r2
 c10dbd8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dbdc:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dbe0:	e1a0200c 	mov	r2, ip
 c10dbe4:	e1823003 	orr	r3, r2, r3
 c10dbe8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dbec:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dbf0:	e5c03000 	strb	r3, [r0]
    rBCDSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c10dbf4:	e59f00cc 	ldr	r0, [pc, #204]	; c10dcc8 <rtc_puttime+0x3d0>
 c10dbf8:	e51b3010 	ldr	r3, [fp, #-16]
 c10dbfc:	e5d32000 	ldrb	r2, [r3]
 c10dc00:	e59f30a8 	ldr	r3, [pc, #168]	; c10dcb0 <rtc_puttime+0x3b8>
 c10dc04:	e0831392 	umull	r1, r3, r2, r3
 c10dc08:	e1a031a3 	lsr	r3, r3, #3
 c10dc0c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dc10:	e59f3098 	ldr	r3, [pc, #152]	; c10dcb0 <rtc_puttime+0x3b8>
 c10dc14:	e0831392 	umull	r1, r3, r2, r3
 c10dc18:	e1a011a3 	lsr	r1, r3, #3
 c10dc1c:	e1a03001 	mov	r3, r1
 c10dc20:	e1a03103 	lsl	r3, r3, #2
 c10dc24:	e0833001 	add	r3, r3, r1
 c10dc28:	e1a03083 	lsl	r3, r3, #1
 c10dc2c:	e0633002 	rsb	r3, r3, r2
 c10dc30:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dc34:	e1a03203 	lsl	r3, r3, #4
 c10dc38:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10dc3c:	e51b3010 	ldr	r3, [fp, #-16]
 c10dc40:	e5d32000 	ldrb	r2, [r3]
 c10dc44:	e59f3064 	ldr	r3, [pc, #100]	; c10dcb0 <rtc_puttime+0x3b8>
 c10dc48:	e0831392 	umull	r1, r3, r2, r3
 c10dc4c:	e1a011a3 	lsr	r1, r3, #3
 c10dc50:	e1a03001 	mov	r3, r1
 c10dc54:	e1a03103 	lsl	r3, r3, #2
 c10dc58:	e0833001 	add	r3, r3, r1
 c10dc5c:	e1a03083 	lsl	r3, r3, #1
 c10dc60:	e0633002 	rsb	r3, r3, r2
 c10dc64:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dc68:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dc6c:	e1a0200c 	mov	r2, ip
 c10dc70:	e1823003 	orr	r3, r2, r3
 c10dc74:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dc78:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dc7c:	e5c03000 	strb	r3, [r0]

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c10dc80:	e59f3020 	ldr	r3, [pc, #32]	; c10dca8 <rtc_puttime+0x3b0>
 c10dc84:	e59f201c 	ldr	r2, [pc, #28]	; c10dca8 <rtc_puttime+0x3b0>
 c10dc88:	e5d22000 	ldrb	r2, [r2]
 c10dc8c:	e20220ff 	and	r2, r2, #255	; 0xff
 c10dc90:	e3c22001 	bic	r2, r2, #1
 c10dc94:	e20220ff 	and	r2, r2, #255	; 0xff
 c10dc98:	e5c32000 	strb	r2, [r3]
}
 c10dc9c:	e24bd00c 	sub	sp, fp, #12
 c10dca0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10dca4:	e12fff1e 	bx	lr
 c10dca8:	01d70040 	.word	0x01d70040
 c10dcac:	01d70088 	.word	0x01d70088
 c10dcb0:	cccccccd 	.word	0xcccccccd
 c10dcb4:	01d70084 	.word	0x01d70084
 c10dcb8:	01d7007c 	.word	0x01d7007c
 c10dcbc:	01d70080 	.word	0x01d70080
 c10dcc0:	01d70078 	.word	0x01d70078
 c10dcc4:	01d70074 	.word	0x01d70074
 c10dcc8:	01d70070 	.word	0x01d70070

0c10dccc <rtc_gettime>:

void rtc_gettime( rtc_time_t *rtc_time )
{
 c10dccc:	e1a0c00d 	mov	ip, sp
 c10dcd0:	e92dd800 	push	{fp, ip, lr, pc}
 c10dcd4:	e24cb004 	sub	fp, ip, #4
 c10dcd8:	e24dd008 	sub	sp, sp, #8
 c10dcdc:	e50b0010 	str	r0, [fp, #-16]
	//Set RTCEN=RTCCON[0] = 1
    rRTCCON |= 1;
 c10dce0:	e59f3404 	ldr	r3, [pc, #1028]	; c10e0ec <rtc_gettime+0x420>
 c10dce4:	e59f2400 	ldr	r2, [pc, #1024]	; c10e0ec <rtc_gettime+0x420>
 c10dce8:	e5d22000 	ldrb	r2, [r2]
 c10dcec:	e20220ff 	and	r2, r2, #255	; 0xff
 c10dcf0:	e3822001 	orr	r2, r2, #1
 c10dcf4:	e20220ff 	and	r2, r2, #255	; 0xff
 c10dcf8:	e5c32000 	strb	r2, [r3]

    rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c10dcfc:	e59f33ec 	ldr	r3, [pc, #1004]	; c10e0f0 <rtc_gettime+0x424>
 c10dd00:	e5d33000 	ldrb	r3, [r3]
 c10dd04:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd08:	e203300f 	and	r3, r3, #15
 c10dd0c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dd10:	e59f33d8 	ldr	r3, [pc, #984]	; c10e0f0 <rtc_gettime+0x424>
 c10dd14:	e5d33000 	ldrb	r3, [r3]
 c10dd18:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd1c:	e1a03223 	lsr	r3, r3, #4
 c10dd20:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd24:	e1a01003 	mov	r1, r3
 c10dd28:	e1a01101 	lsl	r1, r1, #2
 c10dd2c:	e0813003 	add	r3, r1, r3
 c10dd30:	e1a03083 	lsl	r3, r3, #1
 c10dd34:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd38:	e0823003 	add	r3, r2, r3
 c10dd3c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dd40:	e51b3010 	ldr	r3, [fp, #-16]
 c10dd44:	e5c32006 	strb	r2, [r3, #6]
    rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c10dd48:	e59f33a4 	ldr	r3, [pc, #932]	; c10e0f4 <rtc_gettime+0x428>
 c10dd4c:	e5d33000 	ldrb	r3, [r3]
 c10dd50:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd54:	e203300f 	and	r3, r3, #15
 c10dd58:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dd5c:	e59f3390 	ldr	r3, [pc, #912]	; c10e0f4 <rtc_gettime+0x428>
 c10dd60:	e5d33000 	ldrb	r3, [r3]
 c10dd64:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd68:	e1a03223 	lsr	r3, r3, #4
 c10dd6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd70:	e1a01003 	mov	r1, r3
 c10dd74:	e1a01101 	lsl	r1, r1, #2
 c10dd78:	e0813003 	add	r3, r1, r3
 c10dd7c:	e1a03083 	lsl	r3, r3, #1
 c10dd80:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dd84:	e0823003 	add	r3, r2, r3
 c10dd88:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dd8c:	e51b3010 	ldr	r3, [fp, #-16]
 c10dd90:	e5c32005 	strb	r2, [r3, #5]
    rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c10dd94:	e59f335c 	ldr	r3, [pc, #860]	; c10e0f8 <rtc_gettime+0x42c>
 c10dd98:	e5d33000 	ldrb	r3, [r3]
 c10dd9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dda0:	e203300f 	and	r3, r3, #15
 c10dda4:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dda8:	e59f3348 	ldr	r3, [pc, #840]	; c10e0f8 <rtc_gettime+0x42c>
 c10ddac:	e5d33000 	ldrb	r3, [r3]
 c10ddb0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ddb4:	e1a03223 	lsr	r3, r3, #4
 c10ddb8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ddbc:	e1a01003 	mov	r1, r3
 c10ddc0:	e1a01101 	lsl	r1, r1, #2
 c10ddc4:	e0813003 	add	r3, r1, r3
 c10ddc8:	e1a03083 	lsl	r3, r3, #1
 c10ddcc:	e20330ff 	and	r3, r3, #255	; 0xff
 c10ddd0:	e0823003 	add	r3, r2, r3
 c10ddd4:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ddd8:	e51b3010 	ldr	r3, [fp, #-16]
 c10dddc:	e5c32003 	strb	r2, [r3, #3]
    rtc_time->wday = rBCDDATE;
 c10dde0:	e59f3314 	ldr	r3, [pc, #788]	; c10e0fc <rtc_gettime+0x430>
 c10dde4:	e5d33000 	ldrb	r3, [r3]
 c10dde8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ddec:	e51b3010 	ldr	r3, [fp, #-16]
 c10ddf0:	e5c32004 	strb	r2, [r3, #4]
    rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c10ddf4:	e59f3304 	ldr	r3, [pc, #772]	; c10e100 <rtc_gettime+0x434>
 c10ddf8:	e5d33000 	ldrb	r3, [r3]
 c10ddfc:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de00:	e203300f 	and	r3, r3, #15
 c10de04:	e20320ff 	and	r2, r3, #255	; 0xff
 c10de08:	e59f32f0 	ldr	r3, [pc, #752]	; c10e100 <rtc_gettime+0x434>
 c10de0c:	e5d33000 	ldrb	r3, [r3]
 c10de10:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de14:	e1a03223 	lsr	r3, r3, #4
 c10de18:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de1c:	e1a01003 	mov	r1, r3
 c10de20:	e1a01101 	lsl	r1, r1, #2
 c10de24:	e0813003 	add	r3, r1, r3
 c10de28:	e1a03083 	lsl	r3, r3, #1
 c10de2c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de30:	e0823003 	add	r3, r2, r3
 c10de34:	e20320ff 	and	r2, r3, #255	; 0xff
 c10de38:	e51b3010 	ldr	r3, [fp, #-16]
 c10de3c:	e5c32002 	strb	r2, [r3, #2]
    rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c10de40:	e59f32bc 	ldr	r3, [pc, #700]	; c10e104 <rtc_gettime+0x438>
 c10de44:	e5d33000 	ldrb	r3, [r3]
 c10de48:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de4c:	e203300f 	and	r3, r3, #15
 c10de50:	e20320ff 	and	r2, r3, #255	; 0xff
 c10de54:	e59f32a8 	ldr	r3, [pc, #680]	; c10e104 <rtc_gettime+0x438>
 c10de58:	e5d33000 	ldrb	r3, [r3]
 c10de5c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de60:	e1a03223 	lsr	r3, r3, #4
 c10de64:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de68:	e1a01003 	mov	r1, r3
 c10de6c:	e1a01101 	lsl	r1, r1, #2
 c10de70:	e0813003 	add	r3, r1, r3
 c10de74:	e1a03083 	lsl	r3, r3, #1
 c10de78:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de7c:	e0823003 	add	r3, r2, r3
 c10de80:	e20320ff 	and	r2, r3, #255	; 0xff
 c10de84:	e51b3010 	ldr	r3, [fp, #-16]
 c10de88:	e5c32001 	strb	r2, [r3, #1]
    rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c10de8c:	e59f3274 	ldr	r3, [pc, #628]	; c10e108 <rtc_gettime+0x43c>
 c10de90:	e5d33000 	ldrb	r3, [r3]
 c10de94:	e20330ff 	and	r3, r3, #255	; 0xff
 c10de98:	e203300f 	and	r3, r3, #15
 c10de9c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dea0:	e59f3260 	ldr	r3, [pc, #608]	; c10e108 <rtc_gettime+0x43c>
 c10dea4:	e5d33000 	ldrb	r3, [r3]
 c10dea8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10deac:	e1a03223 	lsr	r3, r3, #4
 c10deb0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10deb4:	e1a01003 	mov	r1, r3
 c10deb8:	e1a01101 	lsl	r1, r1, #2
 c10debc:	e0813003 	add	r3, r1, r3
 c10dec0:	e1a03083 	lsl	r3, r3, #1
 c10dec4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dec8:	e0823003 	add	r3, r2, r3
 c10decc:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ded0:	e51b3010 	ldr	r3, [fp, #-16]
 c10ded4:	e5c32000 	strb	r2, [r3]
    if( ! rtc_time->sec ){
 c10ded8:	e51b3010 	ldr	r3, [fp, #-16]
 c10dedc:	e5d33000 	ldrb	r3, [r3]
 c10dee0:	e3530000 	cmp	r3, #0
 c10dee4:	1a000076 	bne	c10e0c4 <rtc_gettime+0x3f8>
    	//Reread, a second may have elapsed so date is invalid
        rtc_time->year = (rBCDYEAR & 0b1111) + 10 * (rBCDYEAR >> 4);
 c10dee8:	e59f3200 	ldr	r3, [pc, #512]	; c10e0f0 <rtc_gettime+0x424>
 c10deec:	e5d33000 	ldrb	r3, [r3]
 c10def0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10def4:	e203300f 	and	r3, r3, #15
 c10def8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10defc:	e59f31ec 	ldr	r3, [pc, #492]	; c10e0f0 <rtc_gettime+0x424>
 c10df00:	e5d33000 	ldrb	r3, [r3]
 c10df04:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df08:	e1a03223 	lsr	r3, r3, #4
 c10df0c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df10:	e1a01003 	mov	r1, r3
 c10df14:	e1a01101 	lsl	r1, r1, #2
 c10df18:	e0813003 	add	r3, r1, r3
 c10df1c:	e1a03083 	lsl	r3, r3, #1
 c10df20:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df24:	e0823003 	add	r3, r2, r3
 c10df28:	e20320ff 	and	r2, r3, #255	; 0xff
 c10df2c:	e51b3010 	ldr	r3, [fp, #-16]
 c10df30:	e5c32006 	strb	r2, [r3, #6]
        rtc_time->mon  = (rBCDMON & 0b1111) + 10 * (rBCDMON >> 4);
 c10df34:	e59f31b8 	ldr	r3, [pc, #440]	; c10e0f4 <rtc_gettime+0x428>
 c10df38:	e5d33000 	ldrb	r3, [r3]
 c10df3c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df40:	e203300f 	and	r3, r3, #15
 c10df44:	e20320ff 	and	r2, r3, #255	; 0xff
 c10df48:	e59f31a4 	ldr	r3, [pc, #420]	; c10e0f4 <rtc_gettime+0x428>
 c10df4c:	e5d33000 	ldrb	r3, [r3]
 c10df50:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df54:	e1a03223 	lsr	r3, r3, #4
 c10df58:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df5c:	e1a01003 	mov	r1, r3
 c10df60:	e1a01101 	lsl	r1, r1, #2
 c10df64:	e0813003 	add	r3, r1, r3
 c10df68:	e1a03083 	lsl	r3, r3, #1
 c10df6c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df70:	e0823003 	add	r3, r2, r3
 c10df74:	e20320ff 	and	r2, r3, #255	; 0xff
 c10df78:	e51b3010 	ldr	r3, [fp, #-16]
 c10df7c:	e5c32005 	strb	r2, [r3, #5]
        rtc_time->mday = (rBCDDAY & 0b1111) + 10 * (rBCDDAY >> 4);
 c10df80:	e59f3170 	ldr	r3, [pc, #368]	; c10e0f8 <rtc_gettime+0x42c>
 c10df84:	e5d33000 	ldrb	r3, [r3]
 c10df88:	e20330ff 	and	r3, r3, #255	; 0xff
 c10df8c:	e203300f 	and	r3, r3, #15
 c10df90:	e20320ff 	and	r2, r3, #255	; 0xff
 c10df94:	e59f315c 	ldr	r3, [pc, #348]	; c10e0f8 <rtc_gettime+0x42c>
 c10df98:	e5d33000 	ldrb	r3, [r3]
 c10df9c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dfa0:	e1a03223 	lsr	r3, r3, #4
 c10dfa4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dfa8:	e1a01003 	mov	r1, r3
 c10dfac:	e1a01101 	lsl	r1, r1, #2
 c10dfb0:	e0813003 	add	r3, r1, r3
 c10dfb4:	e1a03083 	lsl	r3, r3, #1
 c10dfb8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dfbc:	e0823003 	add	r3, r2, r3
 c10dfc0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dfc4:	e51b3010 	ldr	r3, [fp, #-16]
 c10dfc8:	e5c32003 	strb	r2, [r3, #3]
        rtc_time->wday = rBCDDATE;
 c10dfcc:	e59f3128 	ldr	r3, [pc, #296]	; c10e0fc <rtc_gettime+0x430>
 c10dfd0:	e5d33000 	ldrb	r3, [r3]
 c10dfd4:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dfd8:	e51b3010 	ldr	r3, [fp, #-16]
 c10dfdc:	e5c32004 	strb	r2, [r3, #4]
        rtc_time->hour = (rBCDHOUR & 0b1111) + 10 * (rBCDHOUR >> 4);
 c10dfe0:	e59f3118 	ldr	r3, [pc, #280]	; c10e100 <rtc_gettime+0x434>
 c10dfe4:	e5d33000 	ldrb	r3, [r3]
 c10dfe8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10dfec:	e203300f 	and	r3, r3, #15
 c10dff0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10dff4:	e59f3104 	ldr	r3, [pc, #260]	; c10e100 <rtc_gettime+0x434>
 c10dff8:	e5d33000 	ldrb	r3, [r3]
 c10dffc:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e000:	e1a03223 	lsr	r3, r3, #4
 c10e004:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e008:	e1a01003 	mov	r1, r3
 c10e00c:	e1a01101 	lsl	r1, r1, #2
 c10e010:	e0813003 	add	r3, r1, r3
 c10e014:	e1a03083 	lsl	r3, r3, #1
 c10e018:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e01c:	e0823003 	add	r3, r2, r3
 c10e020:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e024:	e51b3010 	ldr	r3, [fp, #-16]
 c10e028:	e5c32002 	strb	r2, [r3, #2]
        rtc_time->min  = (rBCDMIN & 0b1111) + 10 * (rBCDMIN >> 4);
 c10e02c:	e59f30d0 	ldr	r3, [pc, #208]	; c10e104 <rtc_gettime+0x438>
 c10e030:	e5d33000 	ldrb	r3, [r3]
 c10e034:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e038:	e203300f 	and	r3, r3, #15
 c10e03c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e040:	e59f30bc 	ldr	r3, [pc, #188]	; c10e104 <rtc_gettime+0x438>
 c10e044:	e5d33000 	ldrb	r3, [r3]
 c10e048:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e04c:	e1a03223 	lsr	r3, r3, #4
 c10e050:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e054:	e1a01003 	mov	r1, r3
 c10e058:	e1a01101 	lsl	r1, r1, #2
 c10e05c:	e0813003 	add	r3, r1, r3
 c10e060:	e1a03083 	lsl	r3, r3, #1
 c10e064:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e068:	e0823003 	add	r3, r2, r3
 c10e06c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e070:	e51b3010 	ldr	r3, [fp, #-16]
 c10e074:	e5c32001 	strb	r2, [r3, #1]
        rtc_time->sec  = (rBCDSEC & 0b1111) + 10 * (rBCDSEC >> 4);
 c10e078:	e59f3088 	ldr	r3, [pc, #136]	; c10e108 <rtc_gettime+0x43c>
 c10e07c:	e5d33000 	ldrb	r3, [r3]
 c10e080:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e084:	e203300f 	and	r3, r3, #15
 c10e088:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e08c:	e59f3074 	ldr	r3, [pc, #116]	; c10e108 <rtc_gettime+0x43c>
 c10e090:	e5d33000 	ldrb	r3, [r3]
 c10e094:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e098:	e1a03223 	lsr	r3, r3, #4
 c10e09c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e0a0:	e1a01003 	mov	r1, r3
 c10e0a4:	e1a01101 	lsl	r1, r1, #2
 c10e0a8:	e0813003 	add	r3, r1, r3
 c10e0ac:	e1a03083 	lsl	r3, r3, #1
 c10e0b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e0b4:	e0823003 	add	r3, r2, r3
 c10e0b8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e0bc:	e51b3010 	ldr	r3, [fp, #-16]
 c10e0c0:	e5c32000 	strb	r2, [r3]
    }

	//Set RTCEN=RTCCON[0] = 0
    rRTCCON &= ~1;
 c10e0c4:	e59f3020 	ldr	r3, [pc, #32]	; c10e0ec <rtc_gettime+0x420>
 c10e0c8:	e59f201c 	ldr	r2, [pc, #28]	; c10e0ec <rtc_gettime+0x420>
 c10e0cc:	e5d22000 	ldrb	r2, [r2]
 c10e0d0:	e20220ff 	and	r2, r2, #255	; 0xff
 c10e0d4:	e3c22001 	bic	r2, r2, #1
 c10e0d8:	e20220ff 	and	r2, r2, #255	; 0xff
 c10e0dc:	e5c32000 	strb	r2, [r3]
}
 c10e0e0:	e24bd00c 	sub	sp, fp, #12
 c10e0e4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e0e8:	e12fff1e 	bx	lr
 c10e0ec:	01d70040 	.word	0x01d70040
 c10e0f0:	01d70088 	.word	0x01d70088
 c10e0f4:	01d70084 	.word	0x01d70084
 c10e0f8:	01d7007c 	.word	0x01d7007c
 c10e0fc:	01d70080 	.word	0x01d70080
 c10e100:	01d70078 	.word	0x01d70078
 c10e104:	01d70074 	.word	0x01d70074
 c10e108:	01d70070 	.word	0x01d70070

0c10e10c <rtc_set_alarm>:

void rtc_set_alarm( void(*isr)(void), rtc_time_t* rtc_time ) {
 c10e10c:	e1a0c00d 	mov	ip, sp
 c10e110:	e92dd800 	push	{fp, ip, lr, pc}
 c10e114:	e24cb004 	sub	fp, ip, #4
 c10e118:	e24dd008 	sub	sp, sp, #8
 c10e11c:	e50b0010 	str	r0, [fp, #-16]
 c10e120:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec


    //Set alarm date
    rALMYEAR = ((rtc_time->year / 10) % 10) << 4 | (rtc_time->year % 10);
 c10e124:	e59f0380 	ldr	r0, [pc, #896]	; c10e4ac <rtc_set_alarm+0x3a0>
 c10e128:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e12c:	e5d32006 	ldrb	r2, [r3, #6]
 c10e130:	e59f3378 	ldr	r3, [pc, #888]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e134:	e0831392 	umull	r1, r3, r2, r3
 c10e138:	e1a031a3 	lsr	r3, r3, #3
 c10e13c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e140:	e59f3368 	ldr	r3, [pc, #872]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e144:	e0831392 	umull	r1, r3, r2, r3
 c10e148:	e1a011a3 	lsr	r1, r3, #3
 c10e14c:	e1a03001 	mov	r3, r1
 c10e150:	e1a03103 	lsl	r3, r3, #2
 c10e154:	e0833001 	add	r3, r3, r1
 c10e158:	e1a03083 	lsl	r3, r3, #1
 c10e15c:	e0633002 	rsb	r3, r3, r2
 c10e160:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e164:	e1a03203 	lsl	r3, r3, #4
 c10e168:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e16c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e170:	e5d32006 	ldrb	r2, [r3, #6]
 c10e174:	e59f3334 	ldr	r3, [pc, #820]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e178:	e0831392 	umull	r1, r3, r2, r3
 c10e17c:	e1a011a3 	lsr	r1, r3, #3
 c10e180:	e1a03001 	mov	r3, r1
 c10e184:	e1a03103 	lsl	r3, r3, #2
 c10e188:	e0833001 	add	r3, r3, r1
 c10e18c:	e1a03083 	lsl	r3, r3, #1
 c10e190:	e0633002 	rsb	r3, r3, r2
 c10e194:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e198:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e19c:	e1a0200c 	mov	r2, ip
 c10e1a0:	e1823003 	orr	r3, r2, r3
 c10e1a4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e1a8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e1ac:	e5c03000 	strb	r3, [r0]
    rALMMON  = ((rtc_time->mon / 10) % 10) << 4 | (rtc_time->mon % 10);
 c10e1b0:	e59f02fc 	ldr	r0, [pc, #764]	; c10e4b4 <rtc_set_alarm+0x3a8>
 c10e1b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e1b8:	e5d32005 	ldrb	r2, [r3, #5]
 c10e1bc:	e59f32ec 	ldr	r3, [pc, #748]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e1c0:	e0831392 	umull	r1, r3, r2, r3
 c10e1c4:	e1a031a3 	lsr	r3, r3, #3
 c10e1c8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e1cc:	e59f32dc 	ldr	r3, [pc, #732]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e1d0:	e0831392 	umull	r1, r3, r2, r3
 c10e1d4:	e1a011a3 	lsr	r1, r3, #3
 c10e1d8:	e1a03001 	mov	r3, r1
 c10e1dc:	e1a03103 	lsl	r3, r3, #2
 c10e1e0:	e0833001 	add	r3, r3, r1
 c10e1e4:	e1a03083 	lsl	r3, r3, #1
 c10e1e8:	e0633002 	rsb	r3, r3, r2
 c10e1ec:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e1f0:	e1a03203 	lsl	r3, r3, #4
 c10e1f4:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e1f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e1fc:	e5d32005 	ldrb	r2, [r3, #5]
 c10e200:	e59f32a8 	ldr	r3, [pc, #680]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e204:	e0831392 	umull	r1, r3, r2, r3
 c10e208:	e1a011a3 	lsr	r1, r3, #3
 c10e20c:	e1a03001 	mov	r3, r1
 c10e210:	e1a03103 	lsl	r3, r3, #2
 c10e214:	e0833001 	add	r3, r3, r1
 c10e218:	e1a03083 	lsl	r3, r3, #1
 c10e21c:	e0633002 	rsb	r3, r3, r2
 c10e220:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e224:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e228:	e1a0200c 	mov	r2, ip
 c10e22c:	e1823003 	orr	r3, r2, r3
 c10e230:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e234:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e238:	e5c03000 	strb	r3, [r0]
    rALMDAY  = ((rtc_time->mday / 10) % 10) << 4 | (rtc_time->mday % 10);
 c10e23c:	e59f0274 	ldr	r0, [pc, #628]	; c10e4b8 <rtc_set_alarm+0x3ac>
 c10e240:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e244:	e5d32003 	ldrb	r2, [r3, #3]
 c10e248:	e59f3260 	ldr	r3, [pc, #608]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e24c:	e0831392 	umull	r1, r3, r2, r3
 c10e250:	e1a031a3 	lsr	r3, r3, #3
 c10e254:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e258:	e59f3250 	ldr	r3, [pc, #592]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e25c:	e0831392 	umull	r1, r3, r2, r3
 c10e260:	e1a011a3 	lsr	r1, r3, #3
 c10e264:	e1a03001 	mov	r3, r1
 c10e268:	e1a03103 	lsl	r3, r3, #2
 c10e26c:	e0833001 	add	r3, r3, r1
 c10e270:	e1a03083 	lsl	r3, r3, #1
 c10e274:	e0633002 	rsb	r3, r3, r2
 c10e278:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e27c:	e1a03203 	lsl	r3, r3, #4
 c10e280:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e284:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e288:	e5d32003 	ldrb	r2, [r3, #3]
 c10e28c:	e59f321c 	ldr	r3, [pc, #540]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e290:	e0831392 	umull	r1, r3, r2, r3
 c10e294:	e1a011a3 	lsr	r1, r3, #3
 c10e298:	e1a03001 	mov	r3, r1
 c10e29c:	e1a03103 	lsl	r3, r3, #2
 c10e2a0:	e0833001 	add	r3, r3, r1
 c10e2a4:	e1a03083 	lsl	r3, r3, #1
 c10e2a8:	e0633002 	rsb	r3, r3, r2
 c10e2ac:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e2b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e2b4:	e1a0200c 	mov	r2, ip
 c10e2b8:	e1823003 	orr	r3, r2, r3
 c10e2bc:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e2c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e2c4:	e5c03000 	strb	r3, [r0]
    rALMHOUR = ((rtc_time->hour / 10) % 10) << 4 | (rtc_time->hour % 10);
 c10e2c8:	e59f01ec 	ldr	r0, [pc, #492]	; c10e4bc <rtc_set_alarm+0x3b0>
 c10e2cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e2d0:	e5d32002 	ldrb	r2, [r3, #2]
 c10e2d4:	e59f31d4 	ldr	r3, [pc, #468]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e2d8:	e0831392 	umull	r1, r3, r2, r3
 c10e2dc:	e1a031a3 	lsr	r3, r3, #3
 c10e2e0:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e2e4:	e59f31c4 	ldr	r3, [pc, #452]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e2e8:	e0831392 	umull	r1, r3, r2, r3
 c10e2ec:	e1a011a3 	lsr	r1, r3, #3
 c10e2f0:	e1a03001 	mov	r3, r1
 c10e2f4:	e1a03103 	lsl	r3, r3, #2
 c10e2f8:	e0833001 	add	r3, r3, r1
 c10e2fc:	e1a03083 	lsl	r3, r3, #1
 c10e300:	e0633002 	rsb	r3, r3, r2
 c10e304:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e308:	e1a03203 	lsl	r3, r3, #4
 c10e30c:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e310:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e314:	e5d32002 	ldrb	r2, [r3, #2]
 c10e318:	e59f3190 	ldr	r3, [pc, #400]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e31c:	e0831392 	umull	r1, r3, r2, r3
 c10e320:	e1a011a3 	lsr	r1, r3, #3
 c10e324:	e1a03001 	mov	r3, r1
 c10e328:	e1a03103 	lsl	r3, r3, #2
 c10e32c:	e0833001 	add	r3, r3, r1
 c10e330:	e1a03083 	lsl	r3, r3, #1
 c10e334:	e0633002 	rsb	r3, r3, r2
 c10e338:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e33c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e340:	e1a0200c 	mov	r2, ip
 c10e344:	e1823003 	orr	r3, r2, r3
 c10e348:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e34c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e350:	e5c03000 	strb	r3, [r0]
    rALMMIN  = ((rtc_time->min / 10) % 10) << 4 | (rtc_time->min % 10);
 c10e354:	e59f0164 	ldr	r0, [pc, #356]	; c10e4c0 <rtc_set_alarm+0x3b4>
 c10e358:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e35c:	e5d32001 	ldrb	r2, [r3, #1]
 c10e360:	e59f3148 	ldr	r3, [pc, #328]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e364:	e0831392 	umull	r1, r3, r2, r3
 c10e368:	e1a031a3 	lsr	r3, r3, #3
 c10e36c:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e370:	e59f3138 	ldr	r3, [pc, #312]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e374:	e0831392 	umull	r1, r3, r2, r3
 c10e378:	e1a011a3 	lsr	r1, r3, #3
 c10e37c:	e1a03001 	mov	r3, r1
 c10e380:	e1a03103 	lsl	r3, r3, #2
 c10e384:	e0833001 	add	r3, r3, r1
 c10e388:	e1a03083 	lsl	r3, r3, #1
 c10e38c:	e0633002 	rsb	r3, r3, r2
 c10e390:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e394:	e1a03203 	lsl	r3, r3, #4
 c10e398:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e39c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e3a0:	e5d32001 	ldrb	r2, [r3, #1]
 c10e3a4:	e59f3104 	ldr	r3, [pc, #260]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e3a8:	e0831392 	umull	r1, r3, r2, r3
 c10e3ac:	e1a011a3 	lsr	r1, r3, #3
 c10e3b0:	e1a03001 	mov	r3, r1
 c10e3b4:	e1a03103 	lsl	r3, r3, #2
 c10e3b8:	e0833001 	add	r3, r3, r1
 c10e3bc:	e1a03083 	lsl	r3, r3, #1
 c10e3c0:	e0633002 	rsb	r3, r3, r2
 c10e3c4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e3c8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e3cc:	e1a0200c 	mov	r2, ip
 c10e3d0:	e1823003 	orr	r3, r2, r3
 c10e3d4:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e3d8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e3dc:	e5c03000 	strb	r3, [r0]
    rALMSEC  = ((rtc_time->sec / 10) % 10) << 4 | (rtc_time->sec % 10);
 c10e3e0:	e59f00dc 	ldr	r0, [pc, #220]	; c10e4c4 <rtc_set_alarm+0x3b8>
 c10e3e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e3e8:	e5d32000 	ldrb	r2, [r3]
 c10e3ec:	e59f30bc 	ldr	r3, [pc, #188]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e3f0:	e0831392 	umull	r1, r3, r2, r3
 c10e3f4:	e1a031a3 	lsr	r3, r3, #3
 c10e3f8:	e20320ff 	and	r2, r3, #255	; 0xff
 c10e3fc:	e59f30ac 	ldr	r3, [pc, #172]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e400:	e0831392 	umull	r1, r3, r2, r3
 c10e404:	e1a011a3 	lsr	r1, r3, #3
 c10e408:	e1a03001 	mov	r3, r1
 c10e40c:	e1a03103 	lsl	r3, r3, #2
 c10e410:	e0833001 	add	r3, r3, r1
 c10e414:	e1a03083 	lsl	r3, r3, #1
 c10e418:	e0633002 	rsb	r3, r3, r2
 c10e41c:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e420:	e1a03203 	lsl	r3, r3, #4
 c10e424:	e203c0ff 	and	ip, r3, #255	; 0xff
 c10e428:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e42c:	e5d32000 	ldrb	r2, [r3]
 c10e430:	e59f3078 	ldr	r3, [pc, #120]	; c10e4b0 <rtc_set_alarm+0x3a4>
 c10e434:	e0831392 	umull	r1, r3, r2, r3
 c10e438:	e1a011a3 	lsr	r1, r3, #3
 c10e43c:	e1a03001 	mov	r3, r1
 c10e440:	e1a03103 	lsl	r3, r3, #2
 c10e444:	e0833001 	add	r3, r3, r1
 c10e448:	e1a03083 	lsl	r3, r3, #1
 c10e44c:	e0633002 	rsb	r3, r3, r2
 c10e450:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e454:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e458:	e1a0200c 	mov	r2, ip
 c10e45c:	e1823003 	orr	r3, r2, r3
 c10e460:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e464:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e468:	e5c03000 	strb	r3, [r0]

	//Enable alarm (bits [7:0] = 1)
    rRTCALM  = 0x7F;
 c10e46c:	e59f3054 	ldr	r3, [pc, #84]	; c10e4c8 <rtc_set_alarm+0x3bc>
 c10e470:	e3a0207f 	mov	r2, #127	; 0x7f
 c10e474:	e5c32000 	strb	r2, [r3]

    ic_conf_line(INT_RTC, IRQ);
 c10e478:	e3a00001 	mov	r0, #1
 c10e47c:	e3a01000 	mov	r1, #0
 c10e480:	ebfff5f8 	bl	c10bc68 <ic_conf_line>
    ic_cleanflag(INT_RTC);
 c10e484:	e3a00001 	mov	r0, #1
 c10e488:	ebfff659 	bl	c10bdf4 <ic_cleanflag>
    ic_enable(INT_RTC);
 c10e48c:	e3a00001 	mov	r0, #1
 c10e490:	ebfff624 	bl	c10bd28 <ic_enable>

    pISR_RTC = (unsigned) isr;
 c10e494:	e59f3030 	ldr	r3, [pc, #48]	; c10e4cc <rtc_set_alarm+0x3c0>
 c10e498:	e51b2010 	ldr	r2, [fp, #-16]
 c10e49c:	e5832000 	str	r2, [r3]
}
 c10e4a0:	e24bd00c 	sub	sp, fp, #12
 c10e4a4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e4a8:	e12fff1e 	bx	lr
 c10e4ac:	01d70068 	.word	0x01d70068
 c10e4b0:	cccccccd 	.word	0xcccccccd
 c10e4b4:	01d70064 	.word	0x01d70064
 c10e4b8:	01d70060 	.word	0x01d70060
 c10e4bc:	01d7005c 	.word	0x01d7005c
 c10e4c0:	01d70058 	.word	0x01d70058
 c10e4c4:	01d70054 	.word	0x01d70054
 c10e4c8:	01d70050 	.word	0x01d70050
 c10e4cc:	0c7fff24 	.word	0x0c7fff24

0c10e4d0 <rtc_clear_alarm>:

void rtc_clear_alarm() {
 c10e4d0:	e1a0c00d 	mov	ip, sp
 c10e4d4:	e92dd800 	push	{fp, ip, lr, pc}
 c10e4d8:	e24cb004 	sub	fp, ip, #4
	ic_disable(INT_RTC);
 c10e4dc:	e3a00001 	mov	r0, #1
 c10e4e0:	ebfff62a 	bl	c10bd90 <ic_disable>
	pISR_RTC = (unsigned) isr_ALARM_dummy;
 c10e4e4:	e59f301c 	ldr	r3, [pc, #28]	; c10e508 <rtc_clear_alarm+0x38>
 c10e4e8:	e59f201c 	ldr	r2, [pc, #28]	; c10e50c <rtc_clear_alarm+0x3c>
 c10e4ec:	e5832000 	str	r2, [r3]
    rRTCALM  = 0;
 c10e4f0:	e59f3018 	ldr	r3, [pc, #24]	; c10e510 <rtc_clear_alarm+0x40>
 c10e4f4:	e3a02000 	mov	r2, #0
 c10e4f8:	e5c32000 	strb	r2, [r3]
}
 c10e4fc:	e24bd00c 	sub	sp, fp, #12
 c10e500:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e504:	e12fff1e 	bx	lr
 c10e508:	0c7fff24 	.word	0x0c7fff24
 c10e50c:	0c10d7fc 	.word	0x0c10d7fc
 c10e510:	01d70050 	.word	0x01d70050

0c10e514 <rtc_open>:

// Sets ISR to RTC ticks (tick_count)
void rtc_open( void (*isr)(void), uint8 tick_count )
{
 c10e514:	e1a0c00d 	mov	ip, sp
 c10e518:	e92dd800 	push	{fp, ip, lr, pc}
 c10e51c:	e24cb004 	sub	fp, ip, #4
 c10e520:	e24dd008 	sub	sp, sp, #8
 c10e524:	e50b0010 	str	r0, [fp, #-16]
 c10e528:	e1a03001 	mov	r3, r1
 c10e52c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    pISR_TICK = (unsigned)isr;
 c10e530:	e59f3044 	ldr	r3, [pc, #68]	; c10e57c <rtc_open+0x68>
 c10e534:	e51b2010 	ldr	r2, [fp, #-16]
 c10e538:	e5832000 	str	r2, [r3]

    ic_conf_line(INT_TICK, IRQ);
 c10e53c:	e3a00014 	mov	r0, #20
 c10e540:	e3a01000 	mov	r1, #0
 c10e544:	ebfff5c7 	bl	c10bc68 <ic_conf_line>
    ic_cleanflag(INT_TICK);
 c10e548:	e3a00014 	mov	r0, #20
 c10e54c:	ebfff628 	bl	c10bdf4 <ic_cleanflag>
    ic_enable(INT_TICK);
 c10e550:	e3a00014 	mov	r0, #20
 c10e554:	ebfff5f3 	bl	c10bd28 <ic_enable>

    rTICINT = 1 << 7 | (tick_count & 0b1111111);
 c10e558:	e59f2020 	ldr	r2, [pc, #32]	; c10e580 <rtc_open+0x6c>
 c10e55c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10e560:	e1e03c83 	mvn	r3, r3, lsl #25
 c10e564:	e1e03ca3 	mvn	r3, r3, lsr #25
 c10e568:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e56c:	e5c23000 	strb	r3, [r2]
}
 c10e570:	e24bd00c 	sub	sp, fp, #12
 c10e574:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e578:	e12fff1e 	bx	lr
 c10e57c:	0c7fff70 	.word	0x0c7fff70
 c10e580:	01d7008c 	.word	0x01d7008c

0c10e584 <rtc_close>:

// Removes RTC ISR
void rtc_close( void )
{
 c10e584:	e1a0c00d 	mov	ip, sp
 c10e588:	e92dd800 	push	{fp, ip, lr, pc}
 c10e58c:	e24cb004 	sub	fp, ip, #4
    rTICINT = 0;
 c10e590:	e59f3024 	ldr	r3, [pc, #36]	; c10e5bc <rtc_close+0x38>
 c10e594:	e3a02000 	mov	r2, #0
 c10e598:	e5c32000 	strb	r2, [r3]
    ic_disable(INT_TICK);
 c10e59c:	e3a00014 	mov	r0, #20
 c10e5a0:	ebfff5fa 	bl	c10bd90 <ic_disable>
    pISR_TICK = (unsigned)isr_TICK_dummy;
 c10e5a4:	e59f3014 	ldr	r3, [pc, #20]	; c10e5c0 <rtc_close+0x3c>
 c10e5a8:	e59f2014 	ldr	r2, [pc, #20]	; c10e5c4 <rtc_close+0x40>
 c10e5ac:	e5832000 	str	r2, [r3]
}
 c10e5b0:	e24bd00c 	sub	sp, fp, #12
 c10e5b4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e5b8:	e12fff1e 	bx	lr
 c10e5bc:	01d7008c 	.word	0x01d7008c
 c10e5c0:	0c7fff70 	.word	0x0c7fff70
 c10e5c4:	0c10d7d4 	.word	0x0c10d7d4

0c10e5c8 <tmr_set_prescaler>:
/*--- ficheros de cabecera ---*/
#include "44b.h"
#include "timer.h"

int tmr_set_prescaler(int p, int  value)
{
 c10e5c8:	e1a0c00d 	mov	ip, sp
 c10e5cc:	e92dd800 	push	{fp, ip, lr, pc}
 c10e5d0:	e24cb004 	sub	fp, ip, #4
 c10e5d4:	e24dd018 	sub	sp, sp, #24
 c10e5d8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c10e5dc:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
	int offset = p*8;
 c10e5e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e5e4:	e1a03183 	lsl	r3, r3, #3
 c10e5e8:	e50b3010 	str	r3, [fp, #-16]
	value &= 0xFF;
 c10e5ec:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c10e5f0:	e20330ff 	and	r3, r3, #255	; 0xff
 c10e5f4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

	if (p < 0 || p > 3)
 c10e5f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e5fc:	e3530000 	cmp	r3, #0
 c10e600:	ba000002 	blt	c10e610 <tmr_set_prescaler+0x48>
 c10e604:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e608:	e3530003 	cmp	r3, #3
 c10e60c:	da000001 	ble	c10e618 <tmr_set_prescaler+0x50>
		return -1;
 c10e610:	e3e03000 	mvn	r3, #0
 c10e614:	ea00001d 	b	c10e690 <tmr_set_prescaler+0xc8>

	//COMPLETAR: escribir el valor value a partir de la posici√≥n offset en el
	//registro rTCFG0, para establecer el valor de pre-escalado del m√≥dulo p

	int bitfield = value, mask = 0xff, reg = rTCFG0;
 c10e618:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c10e61c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10e620:	e3a030ff 	mov	r3, #255	; 0xff
 c10e624:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10e628:	e59f3070 	ldr	r3, [pc, #112]	; c10e6a0 <tmr_set_prescaler+0xd8>
 c10e62c:	e5933000 	ldr	r3, [r3]
 c10e630:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= offset;
 c10e634:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10e638:	e51b3010 	ldr	r3, [fp, #-16]
 c10e63c:	e1a03312 	lsl	r3, r2, r3
 c10e640:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= offset;
 c10e644:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10e648:	e51b3010 	ldr	r3, [fp, #-16]
 c10e64c:	e1a03312 	lsl	r3, r2, r3
 c10e650:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c10e654:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10e658:	e1e03003 	mvn	r3, r3
 c10e65c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo byte
 c10e660:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e664:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10e668:	e0023003 	and	r3, r2, r3
 c10e66c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo byte
 c10e670:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e674:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e678:	e1823003 	orr	r3, r2, r3
 c10e67c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG0 = reg;
 c10e680:	e59f3018 	ldr	r3, [pc, #24]	; c10e6a0 <tmr_set_prescaler+0xd8>
 c10e684:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e688:	e5832000 	str	r2, [r3]

	return 0;
 c10e68c:	e3a03000 	mov	r3, #0
}
 c10e690:	e1a00003 	mov	r0, r3
 c10e694:	e24bd00c 	sub	sp, fp, #12
 c10e698:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e69c:	e12fff1e 	bx	lr
 c10e6a0:	01d50000 	.word	0x01d50000

0c10e6a4 <tmr_set_divider>:

int tmr_set_divider(int d, enum tmr_div div)
{
 c10e6a4:	e1a0c00d 	mov	ip, sp
 c10e6a8:	e92dd800 	push	{fp, ip, lr, pc}
 c10e6ac:	e24cb004 	sub	fp, ip, #4
 c10e6b0:	e24dd018 	sub	sp, sp, #24
 c10e6b4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c10e6b8:	e1a03001 	mov	r3, r1
 c10e6bc:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
	int pos = d*4;
 c10e6c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e6c4:	e1a03103 	lsl	r3, r3, #2
 c10e6c8:	e50b3010 	str	r3, [fp, #-16]

	if ((d < 0 || d > 5) ||
 c10e6cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e6d0:	e3530000 	cmp	r3, #0
 c10e6d4:	ba000014 	blt	c10e72c <tmr_set_divider+0x88>
 c10e6d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e6dc:	e3530005 	cmp	r3, #5
 c10e6e0:	ca000011 	bgt	c10e72c <tmr_set_divider+0x88>
 c10e6e4:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e6e8:	e3530004 	cmp	r3, #4
 c10e6ec:	1a000002 	bne	c10e6fc <tmr_set_divider+0x58>
			(div == D1_32 && d > 3) ||
 c10e6f0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e6f4:	e3530003 	cmp	r3, #3
 c10e6f8:	ca00000b 	bgt	c10e72c <tmr_set_divider+0x88>
 c10e6fc:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e700:	e3530005 	cmp	r3, #5
 c10e704:	1a000002 	bne	c10e714 <tmr_set_divider+0x70>
			(div == EXTCLK && d != 5) ||
 c10e708:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e70c:	e3530005 	cmp	r3, #5
 c10e710:	1a000005 	bne	c10e72c <tmr_set_divider+0x88>
 c10e714:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e718:	e3530006 	cmp	r3, #6
 c10e71c:	1a000004 	bne	c10e734 <tmr_set_divider+0x90>
			(div == TCLK && d != 4))
 c10e720:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10e724:	e3530004 	cmp	r3, #4
 c10e728:	0a000001 	beq	c10e734 <tmr_set_divider+0x90>
		return -1;
 c10e72c:	e3e03000 	mvn	r3, #0
 c10e730:	ea000025 	b	c10e7cc <tmr_set_divider+0x128>

	if (div == EXTCLK || div == TCLK)
 c10e734:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e738:	e3530005 	cmp	r3, #5
 c10e73c:	0a000002 	beq	c10e74c <tmr_set_divider+0xa8>
 c10e740:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e744:	e3530006 	cmp	r3, #6
 c10e748:	1a000001 	bne	c10e754 <tmr_set_divider+0xb0>
		div = 4;
 c10e74c:	e3a03004 	mov	r3, #4
 c10e750:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

	//COMPLETAR: escribir el valor div a partir de la posici√≥n pos en el
	//registro rTCFG1 para establecer el valor para el divisor d

	int bitfield = div, mask = 0xf, reg = rTCFG1;
 c10e754:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c10e758:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10e75c:	e3a0300f 	mov	r3, #15
 c10e760:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10e764:	e59f3070 	ldr	r3, [pc, #112]	; c10e7dc <tmr_set_divider+0x138>
 c10e768:	e5933000 	ldr	r3, [r3]
 c10e76c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	bitfield <<= pos;
 c10e770:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10e774:	e51b3010 	ldr	r3, [fp, #-16]
 c10e778:	e1a03312 	lsl	r3, r2, r3
 c10e77c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	mask <<= pos;
 c10e780:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c10e784:	e51b3010 	ldr	r3, [fp, #-16]
 c10e788:	e1a03312 	lsl	r3, r2, r3
 c10e78c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	mask ^= ~0;
 c10e790:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10e794:	e1e03003 	mvn	r3, r3
 c10e798:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

	reg &= mask; // Ponemos a 0 todos los valores en la zona que va a ir el nuevo nibble
 c10e79c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e7a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10e7a4:	e0023003 	and	r3, r2, r3
 c10e7a8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	reg |= bitfield; // Ponemos a 1 los bits que esten a 1 del nuevo nibble
 c10e7ac:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e7b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10e7b4:	e1823003 	orr	r3, r2, r3
 c10e7b8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	rTCFG1 = reg;
 c10e7bc:	e59f3018 	ldr	r3, [pc, #24]	; c10e7dc <tmr_set_divider+0x138>
 c10e7c0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e7c4:	e5832000 	str	r2, [r3]

	return 0;
 c10e7c8:	e3a03000 	mov	r3, #0
}
 c10e7cc:	e1a00003 	mov	r0, r3
 c10e7d0:	e24bd00c 	sub	sp, fp, #12
 c10e7d4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e7d8:	e12fff1e 	bx	lr
 c10e7dc:	01d50004 	.word	0x01d50004

0c10e7e0 <tmr_set_count>:

int tmr_set_count(enum tmr_timer t, int count, int cmp)
{
 c10e7e0:	e1a0c00d 	mov	ip, sp
 c10e7e4:	e92dd800 	push	{fp, ip, lr, pc}
 c10e7e8:	e24cb004 	sub	fp, ip, #4
 c10e7ec:	e24dd018 	sub	sp, sp, #24
 c10e7f0:	e1a03000 	mov	r3, r0
 c10e7f4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
 c10e7f8:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
 c10e7fc:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int err = 0;
 c10e800:	e3a03000 	mov	r3, #0
 c10e804:	e50b3010 	str	r3, [fp, #-16]
	switch (t) {
 c10e808:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10e80c:	e3530005 	cmp	r3, #5
 c10e810:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 c10e814:	ea00002c 	b	c10e8cc <tmr_set_count+0xec>
 c10e818:	0c10e830 	.word	0x0c10e830
 c10e81c:	0c10e84c 	.word	0x0c10e84c
 c10e820:	0c10e868 	.word	0x0c10e868
 c10e824:	0c10e884 	.word	0x0c10e884
 c10e828:	0c10e8a0 	.word	0x0c10e8a0
 c10e82c:	0c10e8bc 	.word	0x0c10e8bc
		case TIMER0:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaci√≥n cmp en los registros de buffer del timer0 (rTCNTB0 y
			//rTCMPB0)
			rTCNTB0 = count;
 c10e830:	e59f30b0 	ldr	r3, [pc, #176]	; c10e8e8 <tmr_set_count+0x108>
 c10e834:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e838:	e5832000 	str	r2, [r3]
			rTCMPB0 = cmp;
 c10e83c:	e59f30a8 	ldr	r3, [pc, #168]	; c10e8ec <tmr_set_count+0x10c>
 c10e840:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10e844:	e5832000 	str	r2, [r3]
			break;
 c10e848:	ea000021 	b	c10e8d4 <tmr_set_count+0xf4>
		case TIMER1:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaci√≥n cmp en los registros de buffer del timer1 (rTCNTB1 y
			//rTCMPB1)
			rTCNTB1 = count;
 c10e84c:	e59f309c 	ldr	r3, [pc, #156]	; c10e8f0 <tmr_set_count+0x110>
 c10e850:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e854:	e5832000 	str	r2, [r3]
			rTCMPB1 = cmp;
 c10e858:	e59f3094 	ldr	r3, [pc, #148]	; c10e8f4 <tmr_set_count+0x114>
 c10e85c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10e860:	e5832000 	str	r2, [r3]
			 break;
 c10e864:	ea00001a 	b	c10e8d4 <tmr_set_count+0xf4>
		case TIMER2:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaci√≥n cmp en los registros de buffer del timer2 (rTCNTB2 y
			//rTCMPB2)
			rTCNTB2 = count;
 c10e868:	e59f3088 	ldr	r3, [pc, #136]	; c10e8f8 <tmr_set_count+0x118>
 c10e86c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e870:	e5832000 	str	r2, [r3]
			rTCMPB2 = cmp;
 c10e874:	e59f3080 	ldr	r3, [pc, #128]	; c10e8fc <tmr_set_count+0x11c>
 c10e878:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10e87c:	e5832000 	str	r2, [r3]
			 break;
 c10e880:	ea000013 	b	c10e8d4 <tmr_set_count+0xf4>
		case TIMER3:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaci√≥n cmp en los registros de buffer del timer3 (rTCNTB3 y
			//rTCMPB3)
			rTCNTB3 = count;
 c10e884:	e59f3074 	ldr	r3, [pc, #116]	; c10e900 <tmr_set_count+0x120>
 c10e888:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e88c:	e5832000 	str	r2, [r3]
			rTCMPB3 = cmp;
 c10e890:	e59f306c 	ldr	r3, [pc, #108]	; c10e904 <tmr_set_count+0x124>
 c10e894:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10e898:	e5832000 	str	r2, [r3]
			 break;
 c10e89c:	ea00000c 	b	c10e8d4 <tmr_set_count+0xf4>
		case TIMER4:
			//COMPLETAR: establecer el valor de cuenta count y el valor de
			//comparaci√≥n cmp en los registros de buffer del timer4 (rTCNTB4 y
			//rTCMPB4)
			rTCNTB4 = count;
 c10e8a0:	e59f3060 	ldr	r3, [pc, #96]	; c10e908 <tmr_set_count+0x128>
 c10e8a4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e8a8:	e5832000 	str	r2, [r3]
			rTCMPB4 = cmp;
 c10e8ac:	e59f3058 	ldr	r3, [pc, #88]	; c10e90c <tmr_set_count+0x12c>
 c10e8b0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c10e8b4:	e5832000 	str	r2, [r3]
			 break;
 c10e8b8:	ea000005 	b	c10e8d4 <tmr_set_count+0xf4>
		case TIMER5:
			//COMPLETAR: establecer el valor de cuenta count en el registro de 
			//buffer del timer5 (rTCNTB5)
			rTCNTB5 = count;
 c10e8bc:	e59f304c 	ldr	r3, [pc, #76]	; c10e910 <tmr_set_count+0x130>
 c10e8c0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c10e8c4:	e5832000 	str	r2, [r3]
			 break;
 c10e8c8:	ea000001 	b	c10e8d4 <tmr_set_count+0xf4>
		default:
			err = -1;
 c10e8cc:	e3e03000 	mvn	r3, #0
 c10e8d0:	e50b3010 	str	r3, [fp, #-16]
	}

	return err;
 c10e8d4:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10e8d8:	e1a00003 	mov	r0, r3
 c10e8dc:	e24bd00c 	sub	sp, fp, #12
 c10e8e0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e8e4:	e12fff1e 	bx	lr
 c10e8e8:	01d5000c 	.word	0x01d5000c
 c10e8ec:	01d50010 	.word	0x01d50010
 c10e8f0:	01d50018 	.word	0x01d50018
 c10e8f4:	01d5001c 	.word	0x01d5001c
 c10e8f8:	01d50024 	.word	0x01d50024
 c10e8fc:	01d50028 	.word	0x01d50028
 c10e900:	01d50030 	.word	0x01d50030
 c10e904:	01d50034 	.word	0x01d50034
 c10e908:	01d5003c 	.word	0x01d5003c
 c10e90c:	01d50040 	.word	0x01d50040
 c10e910:	01d50048 	.word	0x01d50048

0c10e914 <tmr_update>:

int tmr_update(enum tmr_timer t)
{
 c10e914:	e1a0c00d 	mov	ip, sp
 c10e918:	e92dd800 	push	{fp, ip, lr, pc}
 c10e91c:	e24cb004 	sub	fp, ip, #4
 c10e920:	e24dd010 	sub	sp, sp, #16
 c10e924:	e1a03000 	mov	r3, r0
 c10e928:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c10e92c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10e930:	e1a03103 	lsl	r3, r3, #2
 c10e934:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c10e938:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10e93c:	e3530000 	cmp	r3, #0
 c10e940:	0a000002 	beq	c10e950 <tmr_update+0x3c>
		pos += 4;
 c10e944:	e51b3010 	ldr	r3, [fp, #-16]
 c10e948:	e2833004 	add	r3, r3, #4
 c10e94c:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c10e950:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10e954:	e3530005 	cmp	r3, #5
 c10e958:	9a000001 	bls	c10e964 <tmr_update+0x50>
		return -1;
 c10e95c:	e3e03000 	mvn	r3, #0
 c10e960:	ea000014 	b	c10e9b8 <tmr_update+0xa4>

	pos++;
 c10e964:	e51b3010 	ldr	r3, [fp, #-16]
 c10e968:	e2833001 	add	r3, r3, #1
 c10e96c:	e50b3010 	str	r3, [fp, #-16]

	//COMPLETAR: poner a 1 en el registro rTCON el bit indicado por pos 
	// y justo despu√©s ponerlo a 0 (deben ser stores distintos, lo hacemos con
	// sentencias C distintas)
	rTCON |= 1 << pos;
 c10e970:	e59f3050 	ldr	r3, [pc, #80]	; c10e9c8 <tmr_update+0xb4>
 c10e974:	e59f204c 	ldr	r2, [pc, #76]	; c10e9c8 <tmr_update+0xb4>
 c10e978:	e5921000 	ldr	r1, [r2]
 c10e97c:	e3a00001 	mov	r0, #1
 c10e980:	e51b2010 	ldr	r2, [fp, #-16]
 c10e984:	e1a02210 	lsl	r2, r0, r2
 c10e988:	e1812002 	orr	r2, r1, r2
 c10e98c:	e5832000 	str	r2, [r3]
	rTCON &= ~(1 << pos);
 c10e990:	e59f3030 	ldr	r3, [pc, #48]	; c10e9c8 <tmr_update+0xb4>
 c10e994:	e59f202c 	ldr	r2, [pc, #44]	; c10e9c8 <tmr_update+0xb4>
 c10e998:	e5921000 	ldr	r1, [r2]
 c10e99c:	e3a00001 	mov	r0, #1
 c10e9a0:	e51b2010 	ldr	r2, [fp, #-16]
 c10e9a4:	e1a02210 	lsl	r2, r0, r2
 c10e9a8:	e1e02002 	mvn	r2, r2
 c10e9ac:	e0012002 	and	r2, r1, r2
 c10e9b0:	e5832000 	str	r2, [r3]

	return 0;
 c10e9b4:	e3a03000 	mov	r3, #0
}
 c10e9b8:	e1a00003 	mov	r0, r3
 c10e9bc:	e24bd00c 	sub	sp, fp, #12
 c10e9c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10e9c4:	e12fff1e 	bx	lr
 c10e9c8:	01d50008 	.word	0x01d50008

0c10e9cc <tmr_set_mode>:

int tmr_set_mode(enum tmr_timer t, enum tmr_mode mode)
{
 c10e9cc:	e1a0c00d 	mov	ip, sp
 c10e9d0:	e92dd800 	push	{fp, ip, lr, pc}
 c10e9d4:	e24cb004 	sub	fp, ip, #4
 c10e9d8:	e24dd010 	sub	sp, sp, #16
 c10e9dc:	e1a02000 	mov	r2, r0
 c10e9e0:	e1a03001 	mov	r3, r1
 c10e9e4:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
 c10e9e8:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	int err = 0;
 c10e9ec:	e3a03000 	mov	r3, #0
 c10e9f0:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c10e9f4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10e9f8:	e1a03103 	lsl	r3, r3, #2
 c10e9fc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c10ea00:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ea04:	e3530000 	cmp	r3, #0
 c10ea08:	0a000002 	beq	c10ea18 <tmr_set_mode+0x4c>
		pos += 4;
 c10ea0c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ea10:	e2833004 	add	r3, r3, #4
 c10ea14:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (t < 0 || t > 5)
 c10ea18:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ea1c:	e3530005 	cmp	r3, #5
 c10ea20:	9a000001 	bls	c10ea2c <tmr_set_mode+0x60>
		return -1;
 c10ea24:	e3e03000 	mvn	r3, #0
 c10ea28:	ea000025 	b	c10eac4 <tmr_set_mode+0xf8>

	if(t == 5)
 c10ea2c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ea30:	e3530005 	cmp	r3, #5
 c10ea34:	1a000003 	bne	c10ea48 <tmr_set_mode+0x7c>
		pos += 2;
 c10ea38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ea3c:	e2833002 	add	r3, r3, #2
 c10ea40:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10ea44:	ea000002 	b	c10ea54 <tmr_set_mode+0x88>
	else
		pos += 3;
 c10ea48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ea4c:	e2833003 	add	r3, r3, #3
 c10ea50:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if (mode == ONE_SHOT)
 c10ea54:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10ea58:	e3530000 	cmp	r3, #0
 c10ea5c:	1a000009 	bne	c10ea88 <tmr_set_mode+0xbc>
		//COMPLETAR: poner a 0 el bit autoreload a partir de la posici√≥n pos (es
		//el cuarto bit a partir de esa posici√≥n)
		rTCON &= ~(1 << pos);
 c10ea60:	e59f306c 	ldr	r3, [pc, #108]	; c10ead4 <tmr_set_mode+0x108>
 c10ea64:	e59f2068 	ldr	r2, [pc, #104]	; c10ead4 <tmr_set_mode+0x108>
 c10ea68:	e5921000 	ldr	r1, [r2]
 c10ea6c:	e3a00001 	mov	r0, #1
 c10ea70:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10ea74:	e1a02210 	lsl	r2, r0, r2
 c10ea78:	e1e02002 	mvn	r2, r2
 c10ea7c:	e0012002 	and	r2, r1, r2
 c10ea80:	e5832000 	str	r2, [r3]
 c10ea84:	ea00000d 	b	c10eac0 <tmr_set_mode+0xf4>
	else if (mode == RELOAD)
 c10ea88:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c10ea8c:	e3530001 	cmp	r3, #1
 c10ea90:	1a000008 	bne	c10eab8 <tmr_set_mode+0xec>
		//COMPLETAR: poner a 1 el bit autoreload a partir de la posici√≥n pos (es
		//el cuarto bit a partir de esa posici√≥n)
		rTCON |= 1 << pos;
 c10ea94:	e59f3038 	ldr	r3, [pc, #56]	; c10ead4 <tmr_set_mode+0x108>
 c10ea98:	e59f2034 	ldr	r2, [pc, #52]	; c10ead4 <tmr_set_mode+0x108>
 c10ea9c:	e5921000 	ldr	r1, [r2]
 c10eaa0:	e3a00001 	mov	r0, #1
 c10eaa4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10eaa8:	e1a02210 	lsl	r2, r0, r2
 c10eaac:	e1812002 	orr	r2, r1, r2
 c10eab0:	e5832000 	str	r2, [r3]
 c10eab4:	ea000001 	b	c10eac0 <tmr_set_mode+0xf4>
	else
		err = -1;
 c10eab8:	e3e03000 	mvn	r3, #0
 c10eabc:	e50b3010 	str	r3, [fp, #-16]

	return err;
 c10eac0:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10eac4:	e1a00003 	mov	r0, r3
 c10eac8:	e24bd00c 	sub	sp, fp, #12
 c10eacc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ead0:	e12fff1e 	bx	lr
 c10ead4:	01d50008 	.word	0x01d50008

0c10ead8 <tmr_start>:

int tmr_start(enum tmr_timer t)
{
 c10ead8:	e1a0c00d 	mov	ip, sp
 c10eadc:	e92dd800 	push	{fp, ip, lr, pc}
 c10eae0:	e24cb004 	sub	fp, ip, #4
 c10eae4:	e24dd010 	sub	sp, sp, #16
 c10eae8:	e1a03000 	mov	r3, r0
 c10eaec:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c10eaf0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eaf4:	e1a03103 	lsl	r3, r3, #2
 c10eaf8:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c10eafc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eb00:	e3530000 	cmp	r3, #0
 c10eb04:	0a000002 	beq	c10eb14 <tmr_start+0x3c>
		pos += 4;
 c10eb08:	e51b3010 	ldr	r3, [fp, #-16]
 c10eb0c:	e2833004 	add	r3, r3, #4
 c10eb10:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c10eb14:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eb18:	e3530005 	cmp	r3, #5
 c10eb1c:	9a000001 	bls	c10eb28 <tmr_start+0x50>
		return -1;
 c10eb20:	e3e03000 	mvn	r3, #0
 c10eb24:	ea000008 	b	c10eb4c <tmr_start+0x74>

	//COMPLETAR: poner a 1 el bit de start a partir de la posici√≥n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON |= 1 << pos;
 c10eb28:	e59f302c 	ldr	r3, [pc, #44]	; c10eb5c <tmr_start+0x84>
 c10eb2c:	e59f2028 	ldr	r2, [pc, #40]	; c10eb5c <tmr_start+0x84>
 c10eb30:	e5921000 	ldr	r1, [r2]
 c10eb34:	e3a00001 	mov	r0, #1
 c10eb38:	e51b2010 	ldr	r2, [fp, #-16]
 c10eb3c:	e1a02210 	lsl	r2, r0, r2
 c10eb40:	e1812002 	orr	r2, r1, r2
 c10eb44:	e5832000 	str	r2, [r3]
	return 0;
 c10eb48:	e3a03000 	mov	r3, #0
}
 c10eb4c:	e1a00003 	mov	r0, r3
 c10eb50:	e24bd00c 	sub	sp, fp, #12
 c10eb54:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10eb58:	e12fff1e 	bx	lr
 c10eb5c:	01d50008 	.word	0x01d50008

0c10eb60 <tmr_stop>:

int tmr_stop(enum tmr_timer t)
{
 c10eb60:	e1a0c00d 	mov	ip, sp
 c10eb64:	e92dd800 	push	{fp, ip, lr, pc}
 c10eb68:	e24cb004 	sub	fp, ip, #4
 c10eb6c:	e24dd010 	sub	sp, sp, #16
 c10eb70:	e1a03000 	mov	r3, r0
 c10eb74:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int pos = t*4;
 c10eb78:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eb7c:	e1a03103 	lsl	r3, r3, #2
 c10eb80:	e50b3010 	str	r3, [fp, #-16]
	if (t > 0)
 c10eb84:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eb88:	e3530000 	cmp	r3, #0
 c10eb8c:	0a000002 	beq	c10eb9c <tmr_stop+0x3c>
		pos += 4;
 c10eb90:	e51b3010 	ldr	r3, [fp, #-16]
 c10eb94:	e2833004 	add	r3, r3, #4
 c10eb98:	e50b3010 	str	r3, [fp, #-16]

	if (t < 0 || t > 5)
 c10eb9c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10eba0:	e3530005 	cmp	r3, #5
 c10eba4:	9a000001 	bls	c10ebb0 <tmr_stop+0x50>
		return -1;
 c10eba8:	e3e03000 	mvn	r3, #0
 c10ebac:	ea000009 	b	c10ebd8 <tmr_stop+0x78>

	//COMPLETAR: poner a 0 el bit de start a partir de la posici√≥n pos en el
	//registro rTCON (es el primer bit del grupo)
	rTCON &= ~(1 << pos);
 c10ebb0:	e59f3030 	ldr	r3, [pc, #48]	; c10ebe8 <tmr_stop+0x88>
 c10ebb4:	e59f202c 	ldr	r2, [pc, #44]	; c10ebe8 <tmr_stop+0x88>
 c10ebb8:	e5921000 	ldr	r1, [r2]
 c10ebbc:	e3a00001 	mov	r0, #1
 c10ebc0:	e51b2010 	ldr	r2, [fp, #-16]
 c10ebc4:	e1a02210 	lsl	r2, r0, r2
 c10ebc8:	e1e02002 	mvn	r2, r2
 c10ebcc:	e0012002 	and	r2, r1, r2
 c10ebd0:	e5832000 	str	r2, [r3]

	return 0;
 c10ebd4:	e3a03000 	mov	r3, #0
}
 c10ebd8:	e1a00003 	mov	r0, r3
 c10ebdc:	e24bd00c 	sub	sp, fp, #12
 c10ebe0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ebe4:	e12fff1e 	bx	lr
 c10ebe8:	01d50008 	.word	0x01d50008

0c10ebec <tmr_isrunning>:

int tmr_isrunning(enum tmr_timer t)
{
 c10ebec:	e1a0c00d 	mov	ip, sp
 c10ebf0:	e92dd800 	push	{fp, ip, lr, pc}
 c10ebf4:	e24cb004 	sub	fp, ip, #4
 c10ebf8:	e24dd010 	sub	sp, sp, #16
 c10ebfc:	e1a03000 	mov	r3, r0
 c10ec00:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int ret = 0;
 c10ec04:	e3a03000 	mov	r3, #0
 c10ec08:	e50b3010 	str	r3, [fp, #-16]
	int pos = t*4;
 c10ec0c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ec10:	e1a03103 	lsl	r3, r3, #2
 c10ec14:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if (t > 0)
 c10ec18:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ec1c:	e3530000 	cmp	r3, #0
 c10ec20:	0a000002 	beq	c10ec30 <tmr_isrunning+0x44>
		pos += 4;
 c10ec24:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ec28:	e2833004 	add	r3, r3, #4
 c10ec2c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	if ((t >= 0) && (t <= 5) 
 c10ec30:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10ec34:	e3530005 	cmp	r3, #5
 c10ec38:	8a000009 	bhi	c10ec64 <tmr_isrunning+0x78>
			&& (rTCON & (0x1 << pos)))
 c10ec3c:	e59f3034 	ldr	r3, [pc, #52]	; c10ec78 <tmr_isrunning+0x8c>
 c10ec40:	e5932000 	ldr	r2, [r3]
 c10ec44:	e3a01001 	mov	r1, #1
 c10ec48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ec4c:	e1a03311 	lsl	r3, r1, r3
 c10ec50:	e0023003 	and	r3, r2, r3
 c10ec54:	e3530000 	cmp	r3, #0
 c10ec58:	0a000001 	beq	c10ec64 <tmr_isrunning+0x78>
		ret = 1;
 c10ec5c:	e3a03001 	mov	r3, #1
 c10ec60:	e50b3010 	str	r3, [fp, #-16]

	return ret;
 c10ec64:	e51b3010 	ldr	r3, [fp, #-16]
}
 c10ec68:	e1a00003 	mov	r0, r3
 c10ec6c:	e24bd00c 	sub	sp, fp, #12
 c10ec70:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ec74:	e12fff1e 	bx	lr
 c10ec78:	01d50008 	.word	0x01d50008

0c10ec7c <uart0_init>:
#include "uart.h"
#include "44b.h"

void uart0_init( void )
{
 c10ec7c:	e1a0c00d 	mov	ip, sp
 c10ec80:	e92dd800 	push	{fp, ip, lr, pc}
 c10ec84:	e24cb004 	sub	fp, ip, #4
	//*Enable FIFO, Rx normal, Tx normal
	//UFCON0[0] = 1
	//UFCON0[1] = 0  Rx FIFO normal (no reset)
	//UFCON0[2] = 0  Rx FIFO normal (no reset)
    rUFCON0 = 0x1;
 c10ec88:	e59f3040 	ldr	r3, [pc, #64]	; c10ecd0 <uart0_init+0x54>
 c10ec8c:	e3a02001 	mov	r2, #1
 c10ec90:	e5832000 	str	r2, [r3]

    //Disable Auto Flow Control and disable Request to Send
    //UMCON0[4] = 0
    rUMCON0 = 0x0;
 c10ec94:	e59f3038 	ldr	r3, [pc, #56]	; c10ecd4 <uart0_init+0x58>
 c10ec98:	e3a02000 	mov	r2, #0
 c10ec9c:	e5832000 	str	r2, [r3]
    //* Formato de la trama:
    //ULCON0[6]   = 0  normal (no infrarrojos)
    //ULCON0[5:3] = 0  sin paridad
    //ULCON0[2]   = 0  1 bit de stop
    //ULCON0[1:0] = 3  8 bits de datos
    rULCON0 = 0x3;
 c10eca0:	e3a0361d 	mov	r3, #30408704	; 0x1d00000
 c10eca4:	e3a02003 	mov	r2, #3
 c10eca8:	e5832000 	str	r2, [r3]

    //* 115200 Baudios
    //UBRDIV0 = 34  64MHz / (115200 √ó 16) ‚Äê 1
    rUBRDIV0 = 34;
 c10ecac:	e59f3024 	ldr	r3, [pc, #36]	; c10ecd8 <uart0_init+0x5c>
 c10ecb0:	e3a02022 	mov	r2, #34	; 0x22
 c10ecb4:	e5832000 	str	r2, [r3]

    //UCON0[1:0] = 1  Rx: polling/interrupt mode
    //UCON0[3:2] = 1  Tx: polling/interrupt mode
    //UCON0[4]   = 0  no break
    //UCON0[5]   = 0  no loopback
    rUCON0 = 0x5;
 c10ecb8:	e59f301c 	ldr	r3, [pc, #28]	; c10ecdc <uart0_init+0x60>
 c10ecbc:	e3a02005 	mov	r2, #5
 c10ecc0:	e5832000 	str	r2, [r3]
}
 c10ecc4:	e24bd00c 	sub	sp, fp, #12
 c10ecc8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10eccc:	e12fff1e 	bx	lr
 c10ecd0:	01d00008 	.word	0x01d00008
 c10ecd4:	01d0000c 	.word	0x01d0000c
 c10ecd8:	01d00028 	.word	0x01d00028
 c10ecdc:	01d00004 	.word	0x01d00004

0c10ece0 <uart0_putchar>:

void uart0_putchar( char ch )
{
 c10ece0:	e1a0c00d 	mov	ip, sp
 c10ece4:	e92dd800 	push	{fp, ip, lr, pc}
 c10ece8:	e24cb004 	sub	fp, ip, #4
 c10ecec:	e24dd008 	sub	sp, sp, #8
 c10ecf0:	e1a03000 	mov	r3, r0
 c10ecf4:	e54b300d 	strb	r3, [fp, #-13]
	//While FIFO is full wait (while UFSTAT0[9] == 1)
    while( rUFSTAT0 & (1 << 9) );
 c10ecf8:	e1a00000 	nop			; (mov r0, r0)
 c10ecfc:	e59f3024 	ldr	r3, [pc, #36]	; c10ed28 <uart0_putchar+0x48>
 c10ed00:	e5933000 	ldr	r3, [r3]
 c10ed04:	e2033c02 	and	r3, r3, #512	; 0x200
 c10ed08:	e3530000 	cmp	r3, #0
 c10ed0c:	1afffffa 	bne	c10ecfc <uart0_putchar+0x1c>
    rUTXH0 = ch;
 c10ed10:	e59f3014 	ldr	r3, [pc, #20]	; c10ed2c <uart0_putchar+0x4c>
 c10ed14:	e55b200d 	ldrb	r2, [fp, #-13]
 c10ed18:	e5c32000 	strb	r2, [r3]
}
 c10ed1c:	e24bd00c 	sub	sp, fp, #12
 c10ed20:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ed24:	e12fff1e 	bx	lr
 c10ed28:	01d00018 	.word	0x01d00018
 c10ed2c:	01d00020 	.word	0x01d00020

0c10ed30 <uart0_getchar>:

char uart0_getchar( void )
{
 c10ed30:	e1a0c00d 	mov	ip, sp
 c10ed34:	e92dd800 	push	{fp, ip, lr, pc}
 c10ed38:	e24cb004 	sub	fp, ip, #4
	//While FIFO is empty wait (while UFSTAT0[3:0] == 0)
    while( (rUFSTAT0 & 0b1111) == 0 );
 c10ed3c:	e1a00000 	nop			; (mov r0, r0)
 c10ed40:	e59f3028 	ldr	r3, [pc, #40]	; c10ed70 <uart0_getchar+0x40>
 c10ed44:	e5933000 	ldr	r3, [r3]
 c10ed48:	e203300f 	and	r3, r3, #15
 c10ed4c:	e3530000 	cmp	r3, #0
 c10ed50:	0afffffa 	beq	c10ed40 <uart0_getchar+0x10>

    //Read URXH0
    return rURXH0;
 c10ed54:	e59f3018 	ldr	r3, [pc, #24]	; c10ed74 <uart0_getchar+0x44>
 c10ed58:	e5d33000 	ldrb	r3, [r3]
 c10ed5c:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c10ed60:	e1a00003 	mov	r0, r3
 c10ed64:	e24bd00c 	sub	sp, fp, #12
 c10ed68:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ed6c:	e12fff1e 	bx	lr
 c10ed70:	01d00018 	.word	0x01d00018
 c10ed74:	01d00024 	.word	0x01d00024

0c10ed78 <uart0_puts>:

void uart0_puts( char *s )
{
 c10ed78:	e1a0c00d 	mov	ip, sp
 c10ed7c:	e92dd800 	push	{fp, ip, lr, pc}
 c10ed80:	e24cb004 	sub	fp, ip, #4
 c10ed84:	e24dd008 	sub	sp, sp, #8
 c10ed88:	e50b0010 	str	r0, [fp, #-16]
    while(*s) {
 c10ed8c:	ea000006 	b	c10edac <uart0_puts+0x34>
    	uart0_putchar(*s);
 c10ed90:	e51b3010 	ldr	r3, [fp, #-16]
 c10ed94:	e5d33000 	ldrb	r3, [r3]
 c10ed98:	e1a00003 	mov	r0, r3
 c10ed9c:	ebffffcf 	bl	c10ece0 <uart0_putchar>
    	s++;
 c10eda0:	e51b3010 	ldr	r3, [fp, #-16]
 c10eda4:	e2833001 	add	r3, r3, #1
 c10eda8:	e50b3010 	str	r3, [fp, #-16]
    return rURXH0;
}

void uart0_puts( char *s )
{
    while(*s) {
 c10edac:	e51b3010 	ldr	r3, [fp, #-16]
 c10edb0:	e5d33000 	ldrb	r3, [r3]
 c10edb4:	e3530000 	cmp	r3, #0
 c10edb8:	1afffff4 	bne	c10ed90 <uart0_puts+0x18>
    	uart0_putchar(*s);
    	s++;
    }
}
 c10edbc:	e24bd00c 	sub	sp, fp, #12
 c10edc0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10edc4:	e12fff1e 	bx	lr

0c10edc8 <uart0_putint>:

void uart0_putint( int32 i )
{
 c10edc8:	e1a0c00d 	mov	ip, sp
 c10edcc:	e92dd800 	push	{fp, ip, lr, pc}
 c10edd0:	e24cb004 	sub	fp, ip, #4
 c10edd4:	e24dd020 	sub	sp, sp, #32
 c10edd8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
	char s[11 + 1];
	int negative = i < 0;
 c10eddc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c10ede0:	e1a03fa3 	lsr	r3, r3, #31
 c10ede4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	char* p = s + 11;
 c10ede8:	e24b3020 	sub	r3, fp, #32
 c10edec:	e283300b 	add	r3, r3, #11
 c10edf0:	e50b3010 	str	r3, [fp, #-16]

	*p = '\0';
 c10edf4:	e51b3010 	ldr	r3, [fp, #-16]
 c10edf8:	e3a02000 	mov	r2, #0
 c10edfc:	e5c32000 	strb	r2, [r3]
	if (negative)
 c10ee00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ee04:	e3530000 	cmp	r3, #0
 c10ee08:	0a000002 	beq	c10ee18 <uart0_putint+0x50>
		i *= -1;
 c10ee0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c10ee10:	e2633000 	rsb	r3, r3, #0
 c10ee14:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

	do {
		*--p = '0' + ( i % 10 );
 c10ee18:	e51b3010 	ldr	r3, [fp, #-16]
 c10ee1c:	e2433001 	sub	r3, r3, #1
 c10ee20:	e50b3010 	str	r3, [fp, #-16]
 c10ee24:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
 c10ee28:	e59f3094 	ldr	r3, [pc, #148]	; c10eec4 <uart0_putint+0xfc>
 c10ee2c:	e0c32391 	smull	r2, r3, r1, r3
 c10ee30:	e1a02143 	asr	r2, r3, #2
 c10ee34:	e1a03fc1 	asr	r3, r1, #31
 c10ee38:	e0632002 	rsb	r2, r3, r2
 c10ee3c:	e1a03002 	mov	r3, r2
 c10ee40:	e1a03103 	lsl	r3, r3, #2
 c10ee44:	e0833002 	add	r3, r3, r2
 c10ee48:	e1a03083 	lsl	r3, r3, #1
 c10ee4c:	e0632001 	rsb	r2, r3, r1
 c10ee50:	e20230ff 	and	r3, r2, #255	; 0xff
 c10ee54:	e2833030 	add	r3, r3, #48	; 0x30
 c10ee58:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ee5c:	e51b3010 	ldr	r3, [fp, #-16]
 c10ee60:	e5c32000 	strb	r2, [r3]
		i /= 10;
 c10ee64:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c10ee68:	e59f2054 	ldr	r2, [pc, #84]	; c10eec4 <uart0_putint+0xfc>
 c10ee6c:	e0c21293 	smull	r1, r2, r3, r2
 c10ee70:	e1a02142 	asr	r2, r2, #2
 c10ee74:	e1a03fc3 	asr	r3, r3, #31
 c10ee78:	e0633002 	rsb	r3, r3, r2
 c10ee7c:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
	} while(i > 0);
 c10ee80:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c10ee84:	e3530000 	cmp	r3, #0
 c10ee88:	caffffe2 	bgt	c10ee18 <uart0_putint+0x50>

	if(negative) {
 c10ee8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10ee90:	e3530000 	cmp	r3, #0
 c10ee94:	0a000005 	beq	c10eeb0 <uart0_putint+0xe8>
		*--p = '-';
 c10ee98:	e51b3010 	ldr	r3, [fp, #-16]
 c10ee9c:	e2433001 	sub	r3, r3, #1
 c10eea0:	e50b3010 	str	r3, [fp, #-16]
 c10eea4:	e51b3010 	ldr	r3, [fp, #-16]
 c10eea8:	e3a0202d 	mov	r2, #45	; 0x2d
 c10eeac:	e5c32000 	strb	r2, [r3]
	}

	uart0_puts(p);
 c10eeb0:	e51b0010 	ldr	r0, [fp, #-16]
 c10eeb4:	ebffffaf 	bl	c10ed78 <uart0_puts>
}
 c10eeb8:	e24bd00c 	sub	sp, fp, #12
 c10eebc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10eec0:	e12fff1e 	bx	lr
 c10eec4:	66666667 	.word	0x66666667

0c10eec8 <uart0_puthex>:

void uart0_puthex( uint32 i )
{
 c10eec8:	e1a0c00d 	mov	ip, sp
 c10eecc:	e92dd800 	push	{fp, ip, lr, pc}
 c10eed0:	e24cb004 	sub	fp, ip, #4
 c10eed4:	e24dd018 	sub	sp, sp, #24
 c10eed8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    char buf[8 + 1];
    char *p = buf + 8;
 c10eedc:	e24b301c 	sub	r3, fp, #28
 c10eee0:	e2833008 	add	r3, r3, #8
 c10eee4:	e50b3010 	str	r3, [fp, #-16]
    uint8 c;

    *p = '\0';
 c10eee8:	e51b3010 	ldr	r3, [fp, #-16]
 c10eeec:	e3a02000 	mov	r2, #0
 c10eef0:	e5c32000 	strb	r2, [r3]

    do {
        c = i & 0xf;
 c10eef4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10eef8:	e20330ff 	and	r3, r3, #255	; 0xff
 c10eefc:	e203300f 	and	r3, r3, #15
 c10ef00:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        if( c < 10 )
 c10ef04:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10ef08:	e3530009 	cmp	r3, #9
 c10ef0c:	8a000008 	bhi	c10ef34 <uart0_puthex+0x6c>
            *--p = '0' + c;
 c10ef10:	e51b3010 	ldr	r3, [fp, #-16]
 c10ef14:	e2433001 	sub	r3, r3, #1
 c10ef18:	e50b3010 	str	r3, [fp, #-16]
 c10ef1c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10ef20:	e2833030 	add	r3, r3, #48	; 0x30
 c10ef24:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ef28:	e51b3010 	ldr	r3, [fp, #-16]
 c10ef2c:	e5c32000 	strb	r2, [r3]
 c10ef30:	ea000007 	b	c10ef54 <uart0_puthex+0x8c>
        else
            *--p = 'a' + c - 10;
 c10ef34:	e51b3010 	ldr	r3, [fp, #-16]
 c10ef38:	e2433001 	sub	r3, r3, #1
 c10ef3c:	e50b3010 	str	r3, [fp, #-16]
 c10ef40:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
 c10ef44:	e2833057 	add	r3, r3, #87	; 0x57
 c10ef48:	e20320ff 	and	r2, r3, #255	; 0xff
 c10ef4c:	e51b3010 	ldr	r3, [fp, #-16]
 c10ef50:	e5c32000 	strb	r2, [r3]
        i = i >> 4;
 c10ef54:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10ef58:	e1a03223 	lsr	r3, r3, #4
 c10ef5c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    } while( i );
 c10ef60:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c10ef64:	e3530000 	cmp	r3, #0
 c10ef68:	1affffe1 	bne	c10eef4 <uart0_puthex+0x2c>

    uart0_puts( p );
 c10ef6c:	e51b0010 	ldr	r0, [fp, #-16]
 c10ef70:	ebffff80 	bl	c10ed78 <uart0_puts>
}
 c10ef74:	e24bd00c 	sub	sp, fp, #12
 c10ef78:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10ef7c:	e12fff1e 	bx	lr

0c10ef80 <uart0_gets>:

void uart0_gets( char *s )
{
 c10ef80:	e1a0c00d 	mov	ip, sp
 c10ef84:	e92dd800 	push	{fp, ip, lr, pc}
 c10ef88:	e24cb004 	sub	fp, ip, #4
 c10ef8c:	e24dd010 	sub	sp, sp, #16
 c10ef90:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	char c = uart0_getchar();
 c10ef94:	ebffff65 	bl	c10ed30 <uart0_getchar>
 c10ef98:	e1a03000 	mov	r3, r0
 c10ef9c:	e54b300d 	strb	r3, [fp, #-13]

	while(c != '\n') {
 c10efa0:	ea000008 	b	c10efc8 <uart0_gets+0x48>
		*s = c;
 c10efa4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10efa8:	e55b200d 	ldrb	r2, [fp, #-13]
 c10efac:	e5c32000 	strb	r2, [r3]
		s++;
 c10efb0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10efb4:	e2833001 	add	r3, r3, #1
 c10efb8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		c = uart0_getchar();
 c10efbc:	ebffff5b 	bl	c10ed30 <uart0_getchar>
 c10efc0:	e1a03000 	mov	r3, r0
 c10efc4:	e54b300d 	strb	r3, [fp, #-13]

void uart0_gets( char *s )
{
	char c = uart0_getchar();

	while(c != '\n') {
 c10efc8:	e55b300d 	ldrb	r3, [fp, #-13]
 c10efcc:	e353000a 	cmp	r3, #10
 c10efd0:	1afffff3 	bne	c10efa4 <uart0_gets+0x24>
		*s = c;
		s++;
		c = uart0_getchar();
	}

	*s = '\0';
 c10efd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10efd8:	e3a02000 	mov	r2, #0
 c10efdc:	e5c32000 	strb	r2, [r3]
}
 c10efe0:	e24bd00c 	sub	sp, fp, #12
 c10efe4:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10efe8:	e12fff1e 	bx	lr

0c10efec <uart0_getint>:

int32 uart0_getint( void )
{
 c10efec:	e1a0c00d 	mov	ip, sp
 c10eff0:	e92dd800 	push	{fp, ip, lr, pc}
 c10eff4:	e24cb004 	sub	fp, ip, #4
 c10eff8:	e24dd018 	sub	sp, sp, #24
	char s[11 + 1];
	char* p = s;
 c10effc:	e24b3020 	sub	r3, fp, #32
 c10f000:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c10f004:	e3a03000 	mov	r3, #0
 c10f008:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c10f00c:	e24b3020 	sub	r3, fp, #32
 c10f010:	e1a00003 	mov	r0, r3
 c10f014:	ebffffd9 	bl	c10ef80 <uart0_gets>

	if(s[0] == '\0')
 c10f018:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c10f01c:	e3530000 	cmp	r3, #0
 c10f020:	1a000001 	bne	c10f02c <uart0_getint+0x40>
		return 0;
 c10f024:	e3a03000 	mov	r3, #0
 c10f028:	ea000021 	b	c10f0b4 <uart0_getint+0xc8>

	if(s[0]=='-')
 c10f02c:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c10f030:	e353002d 	cmp	r3, #45	; 0x2d
 c10f034:	1a000012 	bne	c10f084 <uart0_getint+0x98>
		p++;
 c10f038:	e51b3010 	ldr	r3, [fp, #-16]
 c10f03c:	e2833001 	add	r3, r3, #1
 c10f040:	e50b3010 	str	r3, [fp, #-16]

	while(*p) {
 c10f044:	ea00000f 	b	c10f088 <uart0_getint+0x9c>
		res = 10 * res + (*p - '0');
 c10f048:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10f04c:	e1a03002 	mov	r3, r2
 c10f050:	e1a03103 	lsl	r3, r3, #2
 c10f054:	e0833002 	add	r3, r3, r2
 c10f058:	e1a03083 	lsl	r3, r3, #1
 c10f05c:	e1a02003 	mov	r2, r3
 c10f060:	e51b3010 	ldr	r3, [fp, #-16]
 c10f064:	e5d33000 	ldrb	r3, [r3]
 c10f068:	e2433030 	sub	r3, r3, #48	; 0x30
 c10f06c:	e0823003 	add	r3, r2, r3
 c10f070:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c10f074:	e51b3010 	ldr	r3, [fp, #-16]
 c10f078:	e2833001 	add	r3, r3, #1
 c10f07c:	e50b3010 	str	r3, [fp, #-16]
 c10f080:	ea000000 	b	c10f088 <uart0_getint+0x9c>
		return 0;

	if(s[0]=='-')
		p++;

	while(*p) {
 c10f084:	e1a00000 	nop			; (mov r0, r0)
 c10f088:	e51b3010 	ldr	r3, [fp, #-16]
 c10f08c:	e5d33000 	ldrb	r3, [r3]
 c10f090:	e3530000 	cmp	r3, #0
 c10f094:	1affffeb 	bne	c10f048 <uart0_getint+0x5c>
		res = 10 * res + (*p - '0');
		p++;
	}

	if(s[0] == '-')
 c10f098:	e55b3020 	ldrb	r3, [fp, #-32]	; 0xffffffe0
 c10f09c:	e353002d 	cmp	r3, #45	; 0x2d
 c10f0a0:	1a000002 	bne	c10f0b0 <uart0_getint+0xc4>
		res *= -1;
 c10f0a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10f0a8:	e2633000 	rsb	r3, r3, #0
 c10f0ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	return res;
 c10f0b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c10f0b4:	e1a00003 	mov	r0, r3
 c10f0b8:	e24bd00c 	sub	sp, fp, #12
 c10f0bc:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10f0c0:	e12fff1e 	bx	lr

0c10f0c4 <uart0_gethex>:

uint32 uart0_gethex( void )
{
 c10f0c4:	e1a0c00d 	mov	ip, sp
 c10f0c8:	e92dd800 	push	{fp, ip, lr, pc}
 c10f0cc:	e24cb004 	sub	fp, ip, #4
 c10f0d0:	e24dd018 	sub	sp, sp, #24
	char s[8 + 1];
	char* p = s;
 c10f0d4:	e24b3020 	sub	r3, fp, #32
 c10f0d8:	e50b3010 	str	r3, [fp, #-16]
	int32 res = 0;
 c10f0dc:	e3a03000 	mov	r3, #0
 c10f0e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	uart0_gets(s);
 c10f0e4:	e24b3020 	sub	r3, fp, #32
 c10f0e8:	e1a00003 	mov	r0, r3
 c10f0ec:	ebffffa3 	bl	c10ef80 <uart0_gets>

	while(*p) {
 c10f0f0:	ea00002b 	b	c10f1a4 <uart0_gethex+0xe0>
		res = res << 4;
 c10f0f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10f0f8:	e1a03203 	lsl	r3, r3, #4
 c10f0fc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		char c = *p;
 c10f100:	e51b3010 	ldr	r3, [fp, #-16]
 c10f104:	e5d33000 	ldrb	r3, [r3]
 c10f108:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
		if(c >= '0' && c <= '9')
 c10f10c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f110:	e353002f 	cmp	r3, #47	; 0x2f
 c10f114:	9a000008 	bls	c10f13c <uart0_gethex+0x78>
 c10f118:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f11c:	e3530039 	cmp	r3, #57	; 0x39
 c10f120:	8a000005 	bhi	c10f13c <uart0_gethex+0x78>
			res += c - '0';
 c10f124:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f128:	e2433030 	sub	r3, r3, #48	; 0x30
 c10f12c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10f130:	e0823003 	add	r3, r2, r3
 c10f134:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10f138:	ea000016 	b	c10f198 <uart0_gethex+0xd4>
		else if(c >= 'a' && c <= 'f')
 c10f13c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f140:	e3530060 	cmp	r3, #96	; 0x60
 c10f144:	9a000008 	bls	c10f16c <uart0_gethex+0xa8>
 c10f148:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f14c:	e3530066 	cmp	r3, #102	; 0x66
 c10f150:	8a000005 	bhi	c10f16c <uart0_gethex+0xa8>
			res += 10 + c - 'a';
 c10f154:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f158:	e2433057 	sub	r3, r3, #87	; 0x57
 c10f15c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10f160:	e0823003 	add	r3, r2, r3
 c10f164:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 c10f168:	ea00000a 	b	c10f198 <uart0_gethex+0xd4>
		else if(c >= 'A' && c <= 'F')
 c10f16c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f170:	e3530040 	cmp	r3, #64	; 0x40
 c10f174:	9a000007 	bls	c10f198 <uart0_gethex+0xd4>
 c10f178:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f17c:	e3530046 	cmp	r3, #70	; 0x46
 c10f180:	8a000004 	bhi	c10f198 <uart0_gethex+0xd4>
			res += 10 + c - 'A';
 c10f184:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c10f188:	e2433037 	sub	r3, r3, #55	; 0x37
 c10f18c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c10f190:	e0823003 	add	r3, r2, r3
 c10f194:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		p++;
 c10f198:	e51b3010 	ldr	r3, [fp, #-16]
 c10f19c:	e2833001 	add	r3, r3, #1
 c10f1a0:	e50b3010 	str	r3, [fp, #-16]
	char* p = s;
	int32 res = 0;

	uart0_gets(s);

	while(*p) {
 c10f1a4:	e51b3010 	ldr	r3, [fp, #-16]
 c10f1a8:	e5d33000 	ldrb	r3, [r3]
 c10f1ac:	e3530000 	cmp	r3, #0
 c10f1b0:	1affffcf 	bne	c10f0f4 <uart0_gethex+0x30>
		else if(c >= 'A' && c <= 'F')
			res += 10 + c - 'A';
		p++;
	}

	return res;
 c10f1b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
 c10f1b8:	e1a00003 	mov	r0, r3
 c10f1bc:	e24bd00c 	sub	sp, fp, #12
 c10f1c0:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10f1c4:	e12fff1e 	bx	lr

0c10f1c8 <uart0_put_rtc_time>:

void uart0_put_rtc_time( rtc_time_t* rtc_time )
{
 c10f1c8:	e1a0c00d 	mov	ip, sp
 c10f1cc:	e92dd800 	push	{fp, ip, lr, pc}
 c10f1d0:	e24cb004 	sub	fp, ip, #4
 c10f1d4:	e24dd008 	sub	sp, sp, #8
 c10f1d8:	e50b0010 	str	r0, [fp, #-16]
	uart0_putint( rtc_time->mday );
 c10f1dc:	e51b3010 	ldr	r3, [fp, #-16]
 c10f1e0:	e5d33003 	ldrb	r3, [r3, #3]
 c10f1e4:	e1a00003 	mov	r0, r3
 c10f1e8:	ebfffef6 	bl	c10edc8 <uart0_putint>
	uart0_putchar( '/' );
 c10f1ec:	e3a0002f 	mov	r0, #47	; 0x2f
 c10f1f0:	ebfffeba 	bl	c10ece0 <uart0_putchar>
	uart0_putint( rtc_time->mon );
 c10f1f4:	e51b3010 	ldr	r3, [fp, #-16]
 c10f1f8:	e5d33005 	ldrb	r3, [r3, #5]
 c10f1fc:	e1a00003 	mov	r0, r3
 c10f200:	ebfffef0 	bl	c10edc8 <uart0_putint>
	uart0_putchar( '/' );
 c10f204:	e3a0002f 	mov	r0, #47	; 0x2f
 c10f208:	ebfffeb4 	bl	c10ece0 <uart0_putchar>
	uart0_putint( rtc_time->year );
 c10f20c:	e51b3010 	ldr	r3, [fp, #-16]
 c10f210:	e5d33006 	ldrb	r3, [r3, #6]
 c10f214:	e1a00003 	mov	r0, r3
 c10f218:	ebfffeea 	bl	c10edc8 <uart0_putint>
	uart0_putchar( ' ' );
 c10f21c:	e3a00020 	mov	r0, #32
 c10f220:	ebfffeae 	bl	c10ece0 <uart0_putchar>
	uart0_putint( rtc_time->hour );
 c10f224:	e51b3010 	ldr	r3, [fp, #-16]
 c10f228:	e5d33002 	ldrb	r3, [r3, #2]
 c10f22c:	e1a00003 	mov	r0, r3
 c10f230:	ebfffee4 	bl	c10edc8 <uart0_putint>
	uart0_putchar( ':' );
 c10f234:	e3a0003a 	mov	r0, #58	; 0x3a
 c10f238:	ebfffea8 	bl	c10ece0 <uart0_putchar>
	uart0_putint( rtc_time->min );
 c10f23c:	e51b3010 	ldr	r3, [fp, #-16]
 c10f240:	e5d33001 	ldrb	r3, [r3, #1]
 c10f244:	e1a00003 	mov	r0, r3
 c10f248:	ebfffede 	bl	c10edc8 <uart0_putint>
	uart0_putchar( ':' );
 c10f24c:	e3a0003a 	mov	r0, #58	; 0x3a
 c10f250:	ebfffea2 	bl	c10ece0 <uart0_putchar>
	uart0_putint( rtc_time->sec );
 c10f254:	e51b3010 	ldr	r3, [fp, #-16]
 c10f258:	e5d33000 	ldrb	r3, [r3]
 c10f25c:	e1a00003 	mov	r0, r3
 c10f260:	ebfffed8 	bl	c10edc8 <uart0_putint>
}
 c10f264:	e24bd00c 	sub	sp, fp, #12
 c10f268:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10f26c:	e12fff1e 	bx	lr

0c10f270 <Delay>:

void Delay(int time)
// time=0: adjust the Delay function by WatchDog timer.//
// time>0: the number of loop time//
// 100us resolution.//
{
 c10f270:	e1a0c00d 	mov	ip, sp
 c10f274:	e92dd800 	push	{fp, ip, lr, pc}
 c10f278:	e24cb004 	sub	fp, ip, #4
 c10f27c:	e24dd010 	sub	sp, sp, #16
 c10f280:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
	int i,adjust=0;
 c10f284:	e3a03000 	mov	r3, #0
 c10f288:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	if(time==0)
 c10f28c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10f290:	e3530000 	cmp	r3, #0
 c10f294:	1a000021 	bne	c10f320 <Delay+0xb0>
	{
		time=200;
 c10f298:	e3a030c8 	mov	r3, #200	; 0xc8
 c10f29c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
		adjust=1;
 c10f2a0:	e3a03001 	mov	r3, #1
 c10f2a4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		delayLoopCount=400;
 c10f2a8:	e59f30d8 	ldr	r3, [pc, #216]	; c10f388 <Delay+0x118>
 c10f2ac:	e3a02e19 	mov	r2, #400	; 0x190
 c10f2b0:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
 c10f2b4:	e59f30d0 	ldr	r3, [pc, #208]	; c10f38c <Delay+0x11c>
 c10f2b8:	e59f20d0 	ldr	r2, [pc, #208]	; c10f390 <Delay+0x120>
 c10f2bc:	e5832000 	str	r2, [r3]
		rWTDAT=0xffff;
 c10f2c0:	e59f30cc 	ldr	r3, [pc, #204]	; c10f394 <Delay+0x124>
 c10f2c4:	e59f20cc 	ldr	r2, [pc, #204]	; c10f398 <Delay+0x128>
 c10f2c8:	e5832000 	str	r2, [r3]
		rWTCNT=0xffff;
 c10f2cc:	e59f30c8 	ldr	r3, [pc, #200]	; c10f39c <Delay+0x12c>
 c10f2d0:	e59f20c0 	ldr	r2, [pc, #192]	; c10f398 <Delay+0x128>
 c10f2d4:	e5832000 	str	r2, [r3]
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
 c10f2d8:	e59f30ac 	ldr	r3, [pc, #172]	; c10f38c <Delay+0x11c>
 c10f2dc:	e59f20bc 	ldr	r2, [pc, #188]	; c10f3a0 <Delay+0x130>
 c10f2e0:	e5832000 	str	r2, [r3]
	}
	for(;time>0;time--)
 c10f2e4:	ea00000d 	b	c10f320 <Delay+0xb0>
		for(i=0;i<delayLoopCount;i++);
 c10f2e8:	e3a03000 	mov	r3, #0
 c10f2ec:	e50b3010 	str	r3, [fp, #-16]
 c10f2f0:	ea000002 	b	c10f300 <Delay+0x90>
 c10f2f4:	e51b3010 	ldr	r3, [fp, #-16]
 c10f2f8:	e2833001 	add	r3, r3, #1
 c10f2fc:	e50b3010 	str	r3, [fp, #-16]
 c10f300:	e59f3080 	ldr	r3, [pc, #128]	; c10f388 <Delay+0x118>
 c10f304:	e5933000 	ldr	r3, [r3]
 c10f308:	e51b2010 	ldr	r2, [fp, #-16]
 c10f30c:	e1520003 	cmp	r2, r3
 c10f310:	bafffff7 	blt	c10f2f4 <Delay+0x84>
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);	// 1M/64,Watch-dog,nRESET,interrupt disable//
		rWTDAT=0xffff;
		rWTCNT=0xffff;
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3)|(1<<5); // 1M/64,Watch-dog enable,nRESET,interrupt disable //
	}
	for(;time>0;time--)
 c10f314:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10f318:	e2433001 	sub	r3, r3, #1
 c10f31c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c10f320:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c10f324:	e3530000 	cmp	r3, #0
 c10f328:	caffffee 	bgt	c10f2e8 <Delay+0x78>
		for(i=0;i<delayLoopCount;i++);
	if(adjust==1)
 c10f32c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c10f330:	e3530001 	cmp	r3, #1
 c10f334:	1a000010 	bne	c10f37c <Delay+0x10c>
	{
		rWTCON=((MCLK/1000000-1)<<8)|(2<<3);
 c10f338:	e59f304c 	ldr	r3, [pc, #76]	; c10f38c <Delay+0x11c>
 c10f33c:	e59f204c 	ldr	r2, [pc, #76]	; c10f390 <Delay+0x120>
 c10f340:	e5832000 	str	r2, [r3]
		i=0xffff-rWTCNT;   //  1count/16us?????????//
 c10f344:	e59f3050 	ldr	r3, [pc, #80]	; c10f39c <Delay+0x12c>
 c10f348:	e5933000 	ldr	r3, [r3]
 c10f34c:	e2633cff 	rsb	r3, r3, #65280	; 0xff00
 c10f350:	e28330ff 	add	r3, r3, #255	; 0xff
 c10f354:	e50b3010 	str	r3, [fp, #-16]
		delayLoopCount=8000000/(i*64);	//400*100/(i*64/200)   //
 c10f358:	e51b3010 	ldr	r3, [fp, #-16]
 c10f35c:	e1a03303 	lsl	r3, r3, #6
 c10f360:	e59f003c 	ldr	r0, [pc, #60]	; c10f3a4 <Delay+0x134>
 c10f364:	e1a01003 	mov	r1, r3
 c10f368:	eb00000e 	bl	c10f3a8 <__aeabi_idiv>
 c10f36c:	e1a03000 	mov	r3, r0
 c10f370:	e1a02003 	mov	r2, r3
 c10f374:	e59f300c 	ldr	r3, [pc, #12]	; c10f388 <Delay+0x118>
 c10f378:	e5832000 	str	r2, [r3]
	}
}
 c10f37c:	e24bd00c 	sub	sp, fp, #12
 c10f380:	e89d6800 	ldm	sp, {fp, sp, lr}
 c10f384:	e12fff1e 	bx	lr
 c10f388:	0c100064 	.word	0x0c100064
 c10f38c:	01d30000 	.word	0x01d30000
 c10f390:	00003f10 	.word	0x00003f10
 c10f394:	01d30004 	.word	0x01d30004
 c10f398:	0000ffff 	.word	0x0000ffff
 c10f39c:	01d30008 	.word	0x01d30008
 c10f3a0:	00003f30 	.word	0x00003f30
 c10f3a4:	007a1200 	.word	0x007a1200

0c10f3a8 <__aeabi_idiv>:
 c10f3a8:	e3510000 	cmp	r1, #0
 c10f3ac:	0a000043 	beq	c10f4c0 <.divsi3_skip_div0_test+0x110>

0c10f3b0 <.divsi3_skip_div0_test>:
 c10f3b0:	e020c001 	eor	ip, r0, r1
 c10f3b4:	42611000 	rsbmi	r1, r1, #0
 c10f3b8:	e2512001 	subs	r2, r1, #1
 c10f3bc:	0a000027 	beq	c10f460 <.divsi3_skip_div0_test+0xb0>
 c10f3c0:	e1b03000 	movs	r3, r0
 c10f3c4:	42603000 	rsbmi	r3, r0, #0
 c10f3c8:	e1530001 	cmp	r3, r1
 c10f3cc:	9a000026 	bls	c10f46c <.divsi3_skip_div0_test+0xbc>
 c10f3d0:	e1110002 	tst	r1, r2
 c10f3d4:	0a000028 	beq	c10f47c <.divsi3_skip_div0_test+0xcc>
 c10f3d8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
 c10f3dc:	01a01181 	lsleq	r1, r1, #3
 c10f3e0:	03a02008 	moveq	r2, #8
 c10f3e4:	13a02001 	movne	r2, #1
 c10f3e8:	e3510201 	cmp	r1, #268435456	; 0x10000000
 c10f3ec:	31510003 	cmpcc	r1, r3
 c10f3f0:	31a01201 	lslcc	r1, r1, #4
 c10f3f4:	31a02202 	lslcc	r2, r2, #4
 c10f3f8:	3afffffa 	bcc	c10f3e8 <.divsi3_skip_div0_test+0x38>
 c10f3fc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
 c10f400:	31510003 	cmpcc	r1, r3
 c10f404:	31a01081 	lslcc	r1, r1, #1
 c10f408:	31a02082 	lslcc	r2, r2, #1
 c10f40c:	3afffffa 	bcc	c10f3fc <.divsi3_skip_div0_test+0x4c>
 c10f410:	e3a00000 	mov	r0, #0
 c10f414:	e1530001 	cmp	r3, r1
 c10f418:	20433001 	subcs	r3, r3, r1
 c10f41c:	21800002 	orrcs	r0, r0, r2
 c10f420:	e15300a1 	cmp	r3, r1, lsr #1
 c10f424:	204330a1 	subcs	r3, r3, r1, lsr #1
 c10f428:	218000a2 	orrcs	r0, r0, r2, lsr #1
 c10f42c:	e1530121 	cmp	r3, r1, lsr #2
 c10f430:	20433121 	subcs	r3, r3, r1, lsr #2
 c10f434:	21800122 	orrcs	r0, r0, r2, lsr #2
 c10f438:	e15301a1 	cmp	r3, r1, lsr #3
 c10f43c:	204331a1 	subcs	r3, r3, r1, lsr #3
 c10f440:	218001a2 	orrcs	r0, r0, r2, lsr #3
 c10f444:	e3530000 	cmp	r3, #0
 c10f448:	11b02222 	lsrsne	r2, r2, #4
 c10f44c:	11a01221 	lsrne	r1, r1, #4
 c10f450:	1affffef 	bne	c10f414 <.divsi3_skip_div0_test+0x64>
 c10f454:	e35c0000 	cmp	ip, #0
 c10f458:	42600000 	rsbmi	r0, r0, #0
 c10f45c:	e12fff1e 	bx	lr
 c10f460:	e13c0000 	teq	ip, r0
 c10f464:	42600000 	rsbmi	r0, r0, #0
 c10f468:	e12fff1e 	bx	lr
 c10f46c:	33a00000 	movcc	r0, #0
 c10f470:	01a00fcc 	asreq	r0, ip, #31
 c10f474:	03800001 	orreq	r0, r0, #1
 c10f478:	e12fff1e 	bx	lr
 c10f47c:	e3510801 	cmp	r1, #65536	; 0x10000
 c10f480:	21a01821 	lsrcs	r1, r1, #16
 c10f484:	23a02010 	movcs	r2, #16
 c10f488:	33a02000 	movcc	r2, #0
 c10f48c:	e3510c01 	cmp	r1, #256	; 0x100
 c10f490:	21a01421 	lsrcs	r1, r1, #8
 c10f494:	22822008 	addcs	r2, r2, #8
 c10f498:	e3510010 	cmp	r1, #16
 c10f49c:	21a01221 	lsrcs	r1, r1, #4
 c10f4a0:	22822004 	addcs	r2, r2, #4
 c10f4a4:	e3510004 	cmp	r1, #4
 c10f4a8:	82822003 	addhi	r2, r2, #3
 c10f4ac:	908220a1 	addls	r2, r2, r1, lsr #1
 c10f4b0:	e35c0000 	cmp	ip, #0
 c10f4b4:	e1a00233 	lsr	r0, r3, r2
 c10f4b8:	42600000 	rsbmi	r0, r0, #0
 c10f4bc:	e12fff1e 	bx	lr
 c10f4c0:	e3500000 	cmp	r0, #0
 c10f4c4:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
 c10f4c8:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
 c10f4cc:	ea000007 	b	c10f4f0 <__aeabi_idiv0>

0c10f4d0 <__aeabi_idivmod>:
 c10f4d0:	e3510000 	cmp	r1, #0
 c10f4d4:	0afffff9 	beq	c10f4c0 <.divsi3_skip_div0_test+0x110>
 c10f4d8:	e92d4003 	push	{r0, r1, lr}
 c10f4dc:	ebffffb3 	bl	c10f3b0 <.divsi3_skip_div0_test>
 c10f4e0:	e8bd4006 	pop	{r1, r2, lr}
 c10f4e4:	e0030092 	mul	r3, r2, r0
 c10f4e8:	e0411003 	sub	r1, r1, r3
 c10f4ec:	e12fff1e 	bx	lr

0c10f4f0 <__aeabi_idiv0>:
 c10f4f0:	e12fff1e 	bx	lr
